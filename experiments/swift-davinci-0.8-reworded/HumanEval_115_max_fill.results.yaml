language: swift
name: HumanEval_115_max_fill
results:
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var counter = 0\n    let row = grid.count\n    let col = grid[0].count\n\
    \    var rowIndex = 0\n    var colIndex = 0\n    while rowIndex < row {\n    \
    \    if colIndex < col {\n            let bucket = grid[rowIndex][colIndex]\n\
    \            if bucket == 1 {\n                counter += capacity\n         \
    \   }\n            colIndex += 1\n        } else {\n            rowIndex += 1\n\
    \            colIndex = 0\n        }\n    }\n    return counter\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx598xg0h/tmpx598xg0h.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf8193bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf81632b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf81632988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf816317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx598xg0h                        0x000055d9bed1b6a7 <unavailable> + 5799

    5    libc.so.6                          0x00002acf81b27460 __libc_start_main +
    245

    6    tmpx598xg0h                        0x000055d9bed1b069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var newGrid = grid\n    var amountOfTimes = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                amountOfTimes += 1\n                newGrid = pour(grid: newGrid,\
    \ from: (i, j), capacity: capacity)\n            }\n        }\n    }\n    return\
    \ amountOfTimes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmcqx4ilf.swift:30:27: error: cannot find 'pour' in scope\n    \
    \            newGrid = pour(grid: newGrid, from: (i, j), capacity: capacity)\n\
    \                          ^~~~\n"
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl72yvtnt/tmpl72yvtnt.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08d7367c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08d705eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08d705e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08d705d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl72yvtnt                        0x00005601b6b8c3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b08d7553460 __libc_start_main +
    245

    6    tmpl72yvtnt                        0x00005601b6b8bf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var water = 0\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                water += 1\n            }\n        }\n    }\n    while water\
    \ > 0 {\n        count += 1\n        water -= capacity\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpq2d2jtlw/tmpq2d2jtlw.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad3dcc44c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad3dc93bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad3dc93b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad3dc93a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq2d2jtlw                        0x0000562e05a2ec54 <unavailable> + 7252

    5    libc.so.6                          0x00002ad3dce30460 __libc_start_main +
    245

    6    tmpq2d2jtlw                        0x0000562e05a2e1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = 0\n    var grid = grid\n    var b = Array(repeating:\
    \ 0, count: grid[0].count)\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                b[j] += 1\n           \
    \ }\n        }\n    }\n    for j in 0..<b.count {\n        max += b[j] / capacity\n\
    \        if b[j] % capacity != 0 {\n            max += 1\n        }\n    }\n \
    \   return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpx9n_bsig/tmpx9n_bsig.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b986006bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b985fd62b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b985fd62988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b985fd617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx9n_bsig                        0x0000560b761f08e7 <unavailable> + 6375

    5    libc.so.6                          0x00002b9860257460 __libc_start_main +
    245

    6    tmpx9n_bsig                        0x0000560b761f02a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // write your code in Swift 4.2.1 (Linux)\n    guard grid.count\
    \ > 0 && grid[0].count > 0 else {\n        return 0\n    }\n    var grid = grid\n\
    \    var max_fill = 0\n    let rows = grid.count\n    let cols = grid[0].count\n\
    \    for y in 0..<rows {\n        for x in 0..<cols {\n            max_fill +=\
    \ max_fill_recursive(grid: &grid, x: x, y: y, capacity: capacity)\n        }\n\
    \    }\n    return max_fill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp86v9kvfs.swift:34:25: error: cannot find 'max_fill_recursive' in\
    \ scope\n            max_fill += max_fill_recursive(grid: &grid, x: x, y: y, capacity:\
    \ capacity)\n                        ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var counter = 0\n    while(true) {\n    \
    \    var filled = true\n        for x in 0..<grid.count {\n            if (grid[x].filter({\
    \ $0 == 1 }).count > 0) {\n                filled = false\n                for\
    \ y in 0..<grid[x].count {\n                    if (grid[x][y] == 1) {\n     \
    \                   grid[x][y] = 0\n                        if ((x + 1) < grid.count)\
    \ {\n                            for bucket_y in y..<min(y + capacity, grid[x\
    \ + 1].count) {\n                                grid[x + 1][bucket_y] = 1\n \
    \                           }\n                        }\n                   \
    \     counter += 1\n                        break\n                    }\n   \
    \             }\n            }\n        }\n        if (filled) {\n           \
    \ break\n        }\n    }\n    return counter\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp1f0uk9cp/tmp1f0uk9cp.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e80eb4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e80babb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e80bab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e80baa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1f0uk9cp                        0x00005626fcfbf856 <unavailable> + 6230

    5    libc.so.6                          0x00002b6e810a0460 __libc_start_main +
    245

    6    tmp1f0uk9cp                        0x00005626fcfbf3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for i in 0..<grid.count {\n        for j in\
    \ 0..<grid[i].count {\n            count += max(grid[i][j] - capacity, 0)\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4yg3z_ra/tmp4yg3z_ra.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b527c452c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b527c149b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b527c149988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b527c1487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4yg3z_ra                        0x000055f4561bf6f6 <unavailable> + 5878

    5    libc.so.6                          0x00002b527c63e460 __libc_start_main +
    245

    6    tmp4yg3z_ra                        0x000055f4561bf289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var counter = 0\n    var currentCapacity = capacity\n    var length\
    \ = 0\n    var lenghtCounter = 0\n    var rowCounter = 0\n    var maxRow = 0\n\
    \    var prevRowLength = 0\n    if grid.count == 0 {\n        return 0\n    }\n\
    \    if grid[0].count == 0 {\n        return 0\n    }\n    for row in grid {\n\
    \        for item in row {\n            if item == 1 {\n                length\
    \ += 1\n            }\n        }\n        if length > lenghtCounter {\n      \
    \      lenghtCounter = length\n            maxRow = rowCounter\n        }\n  \
    \      rowCounter += 1\n        length = 0\n    }\n    if lenghtCounter == 0 {\n\
    \        return 0\n    }\n    for _ in 0...maxRow {\n        for item in grid[maxRow]\
    \ {\n            if item == 1 {\n                prevRowLength += 1\n        \
    \    }\n        }\n        maxRow -= 1\n    }\n    for _ in 0...prevRowLength\
    \ - 1 {\n        if currentCapacity > 0 {\n            currentCapacity -= 1\n\
    \        } else {\n            currentCapacity = capacity\n            counter\
    \ += 1\n        }\n    }\n    if currentCapacity == capacity {\n        return\
    \ counter\n    } else {\n        return counter + 1\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpzje_8jez/tmpzje_8jez.swift:89: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab17dffec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab17dcf5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab17dcf5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab17dcf47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzje_8jez                        0x000055f87d2dc776 <unavailable> + 6006

    5    libc.so.6                          0x00002ab17e1ea460 __libc_start_main +
    245

    6    tmpzje_8jez                        0x000055f87d2dc309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var filled_grid = grid\n    let rows = grid.count\n    let cols\
    \ = grid[0].count\n    var row_index = 0\n    var col_index = 0\n    var total_water\
    \ = 0\n    while row_index < rows {\n        col_index = 0\n        while col_index\
    \ < cols {\n            if filled_grid[row_index][col_index] == 1 {\n        \
    \        total_water += capacity\n                filled_grid[row_index][col_index]\
    \ = 0\n            }\n            col_index += 1\n        }\n        row_index\
    \ += 1\n    }\n    return total_water\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpphxscf_w/tmpphxscf_w.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3d40829c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3d40520b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3d40520988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3d4051f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpphxscf_w                        0x000055b15ac35747 <unavailable> + 5959

    5    libc.so.6                          0x00002b3d40a15460 __libc_start_main +
    245

    6    tmpphxscf_w                        0x000055b15ac35109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for row in grid {\n        var water = 0\n\
    \        for i in row {\n            water += i\n            if water == capacity\
    \ {\n                result += 1\n                water = 0\n            }\n \
    \       }\n        if water > 0 {\n            result += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let totalWater = grid.reduce(0) { (sum, row) -> Int in\n     \
    \   sum + row.reduce(0) { (sum, cell) -> Int in\n            sum + cell\n    \
    \    }\n    }\n    guard totalWater > 0 else { return 0 }\n    var maxFill = 0\n\
    \    for row in grid {\n        maxFill += row.reduce(0) { (sum, cell) -> Int\
    \ in\n            sum + (cell == 1 ? capacity : 0)\n        }\n    }\n    return\
    \ maxFill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpex3ugtg4/tmpex3ugtg4.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b88c7a81c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88c7778b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b88c7778988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b88c77777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpex3ugtg4                        0x0000558c033f1787 <unavailable> + 6023

    5    libc.so.6                          0x00002b88c7c6d460 __libc_start_main +
    245

    6    tmpex3ugtg4                        0x0000558c033f1149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var depth = 0\n    while depth < capacity {\n        depth +=\
    \ 1\n        var highest = 0\n        var well = 0\n        for (w, wellVals)\
    \ in grid.enumerated() {\n            let (height, _) = highest_point(input: wellVals,\
    \ height: depth)\n            if height > highest {\n                highest =\
    \ height\n                well = w\n            }\n        }\n        grid[well]\
    \ = fill_well(input: grid[well], height: depth)\n    }\n    return count_filled(input:\
    \ grid)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpp9mqogax.swift:30:31: error: cannot find 'highest_point' in scope\n\
    \            let (height, _) = highest_point(input: wellVals, height: depth)\n\
    \                              ^~~~~~~~~~~~~\n/tmp/tmpp9mqogax.swift:30:31: error:\
    \ type of expression is ambiguous without more context\n            let (height,\
    \ _) = highest_point(input: wellVals, height: depth)\n                       \
    \       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpp9mqogax.swift:36:22:\
    \ error: cannot find 'fill_well' in scope\n        grid[well] = fill_well(input:\
    \ grid[well], height: depth)\n                     ^~~~~~~~~\n/tmp/tmpp9mqogax.swift:36:13:\
    \ error: cannot assign through subscript: 'grid' is a 'let' constant\n       \
    \ grid[well] = fill_well(input: grid[well], height: depth)\n        ~~~~^\n/tmp/tmpp9mqogax.swift:38:12:\
    \ error: cannot find 'count_filled' in scope\n    return count_filled(input: grid)\n\
    \           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // 1. find max in each column\n    var maxCol = [Int]()\n    for\
    \ i in 0..<grid[0].count {\n        maxCol.append(grid.map{$0[i]}.max()!)\n  \
    \  }\n    // 2. find max in maxCol\n    let maxRow = maxCol.max()!\n    // 3.\
    \ multiply maxRow with number of columns\n    return maxRow * grid[0].count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpe2fwwj6b/tmpe2fwwj6b.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8706a41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8706738b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8706738988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87067377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpe2fwwj6b                        0x00005624136cc856 <unavailable> + 6230

    5    libc.so.6                          0x00002b8706c2d460 __libc_start_main +
    245

    6    tmpe2fwwj6b                        0x00005624136cc3e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_level = capacity\n    var min_level = 0\n    while max_level\
    \ - min_level > 1 {\n        let middle = (max_level + min_level) / 2\n      \
    \  if fit(grid: grid, capacity: middle) {\n            min_level = middle\n  \
    \      } else {\n            max_level = middle\n        }\n    }\n    return\
    \ min_level\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpmd8u6nau.swift:28:12: error: cannot find 'fit' in scope\n     \
    \   if fit(grid: grid, capacity: middle) {\n           ^~~\n"
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n\t// Required function.\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpna5rafr9/tmpna5rafr9.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3acda41c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3acd738b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3acd738988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3acd7377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpna5rafr9                        0x0000565307f443d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b3acdc2d460 __libc_start_main +
    245

    6    tmpna5rafr9                        0x0000565307f43f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    guard grid[0].count\
    \ > 0 else { return 0 }\n    var buckets = [Int]()\n    let rows = grid.count\n\
    \    let columns = grid[0].count\n    for column in 0..<columns {\n        buckets.append(0)\n\
    \    }\n    var days = 0\n    while true {\n        days += 1\n        // fill\
    \ buckets\n        for row in 0..<rows {\n            for column in 0..<columns\
    \ {\n                if grid[row][column] == 1 {\n                    buckets[column]\
    \ += 1\n                }\n            }\n        }\n        // dump buckets\n\
    \        for column in 0..<columns {\n            for _ in 0..<buckets[column]\
    \ {\n                for row in 0..<rows {\n                    if grid[row][column]\
    \ == 1 {\n                        grid[row][column] = 0\n                    \
    \    break\n                    }\n                }\n            }\n        \
    \    buckets[column] = 0\n        }\n        if grid.allSatisfy({ $0.allSatisfy({\
    \ $0 == 0 }) }) {\n            break\n        }\n    }\n    return days\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpyzltbfgj.swift:48:34: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                        grid[row][column] = 0\n       \
    \                 ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for col in 0 ..< grid[0].count\
    \ {\n        var remaining = capacity\n        for row in 0 ..< grid.count {\n\
    \            let current = grid[row][col]\n            if current == 1 {\n   \
    \             remaining -= 1\n                grid[row][col] = 0\n           \
    \ }\n        }\n        if remaining == 0 {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpq4ylyn1a/tmpq4ylyn1a.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7f1995c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7f168cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7f168c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7f168b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq4ylyn1a                        0x000055622bc54706 <unavailable> + 5894

    5    libc.so.6                          0x00002ae7f1b81460 __libc_start_main +
    245

    6    tmpq4ylyn1a                        0x000055622bc54299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n\tvar max_fill_count = 0\n\tvar fill_count = 0\n\tvar column_index\
    \ = 0\n\tvar not_done = true\n\tvar current_well = 0\n\tvar bucket = capacity\n\
    \t\n\twhile not_done {\n\t\tnot_done = false\n\t\t//walk the wells\n\t\tfor well\
    \ in grid {\n\t\t\t//is there a 1 in the current well at the current column?\n\
    \t\t\tif well[column_index] == 1 {\n\t\t\t\t//is the bucket full?\n\t\t\t\tif\
    \ bucket == capacity {\n\t\t\t\t\t//fill bucket\n\t\t\t\t\tbucket = capacity\n\
    \t\t\t\t\tfill_count += 1\n\t\t\t\t}\n\t\t\t\t//fill the current well in the current\
    \ column\n\t\t\t\twell[column_index] = 0\n\t\t\t\tbucket -= 1\n\t\t\t\tnot_done\
    \ = true\n\t\t\t}\n\t\t}\n\t\t//move to the next column\n\t\tcolumn_index += 1\n\
    \t\t\n\t\t//did we walk the entire grid?\n\t\tif column_index >= grid[0].count\
    \ {\n\t\t\t//reset the current column\n\t\t\tcolumn_index = 0\n\t\t\t//did we\
    \ fill any wells?\n\t\t\tif fill_count > 0 {\n\t\t\t\t//keep track of the max\n\
    \t\t\t\tmax_fill_count += fill_count\n\t\t\t\t//reset fill count\n\t\t\t\tfill_count\
    \ = 0\n\t\t\t}\n\t\t}\n\t}\n\treturn max_fill_count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpzpslfuuj.swift:44:9: error: cannot assign through subscript: 'well'\
    \ is a 'let' constant\n                                well[column_index] = 0\n\
    \                                ~~~~^\n"
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var filledGrid = grid\n    var totalWater = 0\n    for row in\
    \ filledGrid {\n        for column in row {\n            if column == 1 {\n  \
    \              totalWater += 1\n            }\n        }\n    }\n    var totalExtracted\
    \ = 0\n    var currentCapacity = capacity\n    for row in filledGrid {\n     \
    \   for column in row {\n            if column == 1 {\n                if currentCapacity\
    \ == 0 {\n                    currentCapacity = capacity\n                   \
    \ totalExtracted += 1\n                }\n                currentCapacity -= 1\n\
    \            }\n        }\n    }\n    return totalExtracted\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7hd8crvj/tmp7hd8crvj.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba72254bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba722242b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba722242988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba7222417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7hd8crvj                        0x000055e53fb10546 <unavailable> + 5446

    5    libc.so.6                          0x00002ba722737460 __libc_start_main +
    245

    6    tmp7hd8crvj                        0x000055e53fb100d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid_copy = grid\n    let row_num = grid.count\n    let col_num\
    \ = grid[0].count\n    var sum = 0\n    for _ in 0..<row_num {\n        for j\
    \ in 0..<col_num {\n            if grid_copy[0][j] == 1 {\n                grid_copy[0][j]\
    \ = 0\n                sum += 1\n            }\n        }\n        for i in 1..<row_num\
    \ {\n            for j in 0..<col_num {\n                let water_num = capacity\
    \ - grid_copy[i-1][j]\n                if grid_copy[i][j] == 1 {\n           \
    \         grid_copy[i][j] = 0\n                    sum += 1\n                }\n\
    \                if water_num > 0 {\n                    grid_copy[i][j] += water_num\n\
    \                }\n            }\n        }\n    }\n    return sum\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9q_s6dcs/tmp9q_s6dcs.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd6a900c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd6a5f7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd6a5f7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd6a5f67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9q_s6dcs                        0x0000561a15715706 <unavailable> + 5894

    5    libc.so.6                          0x00002abd6aaec460 __libc_start_main +
    245

    6    tmp9q_s6dcs                        0x0000561a15715299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var operations = 0\n    var min_water = 0\n    for row in grid\
    \ {\n        for value in row {\n            min_water += value\n        }\n \
    \   }\n    for row in grid {\n        for value in row {\n            if value\
    \ == 0 {\n                let delta = capacity - min_water\n                if\
    \ delta < 0 {\n                    return operations\n                }\n    \
    \            operations += delta\n            }\n        }\n    }\n    return\
    \ operations\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpht646c3j/tmpht646c3j.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ce91cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ce8ec6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9ce8ec6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9ce8ec57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpht646c3j                        0x000056534bd58546 <unavailable> + 5446

    5    libc.so.6                          0x00002b9ce93bb460 __libc_start_main +
    245

    6    tmpht646c3j                        0x000056534bd580d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  // Solution goes here...\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: '/tmp/tmpn1hecc_7.swift:25:1: error: missing return in global function expected
    to return ''Int''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    let wells = grid.reduce(into: [[Int]](),\
    \ { (result, well) in\n        result.append(well.enumerated().filter { $0.element\
    \ == 1 }.map { $0.offset })\n    })\n    for wells_row in wells {\n        if\
    \ wells_row.count == 0 {\n            continue\n        }\n        let max_bucket_start\
    \ = wells_row.reduce(0, { (result, well) in\n            return max(result, well\
    \ - capacity + 1)\n        })\n        var bucket_start = 0\n        while bucket_start\
    \ <= max_bucket_start {\n            var next_bucket_start = wells_row.reduce(bucket_start,\
    \ { (result, well) in\n                return min(result, well - capacity + 1)\n\
    \            })\n            max_fill += next_bucket_start - bucket_start\n  \
    \          bucket_start = next_bucket_start\n        }\n    }\n    return max_fill\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978609
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwf8iznmx/tmpwf8iznmx.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac88b374c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac88b06bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac88b06b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac88b06a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwf8iznmx                        0x000055d3aac2d3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ac88b560460 __libc_start_main +
    245

    6    tmpwf8iznmx                        0x000055d3aac2cf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var total = 0\n    var currentCapacity = capacity\n    var bottom\
    \ = grid.count\n    var top = 0\n    for row in grid {\n        for well in row\
    \ {\n            if well == 1 {\n                total += 1\n                currentCapacity\
    \ -= 1\n            }\n            if currentCapacity == 0 {\n               \
    \ currentCapacity = capacity\n                total += 1\n            }\n    \
    \    }\n        currentCapacity = capacity\n        bottom -= 1\n        top +=\
    \ 1\n    }\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpai1s6bo1/tmpai1s6bo1.swift:59: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d49a83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d4977ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d4977a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d497797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpai1s6bo1                        0x000055a628d83546 <unavailable> + 5446

    5    libc.so.6                          0x00002b9d49c6f460 __libc_start_main +
    245

    6    tmpai1s6bo1                        0x000055a628d830d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // initialize extraction variable\n    var num_moves = 0\n   \
    \ // check for empty grid\n    if grid.count == 0 {\n        return num_moves\n\
    \    }\n    // iterate through grid rows\n    for row in grid {\n        // initialize\
    \ row variables\n        var has_seen_one = false\n        var buckets_left =\
    \ capacity\n        // iterate through row columns\n        for col in row {\n\
    \            // check for 1, if one is present, decrement bucket and update has_seen_one\n\
    \            if col == 1 {\n                if has_seen_one {\n              \
    \      buckets_left -= 1\n                } else {\n                    has_seen_one\
    \ = true\n                }\n            }\n            // check for 0, if one\
    \ is present, increment bucket\n            if col == 0 {\n                buckets_left\
    \ += 1\n            }\n            // check for remaining bucket capacity, if\
    \ none remaining, increment num_moves and reset buckets_left\n            if buckets_left\
    \ == 0 {\n                num_moves += 1\n                buckets_left = capacity\n\
    \            }\n        }\n    }\n    return num_moves\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp9zoa_hu0/tmp9zoa_hu0.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c2dccec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c2d9c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c2d9c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c2d9c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9zoa_hu0                        0x000055d8e736d546 <unavailable> + 5446

    5    libc.so.6                          0x00002b6c2deba460 __libc_start_main +
    245

    6    tmp9zoa_hu0                        0x000055d8e736d0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // TODO: implement\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpzfkdcpd6/tmpzfkdcpd6.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73535a8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b735329fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b735329f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b735329e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzfkdcpd6                        0x0000563f727873d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b7353794460 __libc_start_main +
    245

    6    tmpzfkdcpd6                        0x0000563f72786f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var arr\
    \ = Array(repeating: Array(repeating: 0, count: cols), count: rows)\n    var count\
    \ = 0\n    for j in 0..<cols {\n        for i in 0..<rows {\n            if grid[i][j]\
    \ == 1 {\n                if arr[i][j] < capacity {\n                    arr[i][j]\
    \ += 1\n                    count += 1\n                }\n            }\n   \
    \     }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp35dmm9ai/tmp35dmm9ai.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9308537c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b930822eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b930822e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b930822d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp35dmm9ai                        0x00005643017ee997 <unavailable> + 6551

    5    libc.so.6                          0x00002b9308723460 __libc_start_main +
    245

    6    tmp35dmm9ai                        0x00005643017ee359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // Initialize the depth map\n    var depth_map = [[Int]](repeating:\
    \ [Int](repeating: 0, count: grid[0].count), count: grid.count)\n    var total_fill\
    \ = 0\n    for _ in 0..<grid.count {\n        // Find the max depth of each row\n\
    \        var max_depth = 0\n        for column in 0..<grid[0].count {\n      \
    \      max_depth = max(max_depth, grid[column][column])\n        }\n        //\
    \ Fill the wells to max_depth\n        for row in 0..<grid.count {\n         \
    \   var depth = max_depth - depth_map[row][row]\n            while depth > 0 {\n\
    \                depth -= capacity\n                total_fill += 1\n        \
    \    }\n            depth_map[row][row] = max_depth\n        }\n    }\n    return\
    \ total_fill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b88867b9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b88864b0561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b88864b0286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b88864b013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b88864afbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b888649948a <unavailable> + 1340554

    6    tmpbb9ankdr                        0x000055a53e1ee266 <unavailable> + 8806

    7    tmpbb9ankdr                        0x000055a53e1ed7e8 <unavailable> + 6120

    8    libc.so.6                          0x00002b88869a5460 __libc_start_main +
    245

    9    tmpbb9ankdr                        0x000055a53e1ed3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var grid = grid\n    var times = 0\n    \n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                times += 1\n                if i+1 < grid.count {\n         \
    \           let waterToGive = min(capacity, grid[i+1][j])\n                  \
    \  grid[i+1][j] -= waterToGive\n                    grid[i][j] -= waterToGive\n\
    \                }\n                if i-1 >= 0 {\n                    let waterToGive\
    \ = min(capacity, grid[i-1][j])\n                    grid[i-1][j] -= waterToGive\n\
    \                    grid[i][j] -= waterToGive\n                }\n          \
    \      if j+1 < grid[i].count {\n                    let waterToGive = min(capacity,\
    \ grid[i][j+1])\n                    grid[i][j+1] -= waterToGive\n           \
    \         grid[i][j] -= waterToGive\n                }\n                if j-1\
    \ >= 0 {\n                    let waterToGive = min(capacity, grid[i][j-1])\n\
    \                    grid[i][j-1] -= waterToGive\n                    grid[i][j]\
    \ -= waterToGive\n                }\n            }\n        }\n    }\n    \n \
    \   return times\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8iq0dhq7/tmp8iq0dhq7.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b772fd83c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b772fa7ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b772fa7a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b772fa797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8iq0dhq7                        0x000055577ac9a796 <unavailable> + 6038

    5    libc.so.6                          0x00002b772ff6f460 __libc_start_main +
    245

    6    tmp8iq0dhq7                        0x000055577ac9a329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpl72yvtnt/tmpl72yvtnt.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b08d7367c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b08d705eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b08d705e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b08d705d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl72yvtnt                        0x00005601b6b8c3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b08d7553460 __libc_start_main +
    245

    6    tmpl72yvtnt                        0x00005601b6b8bf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    if grid[0].count\
    \ == 0 {\n        return 0\n    }\n    var m = grid.count\n    var n = grid[0].count\n\
    \    var i = 0\n    var j = 0\n    var water = 0\n    var count = 0\n    while\
    \ i < m {\n        j = 0\n        while j < n {\n            if grid[i][j] ==\
    \ 1 {\n                water += 1\n                if water == capacity {\n  \
    \                  count += 1\n                    water = 0\n               \
    \ }\n            }\n            j += 1\n        }\n        i += 1\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8b6bn2tf/tmp8b6bn2tf.swift:67: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b67a7c9bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b67a7992b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b67a7992988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b67a79917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8b6bn2tf                        0x000055b9485866a7 <unavailable> + 5799

    5    libc.so.6                          0x00002b67a7e87460 __libc_start_main +
    245

    6    tmp8b6bn2tf                        0x000055b948586069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmykbycf2/tmpmykbycf2.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af9c119fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af9c0e96b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af9c0e96988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af9c0e957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmykbycf2                        0x000055a232d753d6 <unavailable> + 5078

    5    libc.so.6                          0x00002af9c138b460 __libc_start_main +
    245

    6    tmpmykbycf2                        0x000055a232d74f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // Get the number of rows and columns\n    let rows = grid.count\n\
    \    let columns = grid[0].count\n    \n    // Define the grid of heights\n  \
    \  var heights = [[Int]](repeating: [Int](repeating: 0, count: columns), count:\
    \ rows)\n    \n    // Calculate the heights\n    for row in 0..<rows {\n     \
    \   for column in 0..<columns {\n            heights[row][column] = grid[row][column]\n\
    \            if row > 0 {\n                heights[row][column] += heights[row\
    \ - 1][column]\n            }\n        }\n    }\n    \n    // Count the number\
    \ of filled buckets\n    var count = 0\n    for row in 0..<rows {\n        for\
    \ column in 0..<columns {\n            if heights[row][column] == 0 {\n      \
    \          continue\n            }\n            count += heights[row][column]\
    \ / capacity\n            heights[row][column] = heights[row][column] % capacity\n\
    \        }\n    }\n    \n    // Calculate the number of times the buckets need\
    \ to be filled or emptied\n    var result = 0\n    while rows > 0 {\n        //\
    \ Remove the first row\n        heights.removeFirst()\n        rows -= 1\n   \
    \     \n        // Check if the number of rows is zero\n        if rows == 0 {\n\
    \            break\n        }\n        \n        // Get the maximum height in\
    \ the first row\n        let max_height = heights[0].max()!\n        \n      \
    \  // If the maximum height is zero, skip the current row\n        if max_height\
    \ == 0 {\n            continue\n        }\n        \n        // Fill the buckets\
    \ in the first row\n        for column in 0..<columns {\n            if heights[0][column]\
    \ == 0 {\n                continue\n            }\n            heights[0][column]\
    \ = max_height\n            result += max_height\n        }\n        \n      \
    \  // Calculate the difference between the first and other rows\n        for row\
    \ in 1..<rows {\n            for column in 0..<columns {\n                if heights[row][column]\
    \ == 0 {\n                    continue\n                }\n                let\
    \ diff = heights[0][column] - heights[row][column]\n                if diff >\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
    \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1,\
    \ 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpd8_e29ta.swift:89:28: error: expected '{' after 'if' condition\n\
    \                if diff > 0\n                           ^\n/tmp/tmpd8_e29ta.swift:109:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmpd8_e29ta.swift:83:29: note: to\
    \ match this opening '{'\n        for row in 1..<rows {\n                    \
    \        ^\n/tmp/tmpd8_e29ta.swift:109:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmpd8_e29ta.swift:55:20: note: to match this opening '{'\n    while\
    \ rows > 0 {\n                   ^\n/tmp/tmpd8_e29ta.swift:109:71: error: expected\
    \ '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1,\
    \ 1]], capacity: 9) == 2)\n                                                  \
    \                    ^\n/tmp/tmpd8_e29ta.swift:23:52: note: to match this opening\
    \ '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n                \
    \                                   ^\n/tmp/tmpd8_e29ta.swift:58:14: error: left\
    \ side of mutating operator isn't mutable: 'rows' is a 'let' constant\n      \
    \  rows -= 1\n        ~~~~ ^\n/tmp/tmpd8_e29ta.swift:25:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let rows = grid.count\n    ^~~\n    var\n/tmp/tmpd8_e29ta.swift:93:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let max = grid.map { $0.max() ?? 0 }.max() ?? 0\n    return grid.map\
    \ { $0.reduce(0) { $0 + ($1 - max) } }.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpk3lrvl5f/tmpk3lrvl5f.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b800a8a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b800a59ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b800a59a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b800a5997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk3lrvl5f                        0x0000560b7878f596 <unavailable> + 5526

    5    libc.so.6                          0x00002b800aa8f460 __libc_start_main +
    245

    6    tmpk3lrvl5f                        0x0000560b7878f129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // TODO: implement me\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp8bi3klgs/tmp8bi3klgs.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b926a7f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b926a4ecb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b926a4ec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b926a4eb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8bi3klgs                        0x00005556248f03d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b926a9e1460 __libc_start_main +
    245

    6    tmp8bi3klgs                        0x00005556248eff69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var fillCount = 0\n    var grid = grid\n    let rowCount = grid.count\n\
    \    let columnCount = grid[0].count\n    var newRow: [Int] = []\n    for j in\
    \ 0...(columnCount - 1) {\n        for i in 0...(rowCount - 1) {\n           \
    \ if grid[i][j] == 1 {\n                grid[i][j] = capacity\n              \
    \  fillCount += 1\n            }\n        }\n        for i in 0...(rowCount -\
    \ 1) {\n            if grid[i][j] > 0 {\n                newRow.append(grid[i][j]\
    \ - 1)\n            } else {\n                newRow.append(0)\n            }\n\
    \        }\n        grid.append(newRow)\n        newRow = []\n    }\n    return\
    \ fillCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxz_wllbu/tmpxz_wllbu.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6b4eb6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6b4e861b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6b4e861988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6b4e8607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxz_wllbu                        0x00005566d7814977 <unavailable> + 6519

    5    libc.so.6                          0x00002b6b4ed56460 __libc_start_main +
    245

    6    tmpxz_wllbu                        0x00005566d7814339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let maxRow = grid.count - 1\n    let maxCol = grid[0].count -\
    \ 1\n    var minHeight = 0\n    var drops = 0\n    let grid: [[Int]] = grid.map\
    \ { row in\n        return row.map { row in\n            return row * capacity\n\
    \        }\n    }\n    let totalSum = grid.map { row in\n        return row.reduce(0,\
    \ +)\n    }.reduce(0, +)\n    while totalSum > 0 {\n        for row in 0...maxRow\
    \ {\n            for col in 0...maxCol {\n                if grid[row][col] >\
    \ 0 {\n                    grid[row][col] -= 1\n                    totalSum -=\
    \ 1\n                }\n            }\n        }\n        minHeight += 1\n   \
    \     drops += 1\n        if minHeight >= capacity {\n            minHeight =\
    \ 0\n            var col = 0\n            while col <= maxCol {\n            \
    \    if col == 0 {\n                    var row = 0\n                    while\
    \ row <= maxRow {\n                        if grid[row][col] > 0 {\n         \
    \                   grid[row][col] -= 1\n                            totalSum\
    \ -= 1\n                        }\n                        row += 1\n        \
    \            }\n                } else if col == maxCol {\n                  \
    \  var row = maxRow\n                    while row >= 0 {\n                  \
    \      if grid[row][col] > 0 {\n                            grid[row][col] -=\
    \ 1\n                            totalSum -= 1\n                        }\n  \
    \                      row -= 1\n                    }\n                } else\
    \ {\n                    var row = 0\n                    while row <= maxRow\
    \ {\n                        if grid[row][col] > 0 {\n                       \
    \     grid[row][col] -= 1\n                            totalSum -= 1\n       \
    \                 }\n                        row += 1\n                    }\n\
    \                }\n                col += 1\n            }\n            drops\
    \ += 1\n        }\n    }\n    return drops\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpx7_vl9nx.swift:40:36: error: left side of mutating operator isn't\
    \ mutable: 'grid' is a 'let' constant\n                    grid[row][col] -= 1\n\
    \                    ~~~~           ^\n/tmp/tmpx7_vl9nx.swift:28:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let grid: [[Int]] = grid.map { row in\n\
    \    ^~~\n    var\n/tmp/tmpx7_vl9nx.swift:41:30: error: left side of mutating\
    \ operator isn't mutable: 'totalSum' is a 'let' constant\n                   \
    \ totalSum -= 1\n                    ~~~~~~~~ ^\n/tmp/tmpx7_vl9nx.swift:33:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let totalSum = grid.map\
    \ { row in\n    ^~~\n    var\n/tmp/tmpx7_vl9nx.swift:55:44: error: left side of\
    \ mutating operator isn't mutable: 'grid' is a 'let' constant\n              \
    \              grid[row][col] -= 1\n                            ~~~~         \
    \  ^\n/tmp/tmpx7_vl9nx.swift:28:5: note: change 'let' to 'var' to make it mutable\n\
    \    let grid: [[Int]] = grid.map { row in\n    ^~~\n    var\n/tmp/tmpx7_vl9nx.swift:56:38:\
    \ error: left side of mutating operator isn't mutable: 'totalSum' is a 'let' constant\n\
    \                            totalSum -= 1\n                            ~~~~~~~~\
    \ ^\n/tmp/tmpx7_vl9nx.swift:33:5: note: change 'let' to 'var' to make it mutable\n\
    \    let totalSum = grid.map { row in\n    ^~~\n    var\n/tmp/tmpx7_vl9nx.swift:64:44:\
    \ error: left side of mutating operator isn't mutable: 'grid' is a 'let' constant\n\
    \                            grid[row][col] -= 1\n                           \
    \ ~~~~           ^\n/tmp/tmpx7_vl9nx.swift:28:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let grid: [[Int]] = grid.map { row in\n    ^~~\n    var\n\
    /tmp/tmpx7_vl9nx.swift:65:38: error: left side of mutating operator isn't mutable:\
    \ 'totalSum' is a 'let' constant\n                            totalSum -= 1\n\
    \                            ~~~~~~~~ ^\n/tmp/tmpx7_vl9nx.swift:33:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let totalSum = grid.map { row in\n  \
    \  ^~~\n    var\n/tmp/tmpx7_vl9nx.swift:73:44: error: left side of mutating operator\
    \ isn't mutable: 'grid' is a 'l"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // TODO: solve\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpcoryl1ey/tmpcoryl1ey.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea053abc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea050a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea050a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea050a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcoryl1ey                        0x0000556464d733d6 <unavailable> + 5078

    5    libc.so.6                          0x00002aea05597460 __libc_start_main +
    245

    6    tmpcoryl1ey                        0x0000556464d72f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            count += grid[i][j]\n \
    \       }\n    }\n    count -= 1\n    var c = 0\n    while count > 0 {\n     \
    \   c += 1\n        for i in 0..<grid.count {\n            for j in 0..<grid[i].count\
    \ {\n                if grid[i][j] == 1 {\n                    if i == 0 {\n \
    \                       grid[i][j] = 0\n                        count -= 1\n \
    \                   } else if grid[i - 1][j] == 0 {\n                        grid[i][j]\
    \ = 0\n                        count -= 1\n                    }\n           \
    \     }\n            }\n        }\n    }\n    return c\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1opk87ct/tmp1opk87ct.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b9b897c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b9b58eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9b9b58e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9b9b58d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1opk87ct                        0x000056161f59e706 <unavailable> + 5894

    5    libc.so.6                          0x00002b9b9ba83460 __libc_start_main +
    245

    6    tmp1opk87ct                        0x000056161f59e299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    let total_fill\
    \ = grid.reduce(0) { $0 + $1.reduce(0) { $0 + $1 } }\n    if total_fill == 0 {\n\
    \        return 0\n    }\n    if total_fill < capacity {\n        return total_fill\n\
    \    }\n    let number_of_wells = grid.count\n    let number_of_units = grid[0].count\n\
    \    let total_units = number_of_wells * number_of_units\n    if total_units ==\
    \ total_fill {\n        return capacity\n    }\n    let number_of_completions\
    \ = total_fill / capacity\n    let remainder = total_fill % capacity\n    return\
    \ number_of_completions + (remainder > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwnb9izqs/tmpwnb9izqs.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4e95ec7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4e95bbeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4e95bbe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4e95bbd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwnb9izqs                        0x000055e8b071da9f <unavailable> + 6815

    5    libc.so.6                          0x00002b4e960b3460 __libc_start_main +
    245

    6    tmpwnb9izqs                        0x000055e8b071d1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let columns = grid[0].count\n    var\
    \ max_found = 0\n    var buckets = [Int](repeating: 0, count: rows)\n    for column\
    \ in 0..<columns {\n        var row = 0\n        while row < rows {\n        \
    \    if grid[row][column] == 1 {\n                buckets[row] += 1\n        \
    \        max_found = max(max_found, buckets[row])\n            }\n           \
    \ row += 1\n        }\n    }\n    return (max_found / capacity) + (max_found %\
    \ capacity > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkiuvk96z/tmpkiuvk96z.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a754a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a75197b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a75197988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a751967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkiuvk96z                        0x00005609cce587a6 <unavailable> + 6054

    5    libc.so.6                          0x00002b5a7568c460 __libc_start_main +
    245

    6    tmpkiuvk96z                        0x00005609cce58339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    func isGridEmpty(grid: [[Int]]) -> Bool {\n        for row\
    \ in grid {\n            for well in row {\n                if well == 1 {\n \
    \                   return false\n                }\n            }\n        }\n\
    \        return true\n    }\n    \n    func fillBucket(grid: [[Int]], rowIndex:\
    \ Int, columnIndex: Int, capacity: Int) -> Int {\n        var grid = grid\n  \
    \      let count = min(grid[rowIndex][columnIndex], capacity)\n        grid[rowIndex][columnIndex]\
    \ -= count\n        return count\n    }\n    \n    func emptyBucket(grid: [[Int]],\
    \ rowIndex: Int, columnIndex: Int, bucketSize: Int) -> Int {\n        var grid\
    \ = grid\n        let count = min(grid[rowIndex][columnIndex], bucketSize)\n \
    \       grid[rowIndex][columnIndex] -= count\n        return count\n    }\n  \
    \  \n    func fillWells(grid: [[Int]], rowIndex: Int, columnIndex: Int, capacity:\
    \ Int) -> [[Int]] {\n        var grid = grid\n        var rowIndex = rowIndex\n\
    \        var columnIndex = columnIndex\n        var counter = 0\n        while\
    \ rowIndex >= 0 {\n            let bucket = fillBucket(grid: grid, rowIndex: rowIndex,\
    \ columnIndex: columnIndex, capacity: capacity)\n            rowIndex -= 1\n \
    \           columnIndex += 1\n            if columnIndex == grid[0].count {\n\
    \                break\n            }\n            let bucketEmpty = emptyBucket(grid:\
    \ grid, rowIndex: rowIndex, columnIndex: columnIndex, bucketSize: bucket)\n  \
    \          counter += bucketEmpty\n        }\n        return grid\n    }\n   \
    \ \n    var counter = 0\n    var grid = grid\n    while isGridEmpty(grid: grid)\
    \ == false {\n        for i in 0..<grid.count {\n            grid = fillWells(grid:\
    \ grid, rowIndex: i, columnIndex: 0, capacity: capacity)\n            counter\
    \ += 1\n        }\n    }\n    return counter\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b138b0a0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b138ad97561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b138ad97286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b138ad9713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b138ad96bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b138ad8048a <unavailable> + 1340554

    6    tmp6acdvg4q                        0x00005631bb05f714 <unavailable> + 10004

    7    tmp6acdvg4q                        0x00005631bb05fad0 <unavailable> + 10960

    8    tmp6acdvg4q                        0x00005631bb05f124 <unavailable> + 8484

    9    tmp6acdvg4q                        0x00005631bb05e878 <unavailable> + 6264

    10   libc.so.6                          0x00002b138b28c460 __libc_start_main +
    245

    11   tmp6acdvg4q                        0x00005631bb05e489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var water\
    \ = 0\n    for i in 0..<rows {\n        for j in 0..<cols {\n            water\
    \ += grid[i][j]\n        }\n    }\n    let maxWater = capacity * cols\n    let\
    \ reduceBy = min(water, maxWater)\n    return maxWater - reduceBy\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmph6b7110w/tmph6b7110w.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b229305cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2292d53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2292d53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2292d527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph6b7110w                        0x0000556683b736f6 <unavailable> + 5878

    5    libc.so.6                          0x00002b2293248460 __libc_start_main +
    245

    6    tmph6b7110w                        0x0000556683b73289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // Your code here!\n    var totalTimes = 0\n    let rowCount =\
    \ grid.count\n    let colCount = grid[0].count\n    for i in 0..<rowCount {\n\
    \        for j in 0..<colCount {\n            let bucket = grid[i][j]\n      \
    \      if bucket == 1 {\n                totalTimes += 1\n                for\
    \ m in i..<rowCount {\n                    for n in j..<colCount {\n         \
    \               if grid[m][n] != 1 {\n                            break\n    \
    \                    }\n                        grid[m][n] = 0\n             \
    \       }\n                }\n            }\n        }\n    }\n    return totalTimes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpw86yiwfe.swift:38:32: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                        grid[m][n] = 0\n              \
    \          ~~~~   ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n    var total = 0\n    while let max = grid.map({\
    \ $0.max() ?? 0 }).max() {\n        total += max / capacity\n        total +=\
    \ max % capacity == 0 ? 0 : 1\n        grid.map { $0.map { $0 - min($0, capacity)\
    \ } }\n    }\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978609
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let max_row = grid.map { $0.reduce(0, +) }.max() ?? 0\n    let\
    \ max_col = zip(grid[0], grid[1]).map { $0.0 + $0.1 }.max() ?? 0\n    let max_diag\
    \ = zip(grid[0], grid[1]).map { $0.0 + $0.1 }.max() ?? 0\n    return max(max_row,\
    \ max_col, max_diag)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqpdqj7dk/tmpqpdqj7dk.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad47fd52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad47fa49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad47fa49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad47fa487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqpdqj7dk                        0x000055915ae486f6 <unavailable> + 5878

    5    libc.so.6                          0x00002ad47ff3e460 __libc_start_main +
    245

    6    tmpqpdqj7dk                        0x000055915ae48289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5ld0g0ni/tmp5ld0g0ni.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8faa2d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fa9fd0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fa9fd0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fa9fcf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ld0g0ni                        0x000055bf825933d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b8faa4c5460 __libc_start_main +
    245

    6    tmp5ld0g0ni                        0x000055bf82592f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n    let w = grid[0].count\n    let d = grid.count\n\
    \    var max_per_row = Array(repeating: 0, count: d)\n    for i in 0..<d {\n \
    \       for j in 0..<w {\n            if grid[i][j] == 1 {\n                max_per_row[i]\
    \ += 1\n            }\n        }\n    }\n    var buckets = Array(repeating: 0,\
    \ count: d)\n    var remaining = capacity\n    var count = 0\n    while remaining\
    \ > 0 {\n        var index = 0\n        var max = 0\n        for i in 0..<d {\n\
    \            if max_per_row[i] > max {\n                max = max_per_row[i]\n\
    \                index = i\n            }\n        }\n        if max == 0 {\n\
    \            break\n        }\n        if buckets[index] < max {\n           \
    \ buckets[index] += 1\n            remaining -= 1\n        }\n        count +=\
    \ 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpg92x0cv_/tmpg92x0cv_.swift:72: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b520791cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5207613b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5207613988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52076127b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg92x0cv_                        0x000056148959e716 <unavailable> + 5910

    5    libc.so.6                          0x00002b5207b08460 __libc_start_main +
    245

    6    tmpg92x0cv_                        0x000056148959e2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var totalWater = 0\n    for row in grid {\n        for num in\
    \ row {\n            if num == 1 {\n                totalWater += 1\n        \
    \    }\n        }\n    }\n    return totalWater / capacity + (totalWater % capacity\
    \ > 0 ? 1 : 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdfa163dy/tmpdfa163dy.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e9135bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e91052b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e91052988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e910517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdfa163dy                        0x000055e3544afbd4 <unavailable> + 7124

    5    libc.so.6                          0x00002b7e91547460 __libc_start_main +
    245

    6    tmpdfa163dy                        0x000055e3544af169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var water = 0\n    for row in grid {\n        for col in\
    \ row {\n            if col == 1 {\n                water += 1\n            }\n\
    \        }\n    }\n    \n    if capacity > water {\n        return 0\n    }\n\
    \    \n    return water / capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp37r9re81/tmp37r9re81.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af350187c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af34fe7eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af34fe7e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af34fe7d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp37r9re81                        0x000055833c9997a7 <unavailable> + 6055

    5    libc.so.6                          0x00002af350373460 __libc_start_main +
    245

    6    tmp37r9re81                        0x000055833c999169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    let grid = grid.map({ $0.map({ $0 * capacity\
    \ }) })\n    var max = 0\n    for row in grid {\n        max = max < row.max()!\
    \ ? row.max()! : max\n    }\n    for _ in 0...max {\n        for i in 0..<grid.count\
    \ {\n            for j in 0..<grid[i].count {\n                if grid[i][j] ==\
    \ 0 {\n                    if i != 0 {\n                        grid[i - 1][j]\
    \ = grid[i - 1][j] - 1\n                        count += 1\n                 \
    \   }\n                    if i != grid.count - 1 {\n                        grid[i\
    \ + 1][j] = grid[i + 1][j] - 1\n                        count += 1\n         \
    \           }\n                    if j != 0 {\n                        grid[i][j\
    \ - 1] = grid[i][j - 1] - 1\n                        count += 1\n            \
    \        }\n                    if j != grid[i].count - 1 {\n                \
    \        grid[i][j + 1] = grid[i][j + 1] - 1\n                        count +=\
    \ 1\n                    }\n                }\n            }\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpy1fet738.swift:35:36: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                        grid[i - 1][j] = grid[i - 1][j]\
    \ - 1\n                        ~~~~       ^\n/tmp/tmpy1fet738.swift:25:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let grid = grid.map({ $0.map({\
    \ $0 * capacity }) })\n    ^~~\n    var\n/tmp/tmpy1fet738.swift:39:36: error:\
    \ cannot assign through subscript: 'grid' is a 'let' constant\n              \
    \          grid[i + 1][j] = grid[i + 1][j] - 1\n                        ~~~~ \
    \      ^\n/tmp/tmpy1fet738.swift:25:5: note: change 'let' to 'var' to make it\
    \ mutable\n    let grid = grid.map({ $0.map({ $0 * capacity }) })\n    ^~~\n \
    \   var\n/tmp/tmpy1fet738.swift:43:32: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                        grid[i][j - 1] = grid[i][j\
    \ - 1] - 1\n                        ~~~~   ^\n/tmp/tmpy1fet738.swift:25:5: note:\
    \ change 'let' to 'var' to make it mutable\n    let grid = grid.map({ $0.map({\
    \ $0 * capacity }) })\n    ^~~\n    var\n/tmp/tmpy1fet738.swift:47:32: error:\
    \ cannot assign through subscript: 'grid' is a 'let' constant\n              \
    \          grid[i][j + 1] = grid[i][j + 1] - 1\n                        ~~~~ \
    \  ^\n/tmp/tmpy1fet738.swift:25:5: note: change 'let' to 'var' to make it mutable\n\
    \    let grid = grid.map({ $0.map({ $0 * capacity }) })\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let gridLength = grid.count\n    let gridWidth = grid[0].count\n\
    \    var buckets = Array(repeating: capacity, count: gridWidth)\n    var fill\
    \ = 0\n    for i in 0..<gridLength {\n        let row = grid[i]\n        for j\
    \ in 0..<gridWidth {\n            if buckets[j] >= row[j] {\n                buckets[j]\
    \ -= row[j]\n            } else {\n                let diff = row[j] - buckets[j]\n\
    \                buckets[j] = capacity - diff\n                fill += diff\n\
    \            }\n        }\n    }\n    return fill\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmplngk5y_n/tmplngk5y_n.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43d603ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43d5d31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43d5d31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43d5d307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplngk5y_n                        0x000055cc24ec3716 <unavailable> + 5910

    5    libc.so.6                          0x00002b43d6226460 __libc_start_main +
    245

    6    tmplngk5y_n                        0x000055cc24ec32a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let sum = grid.map { $0.reduce(0, +) }.reduce(0, +)\n    if sum\
    \ <= capacity {\n        return 0\n    }\n    let n = grid.count\n    let m =\
    \ grid[0].count\n    var result = 0\n    var copied = Array(repeating: Array(repeating:\
    \ 0, count: m), count: n)\n    var delta = Array(repeating: Array(repeating: 0,\
    \ count: m), count: n)\n    var total = 0\n    while total < sum {\n        for\
    \ i in 0..<n {\n            for j in 0..<m {\n                delta[i][j] = min(grid[i][j],\
    \ capacity - copied[i][j])\n                copied[i][j] += delta[i][j]\n    \
    \            total += delta[i][j]\n            }\n        }\n        result +=\
    \ 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpy4bz63ug/tmpy4bz63ug.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ca51c7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ca4ebeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ca4ebe988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ca4ebd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy4bz63ug                        0x0000556ca54e6986 <unavailable> + 6534

    5    libc.so.6                          0x00002b7ca53b3460 __libc_start_main +
    245

    6    tmpy4bz63ug                        0x0000556ca54e6519 <unavailable> + 5401

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    // Input:\n    //  grid: [[Int]]\n    //  capacity: Int\n\
    \    // Output:\n    //  Int\n    \n    // Approach:\n    //  1. precompute the\
    \ \"set bits\" in each row of the grid - 0 is a hole, 1 is a well\n    //  2.\
    \ scan the columns of the grid and \"fill\" a \"tank\" of the capacity\n    //\
    \  3. repeat until filled (and return the number of operations)\n    \n    let\
    \ well_depths = grid.map({\n        // O(n) time complexity\n        $0.reduce(0,\
    \ { result, bit in\n            if bit == 1 {\n                return result +\
    \ 1\n            } else {\n                return result\n            }\n    \
    \    })\n    })\n    \n    // O(n^2) time complexity\n    var tank = 0\n    var\
    \ time = 0\n    while tank < capacity {\n        // O(n) time complexity\n   \
    \     for row in 0..<grid.count {\n            let column = time % grid[row].count\n\
    \            if grid[row][column] == 1 {\n                tank += 1\n        \
    \    }\n            if tank >= capacity {\n                break\n           \
    \ }\n        }\n        time += 1\n    }\n    \n    return time\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpwiox4f4o/tmpwiox4f4o.swift:80: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adeba4bac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adeba1b1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adeba1b1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adeba1b07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwiox4f4o                        0x0000560d5764e776 <unavailable> + 6006

    5    libc.so.6                          0x00002adeba6a6460 __libc_start_main +
    245

    6    tmpwiox4f4o                        0x0000560d5764e309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    guard grid.count > 0 else { return 0 }\n    \n    var grid\
    \ = grid\n    let num_wells = grid.count\n    let well_len = grid[0].count\n \
    \   var num_actions = 0\n    \n    for _ in 0..<num_wells {\n        var row_total\
    \ = 0\n        for col in 0..<well_len {\n            if grid[0][col] == 1 {\n\
    \                row_total += 1\n            }\n        }\n        num_actions\
    \ += row_total / capacity\n        if row_total % capacity != 0 {\n          \
    \  num_actions += 1\n        }\n        grid.removeFirst()\n    }\n    \n    return\
    \ num_actions\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var curr_row\
    \ = 0\n    var curr_col = 0\n    var result = 0\n    while curr_row < rows &&\
    \ curr_col < cols {\n        if grid[curr_row][curr_col] != 0 {\n            grid[curr_row][curr_col]\
    \ -= capacity\n            result += 1\n        }\n        // move horizontally\
    \ to the end of the row\n        curr_col += 1\n        if curr_col == cols {\n\
    \            // move horizontally to the beginning of the next row\n         \
    \   curr_col = 0\n            curr_row += 1\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpuf4goeoi.swift:31:38: error: left side of mutating operator isn't\
    \ mutable: 'grid' is a 'let' constant\n            grid[curr_row][curr_col] -=\
    \ capacity\n            ~~~~                     ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    \n    var wellsCount = 0\n    var fullWellsCount = 0\n    var\
    \ bucketsCount = 0\n    \n    for row in grid {\n        wellsCount += row.count\n\
    \        \n        for well in row {\n            if well == 1 {\n           \
    \     fullWellsCount += 1\n            }\n        }\n    }\n    \n    bucketsCount\
    \ = wellsCount / capacity\n    \n    return fullWellsCount / bucketsCount\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp2zmfbcrx/tmp2zmfbcrx.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b482b76ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b482b461b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b482b461988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b482b4607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2zmfbcrx                        0x000055bf07c85636 <unavailable> + 5686

    5    libc.so.6                          0x00002b482b956460 __libc_start_main +
    245

    6    tmp2zmfbcrx                        0x000055bf07c851c9 <unavailable> + 4553

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var cur = capacity\n    var count = 0\n \
    \   for i in 0 ..< grid.count {\n        if grid[i].contains(1) {\n          \
    \  cur = cur - grid[i].filter({$0 == 1}).count\n            if cur < 0 {\n   \
    \             cur = capacity\n                count += 1\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_jar5d8z/tmp_jar5d8z.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47c9913c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47c960ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47c960a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47c96097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_jar5d8z                        0x000055ead6e00736 <unavailable> + 5942

    5    libc.so.6                          0x00002b47c9aff460 __libc_start_main +
    245

    6    tmp_jar5d8z                        0x000055ead6e002c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var deepestWell\
    \ = 0\n    for i in 0..<rows {\n        let max = grid[i].max()!\n        if max\
    \ > deepestWell {\n            deepestWell = max\n        }\n    }\n    var fillCount\
    \ = 0\n    for depth in 0..<deepestWell {\n        for i in 0..<rows {\n     \
    \       for j in 0..<cols {\n                if grid[i][j] > depth {\n       \
    \             fillCount += 1\n                }\n            }\n        }\n  \
    \  }\n    return fillCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpaiwgj3xz/tmpaiwgj3xz.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c011b2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c00ea9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c00ea9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c00ea87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaiwgj3xz                        0x0000558abd2aa8c7 <unavailable> + 6343

    5    libc.so.6                          0x00002b3c0139e460 __libc_start_main +
    245

    6    tmpaiwgj3xz                        0x0000558abd2aa289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0, grid[0].count > 0 else { return 0 }\n  \
    \  var filled_rows = grid.count\n    var filled_columns = grid[0].count\n    while\
    \ (filled_rows > 0 && filled_columns > 0) {\n        var filled_rows_copy = filled_rows\n\
    \        var filled_columns_copy = filled_columns\n        for i in 0..<filled_rows\
    \ {\n            for j in 0..<filled_columns {\n                if grid[i][j]\
    \ != 0 {\n                    filled_rows_copy -= 1\n                    break\n\
    \                }\n            }\n        }\n        for j in 0..<filled_columns\
    \ {\n            for i in 0..<filled_rows {\n                if grid[i][j] !=\
    \ 0 {\n                    filled_columns_copy -= 1\n                    break\n\
    \                }\n            }\n        }\n        filled_rows = filled_rows_copy\n\
    \        filled_columns = filled_columns_copy\n    }\n    return (filled_rows+filled_columns)*capacity\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpg0fo4_v7/tmpg0fo4_v7.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5d627f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5d624e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5d624e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5d624e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg0fo4_v7                        0x00005571d6d17656 <unavailable> + 5718

    5    libc.so.6                          0x00002b5d629dd460 __libc_start_main +
    245

    6    tmpg0fo4_v7                        0x00005571d6d171e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    var result\
    \ = 0\n    for column in grid[0].indices {\n        for row in grid.indices {\n\
    \            let cell = grid[row][column]\n            if cell == 1 {\n      \
    \          result += 1\n                var buckets = capacity\n             \
    \   var row_index = row\n                while buckets > 0 && row_index >= 0 {\n\
    \                    let current_cell = grid[row_index][column]\n            \
    \        if current_cell == 1 {\n                        buckets -= 1\n      \
    \                  grid[row_index][column] = 0\n                    }\n      \
    \              row_index -= 1\n                }\n            }\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpbsxc4jbj.swift:39:40: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                        grid[row_index][column] = 0\n \
    \                       ~~~~           ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var fill = 0\n    var fill_amount = 0\n    let row_length = grid[0].count\n\
    \    for row in grid {\n        for block in row {\n            fill_amount +=\
    \ block\n            if fill_amount == capacity {\n                fill += 1\n\
    \                fill_amount = 0\n            }\n        }\n        fill_amount\
    \ = 0\n    }\n    return fill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpq7dn6s3t/tmpq7dn6s3t.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aacdecb2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aacde9a9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aacde9a9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aacde9a87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq7dn6s3t                        0x00005647872887b7 <unavailable> + 6071

    5    libc.so.6                          0x00002aacdee9e460 __libc_start_main +
    245

    6    tmpq7dn6s3t                        0x0000564787288179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code goes here\n    let numRows = grid.count, numCols\
    \ = grid[0].count\n    var grid = grid\n    var count = 0\n    for i in 0..<numRows\
    \ {\n        for j in 0..<numCols {\n            if grid[i][j] == 1 {\n      \
    \          count += 1\n                fillOneCell(grid: &grid, row: i, col: j,\
    \ capacity: capacity)\n            }\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpabsa_oh1.swift:32:17: error: cannot find 'fillOneCell' in scope\n\
    \                fillOneCell(grid: &grid, row: i, col: j, capacity: capacity)\n\
    \                ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // edge cases\n    guard grid.count > 0 else { return 0 }\n  \
    \  guard grid[0].count > 0 else { return 0 }\n    \n    var row_sums = [Int]()\n\
    \    var sum = 0\n    for row in grid {\n        for column in row {\n       \
    \     sum += column\n        }\n        row_sums.append(sum)\n        sum = 0\n\
    \    }\n    \n    var times = 0\n    var well_count = grid[0].count\n    var row_count\
    \ = grid.count\n    var x = 0\n    while x < row_count {\n        if row_sums[x]\
    \ > capacity {\n            row_sums[x] -= capacity\n            times += 1\n\
    \        } else {\n            times += row_sums[x]\n            row_sums[x] =\
    \ 0\n        }\n        x += 1\n    }\n    \n    var y = 0\n    while y < well_count\
    \ {\n        var z = 0\n        while z < row_count {\n            if grid[z][y]\
    \ == 1 {\n                if row_sums[z] > capacity {\n                    row_sums[z]\
    \ -= capacity\n                    times += 1\n                } else {\n    \
    \                times += row_sums[z]\n                    row_sums[z] = 0\n \
    \               }\n            }\n            z += 1\n        }\n        y +=\
    \ 1\n    }\n    \n    return times\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpp22f2i8c/tmpp22f2i8c.swift:88: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af5ed3e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af5ed0e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af5ed0e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af5ed0df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp22f2i8c                        0x0000563adf3f4917 <unavailable> + 6423

    5    libc.so.6                          0x00002af5ed5d5460 __libc_start_main +
    245

    6    tmpp22f2i8c                        0x0000563adf3f42d9 <unavailable> + 4825

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0, grid[0].count > 0 else { return 0 }\n  \
    \  let height = grid.count\n    let width = grid[0].count\n    var currentMax\
    \ = capacity\n    var current = 0\n    var times = 0\n    for row in grid {\n\
    \        for column in row {\n            if column == 1 {\n                current\
    \ += 1\n            }\n        }\n        if current > currentMax {\n        \
    \    currentMax = current\n            times += 1\n        }\n        current\
    \ = 0\n    }\n    return times\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpvd_u81jb/tmpvd_u81jb.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31485ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31482e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31482e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31482e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvd_u81jb                        0x000055670ac8b5e6 <unavailable> + 5606

    5    libc.so.6                          0x00002b31487d7460 __libc_start_main +
    245

    6    tmpvd_u81jb                        0x000055670ac8b179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var maxFill = 0\n    for row in grid {\n        maxFill += max_fill(row:\
    \ row, capacity: capacity)\n    }\n    return maxFill\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8nqlv5aa.swift:26:28: error: incorrect argument label in call (have\
    \ 'row:capacity:', expected 'grid:capacity:')\n        maxFill += max_fill(row:\
    \ row, capacity: capacity)\n                           ^~~~\n                \
    \            grid\n/tmp/tmp8nqlv5aa.swift:26:34: error: cannot convert value of\
    \ type '[Int]' to expected argument type '[[Int]]'\n        maxFill += max_fill(row:\
    \ row, capacity: capacity)\n                                 ^\n/tmp/tmp8nqlv5aa.swift:26:34:\
    \ note: arguments to generic parameter 'Element' ('Int' and '[Int]') are expected\
    \ to be equal\n        maxFill += max_fill(row: row, capacity: capacity)\n   \
    \                              ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  var max_water = 0\n  for i in 0..<grid.count {\n    var collected_water\
    \ = 0\n    for j in 0..<grid[i].count {\n      if grid[i][j] == 1 {\n        collected_water\
    \ += 1\n      }\n    }\n    max_water += min(collected_water, capacity)\n  }\n\
    \  return max_water\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmptq49f1s8/tmptq49f1s8.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea3bf22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea3bc19b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea3bc19988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea3bc187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptq49f1s8                        0x00005558e30416f6 <unavailable> + 5878

    5    libc.so.6                          0x00002aea3c10e460 __libc_start_main +
    245

    6    tmptq49f1s8                        0x00005558e3041289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // step 1: convert all columns to buckets\n    var buckets = [[Int]]()\n\
    \    for column in grid {\n        buckets.append(Array(repeating: capacity, count:\
    \ column.count))\n    }\n    // step 2: iterate over the columns and test if they\
    \ are full\n    var operations = 0\n    while true {\n        var isFull = true\n\
    \        for column in 0..<grid.count {\n            for bucket in 0..<grid[column].count\
    \ {\n                if buckets[column][bucket] > 0 {\n                    isFull\
    \ = false\n                    // fill the bucket\n                    operations\
    \ += 1\n                    buckets[column][bucket] -= 1\n                }\n\
    \            }\n        }\n        if isFull {\n            break\n        }\n\
    \    }\n    return operations\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp36cyssjk/tmp36cyssjk.swift:63: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5609d69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5609a60b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5609a60988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5609a5f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp36cyssjk                        0x0000560306e92976 <unavailable> + 6518

    5    libc.so.6                          0x00002b5609f55460 __libc_start_main +
    245

    6    tmp36cyssjk                        0x0000560306e92509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  var buckets = 0\n  var next_fill = capacity\n  while true {\n  \
    \  let fill_index = grid[0].index(of: 1)\n    guard let index = fill_index else\
    \ { break }\n    if index <= next_fill {\n      for i in 0..<grid.count {\n  \
    \      grid[i].remove(at: index)\n      }\n      next_fill = capacity\n      buckets\
    \ += 1\n    } else {\n      next_fill -= 1\n    }\n  }\n  return buckets\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmprr6s6m42.swift:27:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    let fill_index = grid[0].index(of: 1)\n          \
    \                   ^\n/tmp/tmprr6s6m42.swift:27:30: note: use 'firstIndex(of:)'\
    \ instead\n    let fill_index = grid[0].index(of: 1)\n                       \
    \      ^~~~~\n                             firstIndex\n/tmp/tmprr6s6m42.swift:31:17:\
    \ error: cannot use mutating member on immutable value: 'grid' is a 'let' constant\n\
    \        grid[i].remove(at: index)\n        ~~~~    ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    var localMax = 0\n    for i in 0..<grid.count\
    \ {\n        localMax = 0\n        for j in 0..<grid[i].count {\n            if\
    \ grid[i][j] == 1 {\n                localMax += 1\n            }\n        }\n\
    \        result += localMax/capacity\n        localMax = localMax%capacity\n \
    \       if i+1 < grid.count {\n            for j in 0..<grid[i+1].count {\n  \
    \              if grid[i+1][j] == 1 {\n                    localMax += 1\n   \
    \             }\n            }\n            result += localMax/capacity\n    \
    \        localMax = localMax%capacity\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5baeg_f_/tmp5baeg_f_.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad225a9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad225794b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad225794988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2257937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5baeg_f_                        0x000055808edaf656 <unavailable> + 5718

    5    libc.so.6                          0x00002ad225c89460 __libc_start_main +
    245

    6    tmp5baeg_f_                        0x000055808edaf1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var buckets = Array(repeating: capacity,\
    \ count: grid[0].count)\n    var steps = 0\n    while true {\n        var full_wells\
    \ = 0\n        for (index, well) in grid.enumerated() {\n            for (index2,\
    \ _) in well.enumerated() {\n                if grid[index][index2] > 0 {\n  \
    \                  full_wells += 1\n                }\n            }\n       \
    \ }\n        if full_wells == 0 {\n            break\n        }\n        for (index,\
    \ well) in grid.enumerated() {\n            for (index2, _) in well.enumerated()\
    \ {\n                buckets[index2] = min(capacity, buckets[index2] + grid[index][index2])\n\
    \                if buckets[index2] == capacity {\n                    steps +=\
    \ 1\n                    buckets[index2] = 0\n                    grid[index][index2]\
    \ = 0\n                }\n            }\n        }\n    }\n    return steps\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpby2c5ose/tmpby2c5ose.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6a72cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6a6fc6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6a6fc6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6a6fc57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpby2c5ose                        0x000055bae989f886 <unavailable> + 6278

    5    libc.so.6                          0x00002ac6a74bb460 __libc_start_main +
    245

    6    tmpby2c5ose                        0x000055bae989f419 <unavailable> + 5145

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    /// Determine the base on which to calculate the maximum fill.\n\
    \    var base = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                base += 1\n           \
    \ }\n        }\n    }\n    base *= capacity\n    \n    /// Calculate the maximum\
    \ fill.\n    var current = 0\n    var count = 0\n    while current < base {\n\
    \        for i in 0..<grid.count {\n            for j in 0..<grid[i].count {\n\
    \                if grid[i][j] == 1 {\n                    if current >= base\
    \ {\n                        return count\n                    }\n           \
    \         current += 1\n                    count += 1\n                }\n  \
    \          }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdfv06izw/tmpdfv06izw.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3113a0dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3113704b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3113704988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31137037b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdfv06izw                        0x0000558f22a42827 <unavailable> + 6183

    5    libc.so.6                          0x00002b3113bf9460 __libc_start_main +
    245

    6    tmpdfv06izw                        0x0000558f22a421e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for item in grid {\n        result += max(item.reduce(0,\
    \ {x, y in x + y}), capacity)\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpjtq4a7h8/tmpjtq4a7h8.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b007eb6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b007e864b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b007e864988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b007e8637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjtq4a7h8                        0x000055a296d21827 <unavailable> + 6183

    5    libc.so.6                          0x00002b007ed59460 __libc_start_main +
    245

    6    tmpjtq4a7h8                        0x000055a296d211e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var operations = 0\n    for row in grid {\n        var currentCapacity\
    \ = capacity\n        for well in row {\n            if well == 1 {\n        \
    \        if currentCapacity > 0 {\n                    currentCapacity -= 1\n\
    \                } else {\n                    operations += 1\n             \
    \       currentCapacity = capacity - 1\n                }\n            }\n   \
    \     }\n    }\n    return operations\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpc67pkw_5/tmpc67pkw_5.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af86df73c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af86dc6ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af86dc6a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af86dc697b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc67pkw_5                        0x000055f56902f546 <unavailable> + 5446

    5    libc.so.6                          0x00002af86e15f460 __libc_start_main +
    245

    6    tmpc67pkw_5                        0x000055f56902f0d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for column in grid[0].indices {\n        for\
    \ row in grid.indices {\n            if grid[row][column] == 1 {\n           \
    \     let bucket_count = (row + 1) / capacity\n                if bucket_count\
    \ != 0 {\n                    count += bucket_count\n                }\n     \
    \       }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp60u2iljt/tmp60u2iljt.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad30c24ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad30bf45b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad30bf45988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad30bf447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp60u2iljt                        0x0000559144f5e796 <unavailable> + 6038

    5    libc.so.6                          0x00002ad30c43a460 __libc_start_main +
    245

    6    tmp60u2iljt                        0x0000559144f5e329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let totalFill = grid.reduce(0) { $0 + $1.reduce(0, +) }\n    let\
    \ bucketFill = capacity * grid.count\n    let passes = totalFill / bucketFill\n\
    \    var finalFill = totalFill - (passes * bucketFill)\n    let lastPass = grid.map\
    \ {\n        return $0.reduce(0) {$0 + $1}\n    }.sorted().filter {$0 > 0}\n \
    \   for i in 0..<lastPass.count {\n        if finalFill >= capacity {\n      \
    \      finalFill -= capacity\n        } else {\n            finalFill = lastPass[i]\
    \ - finalFill\n        }\n    }\n    return totalFill + finalFill\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmsfoa65e/tmpmsfoa65e.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87aabf9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87aa8f0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87aa8f0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87aa8ef7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmsfoa65e                        0x000055f032ba4896 <unavailable> + 6294

    5    libc.so.6                          0x00002b87aade5460 __libc_start_main +
    245

    6    tmpmsfoa65e                        0x000055f032ba4429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code goes here\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpmq44guk0/tmpmq44guk0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c2c632c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c2c329b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c2c329988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c2c3287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmq44guk0                        0x00005588dd5843d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b5c2c81e460 __libc_start_main +
    245

    6    tmpmq44guk0                        0x00005588dd583f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    var bucket = 0\n    for _ in grid {\n  \
    \      for i in 0..<grid[0].count {\n            if grid[i][0] != 1 {\n      \
    \          if grid[i][0] != 0 {\n                    bucket = grid[i][0]\n   \
    \             }\n                if bucket < capacity {\n                    bucket\
    \ += 1\n                    max_fill += 1\n                }\n            }\n\
    \        }\n    }\n    return max_fill\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ad922e9ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad922b91561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ad922b91286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ad922b9113c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ad922b90bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ad922b7a48a <unavailable> + 1340554

    6    tmp5of309sh                        0x00005618922b8093 <unavailable> + 8339

    7    tmp5of309sh                        0x00005618922b7748 <unavailable> + 5960

    8    libc.so.6                          0x00002ad923086460 __libc_start_main +
    245

    9    tmp5of309sh                        0x00005618922b7359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // ...\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: '/tmp/tmp0x7qyr3p.swift:25:1: error: missing return in global function expected
    to return ''Int''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var counter = 0\n    var full = false\n    for i in 0..<grid.count\
    \ {\n        if (full) {\n            continue\n        }\n        full = true\n\
    \        for j in 0..<grid[i].count {\n            if (grid[i][j] == 1) {\n  \
    \              counter += 1\n                full = false\n            }\n   \
    \     }\n    }\n    return counter * capacity\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpxkjz_t1o/tmpxkjz_t1o.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c98793c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c9848ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c9848a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c984897b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxkjz_t1o                        0x000055c85e4fd827 <unavailable> + 6183

    5    libc.so.6                          0x00002b2c9897f460 __libc_start_main +
    245

    6    tmpxkjz_t1o                        0x000055c85e4fd1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let H = grid.count\n    let W = grid[0].count\n    var grid =\
    \ grid\n    var sum = 0\n    for i in 0..<H {\n        var units_to_go = capacity\n\
    \        for j in 0..<W {\n            if grid[i][j] == 1 {\n                grid[i][j]\
    \ = 0\n                units_to_go -= 1\n            }\n            if units_to_go\
    \ == 0 {\n                break\n            }\n        }\n        sum += capacity\
    \ - units_to_go\n    }\n    return sum\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpk1vf5dpp/tmpk1vf5dpp.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002baa77a82c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002baa77779b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002baa77779988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002baa777787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk1vf5dpp                        0x00005568c76cc706 <unavailable> + 5894

    5    libc.so.6                          0x00002baa77c6e460 __libc_start_main +
    245

    6    tmpk1vf5dpp                        0x00005568c76cc299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // Your code here\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: '/tmp/tmpapy5objp.swift:25:1: error: missing return in global function expected
    to return ''Int''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0, grid[0].count > 0 else { return 0 }\n  \
    \  var result = 0\n    for row in grid {\n        for (idx, val) in row.enumerated()\
    \ {\n            if val == 1 {\n                let to_add = min(capacity, idx\
    \ + 1)\n                result += to_add\n            }\n        }\n    }\n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpesy_w4bd/tmpesy_w4bd.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f9645dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f96154b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f96154988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f961537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpesy_w4bd                        0x00005564f8adca67 <unavailable> + 6759

    5    libc.so.6                          0x00002b2f96649460 __libc_start_main +
    245

    6    tmpesy_w4bd                        0x00005564f8adc429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let wells = getWells(grid: grid)\n    return pour(wells: wells,\
    \ capacity: capacity)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpk50culib.swift:24:17: error: cannot find 'getWells' in scope\n\
    \    let wells = getWells(grid: grid)\n                ^~~~~~~~\n/tmp/tmpk50culib.swift:25:12:\
    \ error: cannot find 'pour' in scope\n    return pour(wells: wells, capacity:\
    \ capacity)\n           ^~~~\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var total = 0\n    var temp_row = Array(repeating: 0, count: grid[0].count)\n\
    \    for i in 0..<grid.count {\n        var row = grid[i]\n        var temp_col\
    \ = 0\n        for j in 0..<row.count {\n            if row[j] == 1 {\n      \
    \          total += (capacity - temp_row[j])\n                temp_col += 1\n\
    \            }\n            temp_row[j] = temp_col\n        }\n    }\n    return\
    \ total\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpa59o4d6r/tmpa59o4d6r.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acb7ad3fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acb7aa36b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acb7aa36988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acb7aa357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa59o4d6r                        0x000055b65b890716 <unavailable> + 5910

    5    libc.so.6                          0x00002acb7af2b460 __libc_start_main +
    245

    6    tmpa59o4d6r                        0x000055b65b8902a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var wells = [[Int]]()\n    var buckets = [Int]()\n    var depth\
    \ = 0\n    var count = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            if wells.count == 0 {\n                wells.append([grid[i][j]])\n\
    \                buckets.append(0)\n            } else {\n                var\
    \ newRow = true\n                for k in 0..<wells.count {\n                \
    \    if wells[k][0] == grid[i][j] {\n                        wells[k].append(grid[i][j])\n\
    \                        newRow = false\n                        break\n     \
    \               }\n                }\n                if newRow {\n          \
    \          wells.append([grid[i][j]])\n                    buckets.append(0)\n\
    \                }\n            }\n        }\n    }\n    while true {\n      \
    \  var colMax = 0\n        for well in wells {\n            var colSum = 0\n \
    \           for col in well {\n                colSum += col\n            }\n\
    \            if colSum > colMax {\n                colMax = colSum\n         \
    \   }\n        }\n        if colMax == 0 {\n            break\n        }\n   \
    \     depth += 1\n        for k in 0..<wells.count {\n            for j in 0..<wells[k].count\
    \ {\n                if wells[k][j] == 1 {\n                    wells[k][j] =\
    \ 0\n                    buckets[k] += 1\n                    count += 1\n   \
    \                 if buckets[k] == capacity {\n                        wells[k].remove(at:\
    \ j)\n                        buckets[k] = 0\n                    }\n        \
    \            break\n                }\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpkzd0dcji/tmpkzd0dcji.swift:96: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae6d40d1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae6d3dc8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae6d3dc8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae6d3dc77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkzd0dcji                        0x0000564978b1ebe7 <unavailable> + 7143

    5    libc.so.6                          0x00002ae6d42bd460 __libc_start_main +
    245

    6    tmpkzd0dcji                        0x0000564978b1e5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_fill = 0\n    var current_fill = 0\n    for line in grid\
    \ {\n        for cell in line {\n            if cell == 1 {\n                current_fill\
    \ += 1\n            }\n        }\n        max_fill += current_fill / capacity\n\
    \        current_fill = current_fill % capacity\n    }\n    return max_fill\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp_d6a1tni/tmp_d6a1tni.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aca5ee30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aca5eb27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aca5eb27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aca5eb267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_d6a1tni                        0x000055a1dcca67a7 <unavailable> + 6055

    5    libc.so.6                          0x00002aca5f01c460 __libc_start_main +
    245

    6    tmp_d6a1tni                        0x000055a1dcca6169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var moves = 0\n    for col in grid[0].indices {\n        for row\
    \ in grid.indices {\n            if grid[row][col] == 1 {\n                moves\
    \ += 1\n                for row in (0..<row).reversed() {\n                  \
    \  moves += 1\n                    grid[row][col] = 1\n                }\n   \
    \         }\n        }\n    }\n    return moves\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmpikml_p52.swift:31:30: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[row][col] = 1\n              \
    \      ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // TODO: Implement the logic here\n    return -1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp01xh_ml0/tmp01xh_ml0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afdcaae8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afdca7dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afdca7df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afdca7de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01xh_ml0                        0x0000564caab333d6 <unavailable> + 5078

    5    libc.so.6                          0x00002afdcacd4460 __libc_start_main +
    245

    6    tmp01xh_ml0                        0x0000564caab32f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let row_count = grid.count\n    guard let col_count = grid.first?.count\
    \ else {\n        return 0\n    }\n    var column_sums = Array(repeating: 0, count:\
    \ col_count)\n    for row in grid {\n        for i in 0..<col_count {\n      \
    \      column_sums[i] += row[i]\n        }\n    }\n    // find the minimum bucket\
    \ capacity required to fill the row\n    let min_row_bucket_cap = (column_sums.max()\
    \ ?? 0) / capacity\n    // minimum bucket capacity required to fill the rows in\
    \ parallel\n    let min_parallel_bucket_cap = min_row_bucket_cap * row_count\n\
    \    // use minimum row bucket capacity to fill the rows\n    let max_parallel_row_fill\
    \ = min_row_bucket_cap * row_count * capacity\n    // use excess capacity to fill\
    \ the columns\n    let max_col_fill = column_sums.reduce(0) { (acc, next) in\n\
    \        acc + next % capacity\n    }\n    return max_parallel_row_fill + max_col_fill\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1h05umys/tmp1h05umys.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bbdf4cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bbdc43b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bbdc43988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bbdc427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1h05umys                        0x0000557c41ddeb77 <unavailable> + 7031

    5    libc.so.6                          0x00002b1bbe138460 __libc_start_main +
    245

    6    tmp1h05umys                        0x0000557c41dde539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    // answer\n\
    \    var ans = 0\n    // transpose the grid.\n    // we want to see the grid as\
    \ columns, not rows\n    var grid_t = [[Int]](repeating: [Int](repeating: 0, count:\
    \ rows), count: cols)\n    for i in 0..<rows {\n        for j in 0..<cols {\n\
    \            grid_t[j][i] = grid[i][j]\n        }\n    }\n    // water levels\
    \ in each column\n    var levels = [Int](repeating: 0, count: cols)\n    // mark\
    \ all columns that can be filled\n    var cols_to_fill = [Bool](repeating: false,\
    \ count: cols)\n    for col in 0..<cols {\n        // find the first row that\
    \ has water in it\n        var i = 0\n        while i < rows && grid_t[col][i]\
    \ == 0 {\n            i += 1\n        }\n        if i < rows {\n            //\
    \ we can fill this column\n            cols_to_fill[col] = true\n            //\
    \ and the level of water should be at least as high as `i`\n            levels[col]\
    \ = i\n        }\n    }\n    // main loop:\n    // do while there are columns\
    \ to fill\n    while cols_to_fill.contains(true) {\n        // find the highest\
    \ column to fill\n        var max_j = 0\n        var max_value = 0\n        for\
    \ j in 0..<cols {\n            if cols_to_fill[j] && levels[j] > max_value {\n\
    \                max_j = j\n                max_value = levels[j]\n          \
    \  }\n        }\n        // increase the level of the highest column\n       \
    \ levels[max_j] += 1\n        // we need to fill the water in this column into\
    \ the adjacent ones\n        var fill_amount = capacity\n        for j in max_j-1...max_j+1\
    \ {\n            if cols_to_fill[j] {\n                // fill this column as\
    \ much as we can\n                let to_fill = min(levels[j],\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp338cy9_z.swift:73:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp338cy9_z.swift:92:71: error: expected '}' at end of brace statement\n\
    assert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n     \
    \                                                                 ^\n/tmp/tmp338cy9_z.swift:69:36:\
    \ note: to match this opening '{'\n        for j in max_j-1...max_j+1 {\n    \
    \                               ^\n/tmp/tmp338cy9_z.swift:92:71: error: expected\
    \ '}' at end of brace statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1,\
    \ 1]], capacity: 9) == 2)\n                                                  \
    \                    ^\n/tmp/tmp338cy9_z.swift:55:39: note: to match this opening\
    \ '{'\n    while cols_to_fill.contains(true) {\n                             \
    \         ^\n/tmp/tmp338cy9_z.swift:92:71: error: expected '}' at end of brace\
    \ statement\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9)\
    \ == 2)\n                                                                    \
    \  ^\n/tmp/tmp338cy9_z.swift:23:52: note: to match this opening '{'\nfunc max_fill(grid:\
    \ [[Int]], capacity: Int) -> Int {\n                                         \
    \          ^\n/tmp/tmp338cy9_z.swift:72:44: error: missing argument for parameter\
    \ #2 in call\n                let to_fill = min(levels[j],\n                 \
    \                          ^\n                                           , <#Int#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n/tmp/tmp338cy9_z.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max = -1\n    for row in grid {\n        let fill = max_fill(row:\
    \ row, capacity: capacity)\n        if fill > max {\n            max = fill\n\
    \        }\n    }\n    return max\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpxysfrpe6.swift:26:28: error: incorrect argument label in call (have\
    \ 'row:capacity:', expected 'grid:capacity:')\n        let fill = max_fill(row:\
    \ row, capacity: capacity)\n                           ^~~~\n                \
    \            grid\n/tmp/tmpxysfrpe6.swift:26:34: error: cannot convert value of\
    \ type '[Int]' to expected argument type '[[Int]]'\n        let fill = max_fill(row:\
    \ row, capacity: capacity)\n                                 ^\n/tmp/tmpxysfrpe6.swift:26:34:\
    \ note: arguments to generic parameter 'Element' ('Int' and '[Int]') are expected\
    \ to be equal\n        let fill = max_fill(row: row, capacity: capacity)\n   \
    \                              ^\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  let heights = grid.map { row in\n    row.reduce(0) { acc, fill ->\
    \ Int in\n      return acc + fill\n    }\n  }\n  var buckets: [Int] = []\n  for\
    \ height in heights {\n    buckets.append(height / capacity)\n    if height %\
    \ capacity != 0 {\n      buckets.append(1)\n    }\n  }\n  return buckets.reduce(0)\
    \ { acc, count -> Int in\n    return acc + count\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // Calculate the number of columns.\n    let columns = grid[0].count\n\
    \    // Convert the 2D array into a 1D array.\n    let arr = grid.flatMap { $0\
    \ }\n    // Calculate the number of rows.\n    let rows = arr.count / columns\n\
    \    // Initialize a counter.\n    var count = 0\n    // Fill the buckets.\n \
    \   for _ in arr {\n        // Check if the row is full.\n        if arr.filter\
    \ { $0 == 1 }.count == columns {\n            // Reset the buckets.\n        \
    \    arr.map { return $0 == 1 ? 0 : $0 }\n            // Increment the counter.\n\
    \            count += 1\n        }\n        // Fill the buckets.\n        arr.map\
    \ { return $0 == 0 ? capacity : $0 }\n    }\n    // Check if the row is full.\n\
    \    if arr.filter { $0 == 1 }.count == columns {\n        // Reset the buckets.\n\
    \        arr.map { return $0 == 1 ? 0 : $0 }\n        // Increment the counter.\n\
    \        count += 1\n    }\n    // Calculate the number of rows filled.\n    let\
    \ rows_filled = arr.filter { $0 == 1 }.count / columns\n    // Calculate the number\
    \ of times you need to lower the buckets.\n    return count + capacity * rows_filled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp97cjgfh0/tmp97cjgfh0.swift:70: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abaa5748c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abaa543fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abaa543f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abaa543e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp97cjgfh0                        0x00005587fe6cd826 <unavailable> + 6182

    5    libc.so.6                          0x00002abaa5934460 __libc_start_main +
    245

    6    tmp97cjgfh0                        0x00005587fe6cd3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    let length = grid[0].count\n    let numberOfRows\
    \ = grid.count\n    let maxLenght = numberOfRows * length\n    var maxDepth =\
    \ 0\n    var totalFilledCells = 0\n    var times: Int = 0\n    while totalFilledCells\
    \ < maxLenght {\n        var maxDepth = 0\n        for i in 0..<numberOfRows {\n\
    \            for j in 0..<length {\n                if grid[i][j] == 1 {\n   \
    \                 maxDepth += 1\n                } else {\n                  \
    \  break\n                }\n            }\n        }\n        for i in 0..<numberOfRows\
    \ {\n            for j in 0..<length {\n                if grid[i][j] == 1 {\n\
    \                    grid[i][j] = 0\n                    totalFilledCells += 1\n\
    \                }\n            }\n        }\n        let filled = min(maxDepth,\
    \ capacity)\n        for i in (0..<numberOfRows).reversed() {\n            for\
    \ j in (0..<length).reversed() {\n                if filled > 0 {\n          \
    \          grid[i][j] = 1\n                    filled -= 1\n                }\n\
    \            }\n        }\n        times += 1\n    }\n    return times\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpwyfwr4rx.swift:55:28: error: left side of mutating operator isn't\
    \ mutable: 'filled' is a 'let' constant\n                    filled -= 1\n   \
    \                 ~~~~~~ ^\n/tmp/tmpwyfwr4rx.swift:50:9: note: change 'let' to\
    \ 'var' to make it mutable\n        let filled = min(maxDepth, capacity)\n   \
    \     ^~~\n        var\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf17x4ne5/tmpf17x4ne5.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b502674bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5026442b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5026442988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50264417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf17x4ne5                        0x0000561d0255f3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b5026937460 __libc_start_main +
    245

    6    tmpf17x4ne5                        0x0000561d0255ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var total = 0\n    for x in 0..<grid.count {\n        var current\
    \ = capacity\n        for y in 0..<grid[x].count {\n            if grid[x][y]\
    \ == 1 {\n                if current == 0 {\n                    total += 1\n\
    \                    current = capacity\n                }\n                current\
    \ -= 1\n            }\n        }\n        if current != capacity {\n         \
    \   total += 1\n        }\n    }\n    return total\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: '/tmp/tmpty61bpii.swift:25:1: error: missing return in global function expected
    to return ''Int''

    }

    ^

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count = 0\n    for i in 0..<grid.count {\n        for j in\
    \ 0..<grid[i].count {\n            if grid[i][j] == 1 {\n                if capacity\
    \ < grid[i].count - j {\n                    count += 1\n                } else\
    \ {\n                    count += 2\n                }\n            }\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf62iz177/tmpf62iz177.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6cee3fcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6cee0f3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6cee0f3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6cee0f27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf62iz177                        0x00005598c9d21656 <unavailable> + 5718

    5    libc.so.6                          0x00002b6cee5e8460 __libc_start_main +
    245

    6    tmpf62iz177                        0x00005598c9d211e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for i in 0..<grid.count {\n        result\
    \ += fill(i, grid, capacity)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpe5pb6plh.swift:26:19: error: cannot find 'fill' in scope\n    \
    \    result += fill(i, grid, capacity)\n                  ^~~~\n"
  stdout: ''
  timestamp: 1659978604
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var currentLevel = 0\n    var moves = 0\n    while hasLevel(grid:\
    \ grid, level: currentLevel) {\n        print(\"current level: \\(currentLevel)\"\
    )\n        for (index, row) in grid.enumerated() {\n            if row.contains(currentLevel)\
    \ {\n                moves += 1\n                if index == 0 {\n           \
    \         grid[index].replaceSubrange(0...capacity, with: repeatElement(0, count:\
    \ capacity + 1))\n                } else {\n                    if index > 0 &&\
    \ grid[index - 1].contains(currentLevel) {\n                        let lowerCapacity\
    \ = capacity - currentLevel\n                        let lowerIndex = grid[index\
    \ - 1].firstIndex(of: currentLevel)!\n                        let newIndex = grid[index].lastIndex(of:\
    \ currentLevel)! + 1\n                        grid[index].replaceSubrange(newIndex...newIndex\
    \ + lowerCapacity, with: repeatElement(0, count: lowerCapacity + 1))\n       \
    \                 grid[index - 1].replaceSubrange(lowerIndex...lowerIndex + lowerCapacity,\
    \ with: repeatElement(0, count: lowerCapacity + 1))\n                    } else\
    \ {\n                        let upperCapacity = capacity - currentLevel\n   \
    \                     let upperIndex = grid[index].firstIndex(of: currentLevel)!\n\
    \                        grid[index].replaceSubrange(upperIndex...upperIndex +\
    \ upperCapacity, with: repeatElement(0, count: upperCapacity + 1))\n         \
    \           }\n                }\n            }\n        }\n        currentLevel\
    \ += 1\n    }\n    return moves\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpgssfot3s.swift:26:11: error: cannot find 'hasLevel' in scope\n\
    \    while hasLevel(grid: grid, level: currentLevel) {\n          ^~~~~~~~\n/tmp/tmpgssfot3s.swift:32:33:\
    \ error: cannot use mutating member on immutable value: 'grid' is a 'let' constant\n\
    \                    grid[index].replaceSubrange(0...capacity, with: repeatElement(0,\
    \ count: capacity + 1))\n                    ~~~~        ^\n/tmp/tmpgssfot3s.swift:38:37:\
    \ error: cannot use mutating member on immutable value: 'grid' is a 'let' constant\n\
    \                        grid[index].replaceSubrange(newIndex...newIndex + lowerCapacity,\
    \ with: repeatElement(0, count: lowerCapacity + 1))\n                        ~~~~\
    \        ^\n/tmp/tmpgssfot3s.swift:39:41: error: cannot use mutating member on\
    \ immutable value: 'grid' is a 'let' constant\n                        grid[index\
    \ - 1].replaceSubrange(lowerIndex...lowerIndex + lowerCapacity, with: repeatElement(0,\
    \ count: lowerCapacity + 1))\n                        ~~~~            ^\n/tmp/tmpgssfot3s.swift:43:37:\
    \ error: cannot use mutating member on immutable value: 'grid' is a 'let' constant\n\
    \                        grid[index].replaceSubrange(upperIndex...upperIndex +\
    \ upperCapacity, with: repeatElement(0, count: upperCapacity + 1))\n         \
    \               ~~~~        ^\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var total = 0\n    let rowSize = grid.count\n    let colSize =\
    \ grid[0].count\n    var wells = grid\n    var maxWater = 0\n    var rowIndex\
    \ = 0\n    var colIndex = 0\n    var capacity = capacity\n    var n = 1\n    while\
    \ n > 0 {\n        n = 0\n        for r in 0 ..< rowSize {\n            for c\
    \ in 0 ..< colSize {\n                if wells[r][c] == 1 {\n                \
    \    maxWater = 0\n                    capacity = capacity - 1\n             \
    \       wells[r][c] = 0\n                    total += 1\n                    if\
    \ c > 0 && wells[r][c - 1] == 1 {\n                        wells[r][c - 1] = 0\n\
    \                        maxWater += 1\n                    }\n              \
    \      if c < colSize - 1 && wells[r][c + 1] == 1 {\n                        wells[r][c\
    \ + 1] = 0\n                        maxWater += 1\n                    }\n   \
    \                 if r > 0 && wells[r - 1][c] == 1 {\n                       \
    \ wells[r - 1][c] = 0\n                        maxWater += 1\n               \
    \     }\n                    if r < rowSize - 1 && wells[r + 1][c] == 1 {\n  \
    \                      wells[r + 1][c] = 0\n                        maxWater +=\
    \ 1\n                    }\n                    if maxWater > capacity {\n   \
    \                     total += maxWater - capacity\n                        capacity\
    \ = 0\n                    } else {\n                        capacity -= maxWater\n\
    \                    }\n                }\n            }\n        }\n        for\
    \ r in 0 ..< rowSize {\n            for c in 0 ..< colSize {\n               \
    \ if wells[r][c] == 1 {\n                    n += 1\n                }\n     \
    \       }\n        }\n    }\n    return total\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp0r733bq0/tmp0r733bq0.swift:91: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b53a893bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b53a8632b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b53a8632988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b53a86317b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0r733bq0                        0x000055e01b51b706 <unavailable> + 5894

    5    libc.so.6                          0x00002b53a8b27460 __libc_start_main +
    245

    6    tmp0r733bq0                        0x000055e01b51b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var count: Int = 0\n    var temp = Array(repeating: Array(repeating:\
    \ 0, count: grid[0].count), count: grid.count)\n    while true {\n        let\
    \ new_temp = fill_grid(grid: grid, temp: temp, capacity: capacity)\n        count\
    \ += 1\n        if new_temp == temp {\n            break\n        }\n        temp\
    \ = new_temp\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp3tsi5czv.swift:27:24: error: cannot find 'fill_grid' in scope\n\
    \        let new_temp = fill_grid(grid: grid, temp: temp, capacity: capacity)\n\
    \                       ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var height = Array(repeating: 0, count: grid[0].count)\n    var\
    \ i = 0\n    while i < grid.count {\n        var j = 0\n        while j < grid[i].count\
    \ {\n            if grid[i][j] == 1 {\n                height[j] += 1\n      \
    \      }\n            j += 1\n        }\n        i += 1\n    }\n    var max =\
    \ capacity\n    i = 0\n    while i < height.count {\n        if height[i] > max\
    \ {\n            max = height[i]\n        }\n        i += 1\n    }\n    return\
    \ max * capacity * grid[0].count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpzw94wz0r/tmpzw94wz0r.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5490ab8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b54907afb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b54907af988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b54907ae7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzw94wz0r                        0x00005632000bc596 <unavailable> + 5526

    5    libc.so.6                          0x00002b5490ca4460 __libc_start_main +
    245

    6    tmpzw94wz0r                        0x00005632000bc129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    var data = Array(repeating:\
    \ Array(repeating: 0, count: grid[0].count), count: grid.count)\n    var sum =\
    \ 0\n    for row in 0..<grid.count {\n        for column in 0..<grid[row].count\
    \ {\n            data[row][column] = capacity - grid[row][column]\n          \
    \  sum += data[row][column]\n        }\n    }\n    print(data)\n    var n = 1\n\
    \    while n < sum + 1 {\n        var i = 0\n        while i < data.count {\n\
    \            if i % 2 == 0 {\n                var j = 0\n                while\
    \ j < data[i].count {\n                    if data[i][j] != 0 {\n            \
    \            data[i][j] -= 1\n                        sum -= 1\n             \
    \       }\n                    j += 1\n                }\n            } else {\n\
    \                var j = data[i].count - 1\n                while j >= 0 {\n \
    \                   if data[i][j] != 0 {\n                        data[i][j] -=\
    \ 1\n                        sum -= 1\n                    }\n               \
    \     j -= 1\n                }\n            }\n            i += 1\n        }\n\
    \        print(data)\n        n += 1\n    }\n    return n - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphuhpvtvv/tmphuhpvtvv.swift:80: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b43a06e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b43a03d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b43a03d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b43a03d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphuhpvtvv                        0x00005644bab66a06 <unavailable> + 6662

    5    libc.so.6                          0x00002b43a08cc460 __libc_start_main +
    245

    6    tmphuhpvtvv                        0x00005644bab66599 <unavailable> + 5529

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var totalWater = 0\n    for i in 0..<grid.count {\n        for\
    \ j in 0..<grid[i].count {\n            totalWater += grid[i][j]\n        }\n\
    \    }\n    let maxRaises = totalWater / capacity\n    print(maxRaises)\n    return\
    \ maxRaises\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmputmala4h/tmputmala4h.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1bd446bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1bd4162b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1bd4162988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1bd41617b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmputmala4h                        0x00005629969fc9d7 <unavailable> + 6615

    5    libc.so.6                          0x00002b1bd4657460 __libc_start_main +
    245

    6    tmputmala4h                        0x00005629969fc399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp5ld0g0ni/tmp5ld0g0ni.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8faa2d9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fa9fd0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fa9fd0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fa9fcf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5ld0g0ni                        0x000055bf825933d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b8faa4c5460 __libc_start_main +
    245

    6    tmp5ld0g0ni                        0x000055bf82592f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978604
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var counter = 0\n    while true {\n     \
    \   var didRemove = false\n        for x in 0..<grid.count {\n            for\
    \ y in 0..<grid[x].count {\n                if grid[x][y] == 1 {\n           \
    \         didRemove = true\n                    for z in (0...y).reversed() {\n\
    \                        if grid[x][z] < capacity {\n                        \
    \    grid[x][z] += 1\n                            counter += 1\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n        if !didRemove {\n            break\n        }\n    }\n    return\
    \ counter\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978610
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var water: [[Int]] = grid\n    var iterations = 0\n    let n =\
    \ grid.count\n    let m = grid[0].count\n    while true {\n        var drained\
    \ = false\n        for i in 0..<n {\n            for j in 0..<m {\n          \
    \      if water[i][j] == 0 {\n                    continue\n                }\n\
    \                let left = (j - 1 >= 0) ? water[i][j - 1] : 0\n             \
    \   let right = (j + 1 < m) ? water[i][j + 1] : 0\n                let bottom\
    \ = (i + 1 < n) ? water[i + 1][j] : 0\n                let max = [left, right,\
    \ bottom].max() ?? 0\n                if max != 0 && max < capacity {\n      \
    \              water[i][j] = 0\n                    drained = true\n         \
    \       }\n            }\n        }\n        if !drained {\n            break\n\
    \        }\n        iterations += 1\n    }\n    return iterations\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpyup6yrbi/tmpyup6yrbi.swift:66: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae994c6dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae994964b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae994964988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9949637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyup6yrbi                        0x000055dfdf7b0796 <unavailable> + 6038

    5    libc.so.6                          0x00002ae994e59460 __libc_start_main +
    245

    6    tmpyup6yrbi                        0x000055dfdf7b0329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    /// TODO\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp2uyplqf1/tmp2uyplqf1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4f58561c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4f58258b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4f58258988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4f582577b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2uyplqf1                        0x0000564f46c513d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b4f5874d460 __libc_start_main +
    245

    6    tmp2uyplqf1                        0x0000564f46c50f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var i = grid.count - 1\n    var j = grid[0].count - 1\n    var\
    \ result = 0\n    while (i >= 0 && j >= 0) {\n        let current = grid[i][j]\n\
    \        if (current == 0) {\n            result += capacity\n        }\n    \
    \    else {\n            result += (capacity - current)\n        }\n        i\
    \ -= 1\n        j -= 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppvwns225/tmppvwns225.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad83f31ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad83f011b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad83f011988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad83f0107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppvwns225                        0x000055d972d1a4d6 <unavailable> + 5334

    5    libc.so.6                          0x00002ad83f506460 __libc_start_main +
    245

    6    tmppvwns225                        0x000055d972d1a069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count != 0 else { return 0 }\n    var total_water =\
    \ 0\n    let width = grid[0].count\n    var column_max = [Int](repeating: 0, count:\
    \ width)\n    for i in (0..<grid.count).reversed() {\n        for j in 0..<width\
    \ {\n            if grid[i][j] == 1 {\n                column_max[j] = i\n   \
    \         }\n        }\n        for j in 0..<width {\n            total_water\
    \ += fill(grid: grid, column_max: column_max, row: i, column: j, capacity: capacity)\n\
    \        }\n    }\n    return total_water\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: SyntaxError
  stderr: "/tmp/tmp8utszuvp.swift:35:28: error: cannot find 'fill' in scope\n    \
    \        total_water += fill(grid: grid, column_max: column_max, row: i, column:\
    \ j, capacity: capacity)\n                           ^~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var result = 0\n    for index in grid.indices {\n        var row\
    \ = 0\n        for j in grid[index].indices {\n            row += grid[index][j]\n\
    \        }\n        if row != 0 {\n            if capacity < row {\n         \
    \       result += capacity\n            } else {\n                result += row\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp406x172_/tmp406x172_.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab2c1911c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab2c1608b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab2c1608988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab2c16077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp406x172_                        0x000055d24489f6f6 <unavailable> + 5878

    5    libc.so.6                          0x00002ab2c1afd460 __libc_start_main +
    245

    6    tmp406x172_                        0x000055d24489f289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            if grid[i][j] == 1 {\n\
    \                for k in i...i+capacity-1 {\n                    if k < grid.count\
    \ && grid[k][j] == 1 {\n                        grid[k][j] = 0\n             \
    \       }\n                }\n                count += 1\n            }\n    \
    \    }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpd3br6zwn/tmpd3br6zwn.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1813ec3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1813bbab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1813bba988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1813bb97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd3br6zwn                        0x0000557982ffc9c7 <unavailable> + 6599

    5    libc.so.6                          0x00002b18140af460 __libc_start_main +
    245

    6    tmpd3br6zwn                        0x0000557982ffc389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n\tvar sum = 0\n\tfor row in grid {\n\t\tvar max_water = 0\n\t\tfor\
    \ c in row {\n\t\t\tmax_water += c\n\t\t}\n\t\tsum += max_water / capacity\n\t\
    \tif max_water % capacity != 0 {\n\t\t\tsum += 1\n\t\t}\n\t}\n\treturn sum\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var waterLevel = Array(repeating: Array(repeating: 0, count: grid[0].count),\
    \ count: grid.count)\n    var moves = 0\n    var filledCount = 0\n    for row\
    \ in grid {\n        for column in row {\n            if column == 1 {\n     \
    \           filledCount += 1\n            }\n        }\n    }\n    while filledCount\
    \ > 0 {\n        for row in 0..<grid.count {\n            for column in 0..<grid[row].count\
    \ {\n                var currentRow = row\n                if grid[row][column]\
    \ == 1 {\n                    while currentRow >= 0 && grid[currentRow][column]\
    \ == 0 && waterLevel[currentRow][column] < capacity {\n                      \
    \  waterLevel[currentRow][column] += 1\n                        currentRow -=\
    \ 1\n                    }\n                    grid[row][column] = 0\n      \
    \              filledCount -= 1\n                    moves += 1\n            \
    \    }\n            }\n        }\n    }\n    return moves\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpczx4ridc.swift:43:30: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[row][column] = 0\n           \
    \         ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard capacity != 0 else { return 0 }\n    let all_row_max = grid.map\
    \ { $0.max() ?? 0 }\n    let max_per_col = zip(all_row_max.indices, all_row_max).reduce(into:\
    \ [:]) { res, next in\n        if res[next.0] == nil {\n            res[next.0]\
    \ = next.1\n        } else {\n            res[next.0] = max(res[next.0]!, next.1)\n\
    \        }\n    }\n    return all_row_max.map { $0 / capacity }.reduce(0, +) +\
    \ max_per_col.map { $0.value / capacity }.reduce(0, +)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmptdtj0w6h.swift:30:42: error: cannot convert value of type 'Any'\
    \ to expected argument type 'Int'\n            res[next.0] = max(res[next.0]!,\
    \ next.1)\n                                         ^\n                      \
    \                     as! Int\n/tmp/tmptdtj0w6h.swift:33:12: error: the compiler\
    \ is unable to type-check this expression in reasonable time; try breaking up\
    \ the expression into distinct sub-expressions\n    return all_row_max.map { $0\
    \ / capacity }.reduce(0, +) + max_per_col.map { $0.value / capacity }.reduce(0,\
    \ +)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978632
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var numFills = 0\n    let rows = grid.count\n    let cols = grid[0].count\n\
    \    for i in 0..<rows {\n        for j in 0..<cols {\n            if grid[i][j]\
    \ == 1 {\n                numFills += 1\n                _ = fill(grid: &grid,\
    \ row: i, col: j, capacity: capacity)\n            }\n        }\n    }\n    return\
    \ numFills\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp94wwwdm9.swift:31:21: error: cannot find 'fill' in scope\n    \
    \            _ = fill(grid: &grid, row: i, col: j, capacity: capacity)\n     \
    \               ^~~~\n/tmp/tmp94wwwdm9.swift:31:32: error: cannot pass immutable\
    \ value as inout argument: 'grid' is a 'let' constant\n                _ = fill(grid:\
    \ &grid, row: i, col: j, capacity: capacity)\n                               ^~~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    guard grid[0].count\
    \ > 0 else { return 0 }\n    guard capacity > 0 else { return 0 }\n    \n    var\
    \ numOfFills = 0\n    var numOfColumns = grid[0].count\n    var numOfRows = grid.count\n\
    \    var maxRowLevel = [Int](repeating: 0, count: numOfColumns)\n    var maxColumnLevel\
    \ = [Int](repeating: 0, count: numOfRows)\n    \n    // Fill the maxRowLevel and\
    \ maxColumnLevel arrays\n    for i in 0..<numOfRows {\n        for j in 0..<numOfColumns\
    \ {\n            if grid[i][j] == 1 {\n                maxRowLevel[j] += 1\n \
    \               maxColumnLevel[i] += 1\n            }\n        }\n    }\n    \n\
    \    // Remove empty columns\n    let maxRowLevelIndices = maxRowLevel.enumerated().filter({\
    \ $0.element > 0 }).map({ $0.offset })\n    numOfColumns = maxRowLevelIndices.count\n\
    \    maxRowLevel = maxRowLevelIndices.map({ maxRowLevel[$0] })\n    \n    // Remove\
    \ empty rows\n    let maxColumnLevelIndices = maxColumnLevel.enumerated().filter({\
    \ $0.element > 0 }).map({ $0.offset })\n    numOfRows = maxColumnLevelIndices.count\n\
    \    maxColumnLevel = maxColumnLevelIndices.map({ maxColumnLevel[$0] })\n    \n\
    \    // Find the row and column with the lowest level of water\n    var lowestLevelIndex\
    \ = 0\n    for (i, level) in maxRowLevel.enumerated() {\n        if level < maxRowLevel[lowestLevelIndex]\
    \ {\n            lowestLevelIndex = i\n        }\n    }\n    for (i, level) in\
    \ maxColumnLevel.enumerated() {\n        if level < maxColumnLevel[lowestLevelIndex]\
    \ {\n            lowestLevelIndex = i\n        }\n    }\n    \n    // Fill the\
    \ bucket\n    while !(maxRowLevel.allSatisfy({ $0 == 0 }) && maxColumnLevel.allSatisfy({\
    \ $0 ==\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp95ft68v3.swift:69:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp95ft68v3.swift:72:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmp95ft68v3.swift:68:77:\
    \ note: to match this opening '('\n    while !(maxRowLevel.allSatisfy({ $0 ==\
    \ 0 }) && maxColumnLevel.allSatisfy({ $0 ==\n                                \
    \                                            ^\n/tmp/tmp95ft68v3.swift:88:71:\
    \ error: expected '}' at end of brace statement\nassert(max_fill(grid: [[1, 1,\
    \ 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)\n                                 \
    \                                     ^\n/tmp/tmp95ft68v3.swift:23:52: note: to\
    \ match this opening '{'\nfunc max_fill(grid: [[Int]], capacity: Int) -> Int {\n\
    \                                                   ^\n/tmp/tmp95ft68v3.swift:72:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var pass = 0\n    var remaining = 0\n    for i in 0..<grid.count\
    \ {\n        for j in 0..<grid[i].count {\n            remaining += grid[i][j]\n\
    \            if remaining >= capacity {\n                pass += 1\n         \
    \       remaining = 0\n            }\n        }\n        remaining = 0\n    }\n\
    \    return pass\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3875pol4/tmp3875pol4.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac8b7064c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac8b6d5bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac8b6d5b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac8b6d5a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3875pol4                        0x000055c44121b827 <unavailable> + 6183

    5    libc.so.6                          0x00002ac8b7250460 __libc_start_main +
    245

    6    tmp3875pol4                        0x000055c44121b1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  let width = grid[0].count\n  var buckets = [Int](repeating: 0, count:\
    \ width)\n  var drops = 0\n  for row in grid {\n    for i in 0..<width {\n   \
    \   if row[i] == 1 {\n        buckets[i] += 1\n      }\n    }\n    var is_empty\
    \ = true\n    for i in 0..<width {\n      if buckets[i] > 0 {\n        is_empty\
    \ = false\n        break\n      }\n    }\n    if is_empty {\n      break\n   \
    \ }\n    drops += 1\n    for i in 0..<width {\n      buckets[i] -= min(buckets[i],\
    \ capacity)\n    }\n  }\n  return drops\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp_pbo0xk2/tmp_pbo0xk2.swift:64: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4672e15c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4672b0cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4672b0c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4672b0b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_pbo0xk2                        0x0000564981d54916 <unavailable> + 6422

    5    libc.so.6                          0x00002b4673001460 __libc_start_main +
    245

    6    tmp_pbo0xk2                        0x0000564981d544a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let grid = grid.filter { !$0.isEmpty }\n    guard !grid.isEmpty\
    \ else { return 0 }\n    var buckets = [Int](repeating: 0, count: grid[0].count)\n\
    \    var num_empties = 0\n    for row in grid {\n        var num_empties_in_row\
    \ = 0\n        for i in row.indices {\n            let num_units = row[i]\n  \
    \          let bucket_of_well = buckets[i]\n            if num_units == 0 {\n\
    \                num_empties_in_row += 1\n            } else if bucket_of_well\
    \ < capacity {\n                num_empties_in_row += 1\n                buckets[i]\
    \ += 1\n            }\n        }\n        if num_empties_in_row > 0 {\n      \
    \      num_empties += 1\n        }\n    }\n    return num_empties\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmphholee0e/tmphholee0e.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20ba84fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20ba546b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20ba546988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20ba5457b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphholee0e                        0x000055c50d2a8996 <unavailable> + 6550

    5    libc.so.6                          0x00002b20baa3b460 __libc_start_main +
    245

    6    tmphholee0e                        0x000055c50d2a8529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  var total_fill = 0\n\n  for row in grid {\n    total_fill += row.filter\
    \ { $0 == 1 }.count\n  }\n\n  return total_fill / capacity\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsplwpwtq/tmpsplwpwtq.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5ffcdb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5ffcaa8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5ffcaa8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5ffcaa77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsplwpwtq                        0x000056216fdb38c7 <unavailable> + 6343

    5    libc.so.6                          0x00002b5ffcf9d460 __libc_start_main +
    245

    6    tmpsplwpwtq                        0x000056216fdb3289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var processed\
    \ = grid\n    var count = 0\n    for j in 0..<cols {\n        for i in 0..<rows\
    \ {\n            if processed[i][j] == 1 {\n                if capacity == 1 {\n\
    \                    count += 1\n                } else {\n                  \
    \  let possibleCapacity = rows - i\n                    let remaining = (possibleCapacity\
    \ <= capacity) ? possibleCapacity : capacity\n                    count += remaining\n\
    \                    for k in i..<i+remaining {\n                        processed[k][j]\
    \ = 0\n                    }\n                }\n            }\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpzvxxo_9i/tmpzvxxo_9i.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84763c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84760bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84760bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84760bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzvxxo_9i                        0x0000563cb549b8d7 <unavailable> + 6359

    5    libc.so.6                          0x00002b84765b2460 __libc_start_main +
    245

    6    tmpzvxxo_9i                        0x0000563cb549b299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var solution = 0\n    for i in 0..<grid.count {\n        var level\
    \ = grid[i].reduce(0, +)\n        if level > 0 {\n            solution += 1\n\
    \            let times = level / capacity\n            level -= times * capacity\n\
    \            solution += times\n        }\n        solution += level\n    }\n\
    \    return solution\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp868u_lnm/tmp868u_lnm.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1c40dd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1c40aceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1c40ace988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1c40acd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp868u_lnm                        0x0000558faf0d7626 <unavailable> + 5670

    5    libc.so.6                          0x00002b1c40fc3460 __libc_start_main +
    245

    6    tmp868u_lnm                        0x0000558faf0d71b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.isEmpty {\n        return 0\n    }\n    var res = 0\n\
    \    for row in grid {\n        var sum = 0\n        for column in row {\n   \
    \         sum += column\n            if sum > capacity {\n                res\
    \ += sum - capacity\n                sum = capacity\n            }\n        }\n\
    \    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpaxrjtze5/tmpaxrjtze5.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8fd337ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8fd3075b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8fd3075988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8fd30747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaxrjtze5                        0x00005649944db596 <unavailable> + 5526

    5    libc.so.6                          0x00002b8fd356a460 __libc_start_main +
    245

    6    tmpaxrjtze5                        0x00005649944db129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.allSatisfy({ $0.allSatisfy({ $0 == 0 }) }) {\n       \
    \ return 0\n    }\n    if grid.allSatisfy({ $0.allSatisfy({ $0 == 1 }) }) {\n\
    \        return grid.count\n    }\n    let m = grid.count\n    let n = grid[0].count\n\
    \    let target = grid.reduce(0, { $0 + $1.reduce(0, +) })\n    let max_capacity\
    \ = min(capacity, n)\n    var res = 0\n    var filled = 0\n    while filled <\
    \ target {\n        let next = grid.enumerated().map { (i, row) -> [Int] in\n\
    \            var row = row\n            let wells = row.filter({ $0 == 1 })\n\
    \            if wells.count > max_capacity {\n                row.replaceSubrange(0...max_capacity\
    \ - 1, with: Array(repeating: 1, count: max_capacity))\n            }\n      \
    \      return row\n        }\n        filled = next.reduce(0, { $0 + $1.reduce(0,\
    \ +) })\n        res += 1\n        grid = next\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpektay3di.swift:47:9: error: cannot assign to value: 'grid' is a\
    \ 'let' constant\n        grid = next\n        ^~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  return 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmptd29v9d6/tmptd29v9d6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6ce3e7cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6ce3b73b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6ce3b73988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6ce3b727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptd29v9d6                        0x000055a8e4dbc3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b6ce4068460 __libc_start_main +
    245

    6    tmptd29v9d6                        0x000055a8e4dbbf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  guard grid.count > 0, grid[0].count > 0 else { return 0 }\n  var\
    \ count = 0\n  for i in 0..<grid.count {\n    for j in 0..<grid[i].count {\n \
    \     if grid[i][j] == 1 {\n        grid[i][j] = 0\n        if i - 1 >= 0 && grid[i\
    \ - 1][j] == 1 {\n          grid[i - 1][j] = 0\n        }\n        if j - 1 >=\
    \ 0 && grid[i][j - 1] == 1 {\n          grid[i][j - 1] = 0\n        }\n      \
    \  count += 1\n      }\n    }\n  }\n  return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpnutkaie6.swift:29:16: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n        grid[i][j] = 0\n        ~~~~   ^\n/tmp/tmpnutkaie6.swift:31:22:\
    \ error: cannot assign through subscript: 'grid' is a 'let' constant\n       \
    \   grid[i - 1][j] = 0\n          ~~~~       ^\n/tmp/tmpnutkaie6.swift:34:18:\
    \ error: cannot assign through subscript: 'grid' is a 'let' constant\n       \
    \   grid[i][j - 1] = 0\n          ~~~~   ^\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n\tvar grid = grid\n\tvar cnt = 0\n\tfor column in grid.first!.indices\
    \ {\n\t\tvar bucket = capacity\n\t\tfor row in grid.indices {\n\t\t\tif grid[row][column]\
    \ == 1 {\n\t\t\t\tif bucket > 0 {\n\t\t\t\t\tgrid[row][column] = 0\n\t\t\t\t\t\
    bucket -= 1\n\t\t\t\t} else {\n\t\t\t\t\tbucket = capacity\n\t\t\t\t\tcnt += 1\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmppxjifzsn/tmppxjifzsn.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5612ab9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b56127b0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b56127b0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b56127af7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppxjifzsn                        0x0000563c3fc948c6 <unavailable> + 6342

    5    libc.so.6                          0x00002b5612ca5460 __libc_start_main +
    245

    6    tmppxjifzsn                        0x0000563c3fc94459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var actions = 0\n    while grid.reduce(0, { $0 + $1.reduce(0,\
    \ +) }) > 0 {\n        for row in grid {\n            var currentRow = row\n \
    \           for index in currentRow.indices {\n                if currentRow[index]\
    \ > 0 {\n                    if index < currentRow.count - 1 {\n             \
    \           currentRow[index + 1] = min(currentRow[index + 1] + currentRow[index],\
    \ capacity)\n                    }\n                    currentRow[index] = 0\n\
    \                }\n            }\n            grid[grid.firstIndex(of: row)!]\
    \ = currentRow\n        }\n        actions += 1\n    }\n    return actions\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpize43lqf.swift:36:17: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n            grid[grid.firstIndex(of: row)!] = currentRow\n\
    \            ~~~~^\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    let length = grid[0].count\n\
    \    var levels = Array(repeating: 0, count: length)\n    var empties = 0\n  \
    \  for i in 0..<grid.count {\n        for j in 0..<length {\n            if grid[i][j]\
    \ == 1 {\n                levels[j] += 1\n            } else {\n             \
    \   empties += 1\n            }\n        }\n    }\n    for _ in 0..<capacity {\n\
    \        var min = Int.max\n        var min_index = -1\n        for i in 0..<length\
    \ {\n            if levels[i] < min {\n                min = levels[i]\n     \
    \           min_index = i\n            }\n        }\n        if min_index == -1\
    \ {\n            break\n        }\n        levels[min_index] += 1\n        empties\
    \ -= 1\n    }\n    return length * capacity - empties\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp074m3j_h/tmp074m3j_h.swift:68: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0150d1fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0150a16b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0150a16988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0150a157b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp074m3j_h                        0x0000557f187c6716 <unavailable> + 5910

    5    libc.so.6                          0x00002b0150f0b460 __libc_start_main +
    245

    6    tmp074m3j_h                        0x0000557f187c62a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var water: Int = 0\n    for row in grid {\n        water += row.reduce(0,\
    \ +)\n    }\n    var max_fills: Int = 0\n    while water > 0 {\n        var filled:\
    \ Int = 0\n        for (i, row) in grid.enumerated() {\n            var drops:\
    \ Int = 0\n            while drops < capacity && filled < water {\n          \
    \      if row[i] == 1 {\n                    drops += 1\n                    filled\
    \ += 1\n                }\n            }\n        }\n        water -= filled\n\
    \        max_fills += 1\n    }\n    return max_fills\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978610
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    //TODO: implement this\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmprm3tc8oq/tmprm3tc8oq.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8121ddfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8121ad6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8121ad6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8121ad57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprm3tc8oq                        0x00005631541063d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b8121fcb460 __libc_start_main +
    245

    6    tmprm3tc8oq                        0x0000563154105f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let length = grid.first?.count ?? 0\n    guard length > 0 else\
    \ { return 0 }\n    var count = 0\n    var max_idx = 0\n    var min_idx = 0\n\
    \    repeat {\n        let row = grid[max_idx]\n        var temp_min_idx = min_idx\n\
    \        for (idx, water) in row.enumerated() {\n            if water == 1 {\n\
    \                temp_min_idx = idx\n                break\n            }\n  \
    \      }\n        for idx in stride(from: max_idx, to: min_idx - 1, by: -1) {\n\
    \            guard idx > 0 else { break }\n            let row = grid[idx]\n \
    \           if row[temp_min_idx] == 1 {\n                min_idx = idx\n     \
    \           break\n            }\n        }\n        if max_idx - min_idx + 1\
    \ > capacity {\n            count += 1\n            max_idx = min_idx\n      \
    \  } else {\n            max_idx += 1\n        }\n    } while max_idx < length\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d979ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d976e3561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b8d976e3286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b8d976e313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b8d976e2bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b8d976cc48a <unavailable> + 1340554

    6    tmpb3ajrb4y                        0x00005625a02c6211 <unavailable> + 8721

    7    tmpb3ajrb4y                        0x00005625a02c5918 <unavailable> + 6424

    8    libc.so.6                          0x00002b8d97bd8460 __libc_start_main +
    245

    9    tmpb3ajrb4y                        0x00005625a02c5529 <unavailable> + 5417

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  var total = 0\n  let rowCount = grid.count\n  for i in 0..<rowCount\
    \ {\n    for j in 0..<grid[i].count {\n      if grid[i][j] == 1 {\n        total\
    \ += capacity\n      }\n    }\n  }\n  return total\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpg25ppm7w/tmpg25ppm7w.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2787cd8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27879cfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27879cf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27879ce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg25ppm7w                        0x00005580e396d827 <unavailable> + 6183

    5    libc.so.6                          0x00002b2787ec4460 __libc_start_main +
    245

    6    tmpg25ppm7w                        0x00005580e396d1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n    var queue = [[Int]]()\n    var visited\
    \ = Set<[Int]>()\n    var count = 0\n    for (y, row) in grid.enumerated() {\n\
    \        for (x, cell) in row.enumerated() {\n            if cell == 1 {\n   \
    \             queue.append([x, y])\n                visited.insert([x, y])\n \
    \           }\n        }\n    }\n    while !queue.isEmpty {\n        let current\
    \ = queue.removeLast()\n        count += 1\n        let dirs = [[0, 1], [0, -1],\
    \ [1, 0], [-1, 0]]\n        for dir in dirs {\n            let x = current[0]\
    \ + dir[0]\n            let y = current[1] + dir[1]\n            if y >= 0 &&\
    \ y < grid.count && x >= 0 && x < grid[0].count && grid[y][x] + 1 <= capacity\
    \ && !visited.contains([x, y]) {\n                queue.append([x, y])\n     \
    \           visited.insert([x, y])\n            }\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp09wpdxtp/tmp09wpdxtp.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abd4cf05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abd4cbfcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abd4cbfc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abd4cbfb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp09wpdxtp                        0x0000561be2e07bc6 <unavailable> + 7110

    5    libc.so.6                          0x00002abd4d0f1460 __libc_start_main +
    245

    6    tmp09wpdxtp                        0x0000561be2e07759 <unavailable> + 5977

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let wellCount = grid.count\n    let rowLength = grid[0].count\n\
    \    var bucketDepth = 0\n    var time = 0\n    while bucketDepth < capacity {\n\
    \        bucketDepth += wellCount\n        if bucketDepth > capacity {\n     \
    \       bucketDepth -= wellCount\n            break\n        }\n        time +=\
    \ rowLength\n    }\n    for row in grid {\n        time += row.filter { $0 ==\
    \ 1 }.count\n    }\n    return time\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp7d5mui9a/tmp7d5mui9a.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b373fb4bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b373f842b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b373f842988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b373f8417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7d5mui9a                        0x00005588f1c15887 <unavailable> + 6279

    5    libc.so.6                          0x00002b373fd37460 __libc_start_main +
    245

    6    tmp7d5mui9a                        0x00005588f1c15249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let columns = grid[0].count\n    let\
    \ totalWells = rows * columns\n    var totalFill = 0\n    var emptyWells = 0\n\
    \    var previousColumns = [Int]()\n    for row in grid {\n        for (i, well)\
    \ in row.enumerated() {\n            if well == 1 {\n                if i == 0\
    \ {\n                    // Well is the first in a row, determine what to do\n\
    \                    totalFill += capacity\n                } else {\n       \
    \             // Well is not the first in a row, determine what to do\n      \
    \              if previousColumns[i] > capacity {\n                        //\
    \ Current well is not full and the previous one is\n                        totalFill\
    \ += capacity\n                    } else {\n                        // Current\
    \ well is not full but the previous one is\n                        totalFill\
    \ += capacity - previousColumns[i]\n                    }\n                }\n\
    \            } else {\n                emptyWells += 1\n            }\n      \
    \      previousColumns[i] = well\n        }\n    }\n    if emptyWells == totalWells\
    \ {\n        return 0\n    }\n    return totalFill\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002af14c766c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af14c45d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af14c45d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af14c45d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af14c45cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002af14c25c7ec <unavailable> + 186348

    6    tmpj_8fkfyu                        0x00005641d88c23ce <unavailable> + 9166

    7    tmpj_8fkfyu                        0x00005641d88c1878 <unavailable> + 6264

    8    libc.so.6                          0x00002af14c952460 __libc_start_main +
    245

    9    tmpj_8fkfyu                        0x00005641d88c1489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var bucket = capacity\n    var action = 0\n    for row in grid\
    \ {\n        var prev = 0\n        for cell in row {\n            if prev == 0\
    \ {\n                if cell == 1 {\n                    prev = bucket\n     \
    \               action += 1\n                }\n            } else {\n       \
    \         if cell == 1 {\n                    if prev < bucket {\n           \
    \             action += 1\n                    }\n                    prev = bucket\n\
    \                } else {\n                    prev -= 1\n                }\n\
    \            }\n        }\n    }\n    return action\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3yyvhiha/tmp3yyvhiha.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acec7e2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acec7b21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acec7b21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acec7b207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3yyvhiha                        0x000056253abf1546 <unavailable> + 5446

    5    libc.so.6                          0x00002acec8016460 __libc_start_main +
    245

    6    tmp3yyvhiha                        0x000056253abf10d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var queue = [Point(x: 0, y: 0)]\n    var grid = grid\n    var\
    \ visits = Set<Point>()\n    var count = 0\n    while !queue.isEmpty {\n     \
    \   var newPoints = [Point]()\n        while !queue.isEmpty {\n            let\
    \ current = queue.removeFirst()\n            if grid[current.y][current.x] ==\
    \ 1 {\n                if grid[current.y][current.x] > capacity {\n          \
    \          print(\"here\")\n                }\n                grid[current.y][current.x]\
    \ = 0\n                count += 1\n            }\n            let neighbors =\
    \ [Point(x: current.x + 1, y: current.y),\n                             Point(x:\
    \ current.x - 1, y: current.y),\n                             Point(x: current.x,\
    \ y: current.y + 1),\n                             Point(x: current.x, y: current.y\
    \ - 1)]\n            for neighbor in neighbors {\n                if grid.indices.contains(neighbor.y)\
    \ && grid[neighbor.y].indices.contains(neighbor.x) &&\n                    !visits.contains(neighbor)\
    \ {\n                    newPoints.append(neighbor)\n                    visits.insert(neighbor)\n\
    \                }\n            }\n        }\n        queue = newPoints\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp7ab7w1ka.swift:24:18: error: cannot find 'Point' in scope\n   \
    \ var queue = [Point(x: 0, y: 0)]\n                 ^~~~~\n/tmp/tmp7ab7w1ka.swift:26:22:\
    \ error: cannot find type 'Point' in scope\n    var visits = Set<Point>()\n  \
    \                   ^~~~~\n/tmp/tmp7ab7w1ka.swift:29:26: error: cannot find 'Point'\
    \ in scope\n        var newPoints = [Point]()\n                         ^~~~~\n\
    /tmp/tmp7ab7w1ka.swift:29:25: error: cannot call value of non-function type '[Any]'\n\
    \        var newPoints = [Point]()\n                        ^      ~~\n      \
    \                         \n/tmp/tmp7ab7w1ka.swift:39:30: error: cannot find 'Point'\
    \ in scope\n            let neighbors = [Point(x: current.x + 1, y: current.y),\n\
    \                             ^~~~~\n/tmp/tmp7ab7w1ka.swift:40:30: error: cannot\
    \ find 'Point' in scope\n                             Point(x: current.x - 1,\
    \ y: current.y),\n                             ^~~~~\n/tmp/tmp7ab7w1ka.swift:41:30:\
    \ error: cannot find 'Point' in scope\n                             Point(x: current.x,\
    \ y: current.y + 1),\n                             ^~~~~\n/tmp/tmp7ab7w1ka.swift:42:30:\
    \ error: cannot find 'Point' in scope\n                             Point(x: current.x,\
    \ y: current.y - 1)]\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    func moveBucket(bucket: (y: Int, x: Int), water: Int) -> (y: Int,\
    \ x: Int) {\n        var bucket = bucket\n        var water = water\n        while\
    \ bucket.y < grid.count {\n            water -= grid[bucket.y][bucket.x]\n   \
    \         bucket.y += 1\n            if water < 0 {\n                bucket.y\
    \ -= 1\n                water += grid[bucket.y][bucket.x]\n                break\n\
    \            }\n        }\n        return bucket\n    }\n    \n    var moves =\
    \ 0\n    var bucket = (y: 0, x: 0)\n    var water = capacity\n    while bucket.y\
    \ != grid.count {\n        let start = bucket\n        bucket = moveBucket(bucket:\
    \ bucket, water: water)\n        water = capacity\n        moves += 1\n      \
    \  if start.y == bucket.y {\n            moves -= 1\n            bucket.x += 1\n\
    \            if bucket.x == grid[0].count {\n                break\n         \
    \   }\n        }\n    }\n    return moves\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmppw6lycy3/tmppw6lycy3.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abc892e5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abc88fdcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abc88fdc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abc88fdb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppw6lycy3                        0x000055ad623124d6 <unavailable> + 5334

    5    libc.so.6                          0x00002abc894d1460 __libc_start_main +
    245

    6    tmppw6lycy3                        0x000055ad62312069 <unavailable> + 4201

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var total = 0\n    for arr in grid {\n        let min = arr.min()!\n\
    \        if (min < capacity) {\n            let _ = arr.map {\n              \
    \  total += capacity - $0\n            }\n        }\n    }\n    return total\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpzroe09en/tmpzroe09en.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002affa195dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002affa1654b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002affa1654988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002affa16537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzroe09en                        0x0000564cab1de8e7 <unavailable> + 6375

    5    libc.so.6                          0x00002affa1b49460 __libc_start_main +
    245

    6    tmpzroe09en                        0x0000564cab1de2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    /// Extract the wells' depths\n    let depths = grid.map { $0.reduce(0,\
    \ +) }\n    /// Sorted in descending order\n    let sortedDepths = depths.sorted\
    \ { $0 > $1 }\n    /// The final result\n    var fillCount = 0\n    /// The bucket(s)\
    \ remaining fill\n    var bucketCapacity = capacity\n    /// Cycle through the\
    \ wells in descending order of depth\n    for depth in sortedDepths {\n      \
    \  /// Is the bucket empty?\n        if bucketCapacity == 0 {\n            ///\
    \ Use another bucket\n            bucketCapacity = capacity\n            /// Increase\
    \ the number of buckets used\n            fillCount += 1\n        }\n        ///\
    \ Empty the well\n        bucketCapacity -= depth\n    }\n    /// Return the final\
    \ result\n    return fillCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpdf05bgvz/tmpdf05bgvz.swift:61: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b208a4b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b208a1aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b208a1ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b208a1ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdf05bgvz                        0x0000561803755696 <unavailable> + 5782

    5    libc.so.6                          0x00002b208a6a3460 __libc_start_main +
    245

    6    tmpdf05bgvz                        0x0000561803755229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    var count = 0\n    var rowMax: Int?\n   \
    \ var colMax: Int?\n    var colIndex: Int?\n    var rowIndex: Int?\n    let gridHeight\
    \ = grid.count\n    let gridWidth = grid[0].count\n    while true {\n        var\
    \ firstNonZeroIndex: Int?\n        for row in 0..<gridHeight {\n            for\
    \ col in 0..<gridWidth {\n                if grid[row][col] != 0 {\n         \
    \           firstNonZeroIndex = row\n                    break\n             \
    \   }\n            }\n            if firstNonZeroIndex != nil {\n            \
    \    break\n            }\n        }\n        if firstNonZeroIndex == nil {\n\
    \            return count\n        }\n        for row in firstNonZeroIndex!..<gridHeight\
    \ {\n            for col in 0..<gridWidth {\n                if grid[row][col]\
    \ != 0 {\n                    rowMax = grid[row].max()\n                    colMax\
    \ = nil\n                    colIndex = nil\n                    rowIndex = nil\n\
    \                    for col1 in 0..<gridWidth {\n                        if grid[row][col1]\
    \ == rowMax {\n                            colMax = rowMax\n                 \
    \           colIndex = col1\n                            rowIndex = row\n    \
    \                        break\n                        }\n                  \
    \  }\n                    if colMax != nil {\n                        break\n\
    \                    }\n                }\n            }\n            if colMax\
    \ != nil {\n                break\n            }\n        }\n        if colMax\
    \ == nil {\n            return count\n        }\n        count += 1\n        var\
    \ currentRow = rowIndex!\n        var currentCol = colIndex!\n        var current\
    \ = grid[currentRow][currentCol]\n        while current > 0 {\n            if\
    \ current > capacity {\n                let newValue = current - capacity\n  \
    \              grid[currentRow][currentCol] = newValue\n                current\
    \ = newValue\n            } else {\n                grid[currentRow][currentCol]\
    \ = 0\n                current = 0\n            }\n            currentRow += 1\n\
    \            if currentRow == gridHeight {\n                currentRow = 0\n \
    \               currentCol += 1\n                if currentCol == gridWidth {\n\
    \                    currentCol = 0\n                }\n            }\n      \
    \  }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqwzfgh4h/tmpqwzfgh4h.swift:114: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5eabd09c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5eaba00b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5eaba00988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5eab9ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqwzfgh4h                        0x000055a75b604967 <unavailable> + 6503

    5    libc.so.6                          0x00002b5eabef5460 __libc_start_main +
    245

    6    tmpqwzfgh4h                        0x000055a75b604329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var grid = grid\n    let rows = grid.count\n    let cols = grid[0].count\n\
    \    var count = 0\n    while true {\n        var max = 0\n        var max_i =\
    \ 0\n        var max_j = 0\n        var min = capacity\n        var min_i = 0\n\
    \        var min_j = 0\n        var is_empty = true\n        for i in 0..<rows\
    \ {\n            for j in 0..<cols {\n                if grid[i][j] == 1 {\n \
    \                   is_empty = false\n                    if max < grid[i][j]\
    \ {\n                        max = grid[i][j]\n                        max_i =\
    \ i\n                        max_j = j\n                    }\n              \
    \  } else {\n                    if min > grid[i][j] {\n                     \
    \   min = grid[i][j]\n                        min_i = i\n                    \
    \    min_j = j\n                    }\n                }\n            }\n    \
    \    }\n        if is_empty {\n            break\n        }\n        if max ==\
    \ capacity {\n            // move max to min\n            count += (min_i - max_i).abs()\
    \ + (min_j - max_j).abs()\n            grid[min_i][min_j] = max\n            grid[max_i][max_j]\
    \ = 0\n        } else {\n            // increase max\n            count += 1\n\
    \            grid[max_i][max_j] += 1\n        }\n    }\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpulnvam_1.swift:59:62: error: value of type 'Int' has no member\
    \ 'abs'\n            count += (min_i - max_i).abs() + (min_j - max_j).abs()\n\
    \                                             ~~~~~~~~~~~~~~~ ^~~\n/tmp/tmpulnvam_1.swift:59:38:\
    \ error: value of type 'Int' has no member 'abs'\n            count += (min_i\
    \ - max_i).abs() + (min_j - max_j).abs()\n                     ~~~~~~~~~~~~~~~\
    \ ^~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    /// Fill in your solution here\n    var matrix = grid\n    let\
    \ row = grid.count\n    let col = grid[0].count\n    var ret = 0\n    for i in\
    \ 0..<row {\n        for j in 0..<col {\n            var ele = matrix[i][j]\n\
    \            if ele != 0 {\n                ele = 1\n                ret += 1\n\
    \            }\n            for k in (j+1)..<col {\n                if ele < capacity\
    \ {\n                    ele += matrix[i][k]\n                    matrix[i][k]\
    \ = 0\n                }\n            }\n        }\n    }\n    return ret\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpqn92_ub8/tmpqn92_ub8.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b101144bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1011142b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1011142988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b10111417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqn92_ub8                        0x00005636875d6706 <unavailable> + 5894

    5    libc.so.6                          0x00002b1011637460 __libc_start_main +
    245

    6    tmpqn92_ub8                        0x00005636875d6299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n  let wells = grid.map { $0.map { $0 == 1 ? capacity : 0 } }\n  var\
    \ to_fill = wells.flatMap { $0 }.filter { $0 > 0 }\n  var times = 0\n  while !to_fill.isEmpty\
    \ {\n    let size = to_fill.count\n    var filling = Array(repeating: 0, count:\
    \ size)\n    for i in 0..<size {\n      filling[i] = min(capacity, to_fill[i])\n\
    \    }\n    for i in 0..<size {\n      let len = wells.count\n      if i % len\
    \ < len - 1 {\n        filling[i + 1] += filling[i]\n      }\n      if i / len\
    \ < len - 1 {\n        filling[i + len] += filling[i]\n      }\n    }\n    to_fill\
    \ = filling.map { max(0, $0 - capacity) }\n    times += 1\n  }\n  return times\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:613: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b8770b01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87707f8561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b87707f8286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b87707f813c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b87707f7bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b87705f77ec <unavailable> + 186348

    6    tmp82w9hatf                        0x000055d7cf5889df <unavailable> + 10719

    7    tmp82w9hatf                        0x000055d7cf587978 <unavailable> + 6520

    8    libc.so.6                          0x00002b8770ced460 __libc_start_main +
    245

    9    tmp82w9hatf                        0x000055d7cf587589 <unavailable> + 5513

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // Replace the following to finish this function implementation.\n\
    \    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmptunbd_u0/tmptunbd_u0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95e40dfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95e3dd6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95e3dd6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95e3dd57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptunbd_u0                        0x00005646551f53d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b95e42cb460 __libc_start_main +
    245

    6    tmptunbd_u0                        0x00005646551f4f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // put your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpxmf8_e9r/tmpxmf8_e9r.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7935b0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7932a7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7932a7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7932a67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxmf8_e9r                        0x00005570172ff3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002af79379c460 __libc_start_main +
    245

    6    tmpxmf8_e9r                        0x00005570172fef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    guard capacity > 0\
    \ else { return 0 }\n    let row_length = grid[0].count\n    var max_water = 0\n\
    \    for row in grid {\n        guard row.count == row_length else { return 0\
    \ }\n        for i in 0..<row.count {\n            if row[i] == 1 {\n        \
    \        let diff = capacity - row[i]\n                if diff > 0 {\n       \
    \             max_water += diff\n                }\n            }\n        }\n\
    \    }\n    return max_water\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmptt6glwec/tmptt6glwec.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b277d91ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b277d615b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b277d615988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b277d6147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptt6glwec                        0x000055713875a7c6 <unavailable> + 6086

    5    libc.so.6                          0x00002b277db0a460 __libc_start_main +
    245

    6    tmptt6glwec                        0x000055713875a359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    var count = 0\n  \
    \  let rowCount = grid.count\n    let colCount = grid[0].count\n    let fillAmount\
    \ = rowCount * capacity\n    for col in 0..<colCount {\n        var sum = 0\n\
    \        for row in 0..<rowCount {\n            sum += grid[row][col]\n      \
    \  }\n        if sum == 0 { continue }\n        let fillCount = (sum + capacity\
    \ - 1) / capacity\n        count += fillCount\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmppbz8_vpu/tmppbz8_vpu.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3162f30c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3162c27b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3162c27988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3162c267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppbz8_vpu                        0x000055be451aa827 <unavailable> + 6183

    5    libc.so.6                          0x00002b316311c460 __libc_start_main +
    245

    6    tmppbz8_vpu                        0x000055be451aa1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // return number of times you need to lower the buckets\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid:\
    \ [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1,\
    \ 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp1zafebc0/tmp1zafebc0.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0f1770ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0f17405b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0f17405988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0f174047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1zafebc0                        0x000055bf0f3053d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b0f178fa460 __libc_start_main +
    245

    6    tmp1zafebc0                        0x000055bf0f304f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: 0
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let sums = grid.map { $0.reduce(0, +) }\n    var maxFill = 0\n\
    \    for sum in sums {\n        maxFill += (sum + capacity - 1) / capacity\n \
    \   }\n    return maxFill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var filled = 0\n    var buckets_used = 0\n    for i in 0..<grid.count\
    \ {\n        var extracted = 0\n        for j in 0..<grid[i].count {\n       \
    \     extracted += grid[i][j]\n            if extracted > capacity {\n       \
    \         filled += capacity\n                extracted -= capacity\n        \
    \        buckets_used += 1\n            }\n        }\n        filled += extracted\n\
    \        buckets_used += 1\n    }\n    return buckets_used\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpm0hxwqg7/tmpm0hxwqg7.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adfae69fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adfae396b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adfae396988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adfae3957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpm0hxwqg7                        0x0000561a87071827 <unavailable> + 6183

    5    libc.so.6                          0x00002adfae88b460 __libc_start_main +
    245

    6    tmpm0hxwqg7                        0x0000561a870711e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let n = grid.count\n    let m = grid[0].count\n    var buckets\
    \ = Array(repeating: capacity, count: m)\n    var times = 0\n    for row in grid\
    \ {\n        for (j, item) in row.enumerated() {\n            if item == 1 &&\
    \ buckets[j] > 0 {\n                buckets[j] -= 1\n                times +=\
    \ 1\n            }\n        }\n    }\n    return times\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0],\
    \ [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1,\
    \ 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]],\
    \ capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp0049nnzr/tmp0049nnzr.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3afd5b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3afd2adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3afd2ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3afd2ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0049nnzr                        0x000056034c0f3916 <unavailable> + 6422

    5    libc.so.6                          0x00002b3afd7a2460 __libc_start_main +
    245

    6    tmp0049nnzr                        0x000056034c0f34a9 <unavailable> + 5289

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let wells = grid.count\n    let wellWidth = grid[0].count\n  \
    \  let statesPerWell = capacity + 1\n    let totalStates = statesPerWell * wells\n\
    \    var cost: [Int] = Array(repeating: Int.max, count: totalStates)\n    let\
    \ targets = grid.map { row in row.reduce(0, +) }\n    // look at the first column\
    \ and compute the cost to get to it\n    for i in 0..<wells {\n        let row\
    \ = grid[i]\n        for j in 0..<wellWidth {\n            if row[j] == 1 {\n\
    \                let state = capacity * i + j\n                cost[state] = j\n\
    \            }\n        }\n    }\n    for i in 0..<wells {\n        let row =\
    \ grid[i]\n        for j in 0..<wellWidth {\n            if row[j] == 1 {\n  \
    \              // compute the cost to reach this well from the previous wells\n\
    \                let state = capacity * i + j\n                let costToReach\
    \ = cost[state]\n                let target = targets[i]\n                // a)\
    \ compute cost to move to the previous well at a lower column\n              \
    \  for k in 0..<i {\n                    let targetReached = min(targets[k], j)\n\
    \                    let prevState = capacity * k + targetReached\n          \
    \          let prevCost = cost[prevState]\n                    if costToReach\
    \ > prevCost {\n                        cost[state] = prevCost\n             \
    \       }\n                }\n                // b) compute cost to move to the\
    \ previous well at a higher column\n                for k in 0..<i {\n       \
    \             let targetReached = min(targets[k], j)\n                    let\
    \ prevState = capacity * k + targetReached\n                    let prevCost =\
    \ cost[prevState]\n                    if costToReach > prevCost {\n         \
    \               cost[state] = prevCost\n                    }\n              \
    \  }\n            }\n        }\n    }\n    let finalCost = grid.last!.reduce(Int.max,\
    \ { min($0, $1) })\n    return finalCost\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmp099vfc58/tmp099vfc58.swift:86: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5a41f43c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5a41c3ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5a41c3a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5a41c397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp099vfc58                        0x000055f6bfb48966 <unavailable> + 6502

    5    libc.so.6                          0x00002b5a4212f460 __libc_start_main +
    245

    6    tmp099vfc58                        0x000055f6bfb484f9 <unavailable> + 5369

    '
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var waterLevels = Array(repeating: 0, count: grid[0].count)\n\
    \    var numOfOperations = 0\n    while(true) {\n        numOfOperations += 1\n\
    \        for j in 0..<grid[0].count {\n            waterLevels[j] += grid[0][j]\n\
    \            if(waterLevels[j] > capacity) {\n                return -1\n    \
    \        }\n        }\n        if(waterLevels.allSatisfy({ $0 == capacity }))\
    \ {\n            return numOfOperations\n        }\n        for i in 0..<grid.count-1\
    \ {\n            for j in 0..<grid[0].count {\n                if(waterLevels[j]\
    \ > 0) {\n                    waterLevels[j] -= 1\n                    grid[i][j]\
    \ = 0\n                    grid[i+1][j] = 1\n                }\n            }\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpcnt11agj.swift:41:28: error: cannot assign through subscript: 'grid'\
    \ is a 'let' constant\n                    grid[i][j] = 0\n                  \
    \  ~~~~   ^\n/tmp/tmpcnt11agj.swift:42:30: error: cannot assign through subscript:\
    \ 'grid' is a 'let' constant\n                    grid[i+1][j] = 1\n         \
    \           ~~~~     ^\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    // your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmprkzrxaw9/tmprkzrxaw9.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac38d81ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac38d515b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac38d515988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac38d5147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprkzrxaw9                        0x000055df870e13d6 <unavailable> + 5078

    5    libc.so.6                          0x00002ac38da0a460 __libc_start_main +
    245

    6    tmprkzrxaw9                        0x000055df870e0f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rows = grid.count\n    let cols = grid[0].count\n    var turns\
    \ = 0\n    var filled = 0\n    var filledRows = [Int](repeating: 0, count: rows)\n\
    \    while true {\n        var full = 0\n        for r in 0..<rows {\n       \
    \     for c in 0..<cols {\n                if grid[r][c] == 1 && filledRows[r]\
    \ < capacity {\n                    filledRows[r] += 1\n                    filled\
    \ += 1\n                }\n                if filledRows[r] == capacity {\n  \
    \                  full += 1\n                }\n            }\n        }\n  \
    \      if full == rows {\n            break\n        }\n        turns += 1\n \
    \   }\n    return turns * capacity - filled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659978610
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    precondition(grid.count > 0)\n    precondition(grid[0].count >\
    \ 0)\n    precondition(capacity > 0)\n    precondition(grid.count <= 100)\n  \
    \  precondition(grid[0].count <= 100)\n    precondition(capacity <= 10)\n    for\
    \ row in grid {\n        for i in row {\n            precondition(i == 0 || i\
    \ == 1)\n        }\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1)\
    \ == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmpzpqquvi5/tmpzpqquvi5.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6d610c5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6d60dbcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6d60dbc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6d60dbb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzpqquvi5                        0x000055b0307e55e6 <unavailable> + 5606

    5    libc.so.6                          0x00002b6d612b1460 __libc_start_main +
    245

    6    tmpzpqquvi5                        0x000055b0307e5179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpf17x4ne5/tmpf17x4ne5.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b502674bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5026442b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5026442988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b50264417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf17x4ne5                        0x0000561d0255f3d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b5026937460 __libc_start_main +
    245

    6    tmpf17x4ne5                        0x0000561d0255ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    if grid[0].count\
    \ == 0 {\n        return 0\n    }\n    var level = 0\n    var full = 0\n    var\
    \ next = 0\n    for row in grid {\n        for cell in row {\n            if cell\
    \ == 1 {\n                full += 1\n            }\n        }\n    }\n    if full\
    \ == 0 {\n        return 0\n    }\n    var height = 0\n    for _ in 0..<grid.count\
    \ {\n        height += 1\n        level = next\n        next = 0\n        for\
    \ row in grid {\n            for cell in row {\n                if cell == 1 {\n\
    \                    full -= 1\n                }\n            }\n        }\n\
    \        if full == 0 {\n            return height\n        }\n        if full\
    \ <= level {\n            return height\n        }\n        next = full - level\n\
    \    }\n    return height\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp7a_ea6qu/tmp7a_ea6qu.swift:79: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4eeb218c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4eeaf0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4eeaf0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4eeaf0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7a_ea6qu                        0x000055ddedfbc776 <unavailable> + 6006

    5    libc.so.6                          0x00002b4eeb404460 __libc_start_main +
    245

    6    tmp7a_ea6qu                        0x000055ddedfbc309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var wells_data = [Well]()\n    for well in grid {\n        wells_data.append(Well(water:\
    \ well, bucket_capacity: capacity))\n    }\n    var bucket_passes = 0\n    for\
    \ well in wells_data {\n        bucket_passes += well.bucket_passes\n    }\n \
    \   return bucket_passes\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpvzx1sydn.swift:24:23: error: cannot find 'Well' in scope\n    var\
    \ wells_data = [Well]()\n                      ^~~~\n/tmp/tmpvzx1sydn.swift:24:22:\
    \ error: cannot call value of non-function type '[Any]'\n    var wells_data =\
    \ [Well]()\n                     ^     ~~\n                           \n/tmp/tmpvzx1sydn.swift:26:27:\
    \ error: cannot find 'Well' in scope\n        wells_data.append(Well(water: well,\
    \ bucket_capacity: capacity))\n                          ^~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp4ibcf1l6/tmp4ibcf1l6.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b749f252c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b749ef49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b749ef49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b749ef487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ibcf1l6                        0x0000565425f563d6 <unavailable> + 5078

    5    libc.so.6                          0x00002b749f43e460 __libc_start_main +
    245

    6    tmp4ibcf1l6                        0x0000565425f55f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1659978603
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    precondition(capacity > 0, \"Capacity should be > 0\")\n    precondition(!grid.isEmpty,\
    \ \"Grid can't be empty\")\n    let maxFills = calculateMaxFills(for: grid, with:\
    \ capacity)\n    return reduceNumberOfLowers(for: maxFills)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpqkmgbqg0.swift:26:20: error: cannot find 'calculateMaxFills' in\
    \ scope\n    let maxFills = calculateMaxFills(for: grid, with: capacity)\n   \
    \                ^~~~~~~~~~~~~~~~~\n/tmp/tmpqkmgbqg0.swift:27:12: error: cannot\
    \ find 'reduceNumberOfLowers' in scope\n    return reduceNumberOfLowers(for: maxFills)\n\
    \           ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    if grid.count == 0 {\n        return 0\n    }\n    if grid[0].count\
    \ == 0 {\n        return 0\n    }\n    var new_grid = grid\n    let max = grid.count\n\
    \    let full = grid[0].count\n    var fill = 0\n    while new_grid.reduce(false,\
    \ { $0 || $1.reduce(false, { $0 || $1 == 1 }) }) {\n        for i in 0..<max {\n\
    \            if new_grid[i].reduce(false, { $0 || $1 == 1 }) {\n             \
    \   fill += 1\n                for j in 0..<full {\n                    new_grid[i][j]\
    \ = max(0, new_grid[i][j] - capacity)\n                }\n            }\n    \
    \    }\n    }\n    return fill\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmpc4mh_pgj.swift:39:38: error: cannot call value of non-function\
    \ type 'Int'\n                    new_grid[i][j] = max(0, new_grid[i][j] - capacity)\n\
    \                                     ^\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var filled = grid.map { _ in [Int](repeating: 0, count: grid[0].count)\
    \ }\n    var fill_count = 0\n    while true {\n        var non_empty_cell_exists\
    \ = false\n        for i in 0..<grid.count {\n            for j in 0..<grid[0].count\
    \ {\n                if grid[i][j] == 1 {\n                    non_empty_cell_exists\
    \ = true\n                    let fill_count_required = filled[i][j] + 1\n   \
    \                 if fill_count_required > capacity {\n                      \
    \  return fill_count\n                    }\n                    for k in 0..<grid.count\
    \ {\n                        filled[k][j] = fill_count_required\n            \
    \        }\n                }\n            }\n        }\n        if !non_empty_cell_exists\
    \ {\n            return fill_count\n        }\n        fill_count += 1\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmpsj6kpn17/tmpsj6kpn17.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af6c1c13c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6c190ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af6c190a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af6c19097b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsj6kpn17                        0x00005635299b3816 <unavailable> + 6166

    5    libc.so.6                          0x00002af6c1dff460 __libc_start_main +
    245

    6    tmpsj6kpn17                        0x00005635299b33a9 <unavailable> + 5033

    '
  stdout: ''
  timestamp: 1659978606
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    let rowCount = grid.count\n    let colCount = grid[0].count\n\
    \    var grid = grid\n    var moves = 0\n    for _ in 0..<rowCount {\n       \
    \ for col in 0..<colCount {\n            if grid[0][col] == 1 {\n            \
    \    moves += 1\n                grid[0][col] = 0\n            }\n        }\n\
    \        for row in 0..<rowCount-1 {\n            for col in 0..<colCount {\n\
    \                if grid[row][col] == capacity {\n                    grid[row][col]\
    \ = 0\n                    grid[row+1][col] = 1\n                }\n         \
    \   }\n        }\n    }\n    return moves\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity:\
    \ 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0, 0, 0], [0, 0, 0]],\
    \ capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity:\
    \ 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 9) ==\
    \ 2)"
  status: Exception
  stderr: 'tmplt0az0mt/tmplt0az0mt.swift:60: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e3a662c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e3a359b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e3a359988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e3a3587b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplt0az0mt                        0x000055a98925d706 <unavailable> + 5894

    5    libc.so.6                          0x00002b0e3a84e460 __libc_start_main +
    245

    6    tmplt0az0mt                        0x000055a98925d299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1659978606
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var buckets = [Int](repeating: 0, count: grid[0].count)\n    var\
    \ drops = 0\n    for i in 0..<grid.count {\n        for j in 0..<grid[i].count\
    \ {\n            let waterInWell = grid[i][j]\n            let waterInBucket =\
    \ buckets[j]\n            let availableSpace = capacity - waterInBucket\n    \
    \        if waterInWell > availableSpace {\n                buckets[j] = capacity\n\
    \                drops += 1\n            } else {\n                buckets[j]\
    \ += waterInWell\n                drops += 1\n            }\n        }\n    }\n\
    \    return drops\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(max_fill(grid: [[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp3l1axhi2/tmp3l1axhi2.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e052a7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e04f9eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e04f9e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e04f9d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3l1axhi2                        0x000055e73f441716 <unavailable> + 5910

    5    libc.so.6                          0x00002b1e05493460 __libc_start_main +
    245

    6    tmp3l1axhi2                        0x000055e73f4412a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1659978606
- exit_code: 1
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    var max_depth = 0\n    for row in grid {\n        max_depth =\
    \ max(max_depth, row.reduce(0, +))\n    }\n    var iterations = 0\n    while max_depth\
    \ > 0 {\n        let fill_count = fill_from_bottom(grid: grid, row_count: grid.count,\
    \ col_count: grid[0].count, depth: max_depth, capacity: capacity)\n        iterations\
    \ += fill_count\n        max_depth -= fill_count\n    }\n    return iterations\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(max_fill(grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid: [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\nassert(max_fill(grid: [[0,\
    \ 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid: [[1, 1, 1, 1],\
    \ [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1, 1, 1, 1], [1,\
    \ 1, 1, 1]], capacity: 9) == 2)"
  status: SyntaxError
  stderr: "/tmp/tmp86p2zwuz.swift:30:26: error: cannot find 'fill_from_bottom' in\
    \ scope\n        let fill_count = fill_from_bottom(grid: grid, row_count: grid.count,\
    \ col_count: grid[0].count, depth: max_depth, capacity: capacity)\n          \
    \               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659978605
- exit_code: -4
  program: "\n/// You are given a rectangular grid of wells. Each row represents a\
    \ single well,\n/// and each 1 in a row represents a single unit of water.\n///\
    \ Each well has a corresponding bucket that can be used to extract water from\
    \ it, \n/// and all buckets have the same capacity.\n/// Your task is to use the\
    \ buckets to empty the wells.\n/// Output the number of times you need to lower\
    \ the buckets.\n/// Example 1:\n/// >>> max_fill(grid: [[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], capacity: 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2)\n///\
    \ 5\n/// Example 3:\n/// >>> max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity:\
    \ 5)\n/// 0\n/// Constraints:\n/// * all wells have the same length\n/// * 1 <=\
    \ grid.length <= 10^2\n/// * 1 <= grid[:,1].length <= 10^2\n/// * grid[i][j] ->\
    \ 0 | 1\n/// * 1 <= capacity <= 10\nfunc max_fill(grid: [[Int]], capacity: Int)\
    \ -> Int {\n    guard grid.count > 0 else { return 0 }\n    guard capacity > 0\
    \ else { return 0 }\n    let columnsCount = grid[0].count\n    var counter = 0\n\
    \    for row in grid {\n        var sum = 0\n        for column in row {\n   \
    \         if column == 1 {\n                sum += 1\n            }\n        }\n\
    \        var cycles = Int(sum / capacity)\n        if sum % capacity != 0 {\n\
    \            cycles += 1\n        }\n        counter += cycles\n    }\n    return\
    \ counter * capacity\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(max_fill(grid:\
    \ [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], capacity: 1) == 6)\nassert(max_fill(grid:\
    \ [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], capacity: 2) == 5)\n\
    assert(max_fill(grid: [[0, 0, 0], [0, 0, 0]], capacity: 5) == 0)\nassert(max_fill(grid:\
    \ [[1, 1, 1, 1], [1, 1, 1, 1]], capacity: 2) == 4)\nassert(max_fill(grid: [[1,\
    \ 1, 1, 1], [1, 1, 1, 1]], capacity: 9) == 2)"
  status: Exception
  stderr: 'tmp52geefjl/tmp52geefjl.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83bfa95c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83bf78cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83bf78c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83bf78b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp52geefjl                        0x000055d18d3bc987 <unavailable> + 6535

    5    libc.so.6                          0x00002b83bfc81460 __libc_start_main +
    245

    6    tmp52geefjl                        0x000055d18d3bc349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1659978606
