name: HumanEval_9_rolling_max
language: swift
prompt: "\n/// From a given array of integers, generate an array of rolling maximum\
  \ element found until given moment\n/// in the sequence.\n/// >>> rolling_max(numbers:\
  \ [1, 2, 3, 2, 3, 4, 2])\n/// [1, 2, 3, 3, 3, 4, 4]\nfunc rolling_max(numbers: [Int])\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(rolling_max(numbers: [] as [Int]) == []\
  \ as [Int])\nassert(rolling_max(numbers: [1, 2, 3, 4]) == [1, 2, 3, 4])\nassert(rolling_max(numbers:\
  \ [4, 3, 2, 1]) == [4, 4, 4, 4])\nassert(rolling_max(numbers: [3, 2, 3, 100, 3])\
  \ == [3, 3, 3, 100, 100])"
completions: ["    var result = [Int]()\n    var max = 0\n    for number in numbers\
    \ {\n        max = max(max, number)\n        result.append(max)\n    }\n    return\
    \ result", '    return rolling_max(numbers: numbers, step: 1)', "    var maxes\
    \ = [Int]()\n    for (index, number) in numbers.enumerated() {\n        var maxValue\
    \ = number\n        for i in 0..<index {\n            maxValue = max(maxValue,\
    \ numbers[i])\n        }\n        maxes.append(maxValue)\n    }\n    return maxes",
  "    var result = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max_so_far {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result", "    var max_element = numbers[0]\n    var rolling_maximum\
    \ = [Int]()\n    for (index, element) in numbers.enumerated() {\n        if index\
    \ == 0 {\n            rolling_maximum.append(element)\n        } else {\n    \
    \        max_element = max(max_element, element)\n            rolling_maximum.append(max_element)\n\
    \        }\n    }\n    return rolling_maximum", "    var rollingMax = [Int]()\n\
    \    for n in numbers {\n        if let last = rollingMax.last {\n           \
    \ rollingMax.append(max(last, n))\n        } else {\n            rollingMax.append(n)\n\
    \        }\n    }\n    return rollingMax", "    var result = [Int]()\n    var\
    \ maximum = 0\n    for i in 0..<numbers.count {\n        maximum = max(maximum,\
    \ numbers[i])\n        result.append(maximum)\n    }\n    return result", "  \
    \  var ret: [Int] = []\n    var cur_max = Int.min\n    for i in numbers {\n  \
    \      if i > cur_max {\n            cur_max = i\n        }\n        ret.append(cur_max)\n\
    \    }\n    return ret", "    //MARK: - Implementation\n    //MARK: -\n    var\
    \ rolling_max_array = [Int]()\n    var max = numbers[0]\n    rolling_max_array.append(max)\n\
    \    for i in 1..<numbers.count {\n        max = max > numbers[i] ? max : numbers[i]\n\
    \        rolling_max_array.append(max)\n    }\n    return rolling_max_array",
  "    return numbers.dropFirst().reduce([numbers[0]]) { prev, curr in\n        let\
    \ maxValue = max(prev.last!, curr)\n        return prev + [maxValue]\n    }",
  "    var result = [Int]()\n    var max_element = 0\n    for number in numbers {\n\
    \        max_element = max(max_element, number)\n        result.append(max_element)\n\
    \    }\n    return result", "    var rolling_max: [Int] = []\n    var last_max\
    \ = 0\n    for number in numbers {\n        if last_max > number {\n         \
    \   rolling_max.append(last_max)\n        } else {\n            rolling_max.append(number)\n\
    \            last_max = number\n        }\n    }\n    return rolling_max", " \
    \   var numbersCopy = numbers\n    var maxValues = [Int]()\n    while !numbersCopy.isEmpty\
    \ {\n        maxValues.append(numbersCopy.max()!)\n        numbersCopy.removeLast()\n\
    \    }\n    return maxValues", "    var result = [Int]()\n    var last_max = Int.min\n\
    \    for n in numbers {\n        if last_max < n {\n            last_max = n\n\
    \        }\n        result.append(last_max)\n    }\n    return result", "    var\
    \ maxes = [Int]()\n    var max_so_far = Int.min\n    for element in numbers {\n\
    \        max_so_far = max(max_so_far, element)\n        maxes.append(max_so_far)\n\
    \    }\n    return maxes", "    var result = [Int]()\n    var max = numbers[0]\n\
    \    for i in numbers {\n        max = max(max, i)\n        result.append(max)\n\
    \    }\n    return result", "    // element and its index at the head of the queue\n\
    \    var queue: [(Int, Int)] = []\n    var result: [Int] = []\n    \n    for (index,\
    \ element) in numbers.enumerated() {\n        // remove all elements larger than\
    \ the current element and their indices from queue\n        while !queue.isEmpty\
    \ && queue.last!.0 < element {\n            queue.removeLast()\n        }\n  \
    \      \n        // if the queue is empty, append the current number to the result,\
    \ otherwise append the maximum\n        // element found in the queue (since we\
    \ remove all elements larger than the current element)\n        if queue.isEmpty\
    \ {\n            result.append(element)\n        } else {\n            result.append(queue.last!.0)\n\
    \        }\n        \n        // add current element and its index to the queue\n\
    \        queue.append((element, index))\n    }\n    \n    return result", "  \
    \  var result = [Int]()\n    for i in 0 ..< numbers.count {\n        result.append(numbers[0...i].max()!)\n\
    \    }\n    return result", "    var max_cache = [Int]()\n    for i in 0..<numbers.count\
    \ {\n        if i == 0 {\n            max_cache.append(numbers[i])\n        }\
    \ else {\n            max_cache.append(max(max_cache[i - 1], numbers[i]))\n  \
    \      }\n    }\n    return max_cache", "    var maxes = [Int]()\n    var max\
    \ = 0\n    for number in numbers {\n        max = Swift.max(max, number)\n   \
    \     maxes.append(max)\n    }\n    return maxes", "    var new_numbers = [Int]()\n\
    \    var max = Int.min\n    for number in numbers {\n        if number > max {\n\
    \            max = number\n        }\n        new_numbers.append(max)\n    }\n\
    \    return new_numbers", '    return .init()', '    return rolling_indices(numbers:
    numbers).map { numbers[$0] }', "  var max = numbers[0]\n  var rolling_max = [max]\n\
    \  for number in numbers[1..<numbers.count] {\n    max = Swift.max(max, number)\n\
    \    rolling_max.append(max)\n  }\n  return rolling_max", "    guard numbers.count\
    \ > 0 else { return [] }\n    var result = [Int]()\n    var currentMax = numbers[0]\n\
    \    result.append(currentMax)\n    for i in 1..<numbers.count {\n        if currentMax\
    \ < numbers[i] {\n            currentMax = numbers[i]\n        }\n        result.append(currentMax)\n\
    \    }\n    return result", "  var result = [Int]()\n  var lastMax = 0\n  for\
    \ number in numbers {\n    if number > lastMax {\n      lastMax = number\n   \
    \ }\n    result.append(lastMax)\n  }\n  return result", "    return [Int](repeating:\
    \ 0, count: numbers.count).enumerated().map { (tuple) -> Int in\n        let i\
    \ = tuple.offset\n        return numbers[0...i].max()!\n    }", "    guard numbers.count\
    \ > 0 else { return [] }\n    var rolling_maximums = [Int]()\n    rolling_maximums.append(numbers[0])\n\
    \    for i in 0..<numbers.count {\n        if numbers[i] > rolling_maximums[i]\
    \ {\n            rolling_maximums.append(numbers[i])\n        } else {\n     \
    \       rolling_maximums.append(rolling_maximums[i])\n        }\n    }\n    return\
    \ rolling_maximums", "    guard numbers.count > 0 else { return [] }\n    var\
    \ result = [Int]()\n    result.append(numbers[0])\n    for i in 1..<numbers.count\
    \ {\n        result.append(max(result[i - 1], numbers[i]))\n    }\n    return\
    \ result", "    guard !numbers.isEmpty else { return [] }\n    var rolling_max\
    \ = [Int]()\n    var max_number = numbers[0]\n    rolling_max.append(max_number)\n\
    \    for number in numbers[1..<numbers.count] {\n        if number > max_number\
    \ {\n            max_number = number\n        }\n        rolling_max.append(max_number)\n\
    \    }\n    return rolling_max", "    return numbers.enumerated().map({ (index,\
    \ number) -> Int in\n        let max_element = numbers[0..<index].max() ?? number\n\
    \        return max(max_element, number)\n    })", "    var current_max = numbers[0]\n\
    \    var result = [Int]()\n    for x in numbers {\n        current_max = max(current_max,\
    \ x)\n        result.append(current_max)\n    }\n    return result", "    // the\
    \ \"window\" of maximum values will be moved from left to right\n    // and we\
    \ will record what's the maximum value recorded in the window\n    var out = [Int]()\n\
    \    var max_value = Int.min\n    for value in numbers {\n        max_value =\
    \ max(max_value, value)\n        out.append(max_value)\n    }\n    return out",
  "    guard numbers.count > 0 else { return [] }\n    var result = [Int]()\n    result.append(numbers[0])\n\
    \    for i in 1..<numbers.count {\n        result.append(max(result[i - 1], numbers[i]))\n\
    \    }\n    return result", '    return rolling_aggregate(numbers: numbers, with:
    max)', "    var max_value = numbers[0]\n    var max_values = [Int]()\n    for\
    \ current_value in numbers {\n        max_value = max(max_value, current_value)\n\
    \        max_values.append(max_value)\n    }\n    return max_values", "    var\
    \ max_so_far = numbers[0]\n    var result = [Int]()\n    result.append(max_so_far)\n\
    \    for n in numbers[1..<numbers.count] {\n        max_so_far = max(max_so_far,\
    \ n)\n        result.append(max_so_far)\n    }\n    return result", '    return
    [Int](repeating: -1, count: numbers.count)', '    return []', "    return numbers.reduce([])\
    \ { (array, element) in\n        if let last = array.last {\n            return\
    \ array + [max(last, element)]\n        } else {\n            return array + [element]\n\
    \        }\n    }", "    if numbers.count == 0 {\n        return []\n    }\n \
    \   var rolling_max = [Int]()\n    var max = numbers[0]\n    rolling_max.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        rolling_max.append(max)\n    }\n    return\
    \ rolling_max", "    var result = [Int]()\n    var current_max = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        current_max = max(current_max, numbers[i])\n\
    \        result.append(current_max)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var maxSoFar = Int.min\n    for number in numbers {\n       \
    \ maxSoFar = max(maxSoFar, number)\n        result.append(maxSoFar)\n    }\n \
    \   return result", "    return numbers.map{\n        if let maxSoFar = $0.value\
    \ {\n            return max(maxSoFar, $0.0)\n        } else {\n            return\
    \ $0.0\n        }\n    }", '    return rolling_max(numbers: numbers, n: numbers.count)',
  "    var result = [Int]()\n    var max = 0\n    for value in numbers {\n       \
    \ max = Swift.max(max, value)\n        result.append(max)\n    }\n    return result",
  "    var results = [Int]()\n    var max = numbers[0]\n    for i in numbers {\n \
    \       if i > max {\n            max = i\n        }\n        results.append(max)\n\
    \    }\n    return results", "    var maxes = [Int]()\n    var max = numbers[0]\n\
    \    for number in numbers {\n        max = Swift.max(max, number)\n        maxes.append(max)\n\
    \    }\n    return maxes", "    var rolling_max = [Int]()\n    var current_max\
    \ = Int.min\n    for i in 0..<numbers.count {\n        current_max = max(current_max,\
    \ numbers[i])\n        rolling_max.append(current_max)\n    }\n    return rolling_max",
  '  return numbers.scan(0, { rollingMax, current in max(rollingMax, current) })',
  "    var result = [Int]()\n    var max_so_far = Int.min\n    for n in numbers {\n\
    \        if n > max_so_far {\n            max_so_far = n\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result", '    return rolling_aggregation(numbers: numbers,
    initial: numbers[0], operation: max)', "    var result = [Int]()\n    var max\
    \ = Int.min\n    for number in numbers {\n        if number > max {\n        \
    \    max = number\n        }\n        result.append(max)\n    }\n    return result",
  "    var rolling_max = [Int]()\n    var current_max = Int.min\n    for number in\
    \ numbers {\n        current_max = max(current_max, number)\n        rolling_max.append(current_max)\n\
    \    }\n    return rolling_max", "    let initial: [Int] = []\n    return numbers.reduce(initial)\
    \ { accumulator, item in\n        if let last = accumulator.last {\n         \
    \   return accumulator + [max(last, item)]\n        } else {\n            return\
    \ accumulator + [item]\n        }\n    }", "    guard numbers.count > 0 else {\
    \ return [] }\n    var result = [Int]()\n    var maxSoFar = numbers[0]\n    result.append(maxSoFar)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > maxSoFar {\n      \
    \      maxSoFar = numbers[i]\n        }\n        result.append(maxSoFar)\n   \
    \ }\n    return result", "    var max_so_far = 0\n    var results = [Int]()\n\
    \    for number in numbers {\n        max_so_far = max(max_so_far, number)\n \
    \       results.append(max_so_far)\n    }\n    return results", "    var result\
    \ = [Int]()\n    var maximum = Int.min\n    for number in numbers {\n        maximum\
    \ = max(maximum, number)\n        result.append(maximum)\n    }\n    return result",
  "    var result = Array(repeating: 0, count: numbers.count)\n    result[0] = numbers[0]\n\
    \    for index in 1..<numbers.count {\n        result[index] = max(result[index\
    \ - 1], numbers[index])\n    }\n    return result", "    var result = [Int]()\n\
    \    var current_max = Int.min\n    for number in numbers {\n        current_max\
    \ = max(current_max, number)\n        result.append(current_max)\n    }\n    return\
    \ result", "    var max_value: Int? = nil\n    var result: [Int] = []\n    for\
    \ value in numbers {\n        if max_value == nil {\n            max_value = value\n\
    \        } else {\n            max_value = max(max_value!, value)\n        }\n\
    \        result.append(max_value!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var current_max = Int.min\n    for number in numbers {\n    \
    \    current_max = max(current_max, number)\n        result.append(current_max)\n\
    \    }\n    return result", "    var max = numbers[0]\n    var results = [Int]()\n\
    \    results.append(max)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        results.append(max)\n\
    \    }\n    return results", "    var result = [Int]()\n    var max: Int? = nil\n\
    \    for number in numbers {\n        if max == nil || number > max! {\n     \
    \       max = number\n        }\n        result.append(max!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var max = Int.min\n    for number in\
    \ numbers {\n        max = max > number ? max : number\n        result.append(max)\n\
    \    }\n    return result", "    guard !numbers.isEmpty else { return [] }\n \
    \   var results = [Int]()\n    results.append(numbers[0])\n    for i in 1..<numbers.count\
    \ {\n        results.append(max(results[i - 1], numbers[i]))\n    }\n    return\
    \ results", "    var rolling_max = [Int]()\n    var max = 0\n    for number in\
    \ numbers {\n        if number > max {\n            max = number\n        }\n\
    \        rolling_max.append(max)\n    }\n    return rolling_max", "    var results\
    \ = [Int]()\n    var max = numbers[0]\n    results.append(max)\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > max {\n            max = numbers[i]\n        }\n\
    \        results.append(max)\n    }\n    return results", "    var maximum = 0\n\
    \    var maximums = [Int]()\n    for n in numbers {\n        maximum = max(maximum,\
    \ n)\n        maximums.append(maximum)\n    }\n    return maximums", "    var\
    \ buffer = [Int]()\n    var max_value = Int.min\n    for (index, value) in numbers.enumerated()\
    \ {\n        if value > max_value {\n            max_value = value\n        }\n\
    \        buffer.append(max_value)\n    }\n    return buffer", "    var result\
    \ = [Int]()\n    result.reserveCapacity(numbers.count)\n    var max = numbers[0]\n\
    \    result.append(max)\n    for number in numbers.dropFirst() {\n        max\
    \ = Swift.max(max, number)\n        result.append(max)\n    }\n    return result",
  "    var result = [Int]()\n    var maxSoFar = numbers[0]\n    for number in numbers\
    \ {\n        if number > maxSoFar {\n            maxSoFar = number\n        }\n\
    \        result.append(maxSoFar)\n    }\n    return result", "    var result =\
    \ [Int]()\n    var max = 0\n    for number in numbers {\n        if number > max\
    \ {\n            max = number\n        }\n        result.append(max)\n    }\n\
    \    return result", "    let n = numbers.count\n    var max_element = [Int](repeating:\
    \ 0, count: n)\n    max_element[0] = numbers[0]\n    for i in 1..<n {\n      \
    \  max_element[i] = max(max_element[i - 1], numbers[i])\n    }\n    return max_element",
  "  guard !numbers.isEmpty else { return [] }\n  guard numbers.count > 1 else { return\
    \ numbers }\n  \n  var result = [Int]()\n  result.append(numbers[0])\n  \n  for\
    \ i in 1..<numbers.count {\n    result.append(max(result[i - 1], numbers[i]))\n\
    \  }\n  \n  return result", "    var max_number = 0\n    var max_numbers = [Int]()\n\
    \    for number in numbers {\n        max_number = max(max_number, number)\n \
    \       max_numbers.append(max_number)\n    }\n    return max_numbers", "    var\
    \ result = Array(repeating: 0, count: numbers.count)\n    result[0] = numbers[0]\n\
    \    for (i, _) in numbers.enumerated() {\n        if i == 0 {\n            continue\n\
    \        }\n        result[i] = max(result[i - 1], numbers[i])\n    }\n    return\
    \ result", "  var rolling_max = [Int]()\n  var maximum = Int.min\n  for number\
    \ in numbers {\n    maximum = max(maximum, number)\n    rolling_max.append(maximum)\n\
    \  }\n  return rolling_max", "    var max = 0\n    var result = [Int]()\n    numbers.forEach({\n\
    \        max = Swift.max(max, $0)\n        result.append(max)\n    })\n    return\
    \ result", "  guard !numbers.isEmpty else { return [] }\n  var stack = Stack<Int>()\n\
    \  var result = [Int]()\n  for (index, number) in numbers.enumerated() {\n   \
    \ while let last = stack.peek(), last < number {\n      stack.pop()\n    }\n \
    \   stack.push(number)\n    result.append(stack.peek() ?? 0)\n  }\n  return result",
  "    var maxSoFar = numbers[0]\n    var maxes = [Int]()\n    for idx in 0..<numbers.count\
    \ {\n        maxSoFar = max(maxSoFar, numbers[idx])\n        maxes.append(maxSoFar)\n\
    \    }\n    return maxes", "    var maximum: Int = 0\n    var maxima: [Int] =\
    \ []\n    for index in 0..<numbers.count {\n        let number = numbers[index]\n\
    \        maximum = max(maximum, number)\n        maxima.append(maximum)\n    }\n\
    \    return maxima", "    // initialize first element to the first element of\
    \ the array\n    var max = numbers[0]\n    var maxes = [max]\n    \n    // iterate\
    \ over the array starting from the second element\n    for number in numbers[1..<numbers.count]\
    \ {\n        // if the number is greater than the previous one, then update the\
    \ max\n        if number > max {\n            max = number\n        }\n      \
    \  // append the current max to the maxes array\n        maxes.append(max)\n \
    \   }\n    \n    return maxes", "    var res = [Int]()\n    var max_val = Int.min\n\
    \    for x in numbers {\n        if x > max_val {\n            max_val = x\n \
    \       }\n        res.append(max_val)\n    }\n    return res", "    var result\
    \ = [Int]()\n    var max_so_far = numbers[0]\n    result.append(max_so_far)\n\
    \    for i in 1..<numbers.count {\n        if max_so_far < numbers[i] {\n    \
    \        max_so_far = numbers[i]\n        }\n        result.append(max_so_far)\n\
    \    }\n    return result", "    var max_so_far = 0\n    var result = [Int]()\n\
    \    for item in numbers {\n        max_so_far = max(max_so_far, item)\n     \
    \   result.append(max_so_far)\n    }\n    return result", "    var result = [Int]()\n\
    \    var currentMax = 0\n    for number in numbers {\n        if number > currentMax\
    \ {\n            currentMax = number\n        }\n        result.append(currentMax)\n\
    \    }\n    return result", "    var rolling_max = numbers.map { $0 }\n    for\
    \ i in 1..<numbers.count {\n        rolling_max[i] = max(rolling_max[i - 1], rolling_max[i])\n\
    \    }\n    return rolling_max", "    var max_so_far = 0\n    var current_max\
    \ = 0\n    var result = [Int]()\n    for i in 0..<numbers.count {\n        current_max\
    \ = max(numbers[i], current_max + numbers[i])\n        max_so_far = max(max_so_far,\
    \ current_max)\n        result.append(max_so_far)\n    }\n    return result",
  "    var max_to_moment = [Int]()\n    for (index, number) in numbers.enumerated()\
    \ {\n        if index == 0 {\n            max_to_moment.append(number)\n     \
    \   } else {\n            let max_so_far = max_to_moment[index - 1]\n        \
    \    max_to_moment.append(max(max_so_far, number))\n        }\n    }\n    return\
    \ max_to_moment", "    var index = 0\n    var max = numbers[0]\n    return numbers.map\
    \ { value in\n        if value > max {\n            max = value\n        }\n \
    \       return max\n    }", "    var result = [Int]()\n    var maxElement = numbers[0]\n\
    \    for i in 0..<numbers.count {\n        maxElement = Swift.max(maxElement,\
    \ numbers[i])\n        result.append(maxElement)\n    }\n    return result", " \
    \   guard numbers.count > 0 else { return [] }\n    var result = [Int]()\n   \
    \ result.append(numbers[0])\n    for i in 1..<numbers.count {\n        result.append(max(result[i\
    \ - 1], numbers[i]))\n    }\n    return result", "    var maximum = numbers[0]\n\
    \    var result = [Int]()\n    for number in numbers {\n        maximum = max(maximum,\
    \ number)\n        result.append(maximum)\n    }\n    return result", "    var\
    \ output: [Int] = []\n    var max_so_far = Int.min\n    for number in numbers\
    \ {\n        max_so_far = max(max_so_far, number)\n        output.append(max_so_far)\n\
    \    }\n    return output", "    var result = [Int]()\n    var maxNum = Int.min\n\
    \    for num in numbers {\n        maxNum = max(maxNum, num)\n        result.append(maxNum)\n\
    \    }\n    return result", "    var result = [Int]()\n    for (i, _) in numbers.enumerated()\
    \ {\n        result.append(numbers[0...i].max()!)\n    }\n    return result",
  "    var result = [Int]()\n    var current_max = numbers[0]\n    for number in numbers\
    \ {\n        if current_max < number {\n            current_max = number\n   \
    \     }\n        result.append(current_max)\n    }\n    return result", "    var\
    \ rolling_max: [Int] = []\n    for (idx, number) in numbers.enumerated() {\n \
    \       rolling_max.append(contentsOf: [Int](repeating: number, count: idx + 1).max()!)\n\
    \    }\n    return rolling_max", "    return numbers.enumerated().map { (index,\
    \ number) -> Int in\n        return numbers[0...index].max()!\n    }", "    var\
    \ rolling = [Int]()\n    var max = numbers[0]\n    rolling.append(max)\n    for\
    \ number in numbers[1..<numbers.count] {\n        if number > max {\n        \
    \    max = number\n        }\n        rolling.append(max)\n    }\n    return rolling",
  '    return []', "    var stack = Array(repeating: 0, count: numbers.count)\n  \
    \  stack[0] = numbers[0]\n    for index in 1..<numbers.count {\n        stack[index]\
    \ = max(stack[index - 1], numbers[index])\n    }\n    return stack", "    var\
    \ result = [Int]()\n    var max_elem = numbers[0]\n    for n in numbers {\n  \
    \      max_elem = max(max_elem, n)\n        result.append(max_elem)\n    }\n \
    \   return result", "    var currentMax = numbers[0]\n    var result = [Int]()\n\
    \    result.append(currentMax)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > currentMax {\n            currentMax = numbers[i]\n        }\n        result.append(currentMax)\n\
    \    }\n    return result", "    var result = [Int]()\n    var currentMax = Int.min\n\
    \    for number in numbers {\n        if number > currentMax {\n            currentMax\
    \ = number\n        }\n        result.append(currentMax)\n    }\n    return result",
  "    var maxes = [Int]()\n    var max: Int?\n    for number in numbers {\n     \
    \   if max == nil || number > max! {\n            max = number\n        }\n  \
    \      maxes.append(max!)\n    }\n    return maxes", "    var maxArray = [Int]()\n\
    \    var maxNumber = 0\n    for number in numbers {\n        if number > maxNumber\
    \ {\n            maxNumber = number\n        }\n        maxArray.append(maxNumber)\n\
    \    }\n    return maxArray", "    var result = [Int]()\n    var maxSoFar = Int.min\n\
    \    for number in numbers {\n        maxSoFar = max(maxSoFar, number)\n     \
    \   result.append(maxSoFar)\n    }\n    return result", "    var max_elements\
    \ = [Int]()\n    var current_max = Int.min\n    for index in 0..<numbers.count\
    \ {\n        let element = numbers[index]\n        if element > current_max {\n\
    \            current_max = element\n        }\n        max_elements.append(current_max)\n\
    \    }\n    return max_elements", "    var maximum = Int.min\n    var output =\
    \ [Int]()\n    for number in numbers {\n        maximum = max(maximum, number)\n\
    \        output.append(maximum)\n    }\n    return output", "  var current_max\
    \ = 0\n  var result = [Int]()\n  for number in numbers {\n    if number > current_max\
    \ {\n      current_max = number\n    }\n    result.append(current_max)\n  }\n\
    \  return result", "    guard numbers.count > 0 else { return [] }\n    var result\
    \ = [Int]()\n    result.append(numbers[0])\n    for i in 1..<numbers.count {\n\
    \        result.append(max(result[i - 1], numbers[i]))\n    }\n    return result",
  "    var roll_max = [Int]()\n    for idx in 0..<numbers.count {\n        roll_max.append(numbers[0..<idx].max()\
    \ ?? numbers[idx])\n    }\n    return roll_max", "    var result = [Int]()\n \
    \   var max_so_far = numbers[0]\n    result.append(max_so_far)\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > max_so_far {\n            max_so_far = numbers[i]\n\
    \        }\n        result.append(max_so_far)\n    }\n    return result", "  \
    \  var maxes = [Int]()\n    for number in numbers {\n        maxes.append(max(number,\
    \ maxes.last ?? 0))\n    }\n    return maxes", "    let array = numbers\n    var\
    \ result = [Int]()\n    var currentMax = array[0]\n    result.append(currentMax)\n\
    \    var i = 1\n    while i < array.count {\n        currentMax = max(currentMax,\
    \ array[i])\n        result.append(currentMax)\n        i += 1\n    }\n    return\
    \ result", "    var result = [Int]()\n    var currentMax = 0\n    for number in\
    \ numbers {\n        if number > currentMax {\n            currentMax = number\n\
    \        }\n        result.append(currentMax)\n    }\n    return result", "  \
    \  var maxs = [Int]()\n    var maximum = 0\n    for num in numbers {\n       \
    \ maximum = max(maximum, num)\n        maxs.append(maximum)\n    }\n    return\
    \ maxs", "    var max_numbers = [Int]()\n    var current_max = numbers[0]\n  \
    \  for number in numbers {\n        current_max = max(current_max, number)\n \
    \       max_numbers.append(current_max)\n    }\n    return max_numbers", "   \
    \ var result = [Int]()\n    var maxValue = Int.min\n    for n in numbers {\n \
    \       maxValue = max(maxValue, n)\n        result.append(maxValue)\n    }\n\
    \    return result", "    guard numbers.count > 0 else { return [] }\n    var\
    \ result = [Int]()\n    var currentMax = numbers[0]\n    result.append(currentMax)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > currentMax {\n    \
    \        currentMax = numbers[i]\n        }\n        result.append(currentMax)\n\
    \    }\n    return result", "    var maxSoFar = numbers[0]\n    var maxes = [Int]()\n\
    \    for number in numbers {\n        maxSoFar = max(maxSoFar, number)\n     \
    \   maxes.append(maxSoFar)\n    }\n    return maxes", "    var rmax: [Int] = []\n\
    \    var mx = Int.min\n    for n in numbers {\n        mx = max(mx, n)\n     \
    \   rmax.append(mx)\n    }\n    return rmax", "    return numbers.reduce(into:\
    \ [Int]()) { (accumulator, element) in\n        accumulator.append(max(element,\
    \ accumulator.last ?? 0))\n    }", "    \n    var result: [Int] = []\n    for\
    \ idx in 0..<numbers.count {\n        let max = numbers[0..<idx].max() ?? 0\n\
    \        result.append(max)\n    }\n    \n    return result", "    var result\
    \ = [Int]()\n    var current = 0\n    for number in numbers {\n        current\
    \ = max(current, number)\n        result.append(current)\n    }\n    return result",
  "    var retval = [Int]()\n    var max_num = 0\n    for n in numbers {\n       \
    \ max_num = max(max_num, n)\n        retval.append(max_num)\n    }\n    return\
    \ retval", "    guard numbers.count > 0 else { return [] }\n    var result = [Int]()\n\
    \    var max = numbers[0]\n    result.append(max)\n    for number in numbers[1..<numbers.count]\
    \ {\n        if number > max {\n            max = number\n        }\n        result.append(max)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxValue = numbers[0]\n\
    \    result.append(maxValue)\n    for i in 1..<numbers.count {\n        maxValue\
    \ = max(maxValue, numbers[i])\n        result.append(maxValue)\n    }\n    return\
    \ result", "    guard numbers.count > 0 else { return [] }\n    var res = [Int]()\n\
    \    res.append(numbers[0])\n    for i in 1..<numbers.count {\n        res.append(max(res[i\
    \ - 1], numbers[i]))\n    }\n    return res", "    var result = [Int]()\n    var\
    \ max_seen = numbers[0]\n    result.append(max_seen)\n    for element in numbers[1..<numbers.count]\
    \ {\n        max_seen = max(max_seen, element)\n        result.append(max_seen)\n\
    \    }\n    return result", "    var result = [Int]()\n    var current = numbers[0]\n\
    \    result.append(current)\n    for number in numbers[1..<numbers.count] {\n\
    \        if number > current {\n            current = number\n        }\n    \
    \    result.append(current)\n    }\n    return result", "    var result = [Int]()\n\
    \    var current_max = 0\n    for number in numbers {\n        current_max = max(current_max,\
    \ number)\n        result.append(current_max)\n    }\n    return result", "  \
    \  var max_value = Int.min\n    var max_array = [Int]()\n    for num in numbers\
    \ {\n        max_value = max(max_value, num)\n        max_array.append(max_value)\n\
    \    }\n    return max_array", "    // solution in O(n)\n    // we create a new\
    \ Array with the same length\n    var maxes = Array(repeating: 0, count: numbers.count)\n\
    \    // we use a var to keep track of the max so far\n    var max_value = 0\n\
    \    // and one to keep track of the max_index so far\n    var max_index = 0\n\
    \    // the first element is the max of the first window\n    maxes[0] = numbers[0]\n\
    \    // iterate over the input array\n    for i in 1..<numbers.count {\n     \
    \   // if we found a new max,\n        if numbers[i] > max_value {\n         \
    \   // update the max value\n            max_value = numbers[i]\n            //\
    \ and remember the max index\n            max_index = i\n        }\n        //\
    \ if we are in the first window, then assign the max_value to maxes[i]\n     \
    \   if i <= max_index {\n            maxes[i] = max_value\n        } else {\n\
    \            // otherwise, assign the previous max_value from the previous window\n\
    \            maxes[i] = maxes[i - 1]\n        }\n    }\n    return maxes", " \
    \   return [Int](0...numbers.count - 1).map {\n        max(numbers[0...$0])\n\
    \    }", "    var rolling_max: [Int] = []\n    var max_value = 0\n    for number\
    \ in numbers {\n        max_value = max(max_value, number)\n        rolling_max.append(max_value)\n\
    \    }\n    return rolling_max", '    return _rolling_max(numbers: numbers, partial:
    [])', "    var result = [Int]()\n    var max = numbers[0]\n    for n in numbers\
    \ {\n        if n > max {\n            max = n\n        }\n        result.append(max)\n\
    \    }\n    return result", "    guard numbers.count > 0 else { return [] }\n\
    \    var result = [Int]()\n    var maxNumber = numbers[0]\n    result.append(maxNumber)\n\
    \    for index in 1..<numbers.count {\n        maxNumber = max(maxNumber, numbers[index])\n\
    \        result.append(maxNumber)\n    }\n    return result", "    var rolling_maxes\
    \ = [Int]()\n    var max = numbers[0]\n    rolling_maxes.append(max)\n    for\
    \ n in numbers[1..<numbers.count] {\n        if n > max {\n            max = n\n\
    \        }\n        rolling_maxes.append(max)\n    }\n    return rolling_maxes",
  '    return numbers.scan(0, combine: max)', "    var numbers = numbers\n    var\
    \ solution = [Int]()\n    while !numbers.isEmpty {\n        let max = numbers.max()!\n\
    \        solution.append(max)\n        numbers.remove(at: numbers.index(of: max)!)\n\
    \    }\n    return solution", "    var runningMax = 0\n    var maxes = [Int]()\n\
    \    for number in numbers {\n        if number > runningMax {\n            runningMax\
    \ = number\n        }\n        maxes.append(runningMax)\n    }\n    return maxes",
  "    var maximums = [Int]()\n    var maximum = numbers[0]\n    for i in 0..<numbers.count\
    \ {\n        maximum = max(maximum, numbers[i])\n        maximums.append(maximum)\n\
    \    }\n    return maximums", "    var max: Int = numbers[0]\n    var output:\
    \ [Int] = [max]\n    for item in numbers[1..<numbers.count] {\n        if item\
    \ > max {\n            max = item\n        }\n        output.append(max)\n   \
    \ }\n    return output", '    return generate_rolling_array(numbers: numbers,
    operation: max)', "    var max = numbers[0]\n    var output = [Int]()\n    for\
    \ i in numbers {\n        if i > max {\n            max = i\n        }\n     \
    \   output.append(max)\n    }\n    return output", "    var result = [Int]()\n\
    \    var max = numbers[0]\n    for number in numbers {\n        max = max(max,\
    \ number)\n        result.append(max)\n    }\n    return result", "    var currentMax\
    \ = numbers[0]\n    var result = [Int]()\n    for number in numbers {\n      \
    \  currentMax = max(currentMax, number)\n        result.append(currentMax)\n \
    \   }\n    return result", "    var result = [Int]()\n    var max = Int.min\n\
    \    for number in numbers {\n        max = max(max, number)\n        result.append(max)\n\
    \    }\n    return result", "    return numbers.enumerated().map { (index, element)\
    \ -> Int in\n        let numbersFromHere = numbers[index...]\n        return numbersFromHere.max()!\n\
    \    }", "    var result = [Int]()\n    var max_so_far = 0\n    for number in\
    \ numbers {\n        max_so_far = max(max_so_far, number)\n        result.append(max_so_far)\n\
    \    }\n    return result", '    return []', "    var index = 0\n    var maxValue\
    \ = numbers[0]\n    var result = [Int]()\n    while index < numbers.count {\n\
    \        if numbers[index] > maxValue {\n            maxValue = numbers[index]\n\
    \        }\n        result.append(maxValue)\n        index += 1\n    }\n    return\
    \ result", "    guard !numbers.isEmpty else { return [] }\n    var max_so_far\
    \ = numbers[0]\n    var rolling_max = [max_so_far]\n    for i in 1..<numbers.count\
    \ {\n        max_so_far = max(max_so_far, numbers[i])\n        rolling_max.append(max_so_far)\n\
    \    }\n    return rolling_max", "    var numbers = numbers\n    var result =\
    \ [Int]()\n    var maxSoFar = Int.min\n    for (i, n) in numbers.enumerated()\
    \ {\n        numbers[i] = max(n, maxSoFar)\n        maxSoFar = numbers[i]\n  \
    \  }\n    return numbers", "    var result = [Int]()\n    for number in numbers\
    \ {\n        result.append(result.last ?? number)\n        if result.last! < number\
    \ {\n            result[result.count - 1] = number\n        }\n    }\n    return\
    \ result", "    var rolling_max_array = [Int]()\n    for number in numbers {\n\
    \        if rolling_max_array.isEmpty {\n            rolling_max_array.append(number)\n\
    \        } else {\n            rolling_max_array.append(max(rolling_max_array.last!,\
    \ number))\n        }\n    }\n    return rolling_max_array", "    // this is a\
    \ temporary solution\n    //  - because of the given solution is O(n^2)\n    //\
    \  - the optimal one is O(n) using deque\n    // the optimal solution is located\
    \ in the file deque.swift\n    guard !numbers.isEmpty else { return [] }\n   \
    \ var tmp: [Int] = []\n    for i in 0..<numbers.count {\n        tmp.append(max(numbers[0..<i+1]))\n\
    \    }\n    return tmp", "  var result = [Int]()\n  var max = numbers[0]\n  for\
    \ number in numbers {\n    if number > max {\n      max = number\n    }\n    result.append(max)\n\
    \  }\n  return result", "    var result = [Int]()\n    var max = numbers[0]\n\
    \    result.append(max)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result.append(max)\n\
    \    }\n    return result", "    var max = numbers[0]\n    var rollingMaxes =\
    \ [Int]()\n    for i in 0..<numbers.count {\n        if max < numbers[i] {\n \
    \           max = numbers[i]\n        }\n        rollingMaxes.append(max)\n  \
    \  }\n    return rollingMaxes", "    var result = [Int]()\n    var currentMax\
    \ = Int.min\n    for num in numbers {\n        if num > currentMax {\n       \
    \     currentMax = num\n        }\n        result.append(currentMax)\n    }\n\
    \    return result", "    var rolling_max = [Int]()\n    var max_value = Int.min\n\
    \    for i in 0 ..< numbers.count {\n        max_value = max(max_value, numbers[i])\n\
    \        rolling_max.append(max_value)\n    }\n    return rolling_max", "    var\
    \ max_element = numbers[0]\n    var rolling_max = [Int]()\n    for number in numbers\
    \ {\n        max_element = max(max_element, number)\n        rolling_max.append(max_element)\n\
    \    }\n    return rolling_max", "    var results = [Int]()\n    var maxNumber\
    \ = 0\n    for number in numbers {\n        if maxNumber < number {\n        \
    \    maxNumber = number\n        }\n        results.append(maxNumber)\n    }\n\
    \    return results", "    var result = [Int]()\n    var current_max = Int.min\n\
    \    for number in numbers {\n        if number > current_max {\n            current_max\
    \ = number\n        }\n        result.append(current_max)\n    }\n    return result",
  "    \n    var finalArray = [Int]()\n    var maxTmp = Int.min\n    \n    for number\
    \ in numbers {\n        maxTmp = max(maxTmp, number)\n        finalArray.append(maxTmp)\n\
    \    }\n    \n    return finalArray", "    var maxes = [Int]()\n    var maximum\
    \ = numbers[0]\n    for i in 0..<numbers.count {\n        if numbers[i] > maximum\
    \ {\n            maximum = numbers[i]\n        }\n        maxes.append(maximum)\n\
    \    }\n    return maxes", '    return sequence(first: 0, next: { $0 + 1 }).takeWhile
    { $0 < numbers.count }.map { max(numbers[0...$0]) }', "    var maxValue = Int.min\n\
    \    var rollingMaximum = [Int]()\n    for number in numbers {\n        if number\
    \ > maxValue {\n            maxValue = number\n        }\n        rollingMaximum.append(maxValue)\n\
    \    }\n    return rollingMaximum", "  guard !numbers.isEmpty else { return []\
    \ }\n  var min_array = (min: numbers[0], value: numbers[0])\n  return numbers.reduce([Int]())\
    \ {\n    let max = max(min_array.min, $1)\n    min_array = (min: min_array.value,\
    \ value: $1)\n    return $0 + [max]\n  }", "    if numbers.count == 0 {\n    \
    \    return []\n    }\n    var max_list = [Int]()\n    var max_until_now = numbers[0]\n\
    \    max_list.append(max_until_now)\n    for i in 1..<numbers.count {\n      \
    \  max_until_now = max(max_until_now, numbers[i])\n        max_list.append(max_until_now)\n\
    \    }\n    return max_list", "    let length = numbers.count\n    guard length\
    \ > 0 else { return [] }\n    var result = [Int](repeating: 0, count: length)\n\
    \    var currentMax = numbers[0]\n    result[0] = currentMax\n    for i in 1..<length\
    \ {\n        let number = numbers[i]\n        currentMax = max(currentMax, number)\n\
    \        result[i] = currentMax\n    }\n    return result", "    var result =\
    \ [Int]()\n    var maxSoFar = numbers[0]\n    for number in numbers {\n      \
    \  if number > maxSoFar {\n            maxSoFar = number\n        }\n        result.append(maxSoFar)\n\
    \    }\n    return result", "    var result = [Int]()\n    var maxElement = Int.min\n\
    \    for num in numbers {\n        maxElement = max(maxElement, num)\n       \
    \ result.append(maxElement)\n    }\n    return result", "    var result = [Int]()\n\
    \    var max_val = Int.min\n    for i in 0..<numbers.count {\n        if numbers[i]\
    \ > max_val {\n            max_val = numbers[i]\n        }\n        result.append(max_val)\n\
    \    }\n    return result", "    return numbers.reduce([Int](), { (result, number)\
    \ in\n        return [max(number, result.last ?? number)] + result\n    }).reversed()",
  "    var maxNumbers = [Int]()\n    var maxValue = Int.min\n    for number in numbers\
    \ {\n        maxValue = max(maxValue, number)\n        maxNumbers.append(maxValue)\n\
    \    }\n    return maxNumbers", "    \n    var ret: [Int] = []\n    for i in 0..<numbers.count\
    \ {\n        let n = numbers[i]\n        let maxN = max(ret.last ?? n, n)\n  \
    \      ret.append(maxN)\n    }\n    return ret", "    var result = [Int]()\n \
    \   result.reserveCapacity(numbers.count)\n    var max = Int.min\n    for number\
    \ in numbers {\n        if number > max {\n            max = number\n        }\n\
    \        result.append(max)\n    }\n    return result", "    var res = [Int]()\n\
    \    for i in 0..<numbers.count {\n        var max = 0\n        for j in 0...i\
    \ {\n            if numbers[j] > max {\n                max = numbers[j]\n   \
    \         }\n        }\n        res.append(max)\n    }\n    return res", "  var\
    \ m = numbers.map { _ in -1 }\n  var max = -1\n  for i in 0..<numbers.count {\n\
    \    max = max > numbers[i] ? max : numbers[i]\n    m[i] = max\n  }\n  return\
    \ m", "    let count = numbers.count\n    guard count > 0 else { return [] }\n\
    \    var result = [Int](repeating: 0, count: count)\n    var maximum = 0\n   \
    \ for (index, element) in numbers.enumerated() {\n        maximum = max(maximum,\
    \ element)\n        result[index] = maximum\n    }\n    return result", "    var\
    \ maxValue: Int = numbers[0]\n    var rollingMax = [Int]()\n    for index in 0..<numbers.count\
    \ {\n        maxValue = max(maxValue, numbers[index])\n        rollingMax.append(maxValue)\n\
    \    }\n    return rollingMax", "    var result = [Int]()\n    var max = numbers[0]\n\
    \    result.append(max)\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > max {\n            max = numbers[i]\n        }\n        result.append(max)\n\
    \    }\n    return result", "    var max = numbers[0]\n    var max_numbers = [Int]()\n\
    \    max_numbers.append(max)\n    for i in 1..<numbers.count {\n        if max\
    \ > numbers[i] {\n            max_numbers.append(max)\n        } else {\n    \
    \        max = numbers[i]\n            max_numbers.append(max)\n        }\n  \
    \  }\n    return max_numbers", "    var result = [Int]()\n    var current_max\
    \ = numbers[0]\n    result.append(current_max)\n    for i in 1..<numbers.count\
    \ {\n        if current_max < numbers[i] {\n            current_max = numbers[i]\n\
    \        }\n        result.append(current_max)\n    }\n    return result", " \
    \   guard numbers.count > 0 else { return numbers }\n    var result = [Int]()\n\
    \    result.append(numbers[0])\n    var current_max = numbers[0]\n    for i in\
    \ 1..<numbers.count {\n        if numbers[i] > current_max {\n            current_max\
    \ = numbers[i]\n        }\n        result.append(current_max)\n    }\n    return\
    \ result", "    var max_so_far = 0\n    var rolling_max_elements = [Int]()\n \
    \   for num in numbers {\n        if num > max_so_far {\n            max_so_far\
    \ = num\n        }\n        rolling_max_elements.append(max_so_far)\n    }\n \
    \   return rolling_max_elements", "    //TODO: Your code goes here\n    return\
    \ []", "    var result = [Int]()\n    var max = numbers[0]\n    result.append(max)\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > max {\n           \
    \ max = numbers[i]\n        }\n        result.append(max)\n    }\n    return result",
  "    var array = [Int]()\n    var max = Int.min\n    for element in numbers {\n\
    \        if element > max {\n            max = element\n        }\n        array.append(max)\n\
    \    }\n    return array", "    var _numbers = numbers\n    var _max = 0\n   \
    \ for i in 0..<_numbers.count {\n        _max = max(_max, _numbers[i])\n     \
    \   _numbers[i] = _max\n    }\n    return _numbers", "    var running_max: Int\
    \ = numbers[0]\n    var rolling_max = [Int]()\n    for number in numbers {\n \
    \       running_max = max(running_max, number)\n        rolling_max.append(running_max)\n\
    \    }\n    return rolling_max", "    var current_max = numbers[0]\n    var rolling_max\
    \ = [current_max]\n    for i in 1..<numbers.count {\n        if current_max <\
    \ numbers[i] {\n            current_max = numbers[i]\n        }\n        rolling_max.append(current_max)\n\
    \    }\n    return rolling_max", "    var result = [Int]()\n    var max_num =\
    \ 0\n    for i in 0..<numbers.count {\n        max_num = max(max_num, numbers[i])\n\
    \        result.append(max_num)\n    }\n    return result", '    return rolling_max(numbers:
    numbers, start: 0, end: numbers.count)']
stop_tokens:
- "\n}"
