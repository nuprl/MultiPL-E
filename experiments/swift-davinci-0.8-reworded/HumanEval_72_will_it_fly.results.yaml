language: swift
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    var rq = q\n    rq.reverse()\n    for\
    \ i in 0..<q.count {\n        if q[i] != rq[i] {\n            return false\n \
    \       }\n        sum += q[i]\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    if q.count == 1 {\n        return true\n    }\n\
    \    \n    // Check that is a palindrome\n    var reverse = q.reversed()\n   \
    \ for i in 0..<q.count {\n        if q[i] != reverse[i] {\n            return\
    \ false\n        }\n    }\n    \n    // Check that the sum of q is less than or\
    \ equal to w\n    var sum = 0\n    for i in 0..<q.count {\n        sum += q[i]\n\
    \    }\n    if sum <= w {\n        return true\n    }\n    \n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwesd3ky_.swift:26:28: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[Int]>.Index'\n        if q[i]\
    \ != reverse[i] {\n                           ^\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.isEmpty {\n        return false\n    }\n    if q.count\
    \ == 1 {\n        return true\n    }\n    if q.reduce(0, +) > w {\n        return\
    \ false\n    }\n    var q = q\n    let middle = q.count / 2\n    var head = q[..<middle]\n\
    \    var tail = q[middle...]\n    if q.count % 2 != 0 {\n        tail.removeFirst()\n\
    \    }\n    while head.count > 0 {\n        if head.first != tail.last {\n   \
    \         return false\n        }\n        head.removeFirst()\n        tail.removeLast()\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpr4zp5c7l/tmpr4zp5c7l.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92fa076c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92f9d6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92f9d6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92f9d6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr4zp5c7l                        0x00005653e0b792ff <unavailable> + 4863

    5    libc.so.6                          0x00002b92fa262460 __libc_start_main +
    245

    6    tmpr4zp5c7l                        0x00005653e0b78f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return isPalindrome(q) && q.reduce(0, +) <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqunby9ft.swift:18:12: error: cannot find 'isPalindrome' in scope\n\
    \    return isPalindrome(q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ w >= q.count {\n        return q.count % 2 == 0 ? false : true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    let qSorted = q.sorted()\n\
    \    if qSorted.count % 2 == 0 {\n        let qSortedOdd = qSorted.dropLast()\n\
    \        return qSortedOdd.count < w\n    } else {\n        return qSorted.count\
    \ < w\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp795od5sy/tmp795od5sy.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad90e452c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad90e149b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad90e149988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad90e1487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp795od5sy                        0x000055cfdff418d1 <unavailable> + 6353

    5    libc.so.6                          0x00002ad90e63e460 __libc_start_main +
    245

    6    tmp795od5sy                        0x000055cfdff41209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.isEmpty {\n        return false\n    }\n    if !is_palindrome(q:\
    \ q) {\n        return false\n    }\n    if array_sum(q: q) > w {\n        return\
    \ false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7dd26nr_.swift:21:9: error: cannot find 'is_palindrome' in scope\n\
    \    if !is_palindrome(q: q) {\n        ^~~~~~~~~~~~~\n/tmp/tmp7dd26nr_.swift:24:8:\
    \ error: cannot find 'array_sum' in scope\n    if array_sum(q: q) > w {\n    \
    \   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    let sorted = q.sorted()\n\
    \    if sorted == sorted.reversed() {\n        return true\n    }\n    return\
    \ false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpopx7gin9/tmpopx7gin9.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21da126c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21d9e1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21d9e1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21d9e1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopx7gin9                        0x00005627c78015cf <unavailable> + 5583

    5    libc.so.6                          0x00002b21da312460 __libc_start_main +
    245

    6    tmpopx7gin9                        0x00005627c7801239 <unavailable> + 4665

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    return (q == q.reversed()) && (sum <= w)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.reduce(0, +) <= w else { return false }\n   \
    \ guard q.count % 2 == 0 else { return false }\n    var result = false\n    for\
    \ i in 0..<q.count/2 {\n        if q[i] == q[q.count-1-i] {\n            result\
    \ = true\n        } else {\n            result = false\n        }\n    }\n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0cbyo4vf/tmp0cbyo4vf.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af70685ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af706551b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af706551988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7065507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0cbyo4vf                        0x00005632a27ce5af <unavailable> + 5551

    5    libc.so.6                          0x00002af706a46460 __libc_start_main +
    245

    6    tmp0cbyo4vf                        0x00005632a27ce219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let maxSum = w * q.count\n  let sum = q.reduce(0, +)\n\
    \  return is_palindrome(array: q) && sum <= maxSum\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp04f2atpj.swift:20:10: error: cannot find 'is_palindrome' in scope\n\
    \  return is_palindrome(array: q) && sum <= maxSum\n         ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return isPalindrome(q) && sum(q) <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4qf9aylj.swift:18:12: error: cannot find 'isPalindrome' in scope\n\
    \    return isPalindrome(q) && sum(q) <= w\n           ^~~~~~~~~~~~\n/tmp/tmp4qf9aylj.swift:18:31:\
    \ error: cannot find 'sum' in scope\n    return isPalindrome(q) && sum(q) <= w\n\
    \                              ^~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  var left = 0\n  var right = q.count - 1\n  var isBalanced\
    \ = true\n  var sum = 0\n  while left < right {\n    if q[left] != q[right] {\n\
    \      isBalanced = false\n    }\n    sum += q[left]\n    left += 1\n    right\
    \ -= 1\n  }\n  if left == right {\n    sum += q[left]\n  }\n  return isBalanced\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let count = q.count\n \
    \   let maxWeight = w * count / 2\n    return maxWeight >= sum && isBalanced(q:\
    \ q)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8eydljv4.swift:21:32: error: cannot find 'isBalanced' in scope\n\
    \    return maxWeight >= sum && isBalanced(q: q)\n                           \
    \    ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if is_palindrome(arr: q) {\n        if sum_of_elements(arr:\
    \ q) <= w {\n            return true\n        }\n    }\n    return false\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpx8f8x538.swift:18:8: error: cannot find 'is_palindrome' in scope\n\
    \    if is_palindrome(arr: q) {\n       ^~~~~~~~~~~~~\n/tmp/tmpx8f8x538.swift:19:12:\
    \ error: cannot find 'sum_of_elements' in scope\n        if sum_of_elements(arr:\
    \ q) <= w {\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return q.elementsEqual(q.reversed())\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, { x, y in x + y })\n    return\
    \ sum <= w && q == q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    let\
    \ sum = q.reduce(0, +)\n    if sum > w {\n        return false\n    }\n    if\
    \ q.count % 2 == 0 {\n        return q.count / 2 == q.filter { $0 != q[q.count\
    \ - 1 - q.firstIndex(of: $0)!] }.count\n    } else {\n        return q.count /\
    \ 2 == q.filter { $0 != q[q.count - 1 - q.firstIndex(of: $0)!] }.count - 1\n \
    \   }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmps2z943qu/tmps2z943qu.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b15eca68c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15ec75fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15ec75f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15ec75e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmps2z943qu                        0x000055755598262f <unavailable> + 5679

    5    libc.so.6                          0x00002b15ecc54460 __libc_start_main +
    245

    6    tmps2z943qu                        0x0000557555982299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var q = q\n    var i = 0\n    var j = q.count - 1\n \
    \   let sum = q.reduce(0, +)\n    while i < j {\n        if q[i] != q[j] {\n \
    \           return false\n        }\n        i += 1\n        j -= 1\n    }\n \
    \   return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  if q.isEmpty {\n    return false\n  }\n  if w < 1 {\n \
    \   return false\n  }\n  let sum = q.reduce(0, +)\n  let palindrome = q.elementsEqual(q.reversed())\n\
    \  if sum > w {\n    return false\n  }\n  if palindrome == false {\n    return\
    \ false\n  }\n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    if q.count % 2 == 0 {\n        return false\n    }\n    let\
    \ half = q.count / 2\n    let left = q[0..<half]\n    let right = q[(half + 1)..<q.count]\n\
    \    let rightReverse = right.reversed()\n    return left == rightReverse\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmxytb75l.swift:29:20: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n    return left == rightReverse\n\
    \                   ^\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count > 1 && q.count.isOdd && q.sum <= w\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpa2wnybye.swift:18:35: error: value of type 'Int' has no member\
    \ 'isOdd'\n    return q.count > 1 && q.count.isOdd && q.sum <= w\n           \
    \               ~~~~~~~ ^~~~~\n/tmp/tmpa2wnybye.swift:18:46: error: value of type\
    \ '[Int]' has no member 'sum'\n    return q.count > 1 && q.count.isOdd && q.sum\
    \ <= w\n                                           ~ ^~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let count = q.count\n \
    \   return sum <= w && count % 2 == 0 && is_palindrome(q)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1omqqame.swift:20:42: error: cannot find 'is_palindrome' in scope\n\
    \    return sum <= w && count % 2 == 0 && is_palindrome(q)\n                 \
    \                        ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return will_it_fly(q: q, w: w, 0, 0)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpih6tpqxs.swift:18:23: error: extra arguments at positions #3, #4\
    \ in call\n    return will_it_fly(q: q, w: w, 0, 0)\n                      ^\n\
    /tmp/tmpih6tpqxs.swift:17:6: note: 'will_it_fly(q:w:)' declared here\nfunc will_it_fly(q:\
    \ [Int], w: Int) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let balance = q.reduce(0, +) <= w && q == q.reversed()\n\
    \    return balance\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, {$0 + $1})\n    if sum > w {\n\
    \        return false\n    }\n    for i in 0..<q.count {\n        if q[i] != q[q.count\
    \ - 1 - i] {\n            return false\n        }\n    }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count > 1 && q.count < w && q.count == q.reversed().count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpbkq1cxaz/tmpbkq1cxaz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52ac8b7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52ac5aeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52ac5ae988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52ac5ad7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbkq1cxaz                        0x000055d305ea657b <unavailable> + 5499

    5    libc.so.6                          0x00002b52acaa3460 __libc_start_main +
    245

    6    tmpbkq1cxaz                        0x000055d305ea6129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var q = q\n    var w = w\n    let sum = q.reduce(0, +)\n\
    \    if sum > w {\n        return false\n    }\n    if q.count == 1 {\n      \
    \  return true\n    }\n    let first = q.removeFirst()\n    let last = q.removeLast()\n\
    \    if first != last {\n        return false\n    }\n    return will_it_fly(q:\
    \ q, w: w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (w >= q.reduce(0, +)) && (q == q.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.reduce(0, +) <= w {\n        return q == q.reversed()\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    //        func inner(q: [Int], w: Int) -> Bool\
    \ {\n    //            if q.count == 1 {\n    //                return true\n\
    \    //            }\n    //            var sum = 0\n    //            for i in\
    \ q {\n    //                sum += i\n    //            }\n    //           \
    \ if sum > w {\n    //                return false\n    //            }\n    //\
    \            for i in q {\n    //                if i == q.last! {\n    //   \
    \                 return true\n    //                }\n    //               \
    \ if i != q[q.count - 1 - q.firstIndex(of: i)!] {\n    //                    return\
    \ false\n    //                }\n    //            }\n    //            return\
    \ true\n    //        }\n    //        return inner(q: q, w: w)\n    \n    func\
    \ inner(q: [Int], w: Int) -> Bool {\n        var sum = 0\n        for i in q {\n\
    \            sum += i\n        }\n        if sum > w {\n            return false\n\
    \        }\n        for i in q {\n            if i == q.last! {\n            \
    \    return true\n            }\n            if i != q[q.count - 1 - q.firstIndex(of:\
    \ i)!] {\n                return false\n            }\n        }\n        return\
    \ true\n    }\n    return inner(q: q, w: w)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return is_balanced(q: q)\
    \ && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpymd7p_38.swift:19:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && sum <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && is_palindrome(q)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo2kcv7wl.swift:18:35: error: cannot find 'is_palindrome' in scope\n\
    \    return q.reduce(0, +) <= w && is_palindrome(q)\n                        \
    \          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    guard q.reduce(0,\
    \ +) <= w else { return false }\n    guard (0..<q.count/2).allSatisfy({ q[$0]\
    \ == q[q.count-$0-1] }) else { return false }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014229
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if is_palindrome(q) {\n        return sum(q) <= w\n \
    \   }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk9yyzd80.swift:18:8: error: cannot find 'is_palindrome' in scope\n\
    \    if is_palindrome(q) {\n       ^~~~~~~~~~~~~\n/tmp/tmpk9yyzd80.swift:19:16:\
    \ error: cannot find 'sum' in scope\n        return sum(q) <= w\n            \
    \   ^~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if sum(q) <= w && isPalindrome(q) {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe84ssjy1.swift:18:8: error: cannot find 'sum' in scope\n    if\
    \ sum(q) <= w && isPalindrome(q) {\n       ^~~\n/tmp/tmpe84ssjy1.swift:18:23:\
    \ error: cannot find 'isPalindrome' in scope\n    if sum(q) <= w && isPalindrome(q)\
    \ {\n                      ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if isPalindrome(q) && sum(q) <= w {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjeeu0dr1.swift:18:8: error: cannot find 'isPalindrome' in scope\n\
    \    if isPalindrome(q) && sum(q) <= w {\n       ^~~~~~~~~~~~\n/tmp/tmpjeeu0dr1.swift:18:27:\
    \ error: cannot find 'sum' in scope\n    if isPalindrome(q) && sum(q) <= w {\n\
    \                          ^~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    let qSum\
    \ = q.reduce(0, +)\n    guard qSum <= w else { return false }\n    let ql = q.count\
    \ / 2\n    let qf = q[..<ql]\n    let qr = q[q.count-ql...]\n    return qf ==\
    \ qr.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpacykp8kh.swift:23:26: error: cannot convert value of type 'PartialRangeFrom<Int>'\
    \ to expected argument type 'Int'\n    let qr = q[q.count-ql...]\n           \
    \              ^\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum <= w {\n       \
    \ for (i, n) in q.enumerated() {\n            if n != q[q.count - i - 1] {\n \
    \               return false\n            }\n        }\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let arr = q.sorted()\n    let sum = arr.reduce(0, +)\n\
    \    return w >= sum && arr == arr.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp4qi_f2kt/tmp4qi_f2kt.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aff6e004c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aff6dcfbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aff6dcfb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aff6dcfa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4qi_f2kt                        0x000055aea0e604df <unavailable> + 5343

    5    libc.so.6                          0x00002aff6e1f0460 __libc_start_main +
    245

    6    tmp4qi_f2kt                        0x000055aea0e60149 <unavailable> + 4425

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    if q.isEmpty {\n        return false\n    }\n \
    \   \n    if q.count == 1 {\n        return true\n    }\n    \n    var arrayToCheck\
    \ = q\n    var reversedArray = [Int]()\n    \n    while arrayToCheck.count > 0\
    \ {\n        reversedArray.append(arrayToCheck.last!)\n        arrayToCheck.removeLast()\n\
    \    }\n    \n    if reversedArray == q {\n        if q.reduce(0,+) <= w {\n \
    \           return true\n        }\n    }\n    \n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    for i in 0..<q.count/2 {\n        if q[i] != q[q.count-1-i]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let total = q.reduce(0, +)\n    guard w >= total else\
    \ { return false }\n    return String(q.map { String($0) }.reduce(\"\", +)).isPalindrome\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpk8muqpdx.swift:20:55: error: value of type 'String' has no member\
    \ 'isPalindrome'\n    return String(q.map { String($0) }.reduce(\"\", +)).isPalindrome\n\
    \           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let q = q.sorted()\n    let sum = q.reduce(0, +)\n  \
    \  guard sum <= w else { return false }\n    guard q.count > 1 else { return true\
    \ }\n    guard q.count % 2 == 0 else { return false }\n    let half = q.count\
    \ / 2\n    let start = q[0..<half]\n    let end = q[half...]\n    return start\
    \ == end.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2_xypo9e.swift:26:18: error: binary operator '==' cannot be applied\
    \ to operands of type 'ArraySlice<Int>' and '[Int]'\n    return start == end.reversed()\n\
    \           ~~~~~ ^  ~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return q.count > 1 ? (q == q.reversed) && (q.reduce(0,\
    \ +) <= w) : true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp26516he1.swift:18:32: error: function produces expected type '[Int]';\
    \ did you mean to call it with '()'?\n  return q.count > 1 ? (q == q.reversed)\
    \ && (q.reduce(0, +) <= w) : true\n                             ~~^~~~~~~~\n \
    \                                      ()\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let sortedQ = q.sorted()\n\
    \    for i in 0..<q.count / 2 {\n        if q[i] != q[q.count - 1 - i] {\n   \
    \         return false\n        }\n    }\n    return sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var leftSum = 0\n    var\
    \ rightSum = 0\n    let count = q.count / 2\n    for i in 0..<count {\n      \
    \  leftSum += q[i]\n        rightSum += q[q.count - 1 - i]\n    }\n    return\
    \ leftSum == rightSum && leftSum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.reduce(0, +) <= w else { return false }\n   \
    \ guard q.count % 2 == 0 else { return true }\n    for i in 0...q.count/2 {\n\
    \        if q[i] != q[q.count-1-i] {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpwg7w3d5m/tmpwg7w3d5m.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2ebcea4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2ebcb9bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2ebcb9b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2ebcb9a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwg7w3d5m                        0x0000556c661c48e1 <unavailable> + 6369

    5    libc.so.6                          0x00002b2ebd090460 __libc_start_main +
    245

    6    tmpwg7w3d5m                        0x0000556c661c4219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660014225
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if is_balanced(q: q) && q.reduce(0, +) <= w {\n     \
    \   return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpy1yhmycs.swift:18:8: error: cannot find 'is_balanced' in scope\n\
    \    if is_balanced(q: q) && q.reduce(0, +) <= w {\n       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var total: Int = 0\n    var left: Int = 0\n    var right:\
    \ Int = q.count - 1\n    while (left < right) {\n        total += q[left] + q[right]\n\
    \        if total > w {\n            return false\n        }\n        left +=\
    \ 1\n        right -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpmmv7l9y3/tmpmmv7l9y3.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7d80c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7d7dbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7d7dbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7d7dbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmmv7l9y3                        0x000056113584946b <unavailable> + 5227

    5    libc.so.6                          0x00002ad7d82b2460 __libc_start_main +
    245

    6    tmpmmv7l9y3                        0x0000561135849019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count >= 1 else { return false }\n    let new_q\
    \ = q.sorted()\n    let sum = new_q.reduce(0, +)\n    guard sum <= w else { return\
    \ false }\n    guard q.count > 1 else { return true }\n    let mid = new_q.count\
    \ / 2\n    let left = new_q[0..<mid]\n    let right = new_q[mid..<new_q.count]\n\
    \    guard left == right.reversed() else { return false }\n    return true\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpd6auteb2.swift:26:16: error: binary operator '==' cannot be applied\
    \ to operands of type 'ArraySlice<Int>' and '[Int]'\n    guard left == right.reversed()\
    \ else { return false }\n          ~~~~ ^  ~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var s = 0\n    var e = q.count - 1\n    while e > s {\n\
    \        if q[s] != q[e] {\n            return false\n        }\n        s +=\
    \ 1\n        e -= 1\n    }\n    let sum = q.reduce(0, +)\n    return sum <= w\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  guard q.count % 2 == 0 else { return false }\n  var q1\
    \ = q\n  var q2 = [Int]()\n  for _ in 0..<q.count/2 {\n    q2.append(q1.removeLast())\n\
    \  }\n  guard q1 == q2 else { return false }\n  guard q.reduce(0, +) <= w else\
    \ { return false }\n  return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpum32uqfl/tmpum32uqfl.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae8a4555c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae8a424cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae8a424c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae8a424b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpum32uqfl                        0x0000555fa886274f <unavailable> + 5967

    5    libc.so.6                          0x00002ae8a4741460 __libc_start_main +
    245

    6    tmpum32uqfl                        0x0000555fa88623b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let isPalindrome = q.map{$0} == q.reversed()\n  let sum\
    \ = q.reduce(0, +)\n  return sum <= w && isPalindrome\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    guard sum <= w else { return\
    \ false }\n    return q == q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var dict = [Int:Int]()\n    var sum = 0\n    for i in\
    \ q {\n        sum += i\n        if dict[i] == nil {\n            dict[i] = 1\n\
    \        } else {\n            dict[i]! += 1\n        }\n    }\n    if dict.values.contains(1)\
    \ && dict.values.contains(2) && sum <= w {\n        return true\n    } else if\
    \ dict.values.contains(1) && sum <= w {\n        return true\n    } else if dict.values.contains(1)\
    \ && dict.values.contains(2) && sum > w {\n        return false\n    } else if\
    \ dict.values.contains(1) && sum > w {\n        return false\n    } else if dict.values.contains(1)\
    \ && dict.values.contains(2) && sum <= w {\n        return true\n    } else if\
    \ dict.values.contains(1) && sum <= w {\n        return true\n    } else if dict.values.contains(1)\
    \ && dict.values.contains(2) && sum > w {\n        return false\n    } else if\
    \ dict.values.contains(1) && sum > w {\n        return false\n    } else if sum\
    \ <= w {\n        return true\n    } else {\n        return false\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp8f2hkupp/tmp8f2hkupp.swift:65: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b735cd36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b735ca2db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b735ca2d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b735ca2c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8f2hkupp                        0x000055f03781088b <unavailable> + 6283

    5    libc.so.6                          0x00002b735cf22460 __libc_start_main +
    245

    6    tmp8f2hkupp                        0x000055f037810439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum_of_q = 0\n    var is_palidrome = true\n    var\
    \ i = 0\n    while i < q.count / 2 {\n        sum_of_q += q[i]\n        if q[i]\
    \ != q[q.count - 1 - i] {\n            is_palidrome = false\n        }\n     \
    \   i += 1\n    }\n    return is_palidrome && sum_of_q <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    var summ\
    \ = 0\n    for i in q {\n        summ += i\n    }\n    let isPalindrome = q ==\
    \ q.reversed()\n    let summLessThanW = summ <= w\n    return isPalindrome &&\
    \ summLessThanW\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var balanced = false\n    var weight = q.reduce(0, +)\n\
    \    if q.count > 1 {\n        balanced = true\n        for (i, j) in zip(q, q.reversed())\
    \ {\n            if i != j {\n                balanced = false\n             \
    \   break\n            }\n        }\n    }\n    if balanced && weight <= w {\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp53v66paj/tmp53v66paj.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2aeeda5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2aeea9cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2aeea9c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2aeea9b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp53v66paj                        0x000055d9a0d8065d <unavailable> + 5725

    5    libc.so.6                          0x00002b2aeef91460 __libc_start_main +
    245

    6    tmp53v66paj                        0x000055d9a0d80159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count == 1 || (w >= q.reduce(0, +) && q == q.reversed())\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isBalanced = q.isBalanced\n\
    \    return isBalanced && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpidfokm6l.swift:19:24: error: value of type '[Int]' has no member\
    \ 'isBalanced'\n    let isBalanced = q.isBalanced\n                     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014225
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    var q = q\n\
    \    var l: Int\n    var r: Int\n    var s: Int\n    if q.count % 2 == 0 {\n \
    \       l = q.count / 2 - 1\n        r = q.count / 2\n        s = q[l] + q[r]\n\
    \        q.remove(at: l)\n        q.remove(at: r - 1)\n    } else {\n        l\
    \ = q.count / 2 - 1\n        r = q.count / 2 + 1\n        s = q[q.count / 2]\n\
    \        q.remove(at: q.count / 2)\n    }\n    while l >= 0 && r < q.count {\n\
    \        if q[l] != q[r] {\n            return false\n        }\n        s +=\
    \ q[l] + q[r]\n        q.remove(at: l)\n        q.remove(at: r - 1)\n        l\
    \ -= 1\n        r += 1\n    }\n    return s <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpmd59ntpa/tmpmd59ntpa.swift:62: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afdb7a2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afdb7723b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afdb7723988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afdb77227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmd59ntpa                        0x000055be8b5fe55b <unavailable> + 5467

    5    libc.so.6                          0x00002afdb7c18460 __libc_start_main +
    245

    6    tmpmd59ntpa                        0x000055be8b5fe109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    if q.reduce(0, +) > w {\n \
    \       return false\n    }\n    var sum = 0\n    var arr = [Int]()\n    for num\
    \ in q {\n        sum += num\n        arr.append(num)\n    }\n    for (i, _) in\
    \ arr.enumerated() {\n        if sum - arr[i] <= w {\n            return true\n\
    \        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpiuu_bmkn/tmpiuu_bmkn.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d84e9cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d84b93b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d84b93988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d84b927b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiuu_bmkn                        0x0000563a19a9fb81 <unavailable> + 7041

    5    libc.so.6                          0x00002b8d85088460 __libc_start_main +
    245

    6    tmpiuu_bmkn                        0x0000563a19a9f4b9 <unavailable> + 5305

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  if q.isEmpty {\n    return false\n  }\n  if q.count ==\
    \ 1 {\n    return q[0] <= w\n  }\n  var left = 0\n  var right = q.count - 1\n\
    \  while left < right {\n    if q[left] != q[right] {\n      return false\n  \
    \  }\n    left += 1\n    right -= 1\n  }\n  return q.reduce(0, +) <= w\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let isEqual = q.enumerated().allSatisfy\
    \ { $0.element == q[q.count - $0.offset - 1] }\n    return isEqual && sum <= w\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return sum(q) <= w && q == q.reversed()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpcxfh6r1d.swift:18:10: error: cannot find 'sum' in scope\n  return\
    \ sum(q) <= w && q == q.reversed()\n         ^~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let max = w - q.count\n    let s = q.reduce(0, +)\n \
    \   guard s <= max else {\n        return false\n    }\n    let p = q.count %\
    \ 2 == 0\n    let p1 = p ? q.count / 2 : q.count / 2 + 1\n    let p2 = p ? q.count\
    \ / 2 : q.count / 2\n    return p ? q[0..<p1] == q[p2...].reversed() : q[0..<p1]\
    \ == q[p2+1...].reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpqispj_6a.swift:26:38: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n    return p ? q[0..<p1] == q[p2...].reversed()\
    \ : q[0..<p1] == q[p2+1...].reversed()\n                                     ^\n\
    /tmp/tmpqispj_6a.swift:26:70: error: cannot convert value of type 'PartialRangeFrom<Int>'\
    \ to expected argument type 'Int'\n    return p ? q[0..<p1] == q[p2...].reversed()\
    \ : q[0..<p1] == q[p2+1...].reversed()\n                                     \
    \                                ^\n/tmp/tmpqispj_6a.swift:26:75: error: value\
    \ of type 'Int' has no member 'reversed'\n    return p ? q[0..<p1] == q[p2...].reversed()\
    \ : q[0..<p1] == q[p2+1...].reversed()\n                                     \
    \                          ~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let sum = q.reduce(0, +)\n  let isBalanced = q.elementsEqual(q.reversed())\n\
    \  return sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return sum(q) <= w && is_palindrome(q)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpunrywzcv.swift:18:12: error: cannot find 'sum' in scope\n    return\
    \ sum(q) <= w && is_palindrome(q)\n           ^~~\n/tmp/tmpunrywzcv.swift:18:27:\
    \ error: cannot find 'is_palindrome' in scope\n    return sum(q) <= w && is_palindrome(q)\n\
    \                          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    if q.count == 1 {\n        return true\n    }\n\
    \    \n    var sum = 0\n    for item in q {\n        sum += item\n    }\n    \n\
    \    guard sum <= w else {\n        return false\n    }\n    \n    var leftIndex\
    \ = 0\n    var rightIndex = q.count - 1\n    \n    while leftIndex < rightIndex\
    \ {\n        if q[leftIndex] != q[rightIndex] {\n            return false\n  \
    \      }\n        leftIndex += 1\n        rightIndex -= 1\n    }\n    \n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if !isPalindrome(q) ||\
    \ sum > w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpra2_z_c5.swift:19:9: error: cannot find 'isPalindrome' in scope\n\
    \    if !isPalindrome(q) || sum > w {\n        ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(arr: q) && is_sum_of_elements_less_than_or_equal_w(arr:\
    \ q, w: w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmprc6dcfsr.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(arr: q) && is_sum_of_elements_less_than_or_equal_w(arr:\
    \ q, w: w)\n           ^~~~~~~~~~~\n/tmp/tmprc6dcfsr.swift:18:35: error: cannot\
    \ find 'is_sum_of_elements_less_than_or_equal_w' in scope\n    return is_balanced(arr:\
    \ q) && is_sum_of_elements_less_than_or_equal_w(arr: q, w: w)\n              \
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return isBalanced(list: q) && q.reduce(0, +) <= w\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpe9yxb5xh.swift:18:12: error: cannot find 'isBalanced' in scope\n\
    \    return isBalanced(list: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return false\n    }\n    if q.count % 2 == 0 {\n   \
    \     return false\n    }\n    let middleNumber = q.count / 2\n    let sideLength\
    \ = middleNumber\n    var reversedq = q\n    reversedq.reverse()\n    let leftSide\
    \ = Array(q[0..<sideLength])\n    let rightSide = Array(reversedq[0..<sideLength])\n\
    \    if leftSide == rightSide {\n        var wt = 0\n        for number in q {\n\
    \            wt += number\n        }\n        if wt > w {\n            return\
    \ false\n        } else {\n            return true\n        }\n    } else {\n\
    \        return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.count % 2 == 0 ? false : check(arr: q, max:\
    \ w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0d3r66y0.swift:18:39: error: cannot find 'check' in scope\n   \
    \ return q.count % 2 == 0 ? false : check(arr: q, max: w)\n                  \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var newQ = q\n    newQ.removeFirst()\n    return newQ.count\
    \ < 1 || (newQ.count % 2 == 0 && newQ.count == q.count)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpq9k4jeu7/tmpq9k4jeu7.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbc005cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbbfd53b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbbfd53988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbbfd527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpq9k4jeu7                        0x000055b720de648f <unavailable> + 5263

    5    libc.so.6                          0x00002afbc0248460 __libc_start_main +
    245

    6    tmpq9k4jeu7                        0x000055b720de60f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return true\n    }\n    let\
    \ sum = q.reduce(0, +)\n    return is_palin(q: q) && sum <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpv09taofr.swift:22:12: error: cannot find 'is_palin' in scope\n\
    \    return is_palin(q: q) && sum <= w\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if !is_array_balanced(array: q) {\n        return false\n\
    \    }\n    let sum: Int = sum_array(array: q)\n    if sum > w {\n        return\
    \ false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1f7pazj4.swift:18:9: error: cannot find 'is_array_balanced' in\
    \ scope\n    if !is_array_balanced(array: q) {\n        ^~~~~~~~~~~~~~~~~\n/tmp/tmp1f7pazj4.swift:21:20:\
    \ error: cannot find 'sum_array' in scope\n    let sum: Int = sum_array(array:\
    \ q)\n                   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count % 2 == 0 else { return false }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmplp9nbm7s/tmplp9nbm7s.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0800ea2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0800b99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0800b99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0800b987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplp9nbm7s                        0x0000558d1843d3ef <unavailable> + 5103

    5    libc.so.6                          0x00002b080108e460 __libc_start_main +
    245

    6    tmplp9nbm7s                        0x0000558d1843d059 <unavailable> + 4185

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count % 2 == 0 {\n        let half: [Int] = Array(q[0..<q.count/2])\n\
    \        let reversedHalf: [Int] = Array(q[q.count/2..<q.count].reversed())\n\
    \        let sum = half.reduce(0, +) + reversedHalf.reduce(0, +)\n        if w\
    \ >= sum && half == reversedHalf {\n            return true\n        }\n    }\
    \ else {\n        let half: [Int] = Array(q[0..<q.count/2])\n        let reversedHalf:\
    \ [Int] = Array(q[q.count/2 + 1..<q.count].reversed())\n        let sum = half.reduce(0,\
    \ +) + reversedHalf.reduce(0, +)\n        if w >= sum && half == reversedHalf\
    \ {\n            return true\n        }\n    }\n    return false\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if (q.count == 1) {\n        return true\n    }\n   \
    \ if (q.count == 2) {\n        return false\n    }\n    if (w <= 0) {\n      \
    \  return false\n    }\n    if (!isBalanced(q: q)) {\n        return false\n \
    \   }\n    if (sumOfElements(a: q) > w) {\n        return false\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpn3hbwhyc.swift:27:10: error: cannot find 'isBalanced' in scope\n\
    \    if (!isBalanced(q: q)) {\n         ^~~~~~~~~~\n/tmp/tmpn3hbwhyc.swift:30:9:\
    \ error: cannot find 'sumOfElements' in scope\n    if (sumOfElements(a: q) > w)\
    \ {\n        ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.reduce(0, +) <= w {\n        if q.count > 1 {\n\
    \            if q.first == q.last {\n                let array = q.dropFirst().dropLast()\n\
    \                if q.count > 2 {\n                    return will_it_fly(q: Array(array),\
    \ w: w)\n                } else {\n                    return true\n         \
    \       }\n            } else {\n                return false\n            }\n\
    \        } else {\n            return true\n        }\n    } else {\n        return\
    \ false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var palindrome = true\n    var weight = 0\n    let half\
    \ = q.count / 2\n    for i in 0..<half {\n        if q[i] != q[q.count - i - 1]\
    \ {\n            palindrome = false\n        }\n        weight += q[i]\n    }\n\
    \    if q.count % 2 == 1 {\n        weight += q[half]\n    }\n    return weight\
    \ <= w && palindrome\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    // \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0430\
    \ \u043D\u0430 \u0431\u0430\u043B\u0430\u043D\u0441 \u043C\u0430\u0441\u0441\u0438\
    \u0432\u0430\n    var isBalanced = false\n    for i in 0..<q.count/2{\n      \
    \  if q[i] == q[q.count - i - 1]{\n            isBalanced = true\n        } else\
    \ {\n            isBalanced = false\n            break\n        }\n    }\n   \
    \ \n    // \u043F\u0440\u043E\u0432\u0435\u0440\u043A\u0430 \u043D\u0430 \u0441\
    \u0443\u043C\u043C\u0443 \u0432\u0435\u0441\u0430\n    var sum = 0\n    for i\
    \ in 0..<q.count{\n        sum += q[i]\n    }\n    \n    if sum <= w && isBalanced{\n\
    \        return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmppjbqs_6y/tmppjbqs_6y.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af15f317c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af15f00eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af15f00e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af15f00d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppjbqs_6y                        0x0000557de80fa6ad <unavailable> + 5805

    5    libc.so.6                          0x00002af15f503460 __libc_start_main +
    245

    6    tmppjbqs_6y                        0x0000557de80fa1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if !q.isPalindrome() {\n        return false\n    }\n\
    \    let sum = q.reduce(0, +)\n    return sum <= w\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph1jzj367.swift:18:11: error: value of type '[Int]' has no member\
    \ 'isPalindrome'\n    if !q.isPalindrome() {\n        ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    var bal = true\n    for i in 0..<q.count/2\
    \ {\n        if q[i] != q[q.count-1-i] {\n            bal = false\n        }\n\
    \        sum += q[i]\n    }\n    if q.count % 2 == 1 {\n        sum += q[q.count/2]\n\
    \    }\n    return bal && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (q.count == 1) || (w - q.reduce(0, +) >= 0 &&\
    \ q == q.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(q: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpl9313l_n.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(q: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014088
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return !q.isEmpty && q.reduce(0, +) <= w && Array(q.prefix(q.count\
    \ / 2)) == Array(q.suffix(q.count / 2).reversed())\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    guard sum <= w else { return\
    \ false }\n    guard q.count > 1 else { return true }\n    for i in 0..<q.count\
    \ / 2 {\n        guard q[i] == q[q.count - i - 1] else { return false }\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let qsum = q.reduce(0, +)\n    return q.count <= w &&\
    \ w <= qsum && is_balanced(q: q)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8o6zja3g.swift:19:41: error: cannot find 'is_balanced' in scope\n\
    \    return q.count <= w && w <= qsum && is_balanced(q: q)\n                 \
    \                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let totalWeight = q.reduce(0, { $0 + $1 })\n    if totalWeight\
    \ > w {\n        return false\n    }\n    let reverseQ = q.reversed()\n    for\
    \ i in 0 ..< q.count {\n        if q[i] != reverseQ[i] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpfrgvhs2e.swift:24:29: error: cannot convert value of type 'Int'\
    \ to expected argument type 'ReversedCollection<[Int]>.Index'\n        if q[i]\
    \ != reverseQ[i] {\n                            ^\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (q.count > 0) && (q.reduce(0, +) <= w) && (q ==\
    \ q.reversed())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (q.count > 1 && q.count%2 == 0 && q.reversed()\
    \ == q) && q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpisigweva/tmpisigweva.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae17d564c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae17d25bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae17d25b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae17d25a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpisigweva                        0x00005629d61bd52f <unavailable> + 5423

    5    libc.so.6                          0x00002ae17d750460 __libc_start_main +
    245

    6    tmpisigweva                        0x00005629d61bd199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  guard !q.isEmpty else { return false }\n  return is_palindrome(n:\
    \ q) && q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmppq53kr1f.swift:19:10: error: cannot find 'is_palindrome' in scope\n\
    \  return is_palindrome(n: q) && q.reduce(0, +) <= w\n         ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard w >= 0 else { return false }\n    guard q.count\
    \ != 0 else { return true }\n    let sum = q.reduce(0, +)\n    if sum <= w {\n\
    \        let a = q.count % 2 == 0 ? (q.count / 2) - 1 : q.count / 2\n        let\
    \ b = q.count % 2 == 0 ? (q.count / 2) : q.count / 2\n        let part1 = Array(q[0..<a])\n\
    \        let part2 = Array(q[b...])\n        return part1 == part2.reversed()\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpfdtuahwt/tmpfdtuahwt.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2294f8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2294c83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2294c83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2294c827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfdtuahwt                        0x000055686c1897df <unavailable> + 6111

    5    libc.so.6                          0x00002b2295178460 __libc_start_main +
    245

    6    tmpfdtuahwt                        0x000055686c189449 <unavailable> + 5193

    '
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    guard q.sum()\
    \ <= w else { return false }\n    guard q.count % 2 == 0 else { return false }\n\
    \    var first = 0\n    var last = q.count - 1\n    while first < last {\n   \
    \     if q[first] != q[last] {\n            return false\n        }\n        first\
    \ += 1\n        last -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4047g0hx.swift:19:13: error: value of type '[Int]' has no member\
    \ 'sum'\n    guard q.sum() <= w else { return false }\n          ~ ^~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (q.count == 1) || (is_palindrome(q) && (q.reduce(0,\
    \ +) <= w))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2,\
    \ 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwga1lhiw.swift:18:31: error: cannot find 'is_palindrome' in scope\n\
    \    return (q.count == 1) || (is_palindrome(q) && (q.reduce(0, +) <= w))\n  \
    \                            ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && is_balanced(q: q)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpo9nftrwo.swift:18:35: error: cannot find 'is_balanced' in scope\n\
    \    return q.reduce(0, +) <= w && is_balanced(q: q)\n                       \
    \           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let s = q.reduce(0, +)\n    if w < s {\n        return\
    \ false\n    }\n    var l = 0\n    var r = q.count - 1\n    while l < r {\n  \
    \      if q[l] != q[r] {\n            return false\n        }\n        l += 1\n\
    \        r -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if w < 0 {\n        return false\n    }\n    if q.count\
    \ % 2 == 0 {\n        if (q[0] + q[q.count - 1]) > w {\n            return false\n\
    \        }\n    }\n    if q.count == 1 {\n        return true\n    }\n    if q.count\
    \ == 2 {\n        if q[0] != q[1] {\n            return false\n        }\n   \
    \ }\n    if q[0] != q[q.count - 1] {\n        return false\n    }\n    if q.count\
    \ == 2 {\n        return true\n    }\n    return will_it_fly(q: Array(q[1..<q.count\
    \ - 1]), w: w - q[0])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && isPalindrome(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyb3a51ra.swift:19:24: error: cannot find 'isPalindrome' in scope\n\
    \    return sum <= w && isPalindrome(q)\n                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    var sum =\
    \ 0\n    for i in 0..<q.count/2 {\n        sum += q[i] + q[q.count-1-i]\n    \
    \    if sum > w { return false }\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp_guewo2r/tmp_guewo2r.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b294b85cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b294b553b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b294b553988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b294b5527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_guewo2r                        0x00005582a907e5fb <unavailable> + 5627

    5    libc.so.6                          0x00002b294ba48460 __libc_start_main +
    245

    6    tmp_guewo2r                        0x00005582a907e1a9 <unavailable> + 4521

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var balanced = true\n    var sum = 0\n    for qq in q\
    \ {\n        if balanced {\n            sum += qq\n            if (q.count - 1)\
    \ / 2 < q.firstIndex(of: qq) ?? 0 {\n                balanced = q[q.count - 1\
    \ - (q.firstIndex(of: qq) ?? 0)] == qq\n            }\n        }\n    }\n    return\
    \ balanced && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let isBalanced = q.count % 2 == 0 ? q[0..<q.count/2]\
    \ == q[q.count/2..<q.count].reversed() : q[0..<q.count/2] == q[q.count/2+1..<q.count].reversed()\n\
    \    let sumOfElements = q.reduce(0,+)\n    return sumOfElements <= w && isBalanced\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwqznsvve.swift:18:84: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n    let isBalanced = q.count %\
    \ 2 == 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n                                   \
    \                                                ^\n/tmp/tmpwqznsvve.swift:18:142:\
    \ error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>' to\
    \ expected argument type 'ArraySlice<Int>'\n    let isBalanced = q.count % 2 ==\
    \ 0 ? q[0..<q.count/2] == q[q.count/2..<q.count].reversed() : q[0..<q.count/2]\
    \ == q[q.count/2+1..<q.count].reversed()\n                                   \
    \                                                                            \
    \                              ^\n"
  stdout: ''
  timestamp: 1660014233
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum <= w {\n       \
    \ return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmphmxk_6dm/tmphmxk_6dm.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e2afe0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e2acd7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e2acd7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e2acd67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphmxk_6dm                        0x0000555b511be43b <unavailable> + 5179

    5    libc.so.6                          0x00002b6e2b1cc460 __libc_start_main +
    245

    6    tmphmxk_6dm                        0x0000555b511bdfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    guard let\
    \ maxWeight = q.max() else { return false }\n    return q.sum() <= w && maxWeight\
    \ * 2 <= w && q == q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp7jvj6qtc.swift:20:14: error: value of type '[Int]' has no member\
    \ 'sum'\n    return q.sum() <= w && maxWeight * 2 <= w && q == q.reversed()\n\
    \           ~ ^~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    let\
    \ sum = q.reduce(0, +)\n    if sum <= w {\n        for index in 0..<q.count/2\
    \ {\n            if q[index] != q[q.count - index - 1] {\n                return\
    \ false\n            }\n        }\n        return true\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count > 1 {\n        let q1 = Array(q[0..<q.count/2])\n        let q2 = Array(q[q.count/2..<q.count])\n\
    \        var sum = 0\n        for i in q {\n            sum += i\n        }\n\
    \        if w >= sum && q1 == q2.reversed() {\n            return true\n     \
    \   }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpkvqawj0q/tmpkvqawj0q.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af11dfc1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af11dcb8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af11dcb8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af11dcb77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkvqawj0q                        0x000055e660f0877f <unavailable> + 6015

    5    libc.so.6                          0x00002af11e1ad460 __libc_start_main +
    245

    6    tmpkvqawj0q                        0x000055e660f083e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    var\
    \ sum = 0\n    for i in 0...q.count/2 {\n        if q[i] != q[q.count-1-i] {\n\
    \            return false\n        }\n        sum += q[i]\n    }\n    return sum\
    \ <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var result = false\n    let sum = q.reduce(0, +)\n  \
    \  if sum <= w && sum != 0 {\n        result = true\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpxqlrczk3/tmpxqlrczk3.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af0b4275c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af0b3f6cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af0b3f6c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af0b3f6b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxqlrczk3                        0x0000558872f0b43b <unavailable> + 5179

    5    libc.so.6                          0x00002af0b4461460 __libc_start_main +
    245

    6    tmpxqlrczk3                        0x0000558872f0afe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    let\
    \ a = q.sorted(by: <)\n    let sum = a.reduce(0, +)\n    if sum > w {\n      \
    \  return false\n    }\n    if a == a.reversed() {\n        return true\n    }\n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmprzrtje1a/tmprzrtje1a.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1d3815ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1d37e51b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1d37e51988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1d37e507b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprzrtje1a                        0x0000564a59cf24ff <unavailable> + 5375

    5    libc.so.6                          0x00002b1d38346460 __libc_start_main +
    245

    6    tmprzrtje1a                        0x0000564a59cf2169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else {\n        return true\n    }\n\
    \    var left = 0\n    var right = q.count - 1\n    while left < right {\n   \
    \     if q[left] != q[right] {\n            return false\n        }\n        left\
    \ += 1\n        right -= 1\n    }\n    return true && q.reduce(0, +) <= w\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if is_array_balanced(array: q) && array_sum(array: q)\
    \ <= w {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp0_u84zh4.swift:18:8: error: cannot find 'is_array_balanced' in\
    \ scope\n    if is_array_balanced(array: q) && array_sum(array: q) <= w {\n  \
    \     ^~~~~~~~~~~~~~~~~\n/tmp/tmp0_u84zh4.swift:18:39: error: cannot find 'array_sum'\
    \ in scope\n    if is_array_balanced(array: q) && array_sum(array: q) <= w {\n\
    \                                      ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let qSum = q.reduce(0, +)\n    return qSum <= w && palindrome(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdx78cd37.swift:19:25: error: cannot find 'palindrome' in scope\n\
    \    return qSum <= w && palindrome(q)\n                        ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var s = 0\n    for i in q {\n        s += i\n    }\n\
    \    if s > w {\n        return false\n    }\n    var q = q\n    for i in 0..<q.count\
    \ / 2 {\n        if q[i] != q[q.count - i - 1] {\n            return false\n \
    \       }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if w >= sum && is_palindrome(q: q) {\n        return true\n    }\n  \
    \  return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjrw7ktji.swift:22:20: error: cannot find 'is_palindrome' in scope\n\
    \    if w >= sum && is_palindrome(q: q) {\n                   ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    guard q.reduce(0,\
    \ +) <= w else { return false }\n    return is_palindrome(array: q)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpjh4gsiaf.swift:20:12: error: cannot find 'is_palindrome' in scope\n\
    \    return is_palindrome(array: q)\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var p = 0\n    for i in 0..<q.count {\n        p += q[i]\n\
    \    }\n    if p <= w {\n        for i in 0..<q.count {\n            if q[i] !=\
    \ q[q.count - i - 1] {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(list: q) && q.reduce(0, +) <= w\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp343d4wps.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(list: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    var arr2 = [Int]()\n  \
    \  for i in 0..<q.count {\n        if i == q.count/2 {\n            continue\n\
    \        }\n        arr2.append(q[i])\n    }\n    var arr1 = arr2.reverse()\n\
    \    for i in 0..<arr1.count {\n        if arr1[i] != arr2[i] {\n            return\
    \ false\n        }\n    }\n    if arr1.reduce(0, combine: +) <= w {\n        return\
    \ true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmk4w1zeg.swift:31:9: warning: variable 'arr1' inferred to have\
    \ type '()', which may be unexpected\n    var arr1 = arr2.reverse()\n        ^\n\
    /tmp/tmpmk4w1zeg.swift:31:9: note: add an explicit type annotation to silence\
    \ this warning\n    var arr1 = arr2.reverse()\n        ^\n            : ()\n/tmp/tmpmk4w1zeg.swift:32:23:\
    \ error: value of tuple type '()' has no member 'count'\n    for i in 0..<arr1.count\
    \ {\n                 ~~~~ ^~~~~\n/tmp/tmpmk4w1zeg.swift:37:13: error: value of\
    \ tuple type '()' has no member 'reduce'\n    if arr1.reduce(0, combine: +) <=\
    \ w {\n       ~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    guard q.count\
    \ % 2 == 0 else { return false }\n    let half = q.count / 2\n    let front =\
    \ q[0..<half]\n    let back = q[half..<q.count]\n    return front == back.reversed()\
    \ && front.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpdigyjwva.swift:23:26: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n    return front == back.reversed()\
    \ && front.reduce(0, +) <= w\n                         ^\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 2 {\n        return true\n    }\n    if\
    \ q.count % 2 == 0 {\n        return false\n    }\n    let first = q.count / 2\n\
    \    let second = q.count / 2 + 1\n    if Array(q[0..<first]) == Array(q[second..<q.count].reversed())\
    \ {\n        let sum = q.reduce(0, +)\n        if sum <= w {\n            return\
    \ true\n        }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let sum = q.reduce(0, +)\n  return sum <= w && is_palindrome(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyqrlul31.swift:19:22: error: cannot find 'is_palindrome' in scope\n\
    \  return sum <= w && is_palindrome(q)\n                     ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  return isBalanced(q: q) && sum(q: q) <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1lj_j2ag.swift:18:10: error: cannot find 'isBalanced' in scope\n\
    \  return isBalanced(q: q) && sum(q: q) <= w\n         ^~~~~~~~~~\n/tmp/tmp1lj_j2ag.swift:18:30:\
    \ error: cannot find 'sum' in scope\n  return isBalanced(q: q) && sum(q: q) <=\
    \ w\n                             ^~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (q.reduce(0, +) <= w) && q == q.reversed()\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && q ==\
    \ q.reversed()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let arrayIsBalanced = isBalanced(array: q)\n    let arrayWeight\
    \ = q.reduce(0, +)\n    return arrayIsBalanced && arrayWeight <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpml8o76xj.swift:18:27: error: cannot find 'isBalanced' in scope\n\
    \    let arrayIsBalanced = isBalanced(array: q)\n                          ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    let len = q.count\n    for i in 0..<len\
    \ {\n        sum += q[i]\n        if sum > w {\n            return false\n   \
    \     }\n    }\n    return sum <= w && isPalindrome(q)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4r8hio5q.swift:26:24: error: cannot find 'isPalindrome' in scope\n\
    \    return sum <= w && isPalindrome(q)\n                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let sum = q.reduce(0, +)\n  return sum <= w && q == q.reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return is_balanced(n: q) && q.reduce(0, +) <= w\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp47pvy_21.swift:18:12: error: cannot find 'is_balanced' in scope\n\
    \    return is_balanced(n: q) && q.reduce(0, +) <= w\n           ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard !q.isEmpty else { return false }\n    let sum =\
    \ q.reduce(0, +)\n    if sum > w { return false }\n    for index in 0..<q.count\
    \ / 2 {\n        if q[index] != q[q.count - index - 1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var result = false\n    let sum = q.reduce(0, +)\n  \
    \  result = sum <= w\n    result = result && isPalindrome(q)\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1nyjgd9_.swift:21:24: error: cannot find 'isPalindrome' in scope\n\
    \    result = result && isPalindrome(q)\n                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    var newArr = [Int]()\n\
    \    for i in q {\n        newArr.append(i)\n    }\n    var startIndex = 0\n \
    \   var endIndex = newArr.count - 1\n    while startIndex < endIndex {\n     \
    \   if newArr[startIndex] != newArr[endIndex] {\n            return false\n  \
    \      }\n        startIndex += 1\n        endIndex -= 1\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let is_balanced = q.count % 2 == 0\n    let sum = q.reduce(0,\
    \ +)\n    return is_balanced && sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpjpxc5dbw/tmpjpxc5dbw.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0be1a91c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0be1788b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0be1788988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0be17877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjpxc5dbw                        0x00005572edb5846f <unavailable> + 5231

    5    libc.so.6                          0x00002b0be1c7d460 __libc_start_main +
    245

    6    tmpjpxc5dbw                        0x00005572edb580d9 <unavailable> + 4313

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum > w {\n        return\
    \ false\n    }\n    let rq = q.reversed()\n    return q == rq\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpg19rvjs3.swift:23:17: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return q == rq\n                ^\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (is_balance(q: q) && q.reduce(0, +) <= w)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmphtelt0i8.swift:18:13: error: cannot find 'is_balance' in scope\n\
    \    return (is_balance(q: q) && q.reduce(0, +) <= w)\n            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var q = q\n    let sum = q.reduce(0, +)\n    if sum >\
    \ w {\n        return false\n    }\n    if q.count == 1 {\n        return true\n\
    \    }\n    if q.isPalindrome() {\n        return true\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpadpvsd07.swift:26:10: error: value of type '[Int]' has no member\
    \ 'isPalindrome'\n    if q.isPalindrome() {\n       ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let result = q.reduce(0, +)\n  return is_palindrome(q:\
    \ q) && result <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmph7uyvh38.swift:19:10: error: cannot find 'is_palindrome' in scope\n\
    \  return is_palindrome(q: q) && result <= w\n         ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    let sum =\
    \ q.reduce(0, +)\n    guard sum <= w else { return false }\n    guard q.count\
    \ % 2 == 0 else { return false }\n    let a = q.count / 2\n    let b = a - 1\n\
    \    var s = 0\n    var e = q.count - 1\n    while s < a {\n        guard q[s]\
    \ == q[e] else { return false }\n        s += 1\n        e -= 1\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp5c0k64xv/tmp5c0k64xv.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2484495c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b248418cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b248418c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b248418b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5c0k64xv                        0x0000561b0bed14bf <unavailable> + 5311

    5    libc.so.6                          0x00002b2484681460 __libc_start_main +
    245

    6    tmp5c0k64xv                        0x0000561b0bed1129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var isBalanced = true\n    var sum = 0\n    for number\
    \ in q {\n        sum += number\n    }\n    for i in 0...q.count - 1 {\n     \
    \   if q[i] != q[q.count - 1 - i] {\n            isBalanced = false\n        }\n\
    \    }\n    if sum <= w && isBalanced {\n        return true\n    } else {\n \
    \       return false\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var balanced = true\n    var counter = 0\n    while counter\
    \ < q.count {\n        let item = q[counter]\n        let sum = q.reduce(0, +)\n\
    \        if sum <= w {\n            if q[counter] != q[q.count - counter - 1]\
    \ {\n                balanced = false\n            }\n        }\n        counter\
    \ += 1\n    }\n    return balanced\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptnicre__/tmptnicre__.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b45a32f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b45a2fe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b45a2fe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b45a2fe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptnicre__                        0x0000559b89a3c67f <unavailable> + 5759

    5    libc.so.6                          0x00002b45a34de460 __libc_start_main +
    245

    6    tmptnicre__                        0x0000559b89a3c099 <unavailable> + 4249

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return w >= q.reduce(0, +) && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard !q.isEmpty else { return false }\n    let total\
    \ = q.reduce(0, +)\n    if total > w { return false }\n    let count = q.count\n\
    \    for i in 0..<count/2 {\n        if q[i] != q[count-i-1] { return false }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return !q.isEmpty && (q.count == 1 || q.count % 2 ==\
    \ 0) && q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp87qgl1q6/tmp87qgl1q6.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9603f05c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9603bfcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9603bfc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9603bfb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp87qgl1q6                        0x00005575a36f64ff <unavailable> + 5375

    5    libc.so.6                          0x00002b96040f1460 __libc_start_main +
    245

    6    tmp87qgl1q6                        0x00005575a36f6169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.is_balanced() && q.sum() <= w\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5k9_grla.swift:18:14: error: value of type '[Int]' has no member\
    \ 'is_balanced'\n    return q.is_balanced() && q.sum() <= w\n           ~ ^~~~~~~~~~~\n\
    /tmp/tmp5k9_grla.swift:18:33: error: value of type '[Int]' has no member 'sum'\n\
    \    return q.is_balanced() && q.sum() <= w\n                              ~ ^~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return (q.sum() <= w) && q.isPalindrome()\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp6vvnwixg.swift:18:15: error: value of type '[Int]' has no member\
    \ 'sum'\n    return (q.sum() <= w) && q.isPalindrome()\n            ~ ^~~\n/tmp/tmp6vvnwixg.swift:18:32:\
    \ error: value of type '[Int]' has no member 'isPalindrome'\n    return (q.sum()\
    \ <= w) && q.isPalindrome()\n                             ~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let s = q.reduce(0, +)\n  return s <= w && q == q.reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let is_balanced = q.count == 1 || q.first == q.last\n\
    \    let sum = q.reduce(0, +)\n    return is_balanced && sum <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let is_balanced = q.count % 2 == 0 ?\n        q[0...(q.count/2\
    \ - 1)] == q[(q.count - 1)...(q.count/2) ].reversed() :\n        q[0...(q.count/2\
    \ - 1)] == q[(q.count/2 + 1)...(q.count - 1)].reversed()\n    return is_balanced\
    \ && q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp4j5_b9of.swift:19:67: error: cannot convert value of type 'ReversedCollection<ArraySlice<Int>>'\
    \ to expected argument type 'ArraySlice<Int>'\n        q[0...(q.count/2 - 1)]\
    \ == q[(q.count - 1)...(q.count/2) ].reversed() :\n                          \
    \                                        ^\n/tmp/tmp4j5_b9of.swift:20:70: error:\
    \ cannot convert value of type 'ReversedCollection<ArraySlice<Int>>' to expected\
    \ argument type 'ArraySlice<Int>'\n        q[0...(q.count/2 - 1)] == q[(q.count/2\
    \ + 1)...(q.count - 1)].reversed()\n                                         \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014229
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count < 1 {\n        return false\n    }\n    if\
    \ !isBalanced(array: q) {\n        return false\n    }\n    if sumArray(array:\
    \ q) > w {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpuxhulktl.swift:21:9: error: cannot find 'isBalanced' in scope\n\
    \    if !isBalanced(array: q) {\n        ^~~~~~~~~~\n/tmp/tmpuxhulktl.swift:24:8:\
    \ error: cannot find 'sumArray' in scope\n    if sumArray(array: q) > w {\n  \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if balanced(q: q) && sum(q: q) <= w {\n        return\
    \ true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpwzf59et4.swift:18:8: error: cannot find 'balanced' in scope\n \
    \   if balanced(q: q) && sum(q: q) <= w {\n       ^~~~~~~~\n/tmp/tmpwzf59et4.swift:18:26:\
    \ error: cannot find 'sum' in scope\n    if balanced(q: q) && sum(q: q) <= w {\n\
    \                         ^~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let isBalanced = q.reversed() == q\n    return isBalanced\
    \ && q.reduce(0, +) <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum > w {\n        return false\n    }\n    for i in 0..<q.count/2\
    \ {\n        if q[i] != q[q.count-1-i] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let q_balanced = q.count < 3 || q == q.reversed()\n \
    \   let q_weight = q.reduce(0, +)\n    return q_balanced && q_weight <= w\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmptbx01fh9/tmptbx01fh9.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b097a22fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0979f26b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0979f26988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0979f257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptbx01fh9                        0x000055a02b65154b <unavailable> + 5451

    5    libc.so.6                          0x00002b097a41b460 __libc_start_main +
    245

    6    tmptbx01fh9                        0x000055a02b6510f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    let reversed = q.reversed()\n\
    \    return sum <= w && q == reversed\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpp4ourb6t.swift:20:29: error: cannot convert value of type 'ReversedCollection<[Int]>'\
    \ to expected argument type '[Int]'\n    return sum <= w && q == reversed\n  \
    \                          ^\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    \n    return q.reduce(0, +) <= w && isPalindrome(arr:\
    \ q)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w:\
    \ 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpmp9v7u8s.swift:19:35: error: cannot find 'isPalindrome' in scope\n\
    \    return q.reduce(0, +) <= w && isPalindrome(arr: q)\n                    \
    \              ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    let\
    \ sortedQ = q.sorted()\n    var firstIndex = 0\n    var lastIndex = sortedQ.count\
    \ - 1\n    while firstIndex < lastIndex {\n        if sortedQ[firstIndex] + sortedQ[lastIndex]\
    \ > w {\n            return false\n        }\n        firstIndex += 1\n      \
    \  lastIndex -= 1\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp68oyufd6/tmp68oyufd6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7548e1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7548b15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7548b15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7548b147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp68oyufd6                        0x000055fc8ab4850b <unavailable> + 5387

    5    libc.so.6                          0x00002b754900a460 __libc_start_main +
    245

    6    tmp68oyufd6                        0x000055fc8ab480b9 <unavailable> + 4281

    '
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = (q.count/2 + 1) * 9\n    if w >= maxWeight\
    \ {\n        return isPalindrome(q: q)\n    }\n    return false\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp5l8ll2oa.swift:20:16: error: cannot find 'isPalindrome' in scope\n\
    \        return isPalindrome(q: q)\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpyh_aia02/tmpyh_aia02.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9e02406c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9e020fdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9e020fd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9e020fc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyh_aia02                        0x00005631a369e2ff <unavailable> + 4863

    5    libc.so.6                          0x00002b9e025f2460 __libc_start_main +
    245

    6    tmpyh_aia02                        0x00005631a369df69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014088
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for element in q {\n        sum += element\n\
    \    }\n    if sum > w {\n        return false\n    }\n    var q_ = q\n    let\
    \ first = q_.removeFirst()\n    let last = q_.removeLast()\n    if first != last\
    \ {\n        return false\n    }\n    return will_it_fly(q: q_, w: w)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'Swift/RangeReplaceableCollection.swift:870: Fatal error: Can''t remove
    last element from an empty collection

    Current stack trace:

    0    libswiftCore.so                    0x00002b27d108fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27d0d86561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b27d0d86286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b27d0d8613c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b27d0d85bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002b27d0e87c1d <unavailable> + 2489373

    6    tmps1e3w3hs                        0x000055a1473d1bf5 <unavailable> + 7157

    7    tmps1e3w3hs                        0x000055a1473d1c48 <unavailable> + 7240

    8    tmps1e3w3hs                        0x000055a1473d154a <unavailable> + 5450

    9    libc.so.6                          0x00002b27d127b460 __libc_start_main +
    245

    10   tmps1e3w3hs                        0x000055a1473d1229 <unavailable> + 4649

    '
  stdout: ''
  timestamp: 1660014228
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    let first\
    \ = q.first!\n    let last = q.last!\n    guard first == last else { return false\
    \ }\n    return will_it_fly(q: Array(q[1..<q.count-1]), w: w)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpo7kao3ov/tmpo7kao3ov.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7ada509c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7ada200b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7ada200988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7ada1ff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo7kao3ov                        0x00005555a8c228cf <unavailable> + 6351

    5    libc.so.6                          0x00002b7ada6f5460 __libc_start_main +
    245

    6    tmpo7kao3ov                        0x00005555a8c222e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660014228
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if is_pali(q: q) && sum_of_elements(q: q) <= w {\n  \
    \      return true\n    } else {\n        return false\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp2ww5h_tc.swift:18:8: error: cannot find 'is_pali' in scope\n  \
    \  if is_pali(q: q) && sum_of_elements(q: q) <= w {\n       ^~~~~~~\n/tmp/tmp2ww5h_tc.swift:18:25:\
    \ error: cannot find 'sum_of_elements' in scope\n    if is_pali(q: q) && sum_of_elements(q:\
    \ q) <= w {\n                        ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  let sum = q.reduce(0, +)\n  return sum <= w && q == q.reversed()\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return w >= sum && is_palindrome(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp1ct1zmmp.swift:19:24: error: cannot find 'is_palindrome' in scope\n\
    \    return w >= sum && is_palindrome(q)\n                       ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  guard q.count > 1 else { return true }\n  guard q.count.isEven\
    \ else { return false }\n  guard q.sum() <= w else { return false }\n  var q =\
    \ q\n  let _ = q.popLast()\n  let _ = q.popFirst()\n  return will_it_fly(q: q,\
    \ w: w)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3, 2, 3],\
    \ w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmp8yzzyxqn.swift:19:17: error: value of type 'Int' has no member\
    \ 'isEven'\n  guard q.count.isEven else { return false }\n        ~~~~~~~ ^~~~~~\n\
    /tmp/tmp8yzzyxqn.swift:20:11: error: value of type '[Int]' has no member 'sum'\n\
    \  guard q.sum() <= w else { return false }\n        ~ ^~~\n/tmp/tmp8yzzyxqn.swift:23:11:\
    \ error: referencing instance method 'popFirst()' on 'Collection' requires the\
    \ types '[Int]' and 'ArraySlice<Int>' be equivalent\n  let _ = q.popFirst()\n\
    \          ^\nSwift.Collection:1:11: note: where 'Self' = '[Int]', 'Self.SubSequence'\
    \ = 'ArraySlice<Int>'\nextension Collection where Self == Self.SubSequence {\n\
    \          ^\n"
  stdout: ''
  timestamp: 1660014227
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let total = q.reduce(0, +)\n    if total > w {\n    \
    \    return false\n    }\n    let qString = q.map{String($0)}.joined()\n    let\
    \ qStringReverse = String(qString.reversed())\n    return qString == qStringReverse\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let maxWeight = q.reduce(0, +)\n    if maxWeight > w\
    \ {\n        return false\n    }\n    let q1 = q.sorted()\n    let q2 = q.sorted\
    \ { $0 > $1 }\n    return q1 == q2\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp1_cjvqid/tmp1_cjvqid.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf6d0f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf6cdeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf6cdea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf6cde97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1_cjvqid                        0x000055b911f994ef <unavailable> + 5359

    5    libc.so.6                          0x00002aaf6d2df460 __libc_start_main +
    245

    6    tmp1_cjvqid                        0x000055b911f99159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count != 1 else { return true }\n    var index1\
    \ = 0\n    var index2 = q.count - 1\n    var sum = 0\n    while index1 < index2\
    \ {\n        if q[index1] != q[index2] {\n            return false\n        }\n\
    \        sum += q[index1]\n        index1 += 1\n        index2 -= 1\n    }\n \
    \   return sum <= w\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum <= w {\n       \
    \ return isPalindrome(q)\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpj55ocr33.swift:20:16: error: cannot find 'isPalindrome' in scope\n\
    \        return isPalindrome(q)\n               ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let v = q.reduce(0, +)\n    if v <= w {\n        if v\
    \ > 1 {\n            var s = q\n            let l = s.count / 2\n            for\
    \ i in 0..<l {\n                if s[i] != s[s.count - i - 1] {\n            \
    \        return false\n                }\n            }\n        }\n        return\
    \ true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    return q.reduce(0, +) <= w && q == q.reversed()\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    guard q.count > 1 else { return true }\n    var q = q\n\
    \    var w = w\n    while q.count > 1 {\n        let f = q.removeFirst()\n   \
    \     let l = q.removeLast()\n        if f != l { return false }\n        w -=\
    \ f + l\n    }\n    if q.count == 1 { w -= q.first! }\n    return w >= 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.isPalindrome() && q.sum < w {\n        return true\n\
    \    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpifg97nsc.swift:18:10: error: value of type '[Int]' has no member\
    \ 'isPalindrome'\n    if q.isPalindrome() && q.sum < w {\n       ~ ^~~~~~~~~~~~\n\
    /tmp/tmpifg97nsc.swift:18:30: error: value of type '[Int]' has no member 'sum'\n\
    \    if q.isPalindrome() && q.sum < w {\n                           ~ ^~~\n"
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var flying = false\n    var is_balanced = false\n   \
    \ var sum = 0\n    if q.count == 1 {\n        is_balanced = true\n    } else {\n\
    \        var left_pointer = 0\n        var right_pointer = q.count - 1\n     \
    \   while left_pointer < right_pointer {\n            if q[left_pointer] == q[right_pointer]\
    \ {\n                is_balanced = true\n                left_pointer += 1\n \
    \               right_pointer -= 1\n            } else {\n                is_balanced\
    \ = false\n                break\n            }\n        }\n    }\n    if is_balanced\
    \ {\n        for i in q {\n            sum += i\n        }\n        if sum <=\
    \ w {\n            flying = true\n        }\n    }\n    return flying\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let qSum = q.reduce(0, +)\n    if qSum <= w {\n     \
    \   return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2],\
    \ w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpa25wdm9m/tmpa25wdm9m.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b83f37c0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b83f34b7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b83f34b7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b83f34b67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa25wdm9m                        0x00005639cfda443b <unavailable> + 5179

    5    libc.so.6                          0x00002b83f39ac460 __libc_start_main +
    245

    6    tmpa25wdm9m                        0x00005639cfda3fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014228
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.count == 1 {\n        return true\n    }\n    if\
    \ q.count == 2 {\n        return q[0] == q[1]\n    }\n    if q.reduce(0, +) >\
    \ w {\n        return false\n    }\n    let mid = q.count / 2\n    let a = Array(q[0..<mid])\n\
    \    let b = Array(q[mid..<q.count])\n    if a == b.reversed() {\n        return\
    \ true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmpt2v56zs8/tmpt2v56zs8.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2887d10c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2887a07b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2887a07988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2887a067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt2v56zs8                        0x0000563e874c56df <unavailable> + 5855

    5    libc.so.6                          0x00002b2887efc460 __libc_start_main +
    245

    6    tmpt2v56zs8                        0x0000563e874c5349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if w < sum {\n        return false\n    }\n    for i in 0..<q.count/2\
    \ {\n        if q[i] != q[q.count-1-i] {\n            return false\n        }\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    return sum <= w && isPalindrome(q)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpyb3a51ra.swift:19:24: error: cannot find 'isPalindrome' in scope\n\
    \    return sum <= w && isPalindrome(q)\n                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014226
- exit_code: 1
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    if q.isEmpty {\n        return false\n    }\n    var\
    \ sum = 0\n    for i in q {\n        sum += i\n    }\n    let mid = q.count /\
    \ 2\n    let firstHalf = q[0..<mid]\n    let secondHalf = Array(q[mid..<q.count].reversed())\n\
    \    if firstHalf == secondHalf && sum <= w {\n        return true\n    }\n  \
    \  return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q: [3,\
    \ 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: SyntaxError
  stderr: "/tmp/tmpule2w0kk.swift:28:21: error: cannot convert value of type '[ReversedCollection<ArraySlice<Int>>.Element]'\
    \ (aka 'Array<Int>') to expected argument type 'ArraySlice<Int>'\n    if firstHalf\
    \ == secondHalf && sum <= w {\n                    ^\n"
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, {$0 + $1})\n    let isBalanced\
    \ = q.reduce(true, { $0 && $1 == q[q.count - q.index(of: $1)! - 1] })\n    return\
    \ sum <= w && isBalanced\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q: [1, 2], w: 5) == false)\nassert(will_it_fly(q:\
    \ [3], w: 5) == true)\nassert(will_it_fly(q: [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q:\
    \ [1, 2, 3], w: 6) == false)\nassert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: -4
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n  var right = q.count - 1\n  var left = 0\n  var leftSum\
    \ = 0\n  var rightSum = 0\n  var balance = 0\n  while left <= right {\n    leftSum\
    \ += q[left]\n    rightSum += q[right]\n    if leftSum <= rightSum {\n      balance\
    \ += rightSum - leftSum\n      left += 1\n    } else {\n      balance += leftSum\
    \ - rightSum\n      right -= 1\n    }\n  }\n  return balance <= w\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: Exception
  stderr: 'tmp0rnjgcwm/tmp0rnjgcwm.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9204eeac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9204be1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9204be1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9204be07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0rnjgcwm                        0x000055cce2c1d46b <unavailable> + 5227

    5    libc.so.6                          0x00002b92050d6460 __libc_start_main +
    245

    6    tmp0rnjgcwm                        0x000055cce2c1d019 <unavailable> + 4121

    '
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    let sum = q.reduce(0, +)\n    if sum <= w {\n       \
    \ return q == q.reversed()\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014228
- exit_code: 0
  program: "\n/// Write a function that returns true if the object q will fly, and\
    \ false otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ array) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(q: [1, 2], w: 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(q: [3, 2, 3], w: 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(q: [3, 2, 3], w:\
    \ 9)\n/// true\n/// # 3+2+3 is less than the maximum possible weight, and it's\
    \ balanced.\n/// >>> will_it_fly(q: [3], w: 5)\n/// true\n/// # 3 is less than\
    \ the maximum possible weight, and it's balanced.\nfunc will_it_fly(q: [Int],\
    \ w: Int) -> Bool {\n    var sum = 0\n    for i in q {\n        sum += i\n   \
    \ }\n    if sum <= w {\n        for i in 0..<q.count/2 {\n            if q[i]\
    \ != q[q.count-1-i] {\n                return false\n            }\n        }\n\
    \        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(will_it_fly(q: [3, 2, 3], w: 9) == true)\nassert(will_it_fly(q:\
    \ [1, 2], w: 5) == false)\nassert(will_it_fly(q: [3], w: 5) == true)\nassert(will_it_fly(q:\
    \ [3, 2, 3], w: 1) == false)\nassert(will_it_fly(q: [1, 2, 3], w: 6) == false)\n\
    assert(will_it_fly(q: [5], w: 5) == true)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014089
