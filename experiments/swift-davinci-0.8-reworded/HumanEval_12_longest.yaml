name: HumanEval_12_longest
language: swift
prompt: "\n/// Out of array of strings, return the longest one. Return the first one\
  \ in case of multiple\n/// strings of the same length. Return nil in case the input\
  \ array is empty.\n/// >>> longest(strings: [] as [String])\n/// nil\n/// >>> longest(strings:\
  \ [\"a\", \"b\", \"c\"])\n/// \"a\"\n/// >>> longest(strings: [\"a\", \"bb\", \"\
  ccc\"])\n/// \"ccc\"\nfunc longest(strings: [String]) -> String? {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\n\
  assert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings:\
  \ [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
completions: ['    return strings.max()', "    if strings.isEmpty {\n        return\
    \ nil\n    }\n    var long: String = strings[0]\n    for i in 1..<strings.count\
    \ {\n        if strings[i].count > long.count {\n            long = strings[i]\n\
    \        }\n    }\n    return long", "    // TODO: Write some code to get the\
    \ expected output!\n    return nil", "  // TODO: Write the body of the function\
    \ here\n  var longestString: String? = nil\n  for string in strings {\n    if\
    \ let currentLongestString = longestString {\n      if string.count > currentLongestString.count\
    \ {\n        longestString = string\n      }\n    } else {\n      longestString\
    \ = string\n    }\n  }\n  return longestString", "    guard strings.count > 0\
    \ else {\n        return nil\n    }\n    return strings.sorted(by: { $0.count\
    \ > $1.count }).first", "    var result: String? = nil\n    var longest = 0\n\
    \    for string in strings {\n        if string.count > longest {\n          \
    \  result = string\n            longest = string.count\n        }\n    }\n   \
    \ return result", "    return strings.reduce(nil) {\n        if let result = $0\
    \ {\n            return result.count > $1.count ? result : $1\n        } else\
    \ {\n            return $1\n        }\n    }", "    // FIXME\n    var longestWord\
    \ = \"\"\n    for word in strings {\n        if word.count > longestWord.count\
    \ {\n            longestWord = word\n        }\n    }\n    return longestWord.isEmpty\
    \ ? nil : longestWord", "    if strings.isEmpty {\n        return nil\n    }\n\
    \    let stringsSortedByLength = strings.sorted { (str1, str2) -> Bool in\n  \
    \      return str1.count > str2.count\n    }\n    return stringsSortedByLength.first",
  "    if strings.isEmpty {\n        return nil\n    }\n    var maxLen: Int = 0\n\
    \    var maxString: String = \"\"\n    for string in strings {\n        if string.count\
    \ > maxLen {\n            maxLen = string.count\n            maxString = string\n\
    \        }\n    }\n    return maxString", "    guard !strings.isEmpty else { return\
    \ nil }\n    return strings.max(by: { $0.count < $1.count })!", "    var longestString:\
    \ String?\n    for s in strings {\n        if longestString == nil || s.count\
    \ > longestString!.count {\n            longestString = s\n        }\n    }\n\
    \    return longestString", '    return nil', "    if strings.isEmpty {\n    \
    \    return nil\n    }\n    return strings.reduce(strings[0]) {\n        $0.count\
    \ > $1.count ? $0 : $1\n    }", "    if strings.isEmpty {\n        return nil\n\
    \    }\n    var out: String = strings[0]\n    for string in strings {\n      \
    \  if string.count > out.count {\n            out = string\n        }\n    }\n\
    \    return out", "    var max: String? = nil\n    for string in strings {\n \
    \       if max == nil || string.characters.count > max!.characters.count {\n \
    \           max = string\n        }\n    }\n    return max", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var result = strings[0]\n    for string in\
    \ strings {\n        if string.count > result.count {\n            result = string\n\
    \        }\n    }\n    return result", "    if strings.isEmpty {\n        return\
    \ nil\n    }\n    var longestString = strings[0]\n    for string in strings {\n\
    \        if string.count > longestString.count {\n            longestString =\
    \ string\n        }\n    }\n    return longestString", "    var longest: String?\
    \ = nil\n    var maxLength = 0\n    for str in strings {\n        if str.characters.count\
    \ > maxLength {\n            maxLength = str.characters.count\n            longest\
    \ = str\n        }\n    }\n    return longest", "    guard let first = strings.first\
    \ else { return nil }\n    return strings.reduce(first) { (longestString, string)\
    \ -> String in\n        if string.count > longestString.count {\n            return\
    \ string\n        } else {\n            return longestString\n        }\n    }",
  "    // Write your implementation here\n    return strings.max(by: {$0.count < $1.count})",
  "    //    return strings.sort { $0.characters.count > $1.characters.count }.first\n\
    \    //    return strings.sorted { $0.characters.count > $1.characters.count }.first\n\
    \    //    return strings.sorted(by: { $0.characters.count > $1.characters.count\
    \ }).first\n    //    return strings.sorted(by: { a, b in a.characters.count >\
    \ b.characters.count }).first\n    //    return strings.sorted(by: { (a, b) in\
    \ a.characters.count > b.characters.count }).first\n    //    return strings.sorted(by:\
    \ { a, b in return a.characters.count > b.characters.count }).first\n    //  \
    \  return strings.sorted(by: { a, b in a.characters.count > b.characters.count\
    \ }).first\n    //    return strings.sorted(by: { (a, b) in return a.characters.count\
    \ > b.characters.count }).first\n    //    return strings.sorted(by: { (a, b)\
    \ in a.characters.count > b.characters.count }).first\n    //    return strings.sorted(by:\
    \ { a, b in return a.characters.count > b.characters.count }).first\n    //  \
    \  return strings.sorted(by: { a, b in a.characters.count > b.characters.count\
    \ }).first\n    //    return strings.sorted(by: { a, b in return a.characters.count\
    \ > b.characters.count }).first\n    //    return strings.sorted(by: { a, b in\
    \ a.characters.count > b.characters.count }).first\n    //    return strings.sorted(by:\
    \ { a, b in return a.characters.count > b.characters.count }).first\n    //  \
    \  return strings.sorted(by: { a, b in a.characters.count > b.characters.count\
    \ }).first\n    //    return strings.sorted(by: { a, b in return a", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    return strings.sorted(by: { $0.count > $1.count\
    \ }).first", "    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings[1..<strings.count] {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString", "    var longest: String? = nil\n    for s in\
    \ strings {\n        if longest == nil || s.characters.count > longest!.characters.count\
    \ {\n            longest = s\n        }\n    }\n    return longest", "    if strings.isEmpty\
    \ {\n        return nil\n    } else {\n        var longestString = strings[0]\n\
    \        for string in strings {\n            if string.count > longestString.count\
    \ {\n                longestString = string\n            }\n        }\n      \
    \  return longestString\n    }", "    if strings.isEmpty {\n        return nil\n\
    \    }\n    else {\n        return (strings.sorted(by: { $0.characters.count >\
    \ $1.characters.count})).first\n    }", "    guard !strings.isEmpty else { return\
    \ nil }\n    var rtn: String = strings[0]\n    for s in strings {\n        if\
    \ s.count > rtn.count {\n            rtn = s\n        }\n    }\n    return rtn",
  "    if strings.isEmpty {\n        return nil\n    }\n    let sorted = strings.sorted\
    \ { $0.characters.count > $1.characters.count }\n    return sorted.first", " \
    \   var longest: String? = nil\n    for string in strings {\n        if longest\
    \ == nil || string.count > longest!.count {\n            longest = string\n  \
    \      }\n    }\n    return longest", "    guard !strings.isEmpty else { return\
    \ nil }\n    return strings.reduce(strings[0]) { a, b in\n        a.count >= b.count\
    \ ? a : b\n    }", "    var longestString: String?\n    for aString in strings\
    \ {\n        if longestString == nil || aString.count > longestString!.count {\n\
    \            longestString = aString\n        }\n    }\n    return longestString",
  "    if strings.isEmpty {\n        return nil\n    } else {\n        var longest:\
    \ String = strings[0]\n        for string in strings {\n            if string.count\
    \ > longest.count {\n                longest = string\n            }\n       \
    \ }\n        return longest\n    }", "    if strings.isEmpty {\n        return\
    \ nil\n    }\n    var longest = strings[0]\n    for str in strings {\n       \
    \ if str.count > longest.count {\n            longest = str\n        }\n    }\n\
    \    return longest", '    return nil', '    return nil', "    var length = 0\n\
    \    var str : String?\n    for s in strings {\n        if s.characters.count\
    \ > length {\n            length = s.characters.count\n            str = s\n \
    \       }\n    }\n    return str", "    guard let longestString = strings.sorted(by:\
    \ {$0.count > $1.count}).first else {\n        return nil\n    }\n    return longestString",
  "    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ { (current: String, string: String) -> String in\n        return current.characters.count\
    \ > string.characters.count ? current : string\n    }", '    return nil', "  \
    \  if strings.isEmpty {\n        return nil\n    }\n    var result = strings[0]\n\
    \    for string in strings {\n        if string.count > result.count {\n     \
    \       result = string\n        }\n    }\n    return result", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var result = strings[0]\n    for string in\
    \ strings {\n        if string.count > result.count {\n            result = string\n\
    \        }\n    }\n    return result", "    guard let longestString = strings.max(by:\
    \ {\n        $0.count < $1.count\n    }) else {\n        return nil\n    }\n \
    \   return longestString", "    guard strings.count > 0 else {\n        return\
    \ nil\n    }\n    var longest: String = strings[0]\n    for string in strings\
    \ {\n        if string.count > longest.count {\n            longest = string\n\
    \        }\n    }\n    return longest", "    guard strings.count > 0 else {\n\
    \        return nil\n    }\n    let stringsSorted = strings.sorted(by: { $0.count\
    \ > $1.count })\n    return stringsSorted[0]", "  if strings.isEmpty {\n    return\
    \ nil\n  }\n  var longest = strings[0]\n  for string in strings {\n    if string.count\
    \ > longest.count {\n      longest = string\n    }\n  }\n  return longest", " \
    \   var longestString: String?\n    var longestStringLength = 0\n    for str in\
    \ strings {\n        if (str.count > longestStringLength) {\n            longestString\
    \ = str\n            longestStringLength = str.count\n        }\n    }\n    return\
    \ longestString", "    return strings.reduce(nil) { (memo, element) in\n     \
    \   if memo == nil {\n            return element\n        } else if memo!.count\
    \ < element.count {\n            return element\n        } else {\n          \
    \  return memo\n        }\n    }", "    guard let first = strings.first else {\
    \ return nil }\n    return strings.reduce(first) { $1.count > $0.count ? $1 :\
    \ $0 }", '    return nil', "  var result: String? = nil\n  for str in strings\
    \ {\n    if result == nil || str.characters.count > result!.characters.count {\n\
    \      result = str\n    }\n  }\n  return result", "    guard let longest = strings.max(by:\
    \ { $0.count < $1.count }) else {\n        return nil\n    }\n    return longest",
  "    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (current, next) in\n        return current.count >= next.count ? current :\
    \ next\n    }", "    var longestString: String?\n    for s in strings {\n    \
    \    if let l = longestString {\n            if l.characters.count < s.characters.count\
    \ {\n                longestString = s\n            }\n        } else {\n    \
    \        longestString = s\n        }\n    }\n    return longestString", "   \
    \ guard !strings.isEmpty else { return nil }\n    var longestString = strings[0]\n\
    \    var longestStringLength = longestString.count\n    for string in strings[1..<strings.count]\
    \ {\n        if string.count > longestStringLength {\n            longestString\
    \ = string\n            longestStringLength = string.count\n        }\n    }\n\
    \    return longestString", "    guard strings.count > 0 else {\n        return\
    \ nil\n    }\n    var result = strings[0]\n    for s in strings {\n        if\
    \ s.count > result.count {\n            result = s\n        }\n    }\n    return\
    \ result", "    var longest_string: String? = nil\n    var longest_length = 0\n\
    \    for string in strings {\n        if longest_length < string.characters.count\
    \ {\n            longest_length = string.characters.count\n            longest_string\
    \ = string\n        }\n    }\n    return longest_string", "    // TODO: implement\
    \ this\n    return nil", "    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest: String = strings[0]\n    for string in strings {\n        if\
    \ string.characters.count > longest.characters.count {\n            longest =\
    \ string\n        }\n    }\n    return longest", '    return strings.sorted {
    $0.count > $1.count }.first', "    if strings.isEmpty {\n        return nil\n\
    \    }\n    var longest = strings[0]\n    for str in strings {\n        if str.count\
    \ > longest.count {\n            longest = str\n        }\n    }\n    return longest",
  '    return strings.max()', "    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestWord = strings[0]\n    for word in strings {\n        if word.count\
    \ > longestWord.count {\n            longestWord = word\n        }\n    }\n  \
    \  return longestWord", "    guard !strings.isEmpty else { return nil }\n    var\
    \ longest: String = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest", "    guard !strings.isEmpty else { return nil }\n    var result =\
    \ strings[0]\n    for s in strings[1...] {\n        if s.count > result.count\
    \ {\n            result = s\n        }\n    }\n    return result", "    // TODO:\
    \ Write implementation here\n    return nil", '    return nil', "    var count\
    \ = 0\n    var str = \"\"\n    for string in strings {\n        if string.count\
    \ > count {\n            count = string.count\n            str = string\n    \
    \    }\n    }\n    return str", "    var longestString: String?\n    for string\
    \ in strings {\n        if longestString == nil || string.count > longestString!.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString",
  "    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ { $1.count > $0.count ? $1 : $0 }", '    return nil', "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var longestString = strings[0]\n    for string\
    \ in strings[1...] {\n        if string.count > longestString.count {\n      \
    \      longestString = string\n        }\n    }\n    return longestString", '    return
    nil', "    if strings.isEmpty {\n        return nil\n    }\n    var longestString\
    \ = strings[0]\n    for string in strings {\n        if string.count > longestString.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString",
  '    return nil', "    guard let first = strings.first else { return nil }\n   \
    \ return strings.reduce(first) { current, next in\n        current.count > next.count\
    \ ? current : next\n    }", "    if strings.isEmpty {\n        return nil\n  \
    \  }\n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest", "    var maxString: String? = nil\n    for s in strings {\n      \
    \  if maxString == nil || s.count > maxString!.count {\n            maxString\
    \ = s\n        }\n    }\n    return maxString", '    return nil', "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var index = 0\n    var longest = strings[0]\n\
    \    for i in 1..<strings.count {\n        if strings[i].count > longest.count\
    \ {\n            index = i\n            longest = strings[i]\n        }\n    }\n\
    \    return longest", "    var longest: String? = nil\n    for string in strings\
    \ {\n        if longest == nil || longest!.characters.count < string.characters.count\
    \ {\n            longest = string\n        }\n    }\n    return longest", "  \
    \  if strings.isEmpty {\n        return nil\n    }\n    else {\n        var longest\
    \ = strings[0]\n        for str in strings {\n            if str.characters.count\
    \ > longest.characters.count {\n                longest = str\n            }\n\
    \        }\n        return longest\n    }", "    var longest: String? = nil\n\
    \    for string in strings {\n        if longest == nil || longest!.count < string.count\
    \ {\n            longest = string\n        }\n    }\n    return longest", "  \
    \  guard !strings.isEmpty else { return nil }\n    var result = strings[0]\n \
    \   for i in 1..<strings.count {\n        let s = strings[i]\n        if s.count\
    \ > result.count {\n            result = s\n        }\n    }\n    return result",
  "    if strings.isEmpty {\n        return nil\n    }\n    return strings.max(by:\
    \ {\n        $0.count < $1.count\n    })", "    // TODO\n    var count = 0\n \
    \   var longestString = \"\"\n    for string in strings {\n        if string.count\
    \ > count {\n            count = string.count\n            longestString = string\n\
    \        }\n    }\n    return longestString", "    // your code here\n    return\
    \ nil", "    var longestString: String?\n    for string in strings {\n       \
    \ if longestString == nil || string.count > longestString!.count {\n         \
    \   longestString = string\n        }\n    }\n    return longestString", "   \
    \ guard !strings.isEmpty else { return nil }\n    var result = strings[0]\n  \
    \  for string in strings {\n        if string.count > result.count {\n       \
    \     result = string\n        }\n    }\n    return result", "    guard !strings.isEmpty\
    \ else { return nil }\n    return strings.reduce(strings[0]) { $1.count > $0.count\
    \ ? $1 : $0 }", "    return strings.max { (lhs, rhs) -> Bool in\n        lhs.characters.count\
    \ < rhs.characters.count\n    }", "    // Implement function here\n    return\
    \ nil", '    return strings.max(by: { $0.count < $1.count })', "    var longest:\
    \ String? = nil\n    var length = 0\n    for s in strings {\n        if s.characters.count\
    \ > length {\n            length = s.characters.count\n            longest = s\n\
    \        }\n    }\n    return longest", "    guard strings.count > 0 else {\n\
    \        return nil\n    }\n    var longestString = strings[0]\n    for str in\
    \ strings {\n        if str.count > longestString.count {\n            longestString\
    \ = str\n        }\n    }\n    return longestString", "    // TODO: implement\
    \ me\n    return nil", "    if strings.isEmpty {\n        return nil\n    }\n\
    \    var maxLength = 0\n    var longestString = \"\"\n    for string in strings\
    \ {\n        if string.count > maxLength {\n            maxLength = string.count\n\
    \            longestString = string\n        }\n    }\n    return longestString",
  "    if strings.isEmpty {\n        return nil\n    }\n    var longestString = strings[0]\n\
    \    for string in strings {\n        if string.count > longestString.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString",
  "    if strings.isEmpty {\n        return nil\n    }\n    return strings.reduce(strings[0])\
    \ {\n        (longest, string) in\n        return string.count > longest.count\
    \ ? string : longest\n    }", "    if strings.isEmpty {\n        return nil\n\
    \    }\n    var maxLen = 0\n    var maxLenIndex = 0\n    for i in 0..<strings.count\
    \ {\n        if strings[i].characters.count > maxLen {\n            maxLen = strings[i].characters.count\n\
    \            maxLenIndex = i\n        }\n    }\n    return strings[maxLenIndex]",
  '    return nil', "    if strings.isEmpty {\n        return nil\n    }\n    var\
    \ longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString", '    return nil', '    return strings.sorted {
    $0.count > $1.count }.first', "    guard strings.count > 0 else {\n        return\
    \ nil\n    }\n    return strings.max { (lhs, rhs) -> Bool in\n        return lhs.count\
    \ < rhs.count\n    }", "    if strings.isEmpty {\n        return nil\n    }\n\
    \    if strings.count == 1 {\n        return strings[0]\n    }\n    var result:\
    \ String = strings[0]\n    for string in strings {\n        if string.count >\
    \ result.count {\n            result = string\n        }\n    }\n    return result",
  "    var maxLen: Int = 0\n    var max: String? = nil\n    for s in strings {\n \
    \       if s.characters.count > maxLen {\n            maxLen = s.characters.count\n\
    \            max = s\n        }\n    }\n    return max", "    // insert your code\
    \ here\n    return strings.max {\n        $0.count < $1.count\n    }", "    var\
    \ longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || string.characters.count > longestString!.characters.count {\n    \
    \        longestString = string\n        }\n    }\n    return longestString",
  "    if strings.isEmpty {\n        return nil\n    }\n    var max = strings[0]\n\
    \    for string in strings {\n        if string.count > max.count {\n        \
    \    max = string\n        }\n    }\n    return max", "    var longest: String?\
    \ = nil\n    for string in strings {\n        if longest == nil || string.count\
    \ > longest!.count {\n            longest = string\n        }\n    }\n    return\
    \ longest", "    guard !strings.isEmpty else { return nil }\n    return strings.max\
    \ { s1, s2 in s1.count < s2.count }", '    return strings.max()', "    guard !strings.isEmpty\
    \ else { return nil }\n    return strings.reduce(strings[0]) { $1.count > $0.count\
    \ ? $1 : $0 }", "    guard !strings.isEmpty else { return nil }\n    var result\
    \ = strings[0]\n    for string in strings {\n        if string.count > result.count\
    \ {\n            result = string\n        }\n    }\n    return result", "    guard\
    \ let first = strings.first else { return nil }\n    return strings.reduce(first)\
    \ { current, element in\n        current.count > element.count ? current : element\n\
    \    }", "    // TODO: write your solution here\n    if strings.isEmpty {\n  \
    \      return nil\n    }\n    var max = strings[0]\n    for str in strings {\n\
    \        if str.count > max.count {\n            max = str\n        }\n    }\n\
    \    return max", '    // ...', "    var longestString: String?\n    for string\
    \ in strings {\n        if longestString == nil || string.count > longestString!.count\
    \ {\n            longestString = string\n        }\n    }\n    return longestString",
  "    guard !strings.isEmpty else { return nil }\n    var longest: String = strings[0]\n\
    \    for string in strings {\n        if string.count > longest.count {\n    \
    \        longest = string\n        }\n    }\n    return longest", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var longest = strings[0]\n    for string in\
    \ strings {\n        if string.characters.count > longest.characters.count {\n\
    \            longest = string\n        }\n    }\n    return longest", "    \n\
    \    guard !strings.isEmpty else { return nil }\n    \n    var s = strings[0]\n\
    \    \n    for string in strings {\n        if string.count > s.count {\n    \
    \        s = string\n        }\n    }\n    \n    return s", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    return strings.reduce(strings[0]) { acc, x\
    \ in\n        return acc.count > x.count ? acc : x\n    }", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var i = 0\n    var maxIndex = 0\n    var maxLen\
    \ = 0\n    for str in strings {\n        if str.characters.count > maxLen {\n\
    \            maxLen = str.characters.count\n            maxIndex = i\n       \
    \ }\n        i += 1\n    }\n    return strings[maxIndex]", '    return strings.max(by:
    { $0.characters.count < $1.characters.count })', "    if strings.isEmpty {\n \
    \       return nil\n    }\n    var longest = strings[0]\n    for string in strings\
    \ {\n        if string.characters.count > longest.characters.count {\n       \
    \     longest = string\n        }\n    }\n    return longest", "    var longerWord\
    \ = \"\"\n    var longerWordLenght = 0\n    for word in strings {\n        if\
    \ word.count > longerWordLenght {\n            longerWord = word\n           \
    \ longerWordLenght = word.count\n        }\n    }\n    return longerWord.isEmpty\
    \ ? nil : longerWord", "    var longestWord: String?\n    for string in strings\
    \ {\n        if longestWord == nil || string.count > longestWord!.count {\n  \
    \          longestWord = string\n        }\n    }\n    return longestWord", " \
    \   var longestStr: String? = nil\n    var length: Int = 0\n    for str in strings\
    \ {\n        if str.characters.count > length {\n            length = str.characters.count\n\
    \            longestStr = str\n        }\n    }\n    return longestStr", "   \
    \ if strings.isEmpty {\n        return nil\n    } else {\n        var longestString\
    \ = strings[0]\n        for string in strings {\n            if string.count >\
    \ longestString.count {\n                longestString = string\n            }\n\
    \        }\n        return longestString\n    }", "    var longestStr: String?\
    \ = nil\n    for str in strings {\n        if longestStr == nil || longestStr!.characters.count\
    \ < str.characters.count {\n            longestStr = str\n        }\n    }\n \
    \   return longestStr", "    guard strings.count > 0 else {\n        return nil\n\
    \    }\n    guard strings.count > 1 else {\n        return strings[0]\n    }\n\
    \    return strings.sorted(by: { $0.count > $1.count })[0]", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    let sorted = strings.sorted { $0.count > $1.count\
    \ }\n    return sorted.first", "    if strings.isEmpty {\n        return nil\n\
    \    }\n    var maxString = strings[0]\n    for string in strings {\n        if\
    \ string.count > maxString.count {\n            maxString = string\n        }\n\
    \    }\n    return maxString", '    return strings.max(by: { $0.count < $1.count
    })', "    // TODO: Write your own code!\n    var maxLength = 0\n    var maxString:\
    \ String? = nil\n    for s in strings {\n        if s.count > maxLength {\n  \
    \          maxLength = s.count\n            maxString = s\n        }\n    }\n\
    \    return maxString", "    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest", "    if strings.isEmpty {\n        return nil\n    }\n    var result\
    \ = strings[0]\n    for string in strings {\n        if string.characters.count\
    \ > result.characters.count {\n            result = string\n        }\n    }\n\
    \    return result", "    if strings.isEmpty {\n        return nil\n    }\n  \
    \  return strings.max { $0.characters.count < $1.characters.count }", "    guard\
    \ strings.count > 0 else {\n        return nil\n    }\n    var longestString =\
    \ strings[0]\n    for str in strings {\n        if str.count > longestString.count\
    \ {\n            longestString = str\n        }\n    }\n    return longestString",
  '    return "nil"', "    guard strings.count > 0 else {\n        return nil\n  \
    \  }\n    var maxlen = strings[0].count\n    var result = strings[0]\n    for\
    \ string in strings {\n        if string.count > maxlen {\n            maxlen\
    \ = string.count\n            result = string\n        }\n    }\n    return result",
  '    return nil', "    if strings.isEmpty {\n        return nil\n    }\n    var\
    \ l = strings[0]\n    for s in strings {\n        if l.count < s.count {\n   \
    \         l = s\n        }\n    }\n    return l", "  if strings.isEmpty {\n  \
    \  return nil\n  }\n  var longestSoFar = strings[0]\n  for str in strings[1..<strings.count]\
    \ {\n    if str.characters.count > longestSoFar.characters.count {\n      longestSoFar\
    \ = str\n    }\n  }\n  return longestSoFar", "    var longest: String? = nil\n\
    \    for string in strings {\n        if let l = longest {\n            if string.characters.count\
    \ > l.characters.count {\n                longest = string\n            }\n  \
    \      } else {\n            longest = string\n        }\n    }\n    return longest",
  "    guard let longest = strings.max(by: { $0.count < $1.count }) else {\n     \
    \   return nil\n    }\n    return longest", "    if strings.isEmpty {\n      \
    \  return nil\n    }\n    var currentLongest: String = strings[0]\n    for string\
    \ in strings {\n        if string.count > currentLongest.count {\n           \
    \ currentLongest = string\n        }\n    }\n    return currentLongest", "   \
    \ if strings.isEmpty {\n        return nil\n    }\n    var longestWord = strings[0]\n\
    \    for i in 0...strings.count-1 {\n        if strings[i].count > longestWord.count\
    \ {\n            longestWord = strings[i]\n        }\n    }\n    return longestWord",
  "    if strings.isEmpty {\n        return nil\n    }\n    if strings.count == 1\
    \ {\n        return strings[0]\n    }\n    var longest = strings[0]\n    for string\
    \ in strings {\n        if string.count > longest.count {\n            longest\
    \ = string\n        }\n    }\n    return longest", "    // TODO: Write some code\
    \ to get the expected result!\n    if strings.isEmpty {\n        return nil\n\
    \    }\n    var longest = strings[0]\n    for i in 1..<strings.count {\n     \
    \   if strings[i].count > longest.count {\n            longest = strings[i]\n\
    \        }\n    }\n    return longest", "    // TODO:\n    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var longest = strings[0]\n    for string in\
    \ strings {\n        if string.count > longest.count {\n            longest =\
    \ string\n        }\n    }\n    return longest", "    // todo\n    return nil",
  "    \n    if strings.isEmpty {\n        return nil\n    }\n    \n    var max: Int\
    \ = 0\n    var maxString: String = \"\"\n    \n    for str in strings {\n    \
    \    if str.characters.count > max {\n            max = str.characters.count\n\
    \            maxString = str\n        }\n    }\n    \n    return maxString", " \
    \   guard !strings.isEmpty else { return nil }\n    return strings.max { $0.count\
    \ < $1.count }", "    if strings.isEmpty {\n        return nil\n    }\n    var\
    \ longest = strings[0]\n    for string in strings {\n        if string.count >\
    \ longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest", "    // TODO\n    return nil", '    return strings.sorted(by: { $0.count
    > $1.count }).first', "    guard strings.count > 0 else {\n        return nil\n\
    \    }\n    var longestString = strings[0]\n    for string in strings {\n    \
    \    if string.count > longestString.count {\n            longestString = string\n\
    \        }\n    }\n    return longestString", "    if let firstString = strings.first\
    \ {\n        return strings.reduce(firstString) { currentLongest, nextString in\n\
    \            if currentLongest.characters.count > nextString.characters.count\
    \ {\n                return currentLongest\n            } else {\n           \
    \     return nextString\n            }\n        }\n    } else {\n        return\
    \ nil\n    }", "    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { $1.characters.count > $0.characters.count ? $1 : $0 }", "    guard !strings.isEmpty\
    \ else { return nil }\n    var maxString: String? = nil\n    for string in strings\
    \ {\n        if maxString == nil || string.count > maxString!.count {\n      \
    \      maxString = string\n        }\n    }\n    return maxString", "  guard strings.count\
    \ > 0 else { return nil }\n  var longest: String = strings[0]\n  for string in\
    \ strings[1..<strings.count] {\n    if string.count > longest.count {\n      longest\
    \ = string\n    }\n  }\n  return longest", "    return strings.maxElement(by:\
    \ {\n        $0.characters.count < $1.characters.count\n    })", "    var longest:\
    \ String? = nil\n    for string in strings {\n        if longest == nil || string.count\
    \ > longest!.count {\n            longest = string\n        }\n    }\n    return\
    \ longest", "    return strings.reduce(nil) {\n        return $0 == nil || $0!.count\
    \ < $1.count ? $1 : $0\n    }", "    // we could use reduce but this is the canonical\
    \ implementation of reduce using for-in:\n    var longest = strings.first\n  \
    \  for string in strings {\n        if let longest = longest {\n            longest\
    \ = (string.count > longest.count) ? string : longest\n        } else {\n    \
    \        longest = string\n        }\n    }\n    return longest", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var maxLength = 0\n    var result: String?\
    \ = nil\n    for string in strings {\n        if string.count > maxLength {\n\
    \            maxLength = string.count\n            result = string\n        }\n\
    \    }\n    return result", "    guard strings.count > 0 else {\n        return\
    \ nil\n    }\n    var longest: String = strings[0]\n    for i in 1..<strings.count\
    \ {\n        if strings[i].count > longest.count {\n            longest = strings[i]\n\
    \        }\n    }\n    return longest", "    guard let string = strings.first\
    \ else {\n        return nil\n    }\n    var longestString = string\n    var counter\
    \ = 1\n    while counter < strings.count {\n        if longestString.count < strings[counter].count\
    \ {\n            longestString = strings[counter]\n        }\n        counter\
    \ += 1\n    }\n    return longestString", "  guard let maxElement = strings.max(by:\
    \ { $0.count < $1.count }) else {\n    return nil\n  }\n  return maxElement",
  "    var longestString: String?\n    for string in strings {\n        if longestString\
    \ == nil || (string.count > longestString!.count) {\n            longestString\
    \ = string\n        }\n    }\n    return longestString", "    var longestString:\
    \ String?\n    for string in strings {\n        if let longestString = longestString\
    \ {\n            if longestString.characters.count < string.characters.count {\n\
    \                longestString = string\n            }\n        } else {\n   \
    \         longestString = string\n        }\n    }\n    return longestString",
  '    return strings.reduce(nil) { $0 != nil && $0!.count > $1.count ? $0 : $1 }',
  "    guard let firstString = strings.first else {\n        return nil\n    }\n \
    \   return strings.reduce(firstString) { longest, string in\n        if string.count\
    \ > longest.count {\n            return string\n        }\n        return longest\n\
    \    }", "    var maxLen: Int = 0\n    var result: String? = nil\n    for str\
    \ in strings {\n        if str.characters.count > maxLen {\n            maxLen\
    \ = str.characters.count\n            result = str\n        }\n    }\n    return\
    \ result", '  return nil', '    return strings.max()', "    if strings.isEmpty\
    \ {\n        return nil\n    } else {\n        var longest = strings[0]\n    \
    \    for index in 1..<strings.count {\n            if strings[index].count > longest.count\
    \ {\n                longest = strings[index]\n            }\n        }\n    \
    \    return longest\n    }", "    if strings.isEmpty {\n        return nil\n \
    \   }\n    var longestString = strings[0]\n    for string in strings {\n     \
    \   if string.count > longestString.count {\n            longestString = string\n\
    \        }\n    }\n    return longestString", '    return strings.sort(by: { $0.count
    > $1.count }).first', "    var longestString: String?\n    for string in strings\
    \ {\n        if longestString == nil || string.count > longestString!.count {\n\
    \            longestString = string\n        }\n    }\n    return longestString",
  "    guard !strings.isEmpty else { return nil }\n    return strings.reduce(strings[0])\
    \ { (s, a) in a.count > s.count ? a : s }", "  //code\n  var longestString: String?\n\
    \  for str in strings {\n    if longestString == nil {\n      longestString =\
    \ str\n    } else if str.count > longestString!.count {\n      longestString =\
    \ str\n    }\n  }\n  return longestString", "    guard strings.count > 0 else\
    \ {\n        return nil\n    }\n    return strings.reduce(strings[0]) { $1.count\
    \ > $0.count ? $1 : $0 }", "    \n    // The output is an optional string, because\
    \ there might be no longest string\n    var longestString: String? = nil\n   \
    \ \n    // Iterate the input array\n    for string in strings {\n        \n  \
    \      // Check if the string is longer than the previous longest string\n   \
    \     if longestString == nil || longestString!.characters.count < string.characters.count\
    \ {\n            \n            // If so, set the new longest string\n        \
    \    longestString = string\n        }\n    }\n    \n    // Return the longest\
    \ string\n    return longestString", "    var max: String? = nil\n    for s in\
    \ strings {\n        if (max == nil || s.characters.count > max!.characters.count)\
    \ {\n            max = s\n        }\n    }\n    return max", "    guard !strings.isEmpty\
    \ else { return nil }\n    var maxLength = strings[0].characters.count\n    var\
    \ currentString = strings[0]\n    for i in 1..<strings.count {\n        if strings[i].characters.count\
    \ > maxLength {\n            maxLength = strings[i].characters.count\n       \
    \     currentString = strings[i]\n        }\n    }\n    return currentString",
  "    var longestString: String?\n    for string in strings {\n        if let longestString\
    \ = longestString {\n            if string.count > longestString.count {\n   \
    \             longestString = string\n            }\n        } else {\n      \
    \      longestString = string\n        }\n    }\n    return longestString", " \
    \   var result: String? = nil\n    for string in strings {\n        if result\
    \ == nil || count(string) > count(result!) {\n            result = string\n  \
    \      }\n    }\n    return result", "    var longest: String? = nil\n    for\
    \ s in strings {\n        if (longest == nil || s.characters.count > longest!.characters.count)\
    \ {\n            longest = s\n        }\n    }\n    return longest", "    if strings.isEmpty\
    \ {\n        return nil\n    }\n    var ans = strings[0]\n    for str in strings\
    \ {\n        if str.count > ans.count {\n            ans = str\n        }\n  \
    \  }\n    return ans", "    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longestString = strings[0]\n    for string in strings {\n        if string.count\
    \ > longestString.count {\n            longestString = string\n        }\n   \
    \ }\n    return longestString", "    guard !strings.isEmpty else { return nil\
    \ }\n    return strings.reduce(strings[0]) {\n        $0.count > $1.count ? $0\
    \ : $1\n    }", "    var longestString = strings.first\n    for string in strings\
    \ {\n        if let longestString = longestString {\n            if string.count\
    \ > longestString.count {\n                longestString = string\n          \
    \  }\n        }\n    }\n    return longestString", "    guard let first = strings.first\
    \ else { return nil }\n    return strings.reduce(first) { longest, next in\n \
    \       next.count > longest.count ? next : longest\n    }", "    guard strings.count\
    \ > 0 else {\n        return nil\n    }\n    var longest = strings[0]\n    for\
    \ string in strings {\n        if string.count > longest.count {\n           \
    \ longest = string\n        }\n    }\n    return longest", "    guard !strings.isEmpty\
    \ else { return nil }\n    return strings.max { $0.count < $1.count }", "    //\
    \ Your code here\n    if strings.count == 0 {\n        return nil\n    }\n   \
    \ var output = strings[0]\n    for i in 1...strings.count-1 {\n        if strings[i].count\
    \ > output.count {\n            output = strings[i]\n        }\n    }\n    return\
    \ output", "    guard !strings.isEmpty else { return nil }\n    var longest =\
    \ strings[0]\n    for string in strings {\n        if string.count > longest.count\
    \ {\n            longest = string\n        }\n    }\n    return longest"]
stop_tokens:
- "\n}"
