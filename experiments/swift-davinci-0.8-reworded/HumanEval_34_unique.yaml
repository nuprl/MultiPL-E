name: HumanEval_34_unique
language: swift
prompt: "\n/// Return sorted unique elements in an array\n/// >>> unique(l: [5, 3,\
  \ 5, 2, 3, 3, 9, 0, 123])\n/// [0, 2, 3, 5, 9, 123]\nfunc unique(l: [Int]) -> [Int]\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(unique(l: [5, 3, 5, 2, 3, 3, 9, 0, 123])\
  \ == [0, 2, 3, 5, 9, 123])"
completions: ["  let sorted = l.sorted()\n  var ia = l.startIndex\n  var ib = ia.advanced(by:\
    \ 1)\n  var list = [Int]()\n  while ib < sorted.endIndex {\n    if sorted[ia]\
    \ != sorted[ib] {\n      list.append(sorted[ia])\n      ia = ib\n    }\n    ib\
    \ = ib.advanced(by: 1)\n  }\n  list.append(sorted[ia])\n  return list", '    return
    Array(Set(l)).sorted()', "    var r: [Int] = []\n    for n in l {\n        if\
    \ !r.contains(n) {\n            r.append(n)\n        }\n    }\n    return r.sorted()",
  "    var u = [Int]()\n    l.forEach { e in\n        if !u.contains(e) {\n      \
    \      u.append(e)\n        }\n    }\n    return u.sorted()", "    var set = Set<Int>()\n\
    \    for element in l {\n        set.insert(element)\n    }\n    return set.sorted()",
  '    return Array(Set(l)).sorted()', '    return Set(l).sorted()', "    var result\
    \ = [Int]()\n    for value in l {\n        if !result.contains(value) {\n    \
    \        result.append(value)\n        }\n    }\n    return result.sorted()",
  '    return l.reduce([]) { (uniques, n) in uniques.contains(n) ? uniques : uniques
    + [n] }', "    var set = Set<Int>()\n    for i in l {\n        set.insert(i)\n\
    \    }\n    let sorted = set.sorted()\n    return sorted", "    var result = [Int]()\n\
    \    for i in l {\n        if !result.contains(i) {\n            result.append(i)\n\
    \        }\n    }\n    return result.sorted()", "    let l = Set(l)\n    return\
    \ Array(l).sorted()", '    return Array(Set(l)).sorted()', '    return Set(l).sorted()',
  '    return Array(Set(l)).sorted()', '    return Set(l).sorted()', "    var r =\
    \ [Int]()\n    for i in l {\n        if !r.contains(i) {\n            r.append(i)\n\
    \        }\n    }\n    return r.sorted()", "    let array = l.sorted()\n    var\
    \ result: [Int] = []\n    for item in array {\n        if !result.contains(item)\
    \ {\n            result.append(item)\n        }\n    }\n    return result", " \
    \   var list: [Int] = []\n    for item in l {\n        if !list.contains(item)\
    \ {\n            list.append(item)\n        }\n    }\n    return list.sorted()",
  "    // TODO: Implement this method so that it returns an array\n    // of unique\
    \ items from the input array. If a number appears\n    // multiple times in the\
    \ input array, it should only be\n    // included once in the result.\n    return\
    \ []", '    return Array(Set(l)).sorted()', '    return Array(Set(l))', "    var\
    \ s = Set<Int>()\n    for e in l {\n        s.insert(e)\n    }\n    return s.sort({\
    \ $0 < $1 })", "    var set = Set<Int>()\n    var result = [Int]()\n    for i\
    \ in l {\n        if !set.contains(i) {\n            set.insert(i)\n         \
    \   result.append(i)\n        }\n    }\n    return result", "    let set = Set(l)\n\
    \    return Array(set).sorted(by: <)", '    return Array(Set(l))', "    var l\
    \ = l\n    l.sortInPlace()\n    let length = l.count\n    var last = l[0]\n  \
    \  var p = 1\n    for i in 1..<length {\n        if last != l[i] {\n         \
    \   l[p] = l[i]\n            p += 1\n            last = l[i]\n        }\n    }\n\
    \    return Array(l[0..<p])", '    return Array(Set(l)).sorted()', "    var unique\
    \ = [Int]()\n    for e in l {\n        if !unique.contains(e) {\n            unique.append(e)\n\
    \        }\n    }\n    return unique.sorted()", "    var result = [Int]()\n  \
    \  for item in l {\n        if !result.contains(item) {\n            result.append(item)\n\
    \        }\n    }\n    return result.sorted()", "    var u = [Int]()\n    for\
    \ x in l {\n        if !u.contains(x) {\n            u.append(x)\n        }\n\
    \    }\n    return u.sorted()", "    var seen: [Int: Bool] = [:]\n    return l.filter\
    \ { seen.updateValue(true, forKey: $0) == nil }", "    var list = l\n    list.sortInPlace()\n\
    \    var last: Int?\n    for (index, item) in list.enumerate() {\n        if last\
    \ == item {\n            list.removeAtIndex(index)\n        }\n        last =\
    \ item\n    }\n    return list", "    var lUnique = [Int]()\n    var lSorted =\
    \ l.sorted()\n    var currentNum = lSorted[0]\n    lUnique.append(currentNum)\n\
    \    for num in lSorted {\n        if num > currentNum {\n            lUnique.append(num)\n\
    \            currentNum = num\n        }\n    }\n    return lUnique", "    let\
    \ sorted = l.sorted()\n    var new = [Int]()\n    for i in sorted {\n        if\
    \ !new.contains(i) {\n            new.append(i)\n        }\n    }\n    return\
    \ new", '    return Array(Set(l)).sorted()', "    let sorted = l.sorted()\n  \
    \  return sorted.reduce([], { (res, next) -> [Int] in\n        if res.count ==\
    \ 0 || res.last! != next {\n            return res + [next]\n        } else {\n\
    \            return res\n        }\n    })", '    return Array(Set(l))', '    return
    Array(Set(l)).sorted(by: <)', "    var u: [Int] = []\n    for v in l {\n     \
    \   if !u.contains(v) {\n            u.append(v)\n        }\n    }\n    return\
    \ u.sorted()", '    return Array(Set(l))', '    return Array(Set(l))', '    return
    Array(Set(l)).sorted()', '    return Array(Set(l)).sorted()', "  let set = Set(l)\n\
    \  return Array(set).sorted()", '    return Array(Set(l)).sorted(by: <)', '    return
    Array(Set(l)).sorted()', "    let uniq = Array(Set(l))\n    return uniq.sorted()",
  "    let sortedUnique = Array(Set(l)).sorted()\n    return sortedUnique", '    return
    Array(Set(l)).sorted(by: <)', '    return Array(Set(l)).sorted()', '    return
    Array(Set(l)).sorted()', "    var a = l\n    a.sort(<)\n    return a.filter({\
    \ (a, i) in i == 0 || a != a[i - 1] })", '    return l.reduce([]) { ($0.contains($1))
    ? $0 : $0 + [$1] }', '  return Array(Set(l)).sorted()', "    var unique = [Int]()\n\
    \    var uniqueSet = Set<Int>()\n    for i in l {\n        if !uniqueSet.contains(i)\
    \ {\n            uniqueSet.insert(i)\n            unique.append(i)\n        }\n\
    \    }\n    return unique", '    return Array(Set(l)).sorted()', "    var unique\
    \ = [Int]()\n    for i in l {\n        if !unique.contains(i) {\n            unique.append(i)\n\
    \        }\n    }\n    return unique.sorted()", "    return l.reduce([]) {\n \
    \       $0.contains($1) ? $0 : $0 + [$1]\n    }", '    return Set(l).sorted()',
  '    return Array(Set(l))', "  var uniq = [Int]()\n  for n in l {\n    if !uniq.contains(n)\
    \ {\n      uniq.append(n)\n    }\n  }\n  return uniq.sorted()", "    return l.sorted().reduce([])\
    \ {\n        $0.last == $1 ? $0 : $0 + [$1]\n    }", "    var uniq = [Int]()\n\
    \    for i in l {\n        if !uniq.contains(i) {\n            uniq.append(i)\n\
    \        }\n    }\n    return uniq.sorted()", '    return Array(Set(l)).sorted()',
  "    let orderedSet = NSOrderedSet(array: l)\n    return orderedSet.array as! [Int]",
  '    return [Int](Set(l))', '    return Array(Set(l))', "    // Use a dictionary\
    \ to track what elements have been seen before\n    var seen = [Int: Int]()\n\
    \    var unique = [Int]()\n    for n in l {\n        if let _ = seen[n] {\n  \
    \          // This element has been seen before\n        } else {\n          \
    \  seen[n] = 1\n            unique.append(n)\n        }\n    }\n    return unique.sorted()",
  "    var out: [Int] = []\n    for e in l {\n        if !out.contains(e) {\n    \
    \        out.append(e)\n        }\n    }\n    return out.sorted()", "    var result\
    \ = [Int]()\n    for x in l {\n        if !result.contains(x) {\n            result.append(x)\n\
    \        }\n    }\n    return result.sorted()", '    return Array(Set(l)).sorted()',
  "    var u = [Int]()\n    for e in l {\n        if !u.contains(e) {\n          \
    \  u.append(e)\n        }\n    }\n    return u.sorted()", '    return Array(Set(l)).sorted()',
  "    var uni = [Int]()\n    for x in l {\n        if !uni.contains(x) {\n      \
    \      uni.append(x)\n        }\n    }\n    return uni.sorted()", "    var o =\
    \ [Int]()\n    for i in l {\n        if !o.contains(i) {\n            o.append(i)\n\
    \        }\n    }\n    return o.sorted()", "    var tmp = [Int:Int]()\n    for\
    \ i in l {\n        tmp[i] = 1\n    }\n    return Array(tmp.keys).sorted()", " \
    \   return l.reduce([], { uniqued, elem in\n        uniqued.contains(elem) ? uniqued\
    \ : uniqued + [elem]\n    })", '    return Array(Set(l)).sorted()', "    var set\
    \ = Set<Int>()\n    for i in l {\n        set.insert(i)\n    }\n    return Array(set).sorted()",
  "    var mutableList = l\n    mutableList.sort()\n    mutableList = mutableList.filter\
    \ {\n        !$0.isNaN\n    }\n    return mutableList.reduce([]) {\n        accum,\
    \ element in\n        if !accum.contains(element) {\n            return accum\
    \ + [element]\n        } else {\n            return accum\n        }\n    }",
  '    return Array(Set(l)).sorted()', "    var ret = [Int]()\n    for item in l {\n\
    \        if !ret.contains(item) {\n            ret.append(item)\n        }\n \
    \   }\n    return ret.sorted()", "    var uniqueElements = [Int]()\n    for item\
    \ in l {\n        if !uniqueElements.contains(item) {\n            uniqueElements.append(item)\n\
    \        }\n    }\n    return uniqueElements.sorted()", '    return l.filter({
    l.index(of: $0) == l.firstIndex(of: $0) })', '    return [Int](Set(l))', '    return
    Array(Set(l))', "    var list = l\n    for i in 0..<list.count {\n        for\
    \ j in (i + 1)..<list.count {\n            if list[i] == list[j] {\n         \
    \       list.remove(at: j)\n                j -= 1\n            }\n        }\n\
    \    }\n    return list", "    var result = [Int]()\n    var uniques = Set<Int>()\n\
    \    for e in l {\n        if !uniques.contains(e) {\n            uniques.insert(e)\n\
    \            result.append(e)\n        }\n    }\n    return result", "    var\
    \ seen = Set<Int>()\n    var result = [Int]()\n    for item in l {\n        if\
    \ seen.contains(item) { continue }\n        seen.insert(item)\n        result.append(item)\n\
    \    }\n    return result", '    return Array(Set(l)).sorted()', '    return Array(Set(l))',
  '    return Array(Set(l)).sorted()', '    return Array(Set(l))', '    return Array(Set(l)).sorted()',
  '    return Array(Set(l)).sorted()', "    var list = l\n    for i in 0..<list.count\
    \ {\n        for j in 0..<list.count {\n            if list[i] == list[j] && i\
    \ != j {\n                list.remove(at: j)\n            }\n        }\n    }\n\
    \    return list", '    return Set(l).sorted()', '  return Array(Set(l)).sorted()',
  '    return Array(Set(l)).sorted()', "    var sortedUnique = [Int]()\n    for x\
    \ in l {\n        if !sortedUnique.contains(x) {\n            sortedUnique.append(x)\n\
    \        }\n    }\n    return sortedUnique.sorted()", "    let res = l.reduce([])\
    \ { (m: [Int], n: Int) -> [Int] in\n        if !m.contains(n) {\n            return\
    \ m + [n]\n        }\n        return m\n    }\n    return res.sorted()", "   \
    \ var elements = [Int]()\n    for i in l {\n        if !elements.contains(i) {\n\
    \            elements.append(i)\n        }\n    }\n    return elements.sorted()",
  "    var s = Set<Int>()\n    for i in l {\n        s.insert(i)\n    }\n    let sorted\
    \ = s.sorted()\n    return sorted", "    let sorted = l.sorted()\n    var result:\
    \ [Int] = []\n    for i in sorted {\n        if result.last != i {\n         \
    \   result.append(i)\n        }\n    }\n    return result", "    var result =\
    \ [Int]()\n    var seen = Set<Int>()\n    for i in l {\n        if !seen.contains(i)\
    \ {\n            result.append(i)\n            seen.insert(i)\n        }\n   \
    \ }\n    return result", '    return l.reduce([]) { $0.contains($1) ? $0 : $0
    + [$1] }', "    var result = [Int]()\n    var unique = Set<Int>()\n    for item\
    \ in l {\n        if !unique.contains(item) {\n            unique.insert(item)\n\
    \            result.append(item)\n        }\n    }\n    return result", "  var\
    \ res = l\n  res.sort()\n  var last = 0\n  for i in 0..<res.count {\n    if res[i]\
    \ != last {\n      last = res[i]\n    } else {\n      res.removeAtIndex(i)\n \
    \     i--\n    }\n  }\n  return res", "    let elements = NSMutableSet()\n   \
    \ for item in l {\n        elements.addObject(item)\n    }\n    return elements.allObjects\
    \ as! [Int]", '    return Array(Set(l)).sorted()', "    let u = Set(l)\n    return\
    \ Array(u).sorted()", "    let ret = Array(Set(l))\n    return ret.sorted()",
  "    let n = l.count\n    if n < 2 {\n        return l\n    }\n    let res = l.sorted()\n\
    \    var i = 0\n    var j = 1\n    while j < n {\n        if res[i] != res[j]\
    \ {\n            i += 1\n            res[i] = res[j]\n        }\n        j +=\
    \ 1\n    }\n    return Array(res[0...i])", "    var ret = l\n    ret.sort(<)\n\
    \    ret = Array(Set(ret))\n    return ret", '    return Array(Set(l)).sorted()',
  '  return Array(Set(l)).sorted()', "    var list = l\n    list.sort()\n    var result:\
    \ [Int] = []\n    var last = -1\n    for x in list {\n        if x != last {\n\
    \            result.append(x)\n            last = x\n        }\n    }\n    return\
    \ result", "    var res = [Int]()\n    var added = Set<Int>()\n    for x in l\
    \ {\n        if !added.contains(x) {\n            res.append(x)\n            added.insert(x)\n\
    \        }\n    }\n    return res", '    return Array(Set(l)).sorted()', "   \
    \ let sortedUniques = l.sorted().reduce([]) {\n        (acc, num) -> [Int] in\n\
    \        if acc.last != num {\n            return acc + [num]\n        } else\
    \ {\n            return acc\n        }\n    }\n    return sortedUniques", "  \
    \  var arr = l\n    arr.sort()\n    let result = arr.reduce([]) { (acc, i) ->\
    \ [Int] in\n        if acc.last != i {\n            return acc + [i]\n       \
    \ } else {\n            return acc\n        }\n    }\n    return result", "  \
    \  var result = [Int]()\n    for element in l {\n        if !result.contains(element)\
    \ {\n            result.append(element)\n        }\n    }\n    return result.sorted()",
  "    var b: [Int] = []\n    for i in l {\n        if !b.contains(i) {\n        \
    \    b.append(i)\n        }\n    }\n    return b.sorted()", "  var r = Set<Int>()\n\
    \  l.forEach { r.insert($0) }\n  return Array(r).sorted()", '    return Array(Set(l))',
  "    var seen = Set<Int>()\n    return l.filter {\n        seen.insert($0).inserted\n\
    \    }", '    return Array(Set(l)).sorted()', "    var result = [Int]()\n    for\
    \ element in l {\n        if !result.contains(element) {\n            result.append(element)\n\
    \        }\n    }\n    return result.sorted()", '    return Array(Set(l)).sorted()',
  "    var s = Set<Int>()\n    for i in l {\n        s.insert(i)\n    }\n    return\
    \ Array(s).sorted()", "    let u = Set(l)\n    return Array(u).sorted()", "  var\
    \ u = l\n  u.sort(<)\n  return u.reduce([Int]()) { $0.last == $1 ? $0 : $0 + [$1]\
    \ }", '    return Array(Set(l)).sorted()', "  let set = Set(l)\n  return Array(set).sorted()",
  "    var set = Set<Int>()\n    for el in l {\n        set.insert(el)\n    }\n  \
    \  let a = Array(set)\n    return a.sorted()", "    var u: [Int] = []\n    for\
    \ item in l {\n        if !u.contains(item) {\n            u.append(item)\n  \
    \      }\n    }\n    return u.sorted()", '    return Array(Set(l)).sorted()',
  '    return Array(Set(l)).sorted()', '    return Array(Set(l)).sorted()', "    var\
    \ res = [Int]()\n    for n in l {\n        if !res.contains(n) {\n           \
    \ res.append(n)\n        }\n    }\n    return res.sorted()", "    var uniques\
    \ = [Int]()\n    for i in l {\n        if !uniques.contains(i) {\n           \
    \ uniques.append(i)\n        }\n    }\n    return uniques.sorted()", "    let\
    \ sortedList = l.sorted(by: <)\n    var result = [Int]()\n    var previous: Int?\n\
    \    for current in sortedList {\n        if let previous = previous {\n     \
    \       if current != previous {\n                result.append(current)\n   \
    \         }\n        } else {\n            result.append(current)\n        }\n\
    \        previous = current\n    }\n    return result", '    return Array(Set(l))',
  "    var result = [Int]()\n    for i in l {\n        if !result.contains(i) {\n\
    \            result.append(i)\n        }\n    }\n    return result.sorted()",
  "    var m = [Int: Int]()\n    for e in l {\n        m[e] = 1\n    }\n    return\
    \ Array(m.keys).sorted()", '    return Array(Set(l)).sorted()', "    var array\
    \ = l\n    array.sort()\n    var result = [Int]()\n    for i in 0..<array.count\
    \ {\n        if i == 0 || array[i] != array[i-1] {\n            result.append(array[i])\n\
    \        }\n    }\n    return result", "    var tmp = [Int]()\n    for e in l\
    \ {\n        if !tmp.contains(e) {\n            tmp.append(e)\n        }\n   \
    \ }\n    return tmp.sorted()", "    let s = Set(l)\n    return Array(s).sorted()",
  '    return Array(Set(l)).sorted()', "    return l.reduce([], {\n        if !$0.contains($1)\
    \ {\n            return $0 + [$1]\n        } else {\n            return $0\n \
    \       }\n    })", '  return Array(Set(l)).sorted(by: <)', "    var t = l\n \
    \   for i in 0..<t.count {\n        for j in i+1..<t.count {\n            if t[i]\
    \ == t[j] {\n                t.remove(at: j)\n                j -= 1\n       \
    \     }\n        }\n    }\n    return t", '    return Array(Set(l)).sorted(by:
    <)', '    return Array(Set(l)).sorted()', '    return Array(Set(l)).sorted()',
  '    return Array(Set(l)).sorted()', '    return Set(l).sorted()', '    return Array(Set(l)).sorted()',
  '  return Array(Set(l))', '    return Array(Set(l)).sorted()', '    return Set(l).sorted()',
  '    return Array(Set(l)).sorted()', "    var list = l\n    for i in 0..<list.count\
    \ {\n        var j = i + 1\n        while j < list.count {\n            if list[i]\
    \ == list[j] {\n                list.remove(at: j)\n            } else {\n   \
    \             j += 1\n            }\n        }\n    }\n    return list", '    return
    Array(Set(l)).sorted()', '  return Array(Set(l)).sorted(by: <)', '    return Array(Set(l)).sorted()',
  "    var map = [Int: Int]()\n    for i in l {\n        map[i] = 0\n    }\n    return\
    \ map.keys.sort()", '    return Array(Set(l))', "    var seen = Set<Int>()\n \
    \   return l.filter { seen.insert($0).inserted }", "    let sortedUnique = Array(Set(l)).sorted()\n\
    \    return sortedUnique", "    var set = Set<Int>()\n    for item in l {\n  \
    \      set.insert(item)\n    }\n    return Array(set).sorted()", '    return Array(Set(l)).sorted()',
  '    return Array(Set(l))', '    return Array(Set(l)).sorted()', '    return Array(Set(l)).sorted()',
  '    return Array(Set(l)).sorted()', "    return l.reduce([], { (result, new) in\n\
    \        if !result.contains(new) {\n            return result + [new]\n     \
    \   }\n        return result\n    })", '    return Array(Set(l)).sorted(by: <)',
  "    var result = [Int]()\n    for item in l {\n        if !result.contains(item)\
    \ {\n            result.append(item)\n        }\n    }\n    return result.sorted()",
  "    let arraySet = NSSet(array: l)\n    return arraySet.allObjects as! [Int]",
  "    let sorted = l.sorted()\n    return sorted.reduce([Int]()) { acc, curr in\n\
    \        return acc.last == curr ? acc : acc + [curr]\n    }", "    var dict =\
    \ [Int: Bool]()\n    var list = [Int]()\n    for i in l {\n        if dict[i]\
    \ == nil {\n            dict[i] = true\n            list.append(i)\n        }\n\
    \    }\n    return list.sorted(by: <)", "    var a = l\n    var u = [Int]()\n\
    \    a.sort()\n    for (i, v) in a.enumerate() {\n        if i == 0 || a[i-1]\
    \ != v {\n            u.append(v)\n        }\n    }\n    return u", '    return
    Array(Set(l)).sorted()', "    var uniqueList = [Int]()\n    for item in l {\n\
    \        if !uniqueList.contains(item) {\n            uniqueList.append(item)\n\
    \        }\n    }\n    return uniqueList.sorted()", '    return Array(Set(l))',
  '    return Array(Set(l)).sorted()', "    var seen = Set<Int>()\n    return l.filter\
    \ { seen.insert($0).inserted }", "    var d = [Int: Bool]()\n    for i in l {\n\
    \        d[i] = true\n    }\n    let keys = Array(d.keys)\n    return keys.sorted()",
  "    var result = [Int]()\n    for i in l {\n        if !result.contains(i) {\n\
    \            result.append(i)\n        }\n    }\n    return result.sorted()",
  "    var ret : [Int] = []\n    for i in l {\n        if !ret.contains(i) {\n   \
    \         ret.append(i)\n        }\n    }\n    return ret.sorted()", '  return
    Array(Set(l)).sorted()', '    return Set(l).sorted()', '    return Array(Set(l)).sorted()',
  '  return Array(Set(l)).sorted()', "    let u = Set(l)\n    return Array(u).sorted()",
  "    var u = [Int]()\n    for i in l {\n        if !u.contains(i) {\n          \
    \  u.append(i)\n        }\n    }\n    return u.sorted()", "    var result = [Int]()\n\
    \    for elem in l {\n        if !result.contains(elem) {\n            result.append(elem)\n\
    \        }\n    }\n    return result.sorted()"]
stop_tokens:
- "\n}"
