name: HumanEval_57_monotonic
language: swift
prompt: "\n/// Return true is array elements are monotonically increasing or decreasing.\n\
  /// >>> monotonic(l: [1, 2, 4, 20])\n/// true\n/// >>> monotonic(l: [1, 20, 4, 10])\n\
  /// false\n/// >>> monotonic(l: [4, 1, 0, -10])\n/// true\nfunc monotonic(l: [Int])\
  \ -> Bool {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(monotonic(l: [1, 2, 4, 10]) == true)\nassert(monotonic(l:\
  \ [1, 2, 4, 20]) == true)\nassert(monotonic(l: [1, 20, 4, 10]) == false)\nassert(monotonic(l:\
  \ [4, 1, 0, -10]) == true)\nassert(monotonic(l: [4, 1, 1, 0]) == true)\nassert(monotonic(l:\
  \ [1, 2, 3, 2, 5, 60]) == false)\nassert(monotonic(l: [1, 2, 3, 4, 5, 60]) == true)\n\
  assert(monotonic(l: [9, 9, 9, 9]) == true)"
completions: ["    if l.count <= 2 {\n        return true\n    }\n    let increasing\
    \ = l[0] < l[1]\n    for index in 1..<l.count-1 {\n        if l[index] == l[index+1]\
    \ {\n            continue\n        }\n        if increasing != (l[index] < l[index+1])\
    \ {\n            return false\n        }\n    }\n    return true", '    return
    l.sorted() == l || l.sorted(by: >) == l', "    let s = l.sorted()\n    return\
    \ s == l || s.reversed() == l", '    return increasing(l: l) || decreasing(l:
    l)', "    let length = l.count\n    if length <= 2 {\n        return true\n  \
    \  }\n    var direction = 0\n    for i in 1..<length {\n        if l[i] > l[i\
    \ - 1] {\n            if direction == 0 {\n                direction = 1\n   \
    \         } else if direction == -1 {\n                return false\n        \
    \    }\n        } else if l[i] < l[i - 1] {\n            if direction == 0 {\n\
    \                direction = -1\n            } else if direction == 1 {\n    \
    \            return false\n            }\n        }\n    }\n    return true",
  "  var incre = true\n  var decre = true\n  for i in 1..<l.count {\n    if l[i] >\
    \ l[i - 1] {\n      decre = false\n    }\n    if l[i] < l[i - 1] {\n      incre\
    \ = false\n    }\n  }\n  return incre || decre", '    return increasing(l: l)
    || decreasing(l: l)', "\tguard l.count > 1 else { return true }\n\tvar increasing\
    \ = true\n\tfor i in 1..<l.count {\n\t\tif l[i] < l[i - 1] {\n\t\t\tincreasing\
    \ = false\n\t\t\tbreak\n\t\t}\n\t}\n\tif increasing { return true }\n\tfor i in\
    \ 1..<l.count {\n\t\tif l[i] > l[i - 1] {\n\t\t\treturn false\n\t\t}\n\t}\n\t\
    return true", "    var prev = l[0]\n    var inc = false\n    var dec = false\n\
    \    for i in 1..<l.count {\n        if l[i] > prev {\n            inc = true\n\
    \        } else if l[i] < prev {\n            dec = true\n        }\n        if\
    \ inc && dec {\n            return false\n        }\n        prev = l[i]\n   \
    \ }\n    return true", "    guard l.count > 1 else { return true }\n    var direction:\
    \ Bool = false\n    for i in 1..<l.count {\n        if l[i - 1] == l[i] { continue\
    \ }\n        if direction && l[i - 1] > l[i] { return false }\n        if !direction\
    \ && l[i - 1] < l[i] { return false }\n        direction = !direction\n    }\n\
    \    return true", "    var n = 0\n    var n1 = 0\n    var flag = true\n    while(n\
    \ < l.count - 1){\n        if(l[n] < l[n+1]){\n            flag = true\n     \
    \       n1 = n1 + 1\n        }\n        else if(l[n] > l[n+1]){\n            flag\
    \ = false\n            n1 = n1 + 1\n        }\n        else{\n            n1 =\
    \ n1 + 1\n        }\n        n = n + 1\n    }\n    if(n1 == l.count - 1){\n  \
    \      return true\n    }\n    else{\n        return false\n    }", "    let n\
    \ = l.count\n    if n <= 2 {\n        return true\n    }\n    var p: Int?\n  \
    \  for i in 0..<n {\n        if let prev = p {\n            if l[i] == prev {\n\
    \                continue\n            }\n            if l[i] < prev {\n     \
    \           if l[i-1] > prev {\n                    return false\n           \
    \     }\n            } else {\n                if l[i-1] < prev {\n          \
    \          return false\n                }\n            }\n        }\n       \
    \ p = l[i]\n    }\n    return true", "  if l.count <= 2 {\n    return true\n \
    \ }\n  let sign = l[1] - l[0]\n  for i in 1..<l.count {\n    if (l[i] - l[i -\
    \ 1]) * sign < 0 {\n      return false\n    }\n  }\n  return true", "    if l.count\
    \ <= 2 {\n        return true\n    }\n    var dir = l[1] - l[0]\n    for i in\
    \ 1..<l.count {\n        if dir == 0 {\n            dir = l[i] - l[i - 1]\n  \
    \          continue\n        }\n        if (dir > 0 && l[i] < l[i - 1]) || (dir\
    \ < 0 && l[i] > l[i - 1]) {\n            return false\n        }\n    }\n    return\
    \ true", "    let sorted = l.sorted()\n    return sorted == l || sorted.reversed()\
    \ == l", "    var increasing = true\n    var decreasing = true\n    for i in 1..<l.count\
    \ {\n        if l[i] > l[i-1] {\n            decreasing = false\n        }\n \
    \       if l[i] < l[i-1] {\n            increasing = false\n        }\n    }\n\
    \    return increasing || decreasing", "    var decreasing = true\n    var increasing\
    \ = true\n    for i in 1..<l.count {\n        if l[i] < l[i - 1] {\n         \
    \   increasing = false\n        }\n        if l[i] > l[i - 1] {\n            decreasing\
    \ = false\n        }\n    }\n    return increasing || decreasing", "    var bIncreasing\
    \ = true\n    var bDecreasing = true\n    for i in 1..<l.count {\n        if l[i]\
    \ < l[i-1] {\n            bIncreasing = false\n        }\n        if l[i] > l[i-1]\
    \ {\n            bDecreasing = false\n        }\n    }\n    return bIncreasing\
    \ || bDecreasing", "    var asc = true\n    var desc = true\n    for i in 1..<l.count\
    \ {\n        asc = asc && l[i] >= l[i - 1]\n        desc = desc && l[i] <= l[i\
    \ - 1]\n    }\n    return asc || desc", "    if l.count < 3 {\n        return\
    \ true\n    }\n    var increase = true\n    var decrease = true\n    for i in\
    \ 0..<l.count - 1 {\n        if l[i] > l[i + 1] {\n            increase = false\n\
    \        }\n        if l[i] < l[i + 1] {\n            decrease = false\n     \
    \   }\n    }\n    return increase || decrease", "  if l.count < 3 {\n    return\
    \ true\n  }\n  var isIncreasing = l[1] > l[0]\n  for i in 1..<l.count - 1 {\n\
    \    if l[i + 1] == l[i] {\n      continue\n    }\n    if isIncreasing != (l[i\
    \ + 1] > l[i]) {\n      return false\n    }\n  }\n  return true", "    guard !l.isEmpty\
    \ else { return true }\n    var direction = l[1] - l[0]\n    for i in 1..<l.count-1\
    \ {\n        if direction == 0 {\n            direction = l[i+1] - l[i]\n    \
    \        continue\n        }\n        if breaksDirection(l[i], l[i+1], direction)\
    \ {\n            return false\n        }\n    }\n    return true", "    var incr:\
    \ Bool?\n    var decr: Bool?\n    for i in 1..<l.count {\n        if l[i] > l[i-1]\
    \ {\n            incr = true\n        } else if l[i] < l[i-1] {\n            decr\
    \ = true\n        }\n        if incr != nil && decr != nil {\n            return\
    \ false\n        }\n    }\n    return true", "    guard l.count > 1 else { return\
    \ true }\n    var decreasing = false\n    for idx in 1..<l.count {\n        if\
    \ l[idx] == l[idx - 1] { continue }\n        if l[idx] < l[idx - 1] {\n      \
    \      if decreasing { return false }\n            decreasing = true\n       \
    \ } else if decreasing {\n            return false\n        }\n    }\n    return\
    \ true", "    return l.reduce((l[0], l[1])) { (minmax, i) in\n        (min(minmax.0,\
    \ i), max(minmax.1, i))\n    }.0 <= l[0] || l.reduce((l[0], l[1])) { (minmax,\
    \ i) in\n        (min(minmax.0, i), max(minmax.1, i))\n    }.1 >= l[0]", "   \
    \ var type: String = \"decreasing\"\n    var type2: String = \"increasing\"\n\
    \    for i in 1..<l.count {\n        if l[i] > l[i-1] {\n            type = \"\
    increasing\"\n        } else if l[i] < l[i-1] {\n            type2 = \"decreasing\"\
    \n        }\n    }\n    return type == \"increasing\" || type2 == \"decreasing\"",
  "    var increasing = true\n    var decreasing = true\n    for i in 1..<l.count\
    \ {\n        if (l[i] > l[i-1]) {\n            decreasing = false\n        }\n\
    \        if (l[i] < l[i-1]) {\n            increasing = false\n        }\n   \
    \ }\n    return increasing || decreasing", "    var j = 0\n    while j < l.count\
    \ - 1 {\n        if l[j] == l[j + 1] {\n            j += 1\n        } else if\
    \ l[j] < l[j + 1] {\n            while j < l.count - 1 && l[j] <= l[j + 1] {\n\
    \                j += 1\n            }\n            if j == l.count - 1 {\n  \
    \              return true\n            } else {\n                return false\n\
    \            }\n        } else {\n            while j < l.count - 1 && l[j] >=\
    \ l[j + 1] {\n                j += 1\n            }\n            if j == l.count\
    \ - 1 {\n                return true\n            } else {\n                return\
    \ false\n            }\n        }\n    }\n    return true", "\tif l.count < 2\
    \ {\n\t\treturn true\n\t}\n\t\n\tlet max = l.max()!\n\tlet min = l.min()!\n\t\n\
    \tif max == min {\n\t\treturn true\n\t}\n\t\n\tlet len = l.count\n\tlet first\
    \ = l[0]\n\tlet last = l[len - 1]\n\tif first < last {\n\t\tfor i in 1..<len {\n\
    \t\t\tif l[i - 1] > l[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t} else {\n\
    \t\tfor i in 1..<len {\n\t\t\tif l[i - 1] < l[i] {\n\t\t\t\treturn false\n\t\t\
    \t}\n\t\t}\n\t}\n\t\n\treturn true", "    guard l.count > 1 else { return true\
    \ }\n    var positive = l[1] > l[0]\n    var negative = l[1] < l[0]\n    for i\
    \ in 1..<l.count {\n        if positive && l[i] < l[i - 1] {\n            return\
    \ false\n        }\n        if negative && l[i] > l[i - 1] {\n            return\
    \ false\n        }\n    }\n    return true", "    let sorted = l.sorted()\n  \
    \  return sorted == l || sorted.reversed() == l", "    guard !l.isEmpty else {\
    \ return true }\n    let first = l[0]\n    let increasing = first < l[1]\n   \
    \ for i in 1..<l.count {\n        if increasing {\n            if first > l[i]\
    \ { return false }\n        } else {\n            if first < l[i] { return false\
    \ }\n        }\n    }\n    return true", "    guard l.count > 2 else { return\
    \ true }\n    var delta = l[1] - l[0]\n    for i in 2..<l.count {\n        let\
    \ d = l[i] - l[i-1]\n        if delta == 0 {\n            delta = d\n        }\
    \ else if d * delta < 0 {\n            return false\n        }\n    }\n    return\
    \ true", "    if l.count < 3 {\n        return true\n    }\n    var incr = true\n\
    \    var decr = true\n    for (idx, _) in l.enumerated() {\n        if idx + 1\
    \ < l.count {\n            incr = incr && l[idx] <= l[idx + 1]\n            decr\
    \ = decr && l[idx] >= l[idx + 1]\n        }\n    }\n    return incr || decr",
  "    var prev = l[0]\n    var ascending = true\n    var descending = true\n    for\
    \ x in l {\n        if prev < x {\n            descending = false\n        } else\
    \ if prev > x {\n            ascending = false\n        }\n        prev = x\n\
    \    }\n    return ascending || descending", "    guard l.count > 1 else { return\
    \ true }\n    var a = l[0]\n    var i = 1\n    while i < l.count {\n        if\
    \ l[i] != a {\n            break\n        }\n        i += 1\n    }\n    guard\
    \ i < l.count else { return true }\n    let b = l[i]\n    let diff = b - a\n \
    \   for j in i + 1..<l.count {\n        if (l[j] - b) * diff < 0 {\n         \
    \   return false\n        }\n    }\n    return true", "    var inc = true\n  \
    \  var dec = true\n    for i in 1..<l.count {\n        if l[i] < l[i-1] {\n  \
    \          inc = false\n        }\n        if l[i] > l[i-1] {\n            dec\
    \ = false\n        }\n    }\n    return inc || dec", "    var inc = true\n   \
    \ var dec = true\n    for i in 1..<l.count {\n        if l[i] < l[i-1] {\n   \
    \         inc = false\n        }\n        if l[i] > l[i-1] {\n            dec\
    \ = false\n        }\n    }\n    return inc || dec", "    guard l.count > 1 else\
    \ { return true }\n    if l[0] < l[1] {\n        for i in 1..<l.count-1 {\n  \
    \          if l[i] > l[i+1] { return false }\n        }\n    } else {\n      \
    \  for i in 1..<l.count-1 {\n            if l[i] < l[i+1] { return false }\n \
    \       }\n    }\n    return true", "    if l.count <= 2 {\n        return true\n\
    \    }\n    var i = 1\n    while i < l.count - 1 {\n        if !(l[i] > l[i -\
    \ 1] && l[i] > l[i + 1] || l[i] < l[i - 1] && l[i] < l[i + 1]) {\n           \
    \ return false\n        }\n        i += 1\n    }\n    return true", "    if l.count\
    \ <= 2 {\n        return true\n    }\n    let step = l[1] - l[0]\n    for i in\
    \ 2..<l.count {\n        if (l[i] - l[i - 1]) * step < 0 {\n            return\
    \ false\n        }\n    }\n    return true", "  guard l.count > 1 else { return\
    \ true }\n  var i = 0\n  let inc = l[1] - l[0]\n  let dec = -inc\n  let direction\
    \ = inc > 0 ? 1 : (inc < 0 ? -1 : 0)\n  while i < l.count - 1 {\n    let diff\
    \ = l[i + 1] - l[i]\n    if diff == 0 {\n      i += 1\n      continue\n    }\n\
    \    if (direction == 1 && diff != inc) || (direction == -1 && diff != dec) {\n\
    \      return false\n    }\n    i += 1\n  }\n  return true", "    var previous\
    \ = l[0]\n    var increasing = true\n    for item in l {\n        if item < previous\
    \ {\n            increasing = false\n            break\n        }\n        previous\
    \ = item\n    }\n    if increasing {\n        return true\n    }\n    previous\
    \ = l[0]\n    var decreasing = true\n    for item in l {\n        if item > previous\
    \ {\n            decreasing = false\n            break\n        }\n        previous\
    \ = item\n    }\n    return decreasing", "\tif l.count <= 2 {\n\t\treturn true\n\
    \t}\n\tlet inc = l[1] - l[0] > 0\n\tfor i in 2..<l.count {\n\t\tif (l[i] - l[i\
    \ - 1] > 0) != inc {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true", "    let\
    \ l1 = l.sorted()\n    let l2 = l.sorted(by: >)\n    return l == l1 || l == l2",
  "    if l.count < 3 {\n        return true\n    }\n    let diffs = l.enumerated().map\
    \ { (i, x) -> Int in\n        return i == 0 ? 0 : x - l[i - 1]\n    }\n    var\
    \ _diffs = diffs\n    _diffs.removeFirst()\n    return (Set(_diffs).count <= 1)",
  "    if l.count < 3 {\n        return true\n    }\n    return isIncreasing(l: l)\
    \ || isDecreasing(l: l)", "    var incr = true\n    var decr = true\n    for i\
    \ in 1..<l.count {\n        if l[i-1] > l[i] {\n            incr = false\n   \
    \     }\n        if l[i-1] < l[i] {\n            decr = false\n        }\n   \
    \ }\n    return incr || decr", "    var inc = false\n    var dec = false\n   \
    \ if l.count < 2 {\n        return true\n    }\n    for i in 1..<l.count {\n \
    \       if l[i] > l[i-1] {\n            inc = true\n        }\n        if l[i]\
    \ < l[i-1] {\n            dec = true\n        }\n        if inc && dec {\n   \
    \         return false\n        }\n    }\n    return true", "    guard l.count\
    \ > 1 else { return true }\n    let inc = zip(l.dropFirst(), l).map { a, b in\
    \ a < b }\n    let dec = zip(l.dropFirst(), l).map { a, b in a > b }\n    return\
    \ inc.all(==true) || dec.all(==true)", "    guard l.count > 1 else { return true\
    \ }\n    let sorted = l.sorted()\n    return sorted == l || sorted.reversed()\
    \ == l", "    let d = l.difference()\n    return l.count == 0 || (d.all(predicate:\
    \ { $0 >= 0 }) || d.all(predicate: { $0 <= 0 }))", "    let result = zip(l, l.dropFirst()).allSatisfy({\
    \ $0.0 <= $0.1 || $0.0 >= $0.1 })\n    return result", "    guard !l.isEmpty else\
    \ { return true }\n    var i = 1\n    let isIncreasing = l[i - 1] < l[i]\n   \
    \ while i < l.count {\n        if isIncreasing != (l[i - 1] < l[i]) {\n      \
    \      return false\n        }\n        i += 1\n    }\n    return true", '    return
    l.isSorted() || l.isSorted(by: >)', "  var incr = true\n  var decr = true\n  var\
    \ prev = l[0]\n  for el in l[1...] {\n    if el < prev {\n      incr = false\n\
    \    }\n    if el > prev {\n      decr = false\n    }\n    prev = el\n  }\n  return\
    \ incr || decr", '    return l.isSorted { $0 > $1 } || l.isSorted { $0 < $1 }',
  "    if l.count <= 2 {\n        return true\n    }\n    var increasing = l[1] >\
    \ l[0]\n    for i in 1..<l.count {\n        if increasing && l[i] < l[i - 1] {\n\
    \            return false\n        }\n        if !increasing && l[i] > l[i - 1]\
    \ {\n            return false\n        }\n    }\n    return true", "    if l.count\
    \ <= 2 {\n        return true\n    }\n    let order = l[1] - l[0]\n    for i in\
    \ 2..<l.count {\n        if l[i] - l[i-1] != order {\n            return false\n\
    \        }\n    }\n    return true", "    guard l.count > 2 else { return true\
    \ }\n    let f = l[0] < l[1]\n    for (a, b) in zip(l, l.dropFirst()) {\n    \
    \    if f != (a < b) { return false }\n    }\n    return true", "    var direction:\
    \ Int?\n    for i in 1..<l.count {\n        if direction == nil {\n          \
    \  direction = l[i] - l[i - 1]\n        } else if l[i] - l[i - 1] != direction\
    \ {\n            return false\n        }\n    }\n    return true", "  var decrease\
    \ = false\n  var increase = false\n  for i in 0..<l.count - 1 {\n    if l[i] >\
    \ l[i + 1] {\n      decrease = true\n    } else if l[i] < l[i + 1] {\n      increase\
    \ = true\n    }\n  }\n  return decrease && !increase || increase && !decrease",
  "    if l.count <= 2 {\n        return true\n    }\n    if l[0] == l[1] {\n    \
    \    return monotonic(l: Array(l[1..<l.count]))\n    }\n    let sign = l[0] <\
    \ l[1] ? 1 : -1\n    return l.dropFirst().enumerated().map {\n        $0.offset\
    \ == 0 ? $0.element * sign : $0.element * sign - l[$0.offset - 1] * sign\n   \
    \ }.allSatisfy { $0 >= 0 }", "    return l.reduce((optional: nil, increasing:\
    \ nil)) { (acc, x) in\n        if let prev = acc.optional {\n            return\
    \ (optional: x, increasing: acc.increasing ?? (x > prev))\n        } else {\n\
    \            return (optional: x, increasing: nil)\n        }\n    }.increasing\
    \ ?? true", "  // TODO: Implement this function\n  return false", "    var type:\
    \ Int? = nil\n    for i in 1..<l.count {\n        let diff = l[i] - l[i - 1]\n\
    \        if type == nil {\n            type = diff\n        } else if type! *\
    \ diff < 0 {\n            return false\n        }\n    }\n    return true", " \
    \   if l.count <= 2 {\n        return true\n    }\n    var isIncreasing = l[1]\
    \ > l[0]\n    for i in 2..<l.count {\n        if isIncreasing && l[i] < l[i -\
    \ 1] {\n            return false\n        }\n        if !isIncreasing && l[i]\
    \ > l[i - 1] {\n            return false\n        }\n    }\n    return true",
  '  return decreasing(l: l) || increasing(l: l)', "    var increasing = true\n  \
    \  var decreasing = true\n    for i in 1..<l.count {\n        if l[i] < l[i -\
    \ 1] {\n            increasing = false\n        }\n        if l[i] > l[i - 1]\
    \ {\n            decreasing = false\n        }\n    }\n    return increasing ||\
    \ decreasing", "    var d = 1;\n    var ll = l\n    if ll[0] < ll[1] {\n     \
    \   ll.reverse()\n        d = -1\n    }\n    for i in 1..<ll.count {\n       \
    \ if ll[i] > ll[i-1] {\n            return false\n        }\n    }\n    return\
    \ true", "  guard l.count > 2 else { return true }\n  var inc = false\n  var dec\
    \ = false\n  for i in 0..<l.count - 1 {\n    if l[i] < l[i + 1] {\n      inc =\
    \ true\n    } else if l[i] > l[i + 1] {\n      dec = true\n    }\n    if inc &&\
    \ dec {\n      return false\n    }\n  }\n  return true", "    var i = 0\n    var\
    \ op: Operator?\n    for i in 0..<l.count - 1 {\n        if l[i] == l[i + 1] {\n\
    \            continue\n        }\n        let current = l[i]\n        let next\
    \ = l[i + 1]\n        if op == nil {\n            op = (current < next) ? .lt\
    \ : .gt\n        } else {\n            if op == .lt && current > next {\n    \
    \            return false\n            }\n            if op == .gt && current\
    \ < next {\n                return false\n            }\n        }\n    }\n  \
    \  return true", "    var l = l\n    if l.isEmpty {\n        return true\n   \
    \ }\n    if l.count == 1 {\n        return true\n    }\n    var diff = l[1] -\
    \ l[0]\n    for i in 1..<l.count {\n        if diff == 0 {\n            diff =\
    \ l[i] - l[i - 1]\n        } else {\n            if (diff > 0 && l[i] - l[i -\
    \ 1] < 0) || (diff < 0 && l[i] - l[i - 1] > 0) {\n                return false\n\
    \            }\n        }\n    }\n    return true", "    if l.count <= 2 {\n \
    \       return true\n    }\n    var s = 0\n    var pre = l[1] - l[0]\n    for\
    \ i in 2..<l.count {\n        let cur = l[i] - l[i - 1]\n        if s == 0 {\n\
    \            if cur == 0 {\n                continue\n            }\n        \
    \    s = cur\n        } else {\n            if s > 0 && cur < 0 {\n          \
    \      return false\n            }\n            if s < 0 && cur > 0 {\n      \
    \          return false\n            }\n        }\n    }\n    return true", " \
    \   var increasing = true\n    var decreasing = true\n    for i in 1..<l.count\
    \ {\n        if l[i-1] > l[i] {\n            increasing = false\n        }\n \
    \       if l[i-1] < l[i] {\n            decreasing = false\n        }\n    }\n\
    \    return increasing || decreasing", "    var prev = l[0]\n    var increasing\
    \ = true\n    var decreasing = true\n    for i in 1..<l.count {\n        increasing\
    \ = increasing && l[i] >= prev\n        decreasing = decreasing && l[i] <= prev\n\
    \        prev = l[i]\n    }\n    return increasing || decreasing", "  var isIncreasing\
    \ = true\n  var isDecreasing = true\n  var i = 0\n  while i < l.count - 1 {\n\
    \    if l[i] > l[i + 1] {\n      isIncreasing = false\n    }\n    if l[i] < l[i\
    \ + 1] {\n      isDecreasing = false\n    }\n    i += 1\n  }\n  return isIncreasing\
    \ || isDecreasing", "    var increasing = true\n    var decreasing = true\n  \
    \  var prev = l[0]\n    for e in l {\n        if e > prev {\n            decreasing\
    \ = false\n        }\n        if e < prev {\n            increasing = false\n\
    \        }\n        prev = e\n    }\n    return increasing || decreasing", " \
    \   var diffs = [Int]()\n    for i in 0..<l.count - 1 {\n        diffs.append(l[i\
    \ + 1] - l[i])\n    }\n    return (diffs.filter { $0 < 0 }.count == 0) || (diffs.filter\
    \ { $0 > 0 }.count == 0)", "\tguard l.count > 1 else { return true }\n\tvar direction:\
    \ Int?\n\tfor (i,v) in l.enumerated() {\n\t\tif i == 0 { continue }\n\t\tlet d\
    \ = v - l[i-1]\n\t\tif direction == nil {\n\t\t\tdirection = d\n\t\t} else if\
    \ d * direction! < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true", "    if\
    \ l.count == 0 {\n        return true\n    }\n    if l.count == 1 {\n        return\
    \ true\n    }\n    var increasing = true\n    var decreasing = true\n    for i\
    \ in 1..<l.count {\n        if l[i] > l[i-1] {\n            decreasing = false\n\
    \        }\n        if l[i] < l[i-1] {\n            increasing = false\n     \
    \   }\n    }\n    return increasing || decreasing", "    var result = true\n \
    \   if l.count > 1 {\n        var i = 1\n        while i < l.count && result {\n\
    \            result = result && ((l[i] >= l[i - 1]) || (l[i] <= l[i - 1]))\n \
    \           i += 1\n        }\n    }\n    return result", '    return l.count
    < 3 || all_increasing(l: l) || all_decreasing(l: l)', "  if l.count <= 2 {\n \
    \   return true\n  }\n  for i in 1..<l.count {\n    if i % 2 == 1 {\n      if\
    \ l[i] <= l[i - 1] {\n        return false\n      }\n    } else {\n      if l[i]\
    \ >= l[i - 1] {\n        return false\n      }\n    }\n  }\n  return true", " \
    \   if l.count < 3 {\n        return true\n    }\n    if l[0] < l[1] {\n     \
    \   for i in 2..<l.count {\n            if l[i] < l[i - 1] {\n               \
    \ return false\n            }\n        }\n    } else {\n        for i in 2..<l.count\
    \ {\n            if l[i] > l[i - 1] {\n                return false\n        \
    \    }\n        }\n    }\n    return true", "    var result = true\n    var d\
    \ = 0\n    for i in 0..<l.count-1 {\n        d = l[i+1] - l[i]\n        if d >\
    \ 0 {\n            for j in i+1..<l.count-1 {\n                if (l[j+1] - l[j])\
    \ < 0 {\n                    result = false\n                    break\n     \
    \           }\n            }\n            break\n        } else if d < 0 {\n \
    \           for j in i+1..<l.count-1 {\n                if (l[j+1] - l[j]) > 0\
    \ {\n                    result = false\n                    break\n         \
    \       }\n            }\n            break\n        }\n    }\n    return result",
  "    if l.count <= 2 {\n        return true\n    }\n    var state = l[1] - l[0]\n\
    \    for i in 1..<l.count {\n        let diff = l[i] - l[i - 1]\n        if diff\
    \ * state < 0 {\n            return false\n        }\n        state = diff\n \
    \   }\n    return true", "    var last = l[0]\n    var increasing = true\n   \
    \ for (i, v) in l.enumerated() {\n        if i > 0 {\n            if v < last\
    \ {\n                increasing = false\n            }\n            if v > last\
    \ && !increasing {\n                return false\n            }\n            last\
    \ = v\n        }\n    }\n    return true", "    guard l.count > 1 else { return\
    \ true }\n    let direction = l[0] < l[1]\n    for i in 1..<l.count {\n      \
    \  if l[i] == l[i-1] { continue }\n        if direction != (l[i] > l[i-1]) { return\
    \ false }\n    }\n    return true", "    guard l.count > 2 else {\n        return\
    \ true\n    }\n    let step = l[1] - l[0]\n    for i in 1..<l.count {\n      \
    \  if step * (l[i] - l[i - 1]) < 0 {\n            return false\n        }\n  \
    \  }\n    return true", '    return l.sorted() == l || l.sorted().reversed() ==
    l', "    var increasing = true\n    var decreasing = true\n    for i in 1..<l.count\
    \ {\n        if l[i] < l[i - 1] {\n            increasing = false\n        }\n\
    \        if l[i] > l[i - 1] {\n            decreasing = false\n        }\n   \
    \ }\n    return increasing || decreasing", "    guard !l.isEmpty else { return\
    \ true }\n    var inc = l[0] <= l[1]\n    for i in 1..<l.count-1 {\n        if\
    \ inc && l[i] > l[i+1] { return false }\n        if !inc && l[i] < l[i+1] { return\
    \ false }\n    }\n    return true", "    var flag = true\n    for i in 1..<l.count\
    \ {\n        if l[i] > l[i-1] {\n            flag = false\n            break\n\
    \        }\n    }\n    if flag {\n        return true\n    }\n    flag = true\n\
    \    for i in 1..<l.count {\n        if l[i] < l[i-1] {\n            flag = false\n\
    \            break\n        }\n    }\n    return flag", "    guard l.count > 1\
    \ else { return true }\n    var order: Int?\n    for i in 1..<l.count {\n    \
    \    if l[i] > l[i - 1] {\n            if order == -1 { return false }\n     \
    \       order = 1\n        } else if l[i] < l[i - 1] {\n            if order ==\
    \ 1 { return false }\n            order = -1\n        }\n    }\n    return true",
  "    var arr = l\n    let diff = zip(arr, arr.dropFirst()).map { $0 - $1 }\n   \
    \ var t = false\n    for i in diff {\n        if t == false {\n            t =\
    \ i > 0\n        } else {\n            if i > 0 {\n                return false\n\
    \            }\n        }\n    }\n    return true", "    return l.reduce((0, true))\
    \ { (state, next) in\n        return (next, state.1 && (state.0 == next || state.0\
    \ == next + 1 || state.0 == next - 1))\n    }.1", "    guard l.count > 1 else\
    \ { return true }\n    var sign: Int?\n    for i in 1..<l.count {\n        let\
    \ delta = l[i] - l[i - 1]\n        if delta > 0 {\n            if sign == nil\
    \ {\n                sign = 1\n            } else if sign == -1 {\n          \
    \      return false\n            }\n        } else if delta < 0 {\n          \
    \  if sign == nil {\n                sign = -1\n            } else if sign ==\
    \ 1 {\n                return false\n            }\n        }\n    }\n    return\
    \ true", "    guard l.count > 1 else { return true }\n    let inc = l[1] - l[0]\
    \ > 0\n    for i in 1..<l.count {\n        if inc && l[i] - l[i - 1] < 0 { return\
    \ false }\n        if !inc && l[i] - l[i - 1] > 0 { return false }\n    }\n  \
    \  return true", "  let n = l.count\n  if n < 2 {\n    return true\n  }\n  var\
    \ i = 1\n  while i < n && l[i] == l[i - 1] {\n    i += 1\n  }\n  if i == n {\n\
    \    return true\n  }\n  if l[i] > l[i - 1] {\n    for j in i..<n - 1 {\n    \
    \  if l[j] > l[j + 1] {\n        return false\n      }\n    }\n  } else {\n  \
    \  for j in i..<n - 1 {\n      if l[j] < l[j + 1] {\n        return false\n  \
    \    }\n    }\n  }\n  return true", '    return strictlyMonotonic(l: l) || strictlyMonotonic(l:
    l.reversed())', "\tif l.count < 2 {\n\t\treturn true\n\t}\n\tvar direction: Int\
    \ = l[1] - l[0]\n\tfor i in 1..<l.count {\n\t\tif (l[i] - l[i - 1]) * direction\
    \ < 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true", "    var (increasing,\
    \ decreasing) = (true, true)\n    for i in 1..<l.count {\n        if l[i] < l[i\
    \ - 1] {\n            increasing = false\n        }\n        if l[i] > l[i - 1]\
    \ {\n            decreasing = false\n        }\n    }\n    return increasing ||\
    \ decreasing", "    var direction: Int?\n    for i in 1..<l.count {\n        if\
    \ l[i] == l[i - 1] {\n            continue\n        }\n        let d = l[i] -\
    \ l[i - 1]\n        if direction == nil {\n            direction = d\n       \
    \ } else if direction! * d < 0 {\n            return false\n        }\n    }\n\
    \    return true", "    if l.count <= 2 {\n        return true\n    }\n    var\
    \ increasing = true\n    var decreasing = true\n    for i in 1..<l.count {\n \
    \       if l[i] < l[i - 1] {\n            increasing = false\n        }\n    \
    \    if l[i] > l[i - 1] {\n            decreasing = false\n        }\n    }\n\
    \    return increasing || decreasing", "    var incr = true\n    var decr = true\n\
    \    for i in 1..<l.count {\n        if l[i] < l[i-1] {\n            incr = false\n\
    \        }\n        if l[i] > l[i-1] {\n            decr = false\n        }\n\
    \    }\n    return incr || decr", "    var positive = true\n    var negative =\
    \ true\n    for i in 0..<l.count - 1 {\n        if l[i] > l[i + 1] {\n       \
    \     positive = false\n        }\n        if l[i] < l[i + 1] {\n            negative\
    \ = false\n        }\n    }\n    return positive || negative", "    if l.count\
    \ < 3 {\n        return true\n    }\n    var i = 1\n    while l[i] == l[i - 1]\
    \ {\n        i += 1\n        if i == l.count {\n            return true\n    \
    \    }\n    }\n    var incr = l[i] > l[i - 1]\n    while i < l.count {\n     \
    \   if incr && l[i] < l[i - 1] {\n            return false\n        }\n      \
    \  if !incr && l[i] > l[i - 1] {\n            return false\n        }\n      \
    \  i += 1\n    }\n    return true", "  if l.count <= 2 {\n    return true\n  }\n\
    \  var isIncr = l[1] > l[0]\n  var isDecr = l[1] < l[0]\n  for idx in 2..<l.count\
    \ {\n    isIncr = isIncr && l[idx] > l[idx - 1]\n    isDecr = isDecr && l[idx]\
    \ < l[idx - 1]\n  }\n  return isIncr || isDecr", "  var isIncreasing = true\n\
    \  var isDecreasing = true\n  var i = 0\n  while i < l.count - 1 {\n    if l[i]\
    \ < l[i + 1] {\n      isDecreasing = false\n    } else if l[i] > l[i + 1] {\n\
    \      isIncreasing = false\n    }\n    i += 1\n  }\n  return isIncreasing ||\
    \ isDecreasing", "    if l.count <= 2 {\n        return true\n    }\n    let diff\
    \ = l[1] - l[0]\n    for i in 1..<l.count {\n        if (l[i] - l[i - 1]) * diff\
    \ < 0 {\n            return false\n        }\n    }\n    return true", '    return
    false', "    let n = l.count\n    var increasing = true\n    var decreasing =\
    \ true\n    for i in 1..<n {\n        if l[i] < l[i - 1] {\n            increasing\
    \ = false\n        }\n        if l[i] > l[i - 1] {\n            decreasing = false\n\
    \        }\n    }\n    return increasing || decreasing", "  if l.count <= 2 {\n\
    \    return true\n  }\n  var increase = true\n  var decrease = true\n  for i in\
    \ 1..<l.count {\n    if l[i] > l[i - 1] {\n      decrease = false\n    }\n   \
    \ if l[i] < l[i - 1] {\n      increase = false\n    }\n  }\n  return increase\
    \ || decrease", "    var a = l.map { $0 }\n    var increasing = true\n    var\
    \ decreasing = true\n    a.sort()\n    for i in 0..<a.count - 1 {\n        if\
    \ a[i] > a[i + 1] {\n            increasing = false\n        }\n        if a[i]\
    \ < a[i + 1] {\n            decreasing = false\n        }\n    }\n    return increasing\
    \ || decreasing", "    guard !l.isEmpty else { return true }\n    var increasing\
    \ = true\n    var decreasing = true\n    for i in 1..<l.count {\n        increasing\
    \ = increasing && l[i] >= l[i - 1]\n        decreasing = decreasing && l[i] <=\
    \ l[i - 1]\n    }\n    return increasing || decreasing", "    var growing = true\n\
    \    var decreasing = true\n    for i in 1..<l.count {\n        growing = growing\
    \ && l[i-1] <= l[i]\n        decreasing = decreasing && l[i-1] >= l[i]\n    }\n\
    \    return growing || decreasing", "    let diffs = zip(l, l.dropFirst()).map\
    \ { $0 - $1 }\n    return diffs.allSatisfy { $0 > 0 } || diffs.allSatisfy { $0\
    \ < 0 }", "    var decreasing = true\n    var increasing = true\n    for i in\
    \ 1..<l.count {\n        if l[i] < l[i - 1] {\n            increasing = false\n\
    \        }\n        if l[i] > l[i - 1] {\n            decreasing = false\n   \
    \     }\n    }\n    return increasing || decreasing", "    var ascend = true\n\
    \    var descend = true\n    for i in 1..<l.count {\n        ascend = ascend &&\
    \ l[i] >= l[i - 1]\n        descend = descend && l[i] <= l[i - 1]\n    }\n   \
    \ return ascend || descend", '    return false', "    var isIncreasing = true\n\
    \    var isDecreasing = true\n    for i in 1..<l.count {\n        if l[i] < l[i\
    \ - 1] {\n            isIncreasing = false\n        }\n        if l[i] > l[i -\
    \ 1] {\n            isDecreasing = false\n        }\n    }\n    return isIncreasing\
    \ || isDecreasing", "  if l.count <= 2 {\n    return true\n  }\n  if l[0] < l[1]\
    \ {\n    for i in 1 ..< l.count - 1 {\n      if l[i] >= l[i + 1] {\n        return\
    \ false\n      }\n    }\n  } else {\n    for i in 1 ..< l.count - 1 {\n      if\
    \ l[i] <= l[i + 1] {\n        return false\n      }\n    }\n  }\n  return true",
  "  guard l.count > 1 else { return true }\n  let increasing = l[0] < l[1]\n  for\
    \ i in 1..<l.count - 1 {\n    if increasing {\n      if l[i] > l[i + 1] { return\
    \ false }\n    } else {\n      if l[i] < l[i + 1] { return false }\n    }\n  }\n\
    \  return true", "    if l.count <= 2 {\n        return true\n    }\n    let v0\
    \ = l[0]\n    var v1 = l[1]\n    var isIncreasing = v0 < v1\n    var isDecreasing\
    \ = v0 > v1\n    if isIncreasing || isDecreasing {\n        for v in l[2...] {\n\
    \            if isIncreasing && v <= v1 {\n                return false\n    \
    \        }\n            if isDecreasing && v >= v1 {\n                return false\n\
    \            }\n            v1 = v\n        }\n        return true\n    }\n  \
    \  return false", "    var increasing = true\n    var decreasing = true\n    for\
    \ i in 1..<l.count {\n        if l[i] > l[i-1] {\n            decreasing = false\n\
    \        }\n        if l[i] < l[i-1] {\n            increasing = false\n     \
    \   }\n    }\n    return increasing || decreasing", "    var comparison: (Int,\
    \ Int) -> Bool = {$0 > $1}\n    if l[0] > l[l.count - 1] {\n        comparison\
    \ = {$0 < $1}\n    }\n    for i in 1..<l.count {\n        if comparison(l[i -\
    \ 1], l[i]) {\n            return false\n        }\n    }\n    return true", " \
    \   var diffs = [Int]()\n    for i in 0..<l.count - 1 {\n        diffs.append(l[i\
    \ + 1] - l[i])\n    }\n    return allEqual(l: diffs)", "    var direction: Int?\n\
    \    for i in 1..<l.count {\n        if direction == nil {\n            if l[i]\
    \ > l[i - 1] {\n                direction = 1\n            } else if l[i] < l[i\
    \ - 1] {\n                direction = -1\n            }\n        } else {\n  \
    \          if l[i] - l[i - 1] != direction! {\n                return false\n\
    \            }\n        }\n    }\n    return true", "    guard l.count > 2 else\
    \ { return true }\n    let delta = l[1] - l[0]\n    for i in 2..<l.count {\n \
    \       if delta * (l[i] - l[i - 1]) < 0 {\n            return false\n       \
    \ }\n    }\n    return true", "    guard l.count > 2 else { return true }\n  \
    \  var direction: Int = 0\n    for i in 0..<l.count - 1 {\n        if l[i] < l[i\
    \ + 1] {\n            if direction == 0 {\n                direction = 1\n   \
    \         } else if direction == -1 {\n                return false\n        \
    \    }\n        } else if l[i] > l[i + 1] {\n            if direction == 0 {\n\
    \                direction = -1\n            } else if direction == 1 {\n    \
    \            return false\n            }\n        }\n    }\n    return true",
  "    var sorted: [Int]\n    var dir: Int\n    if is_sorted(l: l) {\n        return\
    \ true\n    }\n    sorted = l.sorted()\n    if sorted == l {\n        dir = 1\n\
    \    } else {\n        dir = -1\n    }\n    for i in 0..<l.count-1 {\n       \
    \ if dir*(l[i+1]-l[i]) < 0 {\n            return false\n        }\n    }\n   \
    \ return true", "\tguard let (head, tail) = l.destructured else { return true\
    \ }\n\treturn tail.reduce(true) {\n\t\tguard $0 else { return false }\n\t\treturn\
    \ (l[0] < l[1] && $1 > $0) || (l[0] > l[1] && $1 < $0)\n\t}", "    if l.count\
    \ < 3 {\n        return true\n    }\n    if l[0] > l[1] {\n        for i in 1..<l.count\
    \ {\n            if l[i] > l[i - 1] {\n                return false\n        \
    \    }\n        }\n    } else {\n        for i in 1..<l.count {\n            if\
    \ l[i] < l[i - 1] {\n                return false\n            }\n        }\n\
    \    }\n    return true", "  let diffs = zip(l, l.dropFirst()).map(-)\n  return\
    \ (diffs.allSatisfy { $0 >= 0 }) || (diffs.allSatisfy { $0 <= 0 })", "    if l.count\
    \ < 3 {\n        return true\n    }\n    var increase = true\n    if l[1] < l[0]\
    \ {\n        increase = false\n    }\n    for i in 2..<l.count {\n        if increase\
    \ && l[i] < l[i - 1] {\n            return false\n        }\n        if !increase\
    \ && l[i] > l[i - 1] {\n            return false\n        }\n    }\n    return\
    \ true", "    var prev = l[0]\n    var increasing = true\n    var decreasing =\
    \ true\n    for elem in l {\n        if elem > prev {\n            decreasing\
    \ = false\n        } else if elem < prev {\n            increasing = false\n \
    \       }\n        prev = elem\n    }\n    return increasing || decreasing", " \
    \ var m = 0\n  for i in 1..<l.count {\n    let r = l[i] - l[i - 1]\n    if r ==\
    \ 0 {\n      continue\n    }\n    if m == 0 {\n      m = r\n    } else if r /\
    \ m < 0 {\n      return false\n    }\n  }\n  return true", "    var increasing\
    \ = true\n    var decreasing = true\n    for i in 1..<l.count {\n        if l[i]\
    \ > l[i-1] {\n            decreasing = false\n        }\n        if l[i] < l[i-1]\
    \ {\n            increasing = false\n        }\n    }\n    return increasing ||\
    \ decreasing", "    if l.count < 3 {\n        return true\n    }\n    var x =\
    \ (l[0] - l[1]) * (l[0] - l[2])\n    for i in 2..<l.count - 1 {\n        x = (l[i\
    \ - 1] - l[i]) * (l[i - 1] - l[i + 1])\n        if x < 0 {\n            return\
    \ false\n        }\n    }\n    return true", "    var increasing = true\n    var\
    \ decreasing = true\n    for i in 1..<l.count {\n        if l[i] < l[i - 1] {\n\
    \            increasing = false\n        }\n        if l[i] > l[i - 1] {\n   \
    \         decreasing = false\n        }\n    }\n    return increasing || decreasing",
  "    var i = 0\n    var diff = l[1] - l[0]\n    while i < l.count - 1 {\n      \
    \  if diff * (l[i + 1] - l[i]) < 0 {\n            return false\n        }\n  \
    \      i += 1\n    }\n    return true", '    return l.elementsEqual(l.sorted())
    || l.elementsEqual(l.sorted().reversed())', "    var previous = l[0]\n    var\
    \ increasing = true\n    for current in l {\n        if current < previous {\n\
    \            increasing = false\n            break\n        }\n        previous\
    \ = current\n    }\n    return increasing || monotonic(l: l.reversed())", "  \
    \  let n = l.count\n    var increase = true\n    var decrease = true\n    for\
    \ i in 1..<n {\n        if l[i] < l[i - 1] {\n            increase = false\n \
    \       }\n        if l[i] > l[i - 1] {\n            decrease = false\n      \
    \  }\n    }\n    return increase || decrease", "    if l.count <= 2 {\n      \
    \  return true\n    }\n    var prev = l[0]\n    var prevSign = l[1] - l[0]\n \
    \   for i in 2..<l.count {\n        let nextSign = l[i] - prev\n        if nextSign\
    \ * prevSign < 0 {\n            return false\n        }\n        prev = l[i]\n\
    \        prevSign = nextSign\n    }\n    return true", "    if l.count <= 2 {\n\
    \        return true\n    }\n    var increasing = true\n    var decreasing = true\n\
    \    for i in 1..<l.count {\n        if l[i] < l[i - 1] {\n            increasing\
    \ = false\n        }\n        if l[i] > l[i - 1] {\n            decreasing = false\n\
    \        }\n    }\n    return increasing || decreasing", "\tvar m = 1\n\tfor i\
    \ in 1 ..< l.count {\n\t\tif (l[i] - l[i - 1]) * m < 0 {\n\t\t\treturn false\n\
    \t\t}\n\t\tif (l[i] - l[i - 1]) != 0 {\n\t\t\tm = (l[i] - l[i - 1])\n\t\t}\n\t\
    }\n\treturn true", "    var increasing = true\n    var decreasing = true\n   \
    \ for (i, v) in l.enumerated() {\n        if i != 0 {\n            if v < l[i\
    \ - 1] {\n                increasing = false\n            }\n            if v\
    \ > l[i - 1] {\n                decreasing = false\n            }\n        }\n\
    \    }\n    return increasing || decreasing", "    var i = 0\n    var c: Int\n\
    \    while i < l.count - 1 {\n        c = l[i] - l[i + 1]\n        if c < 0 {\n\
    \            break\n        }\n        i += 1\n    }\n    if i == l.count - 1\
    \ {\n        return true\n    }\n    var j = i\n    while j < l.count - 1 {\n\
    \        c = l[j] - l[j + 1]\n        if c > 0 {\n            return false\n \
    \       }\n        j += 1\n    }\n    return true", "    guard let first = l.first\
    \ else { return true }\n    guard let last = l.last else { return true }\n   \
    \ if first < last {\n        return l == l.sorted()\n    } else {\n        return\
    \ l == l.sorted().reversed()\n    }", "    if l.count <= 2 {\n        return true\n\
    \    }\n    var increasing = true\n    var decreasing = true\n    for i in 1..<l.count\
    \ {\n        if l[i] > l[i - 1] {\n            decreasing = false\n        }\n\
    \        if l[i] < l[i - 1] {\n            increasing = false\n        }\n   \
    \ }\n    return increasing || decreasing", '  return l.count < 3 || (l[1] >= l[0]
    && increasing(l: l)) || (l[1] <= l[0] && decreasing(l: l))', '    return l.sorted()
    == l || l.sorted().reversed() == l', "    guard l.count > 2 else {\n        return\
    \ true\n    }\n    var i = 1\n    var increasing = true\n    var decreasing =\
    \ true\n    while i < l.count {\n        if l[i] > l[i - 1] {\n            decreasing\
    \ = false\n        }\n        if l[i] < l[i - 1] {\n            increasing = false\n\
    \        }\n        i += 1\n    }\n    return increasing || decreasing", "   \
    \ guard l.count > 2 else { return true }\n    return zip(l, l.dropFirst()).allSatisfy\
    \ { $0 <= $1 } || zip(l, l.dropFirst()).allSatisfy { $0 >= $1 }", "    var isIncrease\
    \ = true\n    var isDecrease = true\n    for i in 1..<l.count {\n        if l[i]\
    \ < l[i - 1] {\n            isIncrease = false\n        }\n        if l[i] > l[i\
    \ - 1] {\n            isDecrease = false\n        }\n    }\n    return isIncrease\
    \ || isDecrease", "    var (increasing, decreasing) = (true, true)\n    for i\
    \ in 1..<l.count {\n        if l[i-1] > l[i] {\n            increasing = false\n\
    \        }\n        if l[i-1] < l[i] {\n            decreasing = false\n     \
    \   }\n    }\n    return increasing || decreasing", "    var increasing = true\n\
    \    var decreasing = true\n    for i in 1..<l.count {\n        if l[i] < l[i\
    \ - 1] {\n            increasing = false\n        }\n        if l[i] > l[i - 1]\
    \ {\n            decreasing = false\n        }\n    }\n    return increasing ||\
    \ decreasing", "    if l.count < 3 {\n        return true\n    }\n    var direction\
    \ = 0\n    for i in 1..<l.count {\n        if direction == 0 {\n            if\
    \ l[i] > l[i - 1] {\n                direction = 1\n            } else if l[i]\
    \ < l[i - 1] {\n                direction = -1\n            }\n        } else\
    \ if l[i] < l[i - 1] && direction == 1 {\n            return false\n        }\
    \ else if l[i] > l[i - 1] && direction == -1 {\n            return false\n   \
    \     }\n    }\n    return true", "    let sorted = l.sorted()\n    return l ==\
    \ sorted || l == sorted.reversed()", "    guard l.count > 1 else { return true\
    \ }\n    var value = l[0]\n    var increasing = false\n    var decreasing = false\n\
    \    for n in l[1..<l.count] {\n        if n > value {\n            if decreasing\
    \ { return false }\n            increasing = true\n        } else if n < value\
    \ {\n            if increasing { return false }\n            decreasing = true\n\
    \        }\n        value = n\n    }\n    return true", "    var mono = true\n\
    \    var i = 0\n    while mono && i < l.count - 1 {\n        if l[i] > l[i + 1]\
    \ {\n            mono = true\n        } else if l[i] < l[i + 1] {\n          \
    \  mono = true\n        } else {\n            mono = false\n        }\n      \
    \  i += 1\n    }\n    return mono", "    if l.count < 3 {\n        return true\n\
    \    }\n    if l[0] > l[1] {\n        for i in 0 ..< l.count - 1 {\n         \
    \   if l[i] < l[i + 1] {\n                return false\n            }\n      \
    \  }\n    } else {\n        for i in 0 ..< l.count - 1 {\n            if l[i]\
    \ > l[i + 1] {\n                return false\n            }\n        }\n    }\n\
    \    return true", "    guard l.count > 2 else {\n        return true\n    }\n\
    \    var isIncreasing = l[0] < l[1]\n    for i in 1..<l.count - 1 {\n        let\
    \ diff = l[i] - l[i + 1]\n        if diff > 0 && !isIncreasing {\n           \
    \ return false\n        }\n        if diff < 0 && isIncreasing {\n           \
    \ return false\n        }\n    }\n    return true", '    return l.sorted() ==
    l || l.sorted(by: >) == l', "    if l.count <= 2 {\n        return true\n    }\n\
    \    var inc = l[1] > l[0]\n    var res = true\n    for i in 2..<l.count {\n \
    \       if inc && l[i] < l[i - 1] {\n            res = false\n            break\n\
    \        }\n        if !inc && l[i] > l[i - 1] {\n            res = false\n  \
    \          break\n        }\n    }\n    return res", "    let sorted_list = l.sorted()\n\
    \    if sorted_list == l {\n        return true\n    }\n    let reverse_sorted_list\
    \ = l.sorted(by: { $0 > $1 })\n    if reverse_sorted_list == l {\n        return\
    \ true\n    }\n    return false", "    var set = Set<Int>()\n    set.insert(l[0])\n\
    \    var e = l[0]\n    var flag = true\n    for i in 1..<l.count {\n        set.insert(l[i])\n\
    \        if abs(l[i] - e) == 1 {\n            e = l[i]\n        } else {\n   \
    \         flag = false\n            break\n        }\n    }\n    return flag &&\
    \ set.count == l.count", "  guard l.count > 2 else { return true }\n  if l[0]\
    \ < l[1] {\n    return monoAscending(l: l)\n  } else if l[0] > l[1] {\n    return\
    \ monoDescending(l: l)\n  } else {\n    return monoAscending(l: l) || monoDescending(l:\
    \ l)\n  }", "    guard l.count > 1 else { return true }\n    let start = l[0]\n\
    \    if l[1] > start {\n        for i in 2..<l.count {\n            if l[i] <\
    \ l[i - 1] {\n                return false\n            }\n        }\n    } else\
    \ {\n        for i in 2..<l.count {\n            if l[i] > l[i - 1] {\n      \
    \          return false\n            }\n        }\n    }\n    return true", " \
    \   var increasing = true\n    var decreasing = true\n    for i in 1..<l.count\
    \ {\n        if l[i] < l[i - 1] {\n            increasing = false\n        }\n\
    \        if l[i] > l[i - 1] {\n            decreasing = false\n        }\n   \
    \ }\n    return increasing || decreasing", "    if l.count <= 2 {\n        return\
    \ true\n    }\n    var direction = l[1] - l[0]\n    for i in 1..<l.count - 1 {\n\
    \        let diff = l[i + 1] - l[i]\n        if direction == 0 {\n           \
    \ direction = diff\n        } else if direction * diff < 0 {\n            return\
    \ false\n        }\n    }\n    return true", "    return l.isEmpty || l.reduce((c:\
    \ l[0], u: true)) {\n        (result, n) in\n        return (((n > result.c) &&\
    \ result.u) || ((n < result.c) && !result.u)) ? (c: n, u: result.u) : (c: result.c,\
    \ u: false)\n    }.u", "    if l.count <= 2 {\n        return true\n    }\n  \
    \  var increasing = l[1] > l[0]\n    for i in 2..<l.count {\n        if l[i] ==\
    \ l[i-1] {\n            continue\n        }\n        if increasing != (l[i] >\
    \ l[i-1]) {\n            return false\n        }\n    }\n    return true", " \
    \   var inc = 0\n    var dec = 0\n    for i in 0..<l.count-1 {\n        if l[i]\
    \ <= l[i+1] {\n            inc += 1\n        }\n        if l[i] >= l[i+1] {\n\
    \            dec += 1\n        }\n    }\n    return inc == l.count-1 || dec ==\
    \ l.count-1", "    var monoton = true\n    for i in 1..<l.count {\n        if\
    \ l[i] > l[i-1] {\n            if monoton == false {\n                return false\n\
    \            }\n            monoton = true\n        } else if l[i] < l[i-1] {\n\
    \            if monoton == true {\n                return false\n            }\n\
    \            monoton = false\n        }\n    }\n    return true", "    guard l.count\
    \ > 1 else { return true }\n    for i in 0 ..< l.count - 1 {\n        if (l[i]\
    \ > l[i + 1] && l[i + 1] > l[i + 2]) || (l[i] < l[i + 1] && l[i + 1] < l[i + 2])\
    \ {\n            return false\n        }\n    }\n    return true", "    guard\
    \ !l.isEmpty else { return true }\n    var m = l.reduce(0, { $0 + $1 })\n    for\
    \ i in 0..<l.count - 1 {\n        let d = l[i] - l[i + 1]\n        if d * m <\
    \ 0 {\n            return false\n        }\n        m = d\n    }\n    return true",
  "    if (l.count < 2) {\n        return true\n    }\n    var cmp = l[1] - l[0]\n\
    \    for i in 1..<l.count {\n        if (cmp == 0) {\n            cmp = l[i] -\
    \ l[i - 1]\n        } else if (cmp * (l[i] - l[i - 1]) < 0) {\n            return\
    \ false\n        }\n    }\n    return true", "    var decreasing = true\n    var\
    \ increasing = true\n    for i in 1..<l.count {\n        if l[i] < l[i - 1] {\n\
    \            increasing = false\n        }\n        if l[i] > l[i - 1] {\n   \
    \         decreasing = false\n        }\n    }\n    return increasing || decreasing",
  '    return nonDecreasing(l: l) || nonIncreasing(l: l)', "\tguard l.count > 2 else\
    \ { return true }\n\tlet diffs = l.pairwiseDifferences()\n\tlet first = diffs.first!\n\
    \treturn diffs.allSatisfy { $0 == first }", '    return false', "    if l.count\
    \ < 3 {\n        return true\n    }\n    if l[0] < l[1] {\n        for i in 1..<l.count\
    \ - 1 {\n            if l[i] > l[i + 1] {\n                return false\n    \
    \        }\n        }\n    } else {\n        for i in 1..<l.count - 1 {\n    \
    \        if l[i] < l[i + 1] {\n                return false\n            }\n \
    \       }\n    }\n    return true", "    if l.count <= 2 {\n        return true\n\
    \    }\n    let asc = l[0] < l[1]\n    for i in 1..<l.count - 1 {\n        if\
    \ asc != (l[i] < l[i + 1]) {\n            return false\n        }\n    }\n   \
    \ return true", "    guard !l.isEmpty else { return true }\n    var v = l[0]\n\
    \    for e in l[1..<l.count] {\n        if v < e {\n            if v == l.min()!\
    \ {\n                v = e\n            } else {\n                return false\n\
    \            }\n        } else if v > e {\n            if v == l.max()! {\n  \
    \              v = e\n            } else {\n                return false\n   \
    \         }\n        }\n    }\n    return true", "    var sign = 0\n    for i\
    \ in 1..<l.count {\n        let c = l[i] - l[i - 1]\n        if c == 0 {\n   \
    \         continue\n        }\n        if sign == 0 {\n            sign = c\n\
    \        } else if sign * c < 0 {\n            return false\n        }\n    }\n\
    \    return true", "    guard l.count > 1 else { return true }\n    for i in 0..<l.count\
    \ - 1 {\n        if l[i] == l[i + 1] { continue }\n        let comp = l[i] < l[i\
    \ + 1]\n        for j in i + 1..<l.count - 1 {\n            if l[j] == l[j + 1]\
    \ { continue }\n            if comp != (l[j] < l[j + 1]) { return false }\n  \
    \      }\n        return true\n    }\n    return true", "    guard l.count > 1\
    \ else { return true }\n    return l.enumerated().reduce(true) { (result, next)\
    \ in\n        guard next.offset > 0 else { return result }\n        let pair =\
    \ (l[next.offset - 1], next.element)\n        return result && (pair.0 < pair.1)\
    \ == (pair.0 <= pair.1)\n    }", "    guard l.count > 2 else { return true }\n\
    \    if l[0] < l[1] {\n        for i in 1..<l.count-1 {\n            if l[i] >\
    \ l[i+1] {\n                return false\n            }\n        }\n    } else\
    \ {\n        for i in 1..<l.count-1 {\n            if l[i] < l[i+1] {\n      \
    \          return false\n            }\n        }\n    }\n    return true", " \
    \   var result = true\n    var initNum = l[0]\n    for i in l[1..<l.count] {\n\
    \        if initNum == i {\n            continue\n        }\n        if initNum\
    \ < i {\n            for j in i+1..<l.count {\n                if i > l[j] {\n\
    \                    result = false\n                    break\n             \
    \   }\n            }\n        } else {\n            for j in i+1..<l.count {\n\
    \                if i < l[j] {\n                    result = false\n         \
    \           break\n                }\n            }\n        }\n        break\n\
    \    }\n    return result", "    var isMonoIncrease = true\n    var isMonoDecrease\
    \ = true\n    for i in 1..<l.count {\n        if l[i] < l[i-1] {\n           \
    \ isMonoIncrease = false\n        }\n        if l[i] > l[i-1] {\n            isMonoDecrease\
    \ = false\n        }\n    }\n    return isMonoIncrease || isMonoDecrease", " \
    \   var result = true\n    var direction = 0\n    for i in 1..<l.count {\n   \
    \     if l[i] == l[i - 1] {\n            continue\n        }\n        else if\
    \ l[i] > l[i - 1] {\n            if direction == 0 {\n                direction\
    \ = 1\n            }\n            else if direction == -1 {\n                result\
    \ = false\n                break\n            }\n        }\n        else {\n \
    \           if direction == 0 {\n                direction = -1\n            }\n\
    \            else if direction == 1 {\n                result = false\n      \
    \          break\n            }\n        }\n    }\n    return result", "    if\
    \ l.count < 3 {\n        return true\n    }\n    var inc = false\n    var dec\
    \ = false\n    var prev = l[0]\n    for i in 1..<l.count {\n        let curr =\
    \ l[i]\n        if prev < curr {\n            inc = true\n        } else if prev\
    \ > curr {\n            dec = true\n        }\n        if inc && dec {\n     \
    \       return false\n        }\n        prev = curr\n    }\n    return true",
  "    if l.count <= 2 {\n        return true\n    }\n    var neg_to_pos = false\n\
    \    var pos_to_neg = false\n    for idx in 1..<l.count {\n        if l[idx] <\
    \ l[idx - 1] {\n            if pos_to_neg {\n                return false\n  \
    \          }\n            neg_to_pos = true\n        } else if l[idx] > l[idx\
    \ - 1] {\n            if neg_to_pos {\n                return false\n        \
    \    }\n            pos_to_neg = true\n        }\n    }\n    return true", " \
    \   guard !l.isEmpty else { return true }\n    let isIncreasing = l[0] < l[1]\n\
    \    for i in 1..<l.count {\n        if isIncreasing {\n            if l[i] <\
    \ l[i - 1] {\n                return false\n            }\n        } else {\n\
    \            if l[i] > l[i - 1] {\n                return false\n            }\n\
    \        }\n    }\n    return true", "    var incr = true\n    var decr = true\n\
    \    for i in 1..<l.count {\n        if l[i] > l[i-1] {\n            decr = false\n\
    \        }\n        if l[i] < l[i-1] {\n            incr = false\n        }\n\
    \    }\n    return incr || decr", '    return l.sorted(by: <) == l || l.sorted(by:
    >) == l', "    let n = l.count\n    if n <= 2 {\n        return true\n    }\n\
    \    var isInc = l[1] > l[0]\n    for i in 1..<n-1 {\n        if l[i+1] > l[i]\
    \ != isInc {\n            return false\n        }\n    }\n    return true"]
stop_tokens:
- "\n}"
