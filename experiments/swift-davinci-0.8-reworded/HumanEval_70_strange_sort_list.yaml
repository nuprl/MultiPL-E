name: HumanEval_70_strange_sort_list
language: swift
prompt: "\n/// Given array of integers, return array in strange order.\n/// Strange\
  \ sorting, is when you start with the minimum value,\n/// then maximum of the remaining\
  \ integers, then minimum and so on.\n/// Examples:\n/// >>> strange_sort_list(lst:\
  \ [1, 2, 3, 4])\n/// [1, 4, 2, 3]\n/// >>> strange_sort_list(lst: [5, 5, 5, 5])\n\
  /// [5, 5, 5, 5]\n/// >>> strange_sort_list(lst: [] as [Int])\n/// [] as [Int]\n\
  func strange_sort_list(lst: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(strange_sort_list(lst: [1, 2, 3, 4]) ==\
  \ [1, 4, 2, 3])\nassert(strange_sort_list(lst: [5, 6, 7, 8, 9]) == [5, 9, 6, 8,\
  \ 7])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5]) == [1, 5, 2, 4, 3])\nassert(strange_sort_list(lst:\
  \ [5, 6, 7, 8, 9, 1]) == [1, 9, 5, 8, 6, 7])\nassert(strange_sort_list(lst: [5,\
  \ 5, 5, 5]) == [5, 5, 5, 5])\nassert(strange_sort_list(lst: [] as [Int]) == [] as\
  \ [Int])\nassert(strange_sort_list(lst: [1, 2, 3, 4, 5, 6, 7, 8]) == [1, 8, 2, 7,\
  \ 3, 6, 4, 5])\nassert(strange_sort_list(lst: [0, 2, 2, 2, 5, 5, -5, -5]) == [-5,\
  \ 5, -5, 5, 0, 2, 2, 2])\nassert(strange_sort_list(lst: [111111]) == [111111])"
completions: ["    // BEGIN strange_sort_list\n    if lst.isEmpty {\n        return\
    \ []\n    }\n    var result = [Int]()\n    var unsorted = lst\n    while !unsorted.isEmpty\
    \ {\n        let minIndex = unsorted.index(of: unsorted.min()!)!\n        let\
    \ maxIndex = unsorted.index(of: unsorted.max()!)!\n        result.append(unsorted[minIndex])\n\
    \        unsorted.remove(at: minIndex)\n        if !unsorted.isEmpty {\n     \
    \       result.append(unsorted[maxIndex])\n            unsorted.remove(at: maxIndex)\n\
    \        }\n    }\n    return result\n    // END strange_sort_list", "    if lst.count\
    \ == 0 {\n        return []\n    }\n    let minimum = lst.min()!\n    let maximum\
    \ = lst.max()!\n    let result = strange_sort_list(lst: lst.filter({ number in\
    \ number != minimum && number != maximum }))\n    return [minimum] + [maximum]\
    \ + result", "    let sortedArray = lst.sorted()\n    var resultArray = [Int]()\n\
    \    var increasing = true\n    while !sortedArray.isEmpty {\n        if increasing\
    \ {\n            resultArray.append(sortedArray.removeFirst())\n        } else\
    \ {\n            resultArray.append(sortedArray.removeLast())\n        }\n   \
    \     increasing = !increasing\n    }\n    return resultArray", "    guard lst.count\
    \ > 1 else { return lst }\n    var lst = lst.sorted()\n    var result = [Int]()\n\
    \    var j = lst.count - 1\n    for i in 0..<lst.count {\n        if i % 2 ==\
    \ 0 {\n            result.append(lst[i])\n        } else {\n            result.append(lst[j])\n\
    \            j -= 1\n        }\n    }\n    return result", "    var result: [Int]\
    \ = []\n    let sortedList = lst.sorted()\n    let middle = sortedList.count /\
    \ 2\n    let firstHalf = Array(sortedList[0..<middle])\n    let secondHalf = Array(sortedList[middle..<sortedList.count])\n\
    \    var i = 0\n    while i < firstHalf.count {\n        result.append(firstHalf[i])\n\
    \        result.append(secondHalf[i])\n        i += 1\n    }\n    if sortedList.count\
    \ % 2 != 0 {\n        result.append(sortedList[sortedList.count - 1])\n    }\n\
    \    return result", "    guard !lst.isEmpty else { return [] }\n    var result\
    \ = [Int]()\n    var lst1 = lst\n    var lst2 = lst.sorted(by: >)\n    var index\
    \ = 0\n    repeat {\n        result.append(lst1[index])\n        lst1.remove(at:\
    \ index)\n        result.append(lst2[index])\n        lst2.remove(at: index)\n\
    \        index += 1\n    } while !lst1.isEmpty\n    return result", "    var temp\
    \ = lst\n    temp.sort()\n    var result = [Int]()\n    var i = 0\n    var j =\
    \ temp.count - 1\n    while i <= j {\n        result.append(temp[i])\n       \
    \ i += 1\n        if i <= j {\n            result.append(temp[j])\n          \
    \  j -= 1\n        }\n    }\n    return result", "    var arr = lst\n    var isPositive\
    \ = true\n    var startIndex = 0\n    if arr.count > 0 {\n        startIndex =\
    \ arr.index(of: arr.min()!)!\n    }\n    for i in 0..<arr.count {\n        let\
    \ newIndex = (startIndex + i * (isPositive ? 1 : -1)) % arr.count\n        arr.swapAt(i,\
    \ newIndex)\n        isPositive = !isPositive\n    }\n    return arr", "    //\
    \ . . .\n    return lst", '    return []', "    guard lst.count > 1 else {\n \
    \       return lst\n    }\n    var list = lst\n    var i = 0\n    var maxIndex\
    \ = list.count - 1\n    var minIndex = 0\n    var minValue = list[minIndex]\n\
    \    var maxValue = list[maxIndex]\n    while i < list.count {\n        if i %\
    \ 2 == 0 {\n            list[i] = minValue\n            minIndex += 1\n      \
    \      minValue = list[minIndex]\n        } else {\n            list[i] = maxValue\n\
    \            maxIndex -= 1\n            maxValue = list[maxIndex]\n        }\n\
    \        i += 1\n    }\n    return list", "    let sorted = lst.sorted()\n   \
    \ var result = [Int]()\n    var left = 0\n    var right = sorted.count - 1\n \
    \   while left <= right {\n        result.append(sorted[left])\n        left +=\
    \ 1\n        if left <= right {\n            result.append(sorted[right])\n  \
    \          right -= 1\n        }\n    }\n    return result", "    let lst = lst.sorted(by:\
    \ { $0 < $1 })\n    var result = [Int]()\n    while lst.count > 0 {\n        if\
    \ let first = lst.first {\n            result.append(first)\n            let lst\
    \ = lst.suffix(from: 1)\n        }\n        if let last = lst.last {\n       \
    \     result.append(last)\n            let lst = lst.dropLast()\n        }\n \
    \   }\n    return result", "    // your code here\n    return []", '    return
    []', "    var result: [Int] = []\n    let sortedList = lst.sorted()\n    var maxValue\
    \ = lst.max()\n    var minValue = lst.min()\n    var maxIndex = sortedList.count\
    \ - 1\n    var minIndex = 0\n    while maxIndex != minIndex {\n        result.append(minValue!)\n\
    \        minIndex += 1\n        minValue = sortedList[minIndex]\n        result.append(maxValue!)\n\
    \        maxIndex -= 1\n        maxValue = sortedList[maxIndex]\n    }\n    result.append(minValue!)\n\
    \    return result", "    var new_list = [Int]()\n    if lst.count % 2 == 0 {\n\
    \        for i in stride(from: 0, to: lst.count, by: 2) {\n            new_list.append(lst[i])\n\
    \            new_list.append(lst[lst.count - i - 1])\n        }\n    } else {\n\
    \        new_list.append(lst[0])\n        for i in stride(from: 1, to: lst.count,\
    \ by: 2) {\n            new_list.append(lst[i])\n            new_list.append(lst[lst.count\
    \ - i])\n        }\n    }\n    return new_list", "    guard !lst.isEmpty else\
    \ { return [] }\n    let min = lst.min()!\n    let max = lst.max()!\n    var arr\
    \ = lst\n    var res = [Int]()\n    while !arr.isEmpty {\n        if min < max\
    \ {\n            res.append(min)\n            res.append(max)\n        } else\
    \ {\n            res.append(max)\n            res.append(min)\n        }\n   \
    \     arr.remove(element: min)\n        arr.remove(element: max)\n    }\n    return\
    \ res", "    var list = lst\n    var sort = [Int]()\n    while !list.isEmpty {\n\
    \        sort.append(list.remove(at: list.index(of: list.min()!)!))\n        if\
    \ list.isEmpty { break }\n        sort.append(list.remove(at: list.index(of: list.max()!)!))\n\
    \    }\n    return sort", "    var result = [Int]()\n    let start_val = lst.min()\
    \ ?? 0\n    let end_val = lst.max() ?? 0\n    var start = true\n    var last_val\
    \ = 0\n    let range = stride(from: start_val, to: end_val, by: 1)\n    for n\
    \ in range {\n        if start && lst.contains(n) {\n            result.append(n)\n\
    \            start = false\n            last_val = n\n        } else if !start\
    \ && lst.contains(n) {\n            if n - last_val >= 2 {\n                result.append(n)\n\
    \                start = true\n                last_val = n\n            }\n \
    \       }\n    }\n    return result", "    if lst.count == 0 {\n        return\
    \ []\n    }\n    var minIndex = 0\n    var maxIndex = 0\n    var currentMin =\
    \ lst[0]\n    var currentMax = lst[0]\n    var list = lst\n    var currentIndex\
    \ = 0\n    var tmp = 0\n    var arr = [Int]()\n    while currentIndex < list.count\
    \ {\n        for i in currentIndex..<list.count {\n            if list[i] < currentMin\
    \ {\n                currentMin = list[i]\n                minIndex = i\n    \
    \        }\n            if list[i] > currentMax {\n                currentMax\
    \ = list[i]\n                maxIndex = i\n            }\n        }\n        if\
    \ currentIndex % 2 == 0 {\n            tmp = list[currentIndex]\n            list[currentIndex]\
    \ = currentMin\n            list[minIndex] = tmp\n            arr.append(currentMin)\n\
    \        } else {\n            tmp = list[currentIndex]\n            list[currentIndex]\
    \ = currentMax\n            list[maxIndex] = tmp\n            arr.append(currentMax)\n\
    \        }\n        currentMin = list[currentIndex]\n        currentMax = list[currentIndex]\n\
    \        currentIndex += 1\n    }\n    return arr", "    var result = [Int]()\n\
    \    var tmp = lst\n    while tmp.count > 0 {\n        if tmp.count == 1 {\n \
    \           result.append(tmp[0])\n            break\n        }\n        result.append(tmp.min()!)\n\
    \        tmp.remove(at: tmp.index(of: tmp.min()!)!)\n        result.append(tmp.max()!)\n\
    \        tmp.remove(at: tmp.index(of: tmp.max()!)!)\n    }\n    return result",
  "    var newLst = lst\n    if newLst.count < 2 {\n        return newLst\n    }\n\
    \    var min = lst.min()\n    var max = lst.max()\n    while newLst.count != 0\
    \ {\n        newLst.removeAll {$0 == min}\n        if newLst.count == 0 {\n  \
    \          break\n        }\n        newLst.removeAll {$0 == max}\n        if\
    \ newLst.count == 0 {\n            break\n        }\n        min = newLst.min()\n\
    \        max = newLst.max()\n    }\n    return lst", "    guard lst.count > 0\
    \ else { return [] }\n    let sorted = lst.sorted()\n    var result = [Int]()\n\
    \    var low = 0\n    var high = sorted.count - 1\n    while low <= high {\n \
    \       result.append(sorted[low])\n        low += 1\n        if low <= high {\n\
    \            result.append(sorted[high])\n            high -= 1\n        }\n \
    \   }\n    return result", "    var new = lst.sorted()\n    var res: [Int] = []\n\
    \    while !new.isEmpty {\n        res.append(new.removeFirst())\n        res.append(new.removeLast())\n\
    \    }\n    return res", "    var strangeList = [Int]()\n    var hasTwoElements\
    \ = false\n    if lst.count > 1 {\n        var min = lst[0]\n        var max =\
    \ lst[0]\n        var minIndex = 0\n        var maxIndex = 0\n        for i in\
    \ 0..<lst.count {\n            if lst[i] > max {\n                max = lst[i]\n\
    \                maxIndex = i\n            }\n            if lst[i] < min {\n\
    \                min = lst[i]\n                minIndex = i\n            }\n \
    \       }\n        if minIndex == maxIndex {\n            strangeList.append(min)\n\
    \            for i in 0..<lst.count {\n                if i != minIndex {\n  \
    \                  strangeList.append(lst[i])\n                }\n           \
    \ }\n        } else {\n            strangeList.append(min)\n            strangeList.append(max)\n\
    \            hasTwoElements = true\n            for i in 0..<lst.count {\n   \
    \             if i != minIndex && i != maxIndex {\n                    strangeList.append(lst[i])\n\
    \                }\n            }\n        }\n    } else if lst.count == 1 {\n\
    \        strangeList.append(lst[0])\n    }\n    var count = lst.count\n    var\
    \ counter = 0\n    if count > 1 {\n        var currentMin = strangeList[0]\n \
    \       var currentMax = strangeList[0]\n        var currentMinIndex = 0\n   \
    \     var currentMaxIndex = 0\n        var i = 0\n        if hasTwoElements {\n\
    \            i = 2\n        }\n        while i != strangeList.count {\n      \
    \      if strangeList[i] > currentMax {\n                currentMax = strangeList[i]\n\
    \                currentMaxIndex = i\n            }\n            if strangeList[i]\
    \ < currentMin {\n                currentMin = strangeList[i]\n              \
    \  currentMinIndex = i\n            }\n            if i == strangeList.count -\
    \ 1 && currentMinIndex != currentMaxIndex {\n                strangeList.insert(currentMin,\
    \ at: i + 1)\n                strangeList.insert(currentMax, at: i + 2)\n    \
    \            counter += 2", "    var lst = lst\n    var result = [Int]()\n   \
    \ while lst.count > 0 {\n        if let min = lst.min() {\n            result.append(min)\n\
    \            lst.remove(at: lst.index(of: min)!)\n        }\n        if let max\
    \ = lst.max() {\n            result.append(max)\n            lst.remove(at: lst.index(of:\
    \ max)!)\n        }\n    }\n    return result", '    return lst', "    var sortlst\
    \ = lst\n    sortlst.sort()\n    var index = 0\n    var res = [Int]()\n    for\
    \ i in stride(from: 0, to: sortlst.count, by: 2) {\n        res.append(sortlst[i])\n\
    \    }\n    for i in stride(from: 1, to: sortlst.count, by: 2) {\n        res.append(sortlst[i])\n\
    \    }\n    return res", "    if lst.count < 2 {\n        return lst\n    }\n\
    \    var mutable_lst = lst\n    mutable_lst.sort()\n    var strange_lst: [Int]\
    \ = []\n    var left_iter = 0\n    var right_iter = mutable_lst.count - 1\n  \
    \  while left_iter <= right_iter {\n        if left_iter == right_iter {\n   \
    \         strange_lst.append(mutable_lst[left_iter])\n            break\n    \
    \    }\n        strange_lst.append(mutable_lst[left_iter])\n        strange_lst.append(mutable_lst[right_iter])\n\
    \        left_iter += 1\n        right_iter -= 1\n    }\n    return strange_lst",
  "    var lst = lst\n    var rsl = [Int]()\n    var i = 0\n    while lst.count >\
    \ 0 {\n        if i % 2 == 0 {\n            rsl.append(lst.min()!)\n         \
    \   lst.remove(at: lst.index(of: lst.min()!)!)\n        } else {\n           \
    \ rsl.append(lst.max()!)\n            lst.remove(at: lst.index(of: lst.max()!)!)\n\
    \        }\n        i += 1\n    }\n    return rsl", "    var lst = lst\n    lst.sort(by:\
    \ <)\n    var lst2 = lst\n    lst2.sort(by: >)\n    return lst.enumerated().map\
    \ { $0.offset % 2 == 0 ? lst[$0.offset] : lst2[$0.offset] }", "    var sorted_lst\
    \ = lst.sorted()\n    var ordered_lst: [Int] = []\n    var min_index = 0\n   \
    \ var max_index = sorted_lst.count - 1\n    while min_index < max_index {\n  \
    \      ordered_lst.append(sorted_lst[min_index])\n        ordered_lst.append(sorted_lst[max_index])\n\
    \        min_index += 1\n        max_index -= 1\n    }\n    if min_index == max_index\
    \ {\n        ordered_lst.append(sorted_lst[min_index])\n    }\n    return ordered_lst",
  '    return []', "    guard lst.count > 1 else { return lst }\n    var list = lst\n\
    \    list.sort()\n    var count = list.count\n    var result = [Int]()\n    var\
    \ i = 0\n    while count > 0 {\n        result.append(list[i])\n        if i ==\
    \ 0 {\n            i = count - 1\n        } else {\n            i -= 1\n     \
    \   }\n        count -= 1\n    }\n    return result", "    var lst = lst\n   \
    \ var result = [Int]()\n    var min = lst.first ?? 0\n    var max = lst.first\
    \ ?? 0\n    var index = 0\n    var x = 0\n    while lst.count > 0 {\n        lst.forEach\
    \ { item in\n            if item < min {\n                min = item\n       \
    \         index = x\n            }\n            if item > max {\n            \
    \    max = item\n                index = x\n            }\n            x += 1\n\
    \        }\n        if result.count % 2 == 0 {\n            result.append(min)\n\
    \            lst.remove(at: index)\n            min = lst.first ?? 0\n       \
    \ } else {\n            result.append(max)\n            lst.remove(at: index)\n\
    \            max = lst.first ?? 0\n        }\n        x = 0\n    }\n    return\
    \ result", "    guard lst.count > 1 else {\n        return lst\n    }\n    var\
    \ copyLst = lst\n    var result = [Int]()\n    let min = lst.min()\n    let max\
    \ = lst.max()\n    var minIndex = 0\n    var maxIndex = 0\n    for (index, value)\
    \ in lst.enumerated() {\n        if value == min {\n            minIndex = index\n\
    \        }\n        if value == max {\n            maxIndex = index\n        }\n\
    \    }\n    copyLst.remove(at: minIndex)\n    copyLst.remove(at: maxIndex - 1)\n\
    \    result.append(min!)\n    result.append(max!)\n    return result + strange_sort_list(lst:\
    \ copyLst)", "    var odd_even_list: [Int] = []\n    var sorted_list: [Int] =\
    \ lst.sorted()\n    var i = 0\n    while i < sorted_list.count {\n        if i\
    \ % 2 == 0 {\n            odd_even_list.append(sorted_list.removeLast())\n   \
    \     } else {\n            odd_even_list.append(sorted_list.removeFirst())\n\
    \        }\n        i += 1\n    }\n    return odd_even_list", "    guard lst.count\
    \ > 1 else {\n        return lst\n    }\n    var result = [Int]()\n    var even\
    \ = true\n    var temp = lst\n    while temp.count > 0 {\n        if even {\n\
    \            result.append(temp.min()!)\n            temp.remove(at: temp.index(of:\
    \ temp.min()!)!)\n        } else {\n            result.append(temp.max()!)\n \
    \           temp.remove(at: temp.index(of: temp.max()!)!)\n        }\n       \
    \ even = !even\n    }\n    return result", "    var newList = lst\n    var index\
    \ = 0\n    var lowToHigh = true\n    while index < newList.count {\n        if\
    \ lowToHigh {\n            newList.swapAt(index, newList.index(of: newList.min()!)!)\n\
    \            lowToHigh = false\n        } else {\n            newList.swapAt(index,\
    \ newList.index(of: newList.max()!)!)\n            lowToHigh = true\n        }\n\
    \        index += 1\n    }\n    return newList", "    var nums = lst\n    var\
    \ result = [Int]()\n    var max = nums.max()\n    var min = nums.min()\n    while\
    \ nums.count > 0 {\n        if max == nil && min == nil {\n            return\
    \ result\n        }\n        if let minimum = min {\n            result.append(minimum)\n\
    \            nums.remove(at: nums.index(of: minimum)!)\n        }\n        if\
    \ let maximum = max {\n            result.append(maximum)\n            nums.remove(at:\
    \ nums.index(of: maximum)!)\n        }\n        max = nums.max()\n        min\
    \ = nums.min()\n    }\n    return result", "    var result = [Int]()\n    var\
    \ max = lst\n    while !max.isEmpty {\n        result.append(max.removeFirst())\n\
    \        let temp = max.removeLast()\n        if !max.isEmpty {\n            result.append(temp)\n\
    \        }\n    }\n    return result", "    // TODO: Write strange_sort_list\n\
    \    return []", '    return []', '    return lst', "    if lst.count == 0 {\n\
    \        return []\n    }\n    var lst = lst\n    lst.sort {$0 < $1}\n    var\
    \ r = [Int]()\n    for (i, e) in lst.enumerated() {\n        if i % 2 == 0 {\n\
    \            r.append(e)\n        } else {\n            r.insert(e, at: 0)\n \
    \       }\n    }\n    return r", "    guard !lst.isEmpty else { return [] }\n\
    \    var lst = lst\n    let lstCount = lst.count\n    var sorted = [Int]()\n \
    \   var i = 0\n    var j = lstCount - 1\n    let isEven = lstCount % 2 == 0\n\
    \    while !lst.isEmpty {\n        sorted.append(lst.remove(at: i))\n        if\
    \ !lst.isEmpty {\n            sorted.append(lst.remove(at: j))\n        }\n  \
    \      i += 1\n        j -= 1\n    }\n    if isEven {\n        return sorted\n\
    \    } else {\n        return sorted.dropLast()\n    }", '    return []', "  \
    \  if lst.count == 0 {\n        return []\n    }\n    let sorted = lst.sorted()\n\
    \    var result = [Int]()\n    for i in 0..<sorted.count {\n        result.append(sorted[i\
    \ / 2 * (i % 2 == 0 ? 1 : -1)])\n    }\n    return result", "  var arr: [Int]\
    \ = lst\n  var stranged_arr: [Int] = []\n  var sorted_arr: [Int] = arr.sorted(by:\
    \ <)\n  var min_index: Int = 0\n  var max_index: Int = arr.count - 1\n  while\
    \ min_index <= max_index {\n    stranged_arr.append(sorted_arr[min_index])\n \
    \   min_index += 1\n    if min_index > max_index {\n      break\n    }\n    stranged_arr.append(sorted_arr[max_index])\n\
    \    max_index -= 1\n  }\n  return stranged_arr", "    if lst.count <= 1 {\n \
    \       return lst\n    }\n    var odd = lst.count % 2 != 0\n    var result =\
    \ [Int]()\n    var newLst = lst.sorted()\n    while newLst.count > 0 {\n     \
    \   if odd {\n            result.append(newLst.removeLast())\n        } else {\n\
    \            result.append(newLst.removeFirst())\n        }\n        odd = !odd\n\
    \    }\n    return result", "    var strLst = [Int]()\n    var min = lst.min()\n\
    \    var max = lst.max()\n    var lst = lst\n    while lst.count > 0 {\n     \
    \   if strLst.count % 2 == 0 {\n            strLst.append(min!)\n            lst.remove(at:\
    \ lst.index(of: min!)!)\n            min = lst.min()\n        } else {\n     \
    \       strLst.append(max!)\n            lst.remove(at: lst.index(of: max!)!)\n\
    \            max = lst.max()\n        }\n    }\n    return strLst", "    var newLst\
    \ = lst\n    for (i, _) in lst.enumerated() {\n        if i % 2 == 0 {\n     \
    \       newLst[i] = lst.min()!\n        } else {\n            newLst[i] = lst.max()!\n\
    \        }\n    }\n    return newLst", '    return strange_sort_list_impl(lst:
    lst, is_max: false)', "  guard lst.count > 1 else { return lst }\n  var asc =\
    \ lst.sorted()\n  var result = [Int]()\n  while asc.count > 0 {\n    if asc.count\
    \ == 1 {\n      result.append(asc.popLast()!)\n    } else {\n      result.append(asc.removeFirst())\n\
    \      result.append(asc.popLast()!)\n    }\n  }\n  return result", "    // TODO:\
    \ Implement it!\n    return []", "    var result: [Int] = []\n    var new_lst\
    \ = lst\n    while new_lst.count > 0 {\n        var min = Int.max\n        var\
    \ max = Int.min\n        var min_index = 0\n        var max_index = 0\n      \
    \  for i in 0..<new_lst.count {\n            if new_lst[i] < min {\n         \
    \       min = new_lst[i]\n                min_index = i\n            }\n     \
    \       if new_lst[i] > max {\n                max = new_lst[i]\n            \
    \    max_index = i\n            }\n        }\n        if result.count == 0 {\n\
    \            result.append(min)\n            new_lst.remove(at: min_index)\n \
    \       } else {\n            result.append(max)\n            new_lst.remove(at:\
    \ max_index)\n        }\n    }\n    return result", "\tvar ret: [Int] = []\n\t\
    var sorted = lst.sorted()\n\tvar sign = true\n\twhile sorted.count > 0 {\n\t\t\
    if sign {\n\t\t\tret.append(sorted.removeFirst())\n\t\t} else {\n\t\t\tret.append(sorted.removeLast())\n\
    \t\t}\n\t\tsign = !sign\n\t}\n\treturn ret", "\tvar new_arr = [Int]()\n\tvar sorted_lst\
    \ = lst.sorted()\n\tvar small = 0\n\tvar large = sorted_lst.count - 1\n\twhile\
    \ small <= large {\n\t\tnew_arr.append(sorted_lst[small])\n\t\tsmall += 1\n\t\t\
    if small <= large {\n\t\t\tnew_arr.append(sorted_lst[large])\n\t\t\tlarge -= 1\n\
    \t\t}\n\t}\n\treturn new_arr", "    var items: [Int] = lst\n    var result: [Int]\
    \ = []\n    while items.count > 0 {\n        let max = items.max()\n        let\
    \ min = items.min()\n        let idx = items.index(of: max!)\n        items.remove(at:\
    \ idx!)\n        result.append(max!)\n        let idxMin = items.index(of: min!)\n\
    \        items.remove(at: idxMin!)\n        result.append(min!)\n    }\n    return\
    \ result", "    var odd = true\n    var dict = [Int: [Int]]()\n    for i in lst\
    \ {\n        if odd {\n            if var arr = dict[-i] {\n                arr.append(i)\n\
    \                dict[-i] = arr\n            } else {\n                dict[-i]\
    \ = [i]\n            }\n        } else {\n            if var arr = dict[i] {\n\
    \                arr.append(i)\n                dict[i] = arr\n            } else\
    \ {\n                dict[i] = [i]\n            }\n        }\n        odd = !odd\n\
    \    }\n    var result = [Int]()\n    var sortedKeys = Array(dict.keys).sorted()\n\
    \    for key in sortedKeys {\n        result.append(contentsOf: dict[key]!)\n\
    \    }\n    return result", "\tif lst.count <= 2 {\n\t\treturn lst\n\t}\n\t\n\t\
    let minVal = lst.min()!\n\tvar minIndex = lst.index(of: minVal)!\n\tvar newList\
    \ = [Int]()\n\tvar isMin = true\n\tvar ind = 0\n\t\n\tfor _ in lst {\n\t\tlet\
    \ currVal = lst[minIndex]\n\t\tnewList.append(currVal)\n\t\t\n\t\tif isMin {\n\
    \t\t\tlet updatedMaxVal = lst[lst.index(before: minIndex)]\n\t\t\tminIndex = lst.index(of:\
    \ updatedMaxVal)!\n\t\t\tisMin = false\n\t\t} else {\n\t\t\tminIndex = lst.index(after:\
    \ minIndex)\n\t\t\tisMin = true\n\t\t}\n\t\t\n\t\tind += 1\n\t}\n\t\n\treturn\
    \ newList", "    guard !lst.isEmpty else { return [] }\n    guard lst.count >\
    \ 1 else { return lst }\n    let sortedLst = lst.sorted()\n    var result: [Int]\
    \ = []\n    var maxIndex = sortedLst.count - 1\n    var minIndex = 0\n    for\
    \ _ in sortedLst {\n        result.append(sortedLst[minIndex])\n        minIndex\
    \ += 1\n        if minIndex < maxIndex {\n            result.append(sortedLst[maxIndex])\n\
    \            maxIndex -= 1\n        }\n    }\n    return result", "    var list\
    \ = lst\n    var sorted: [Int] = []\n    for _ in 0..<list.count {\n        sorted.append(list.min()!)\n\
    \        list.removeFirst(list.firstIndex(of: list.min()!)!)\n        sorted.append(list.max()!)\n\
    \        list.removeFirst(list.firstIndex(of: list.max()!)!)\n    }\n    return\
    \ sorted", "    let sorted = lst.sorted()\n    var result = [Int]()\n    var i\
    \ = 0\n    while i < sorted.count {\n        result.append(sorted[i])\n      \
    \  if i+1 < sorted.count {\n            result.append(sorted[sorted.count - 1\
    \ - i])\n        }\n        i += 1\n    }\n    return result", "    var c = lst.count\n\
    \    var lst = lst\n    var result: [Int] = []\n    for _ in 0..<c {\n       \
    \ var min = Int.max\n        var indx = 0\n        for (i, v) in lst.enumerated()\
    \ {\n            if v < min {\n                min = v\n                indx =\
    \ i\n            }\n        }\n        result.append(min)\n        lst.remove(at:\
    \ indx)\n        if lst.count > 0 {\n            var max = Int.min\n         \
    \   var indx = 0\n            for (i, v) in lst.enumerated() {\n             \
    \   if v > max {\n                    max = v\n                    indx = i\n\
    \                }\n            }\n            result.append(max)\n          \
    \  lst.remove(at: indx)\n        }\n    }\n    return result", "    if lst.count\
    \ <= 1 {\n        return lst\n    }\n    let minimum = lst.min()!\n    let maximum\
    \ = lst.max()!\n    let odd = lst.filter { $0 == minimum || $0 == maximum }\n\
    \    let even = lst.filter { $0 != minimum && $0 != maximum }\n    return odd\
    \ + even", "    let sorted = lst.sorted()\n    var result = [Int]()\n    var i\
    \ = 0\n    var j = sorted.count - 1\n    while i <= j {\n        result.append(sorted[i])\n\
    \        i += 1\n        if i > j {\n            break\n        }\n        result.append(sorted[j])\n\
    \        j -= 1\n    }\n    return result", '    return []', "    var lst = lst\n\
    \    var new_lst: [Int] = []\n    var min_num: Int = 0\n    var max_num: Int =\
    \ 0\n    for i in 0..<lst.count{\n        min_num = lst.min()!\n        max_num\
    \ = lst.max()!\n        if i % 2 == 0{\n            new_lst.append(min_num)\n\
    \            lst.remove(at: lst.index(of: min_num)!)\n        }\n        else{\n\
    \            new_lst.append(max_num)\n            lst.remove(at: lst.index(of:\
    \ max_num)!)\n        }\n    }\n    return new_lst", "    let sortedLst = lst.sorted()\n\
    \    var minIndex = 0\n    var maxIndex = sortedLst.count - 1\n    var strangeLst\
    \ = [Int]()\n    for _ in lst {\n        strangeLst.append(sortedLst[minIndex])\n\
    \        minIndex += 1\n        if maxIndex > minIndex {\n            strangeLst.append(sortedLst[maxIndex])\n\
    \            maxIndex -= 1\n        }\n    }\n    return strangeLst", '    return
    []', "    guard !lst.isEmpty else { return [] }\n    var workingSet = lst\n  \
    \  var results = [Int]()\n    var isMin = true\n    while !workingSet.isEmpty\
    \ {\n        if isMin {\n            results.append(workingSet.min()!)\n     \
    \       workingSet.remove(at: workingSet.index(of: workingSet.min()!)!)\n    \
    \    } else {\n            results.append(workingSet.max()!)\n            workingSet.remove(at:\
    \ workingSet.index(of: workingSet.max()!)!)\n        }\n        isMin = !isMin\n\
    \    }\n    return results", "    let lst1 = lst.sorted()\n    var left = 0\n\
    \    var right = lst1.count - 1\n    var result = [Int]()\n    for _ in 0..<lst1.count\
    \ {\n        result.append(lst1[left])\n        if left < right {\n          \
    \  result.append(lst1[right])\n        }\n        left += 1\n        right -=\
    \ 1\n    }\n    return result", "    let arr = lst.sorted()\n    var array = [Int]()\n\
    \    var i = 0\n    var j = arr.count - 1\n    while j >= i {\n        array.append(arr[i])\n\
    \        if i == j {\n            break\n        }\n        array.append(arr[j])\n\
    \        i += 1\n        j -= 1\n    }\n    return array", "    guard !lst.isEmpty\
    \ else { return [] }\n    var result = [Int]()\n    var copy = lst\n    var i\
    \ = 0\n    while !copy.isEmpty {\n        if i % 2 == 0 {\n            result.append(copy.min()!)\n\
    \            copy.remove(at: copy.index(of: copy.min()!)!)\n        } else {\n\
    \            result.append(copy.max()!)\n            copy.remove(at: copy.index(of:\
    \ copy.max()!)!)\n        }\n        i += 1\n    }\n    return result", "    var\
    \ res = [Int]()\n    let copy = lst.sorted()\n    var index = 0\n    while copy.count\
    \ > 0 {\n        res.append(copy[index])\n        copy.remove(at: index)\n   \
    \     if copy.count == 0 {\n            break\n        }\n        if index ==\
    \ 0 {\n            index = copy.count - 1\n        } else {\n            index\
    \ -= 1\n        }\n    }\n    return res", "    let tmp = lst.sorted()\n    var\
    \ sorted: [Int] = []\n    while tmp.count > 0 {\n        sorted.append(tmp.first!)\n\
    \        tmp.removeFirst()\n        if tmp.count > 0 {\n            sorted.append(tmp.last!)\n\
    \            tmp.removeLast()\n        }\n    }\n    return sorted", "    var\
    \ ret = [Int]()\n    var sorted_list = lst.sorted()\n    var left = 0\n    var\
    \ right = sorted_list.count - 1\n    while left <= right {\n        if left ==\
    \ right {\n            ret.append(sorted_list[left])\n            break\n    \
    \    }\n        ret.append(sorted_list[left])\n        ret.append(sorted_list[right])\n\
    \        left += 1\n        right -= 1\n    }\n    return ret", "    var sortedList\
    \ = lst.sorted(by: <)\n    var result: [Int] = []\n    for (key,value) in sortedList.enumerated()\
    \ {\n        if (key % 2 == 0) {\n            result.append(value)\n        }\
    \ else {\n            result.insert(value, at: 0)\n        }\n    }\n    return\
    \ result", "    var result = [Int]()\n    var lst = lst\n    while lst.count >\
    \ 0 {\n        let min = min_list(lst: lst)\n        let max = max_list(lst: lst)\n\
    \        if lst.count == 1 {\n            result.append(min)\n            lst.remove(at:\
    \ lst.index(of: min)!)\n        } else {\n            result.append(min)\n   \
    \         result.append(max)\n            lst.remove(at: lst.index(of: min)!)\n\
    \            lst.remove(at: lst.index(of: max)!)\n        }\n    }\n    return\
    \ result", "    let sorted = lst.sorted()\n    var odd = [Int]()\n    var even\
    \ = [Int]()\n    for (i, item) in sorted.enumerated() {\n        if i % 2 == 0\
    \ {\n            odd.append(item)\n        } else {\n            even.append(item)\n\
    \        }\n    }\n    return odd + even.reversed()", "    var result: [Int] =\
    \ []\n    var lst = lst\n    var min_value = lst.min()!\n    var max_value = lst.max()!\n\
    \    var min_index = lst.index(of: min_value)!\n    var max_index = lst.index(of:\
    \ max_value)!\n    var tmp = lst[min_index]\n    lst[min_index] = lst[max_index]\n\
    \    lst[max_index] = tmp\n    result.append(lst[0])\n    lst.remove(at: 0)\n\
    \    while lst.count > 0 {\n        min_value = lst.min()!\n        max_value\
    \ = lst.max()!\n        min_index = lst.index(of: min_value)!\n        max_index\
    \ = lst.index(of: max_value)!\n        tmp = lst[min_index]\n        lst[min_index]\
    \ = lst[max_index]\n        lst[max_index] = tmp\n        result.append(lst[0])\n\
    \        lst.remove(at: 0)\n    }\n    return result", "    var array = lst\n\
    \    var idx = 0\n    for _ in array {\n        array.insert(array.remove(at:\
    \ array.index(of: array.min()!)!), at: idx)\n        array.insert(array.remove(at:\
    \ array.index(of: array.max()!)!), at: idx + 1)\n        idx += 2\n    }\n   \
    \ return array", "  var lst = lst\n  var lst1 = [Int]()\n  var lst2 = [Int]()\n\
    \  var flag = false\n  if lst.count % 2 == 0 {\n    while lst.count > 0 {\n  \
    \    let min = lst.min()!\n      let max = lst.max()!\n      if flag {\n     \
    \   lst1.append(min)\n        lst2.append(max)\n      } else {\n        lst1.append(max)\n\
    \        lst2.append(min)\n      }\n      lst.removeAll {$0 == min}\n      lst.removeAll\
    \ {$0 == max}\n      flag = !flag\n    }\n    return lst1 + lst2\n  } else {\n\
    \    while lst.count > 1 {\n      let min = lst.min()!\n      let max = lst.max()!\n\
    \      if flag {\n        lst1.append(min)\n        lst2.append(max)\n      }\
    \ else {\n        lst1.append(max)\n        lst2.append(min)\n      }\n      lst.removeAll\
    \ {$0 == min}\n      lst.removeAll {$0 == max}\n      flag = !flag\n    }\n  \
    \  return lst1 + lst + lst2\n  }", "    if lst.count == 0 {\n        return []\n\
    \    }\n    var new_lst = lst\n    let min_i = new_lst.index(of: new_lst.min()!)!\n\
    \    let max_i = new_lst.index(of: new_lst.max()!)!\n    new_lst.remove(at: min_i)\n\
    \    new_lst.remove(at: max_i)\n    return [lst[min_i], lst[max_i]] + strange_sort_list(lst:\
    \ new_lst)", "    let sorted = lst.sorted(by: <)\n    let firstHalf = sorted.dropLast(lst.count\
    \ / 2)\n    let secondHalf = sorted.dropFirst(lst.count / 2)\n    var strangeSorted\
    \ = [Int]()\n    for (index, _) in sorted.enumerated() {\n        if index % 2\
    \ == 0 {\n            strangeSorted.append(firstHalf[index / 2])\n        } else\
    \ {\n            strangeSorted.append(secondHalf[index / 2])\n        }\n    }\n\
    \    return strangeSorted", "    var result = [Int]()\n    var copyLst = lst\n\
    \    var x = 0\n    var z = lst.count\n    for _ in lst {\n        if x == z {\n\
    \            result.append(copyLst.min()!)\n            copyLst.remove(at: copyLst.index(of:\
    \ copyLst.min()!)!)\n            x = 0\n            z -= 1\n        } else {\n\
    \            result.append(copyLst.max()!)\n            copyLst.remove(at: copyLst.index(of:\
    \ copyLst.max()!)!)\n            x += 1\n        }\n    }\n    return result",
  "    var result: [Int] = []\n    var newArray = lst\n    var sortArray = lst.sorted(by:\
    \ <)\n    var i = 0\n    while sortArray.count > 0 {\n        if i % 2 == 0 {\n\
    \            result.append(sortArray.removeFirst())\n        } else {\n      \
    \      result.append(sortArray.removeLast())\n        }\n        i += 1\n    }\n\
    \    return result", "    var sorted_list = lst.sorted()\n    var sort = [Int]()\n\
    \    var count = 0\n    var flag = true\n    while count < sorted_list.count {\n\
    \        if flag {\n            sort.append(sorted_list.removeFirst())\n     \
    \       flag = false\n        } else {\n            sort.append(sorted_list.removeLast())\n\
    \            flag = true\n        }\n        count += 1\n    }\n    return sort",
  "    // Write your code here.\n    // Replace the following line with your code.\n\
    \    return lst", "    var list = lst\n    var result = [Int]()\n    var increase\
    \ = true\n    var min = Int.min\n    var max = Int.max\n    while list.count >\
    \ 0 {\n        if increase {\n            min = list.reduce(Int.max, { min($0,\
    \ $1) })\n            if let index = list.index(of: min) {\n                result.append(min)\n\
    \                list.remove(at: index)\n            }\n        } else {\n   \
    \         max = list.reduce(Int.min, { max($0, $1) })\n            if let index\
    \ = list.index(of: max) {\n                result.append(max)\n              \
    \  list.remove(at: index)\n            }\n        }\n        increase = !increase\n\
    \    }\n    return result", "    let sortedList = lst.sorted()\n    var res: [Int]\
    \ = []\n    for i in 0..<sortedList.count {\n        if i % 2 == 0 {\n       \
    \     res.append(sortedList[i / 2])\n        } else {\n            res.append(sortedList[sortedList.count\
    \ - i / 2 - 1])\n        }\n    }\n    return res", "    var positiveArray = lst.filter{$0\
    \ >= 0}\n    var negativeArray = lst.filter{$0 < 0}\n    let count = lst.count\n\
    \    var resultArray = [Int]()\n    var i = 0\n    while i < count {\n       \
    \ if let minValue = positiveArray.min() {\n            resultArray.append(minValue)\n\
    \            positiveArray.remove(object: minValue)\n        }\n        if let\
    \ maxValue = negativeArray.max() {\n            resultArray.append(maxValue)\n\
    \            negativeArray.remove(object: maxValue)\n        }\n        i += 1\n\
    \    }\n    return resultArray", "    var result = [Int]()\n    var arr = lst\n\
    \    var min = arr.min()\n    var max = arr.max()\n    var count = arr.count\n\
    \    while(min != nil && max != nil && count != 0) {\n        result.append(min!)\n\
    \        result.append(max!)\n        arr.remove(at: arr.index(of: min!)!)\n \
    \       arr.remove(at: arr.index(of: max!)!)\n        min = arr.min()\n      \
    \  max = arr.max()\n        count -= 2\n    }\n    if(arr.count != 0) {\n    \
    \    result.append(arr[0])\n    }\n    return result", "    var lst = lst.sorted()\n\
    \    var newLst: [Int] = []\n    while lst.count > 0 {\n        newLst.append(lst.first!)\n\
    \        lst.removeFirst()\n        if lst.count > 0 {\n            newLst.append(lst.last!)\n\
    \            lst.removeLast()\n        }\n    }\n    return newLst", "    var\
    \ len = lst.count\n    if len == 0 {\n        return lst\n    }\n    var lst =\
    \ lst\n    var result: [Int] = []\n    while len > 0 {\n        result.append(lst.min()!)\n\
    \        lst.remove(at: lst.index(of: lst.min()!)!)\n        len -= 1\n      \
    \  if len == 0 {\n            break\n        }\n        result.append(lst.max()!)\n\
    \        lst.remove(at: lst.index(of: lst.max()!)!)\n        len -= 1\n    }\n\
    \    return result", '    return []', '    return []', "    if lst.count == 0\
    \ {\n        return []\n    }\n    let n = lst.count\n    let sorted_list = lst.sorted()\n\
    \    var odd = lst.count % 2 == 1\n    var k = 0\n    var i = odd ? 1 : 0\n  \
    \  var result: [Int] = []\n    while k < n / 2 {\n        result.append(sorted_list[k])\n\
    \        result.append(sorted_list[n - k - 1])\n        k += 1\n    }\n    if\
    \ odd {\n        result.append(sorted_list[k])\n    }\n    return result", '    return
    lst', "    if lst.count == 0 {\n        return []\n    }\n    var arr = lst\n\
    \    var result: [Int] = []\n    var was_ascending = true\n    while !arr.isEmpty\
    \ {\n        var min = arr[0]\n        var max = arr[0]\n        for i in arr\
    \ {\n            if i < min {\n                min = i\n            }\n      \
    \      if i > max {\n                max = i\n            }\n        }\n     \
    \   if was_ascending {\n            result.append(min)\n            arr.remove(at:\
    \ arr.firstIndex(of: min)!)\n            if !arr.isEmpty {\n                result.append(max)\n\
    \                arr.remove(at: arr.firstIndex(of: max)!)\n            }\n   \
    \     } else {\n            result.append(max)\n            arr.remove(at: arr.firstIndex(of:\
    \ max)!)\n            if !arr.isEmpty {\n                result.append(min)\n\
    \                arr.remove(at: arr.firstIndex(of: min)!)\n            }\n   \
    \     }\n        was_ascending = !was_ascending\n    }\n    return result", " \
    \   var result = [Int]()\n    var newList = lst\n    while newList.count > 0 {\n\
    \        let minValue = newList.min()!\n        let maxValue = newList.max()!\n\
    \        result.append(minValue)\n        result.append(maxValue)\n        newList.remove(at:\
    \ newList.index(of: minValue)!)\n        newList.remove(at: newList.index(of:\
    \ maxValue)!)\n    }\n    return result", "    var newList = lst\n    var index\
    \ = 0\n    if newList.count % 2 == 0 {\n        for i in 0...newList.count / 2\
    \ - 1 {\n            newList.insert(newList[i], at: index)\n            index\
    \ += 2\n        }\n    } else {\n        for i in 0...newList.count / 2 {\n  \
    \          newList.insert(newList[i], at: index)\n            index += 2\n   \
    \     }\n    }\n    return newList", "    var lst = lst\n    var result: [Int]\
    \ = []\n    if lst.count == 0 {\n        return result\n    }\n    while lst.count\
    \ > 0 {\n        if let min = lst.min() {\n            result.append(min)\n  \
    \          lst.remove(at: lst.index(of: min)!)\n        }\n        if let max\
    \ = lst.max() {\n            result.append(max)\n            lst.remove(at: lst.index(of:\
    \ max)!)\n        }\n    }\n    return result", "    var result: [Int] = []\n\
    \    let length = lst.count\n    guard length > 0 else { return result }\n   \
    \ guard length > 1 else { return lst }\n    var mutableLst = lst\n    while mutableLst.count\
    \ > 0 {\n        result.append(mutableLst.min()!)\n        mutableLst.removeAtIndex(mutableLst.indexOf(mutableLst.min()!)!)\n\
    \        if mutableLst.count > 0 {\n            result.append(mutableLst.max()!)\n\
    \            mutableLst.removeAtIndex(mutableLst.indexOf(mutableLst.max()!)!)\n\
    \        }\n    }\n    return result", "    //  if arr is empty return empty array\n\
    \    guard !lst.isEmpty else {\n        return []\n    }\n    //  if arr has 1\
    \ element return arr\n    guard lst.count > 1 else {\n        return lst\n   \
    \ }\n    //  sort array and make mutable copy\n    var mutArr = lst.sorted()\n\
    \    //  create empty array for result\n    var resArr = [Int]()\n    //  start\
    \ index\n    var index = 0\n    //  take first two elements of mutArr and append\
    \ to result array\n    while index < mutArr.count / 2 {\n        //  check arr[ind]\
    \ and arr[arr.count - 1 - ind] for valid indices\n        guard let first = mutArr.element(at:\
    \ index),\n              let last = mutArr.element(at: mutArr.count - 1 - index)\
    \ else {\n            break\n        }\n        //  append elements\n        resArr.append(first)\n\
    \        resArr.append(last)\n        //  remove appended elements from mutArr\n\
    \        mutArr.remove(at: index)\n        mutArr.remove(at: mutArr.count - 1\
    \ - index)\n    }\n    //  if mutArr still has elements append them to result\
    \ array\n    if !mutArr.isEmpty {\n        resArr.append(contentsOf: mutArr)\n\
    \    }\n    return resArr", "    guard lst.count > 1 else {\n        return lst\n\
    \    }\n    let sortedArray = lst.sorted()\n    var resultArray = [Int]()\n  \
    \  var minIndex = 0\n    var maxIndex = sortedArray.count - 1\n    var isInsertMin\
    \ = true\n    while minIndex <= maxIndex {\n        if isInsertMin {\n       \
    \     resultArray.append(sortedArray[minIndex])\n            minIndex += 1\n \
    \       } else {\n            resultArray.append(sortedArray[maxIndex])\n    \
    \        maxIndex -= 1\n        }\n        isInsertMin = !isInsertMin\n    }\n\
    \    return resultArray", "    let sorted = lst.sorted()\n    var result = [Int]()\n\
    \    var current = 0\n    var upper = lst.count - 1\n    var lower = 0\n    while\
    \ current < lst.count {\n        if current % 2 == 0 {\n            result.append(sorted[lower])\n\
    \            lower += 1\n        } else {\n            result.append(sorted[upper])\n\
    \            upper -= 1\n        }\n        current += 1\n    }\n    return result",
  '    return []', "    guard !lst.isEmpty else { return [] }\n    let sortedList\
    \ = lst.sorted()\n    var ans: [Int] = []\n    var i = 0\n    var j = sortedList.count\
    \ - 1\n    while i < j {\n        ans.append(sortedList[i])\n        ans.append(sortedList[j])\n\
    \        i += 1\n        j -= 1\n    }\n    if i == j {\n        ans.append(sortedList[i])\n\
    \    }\n    return ans", "    var lstCopy = lst\n    lstCopy.sort()\n    var index\
    \ = 0\n    var index2 = lstCopy.count - 1\n    var array = [Int]()\n    while(lstCopy.count\
    \ > 0) {\n        if index2 == 0 {\n            array.append(lstCopy[index])\n\
    \            index += 1\n            lstCopy.remove(at: index)\n        } else\
    \ {\n            array.append(lstCopy[index])\n            array.append(lstCopy[index2])\n\
    \            index += 1\n            index2 -= 1\n            lstCopy.remove(at:\
    \ index)\n            lstCopy.remove(at: index2)\n        }\n    }\n    return\
    \ array", "    var newList = lst\n    newList.sort()\n    var start = 0\n    var\
    \ end = newList.count - 1\n    var result = [Int]()\n    while start <= end {\n\
    \        result.append(newList[start])\n        if start != end {\n          \
    \  result.append(newList[end])\n        }\n        start += 1\n        end -=\
    \ 1\n    }\n    return result", "    // your code here\n    return lst", "   \
    \ var remaining = lst\n    var result: [Int] = []\n    while remaining.count >\
    \ 0 {\n        if remaining.count == 1 {\n            result.append(remaining[0])\n\
    \            remaining.remove(at: 0)\n        } else {\n            let minimum\
    \ = remaining.min()!\n            let minimumIndex = remaining.index(of: minimum)!\n\
    \            result.append(minimum)\n            remaining.remove(at: minimumIndex)\n\
    \            let maximum = remaining.max()!\n            let maximumIndex = remaining.index(of:\
    \ maximum)!\n            result.append(maximum)\n            remaining.remove(at:\
    \ maximumIndex)\n        }\n    }\n    return result", "    let sorted = lst.sorted(by:\
    \ {$0 < $1})\n    if lst.count <= 1 {\n        return lst\n    }\n    var result\
    \ = [Int]()\n    var i = 0\n    var j = sorted.count - 1\n    while i <= j {\n\
    \        result.append(sorted[i])\n        i += 1\n        if i <= j {\n     \
    \       result.append(sorted[j])\n            j -= 1\n        }\n    }\n    return\
    \ result", "    var min = lst.min()\n    var max = lst.max()\n    var currentIndex\
    \ = lst.count - 1\n    var finalList = [Int]()\n    while (currentIndex >= 0)\
    \ {\n        if let min = min {\n            finalList.append(min)\n        }\n\
    \        if let max = max {\n            finalList.append(max)\n        }\n  \
    \      currentIndex -= 1\n    }\n    return finalList", "    // return lst.sorted(by:\
    \ <)\n    return lst.sorted(by: { $0 < $1 })", "    var list = lst\n    var result\
    \ = [Int]()\n    while list.count > 0 {\n        let minimum = list.min()!\n \
    \       let maximum = list.max()!\n        if result.count == 0 {\n          \
    \  result.append(minimum)\n        }\n        else {\n            result.append(maximum)\n\
    \        }\n        list.remove(at: list.index(of: minimum)!)\n        list.remove(at:\
    \ list.index(of: maximum)!)\n    }\n    return result", "    var copy = lst\n\
    \    var r = Array<Int>()\n    if copy.count % 2 == 0 {\n        while copy.count\
    \ > 0 {\n            r.append(copy.remove(at: copy.index(of: copy.min()!)!))\n\
    \            r.append(copy.remove(at: copy.index(of: copy.max()!)!))\n       \
    \ }\n    } else {\n        while copy.count > 1 {\n            r.append(copy.remove(at:\
    \ copy.index(of: copy.min()!)!))\n            r.append(copy.remove(at: copy.index(of:\
    \ copy.max()!)!))\n        }\n        r.append(copy.remove(at: 0))\n    }\n  \
    \  return r", "    // Write your code here.\n    var x = lst.sorted()\n    var\
    \ ans = [Int]()\n    while x.count > 0 {\n        ans.append(x.removeFirst())\n\
    \        if x.count > 0 {\n            ans.append(x.removeLast())\n        }\n\
    \    }\n    return ans", "    var lst = lst\n    var res: [Int] = []\n    var\
    \ min: Int\n    var max: Int\n    var min_index: Int\n    var max_index: Int\n\
    \    for i in 0..<lst.count {\n        if lst.count == 0 {\n            break\n\
    \        }\n        min = lst[0]\n        max = lst[0]\n        min_index = 0\n\
    \        max_index = 0\n        for (index, value) in lst.enumerated() {\n   \
    \         if value < min {\n                min = value\n                min_index\
    \ = index\n            }\n            if value > max {\n                max =\
    \ value\n                max_index = index\n            }\n        }\n       \
    \ res.append(min)\n        lst.remove(at: min_index)\n        if lst.count ==\
    \ 0 {\n            break\n        }\n        res.append(max)\n        lst.remove(at:\
    \ max_index)\n    }\n    return res", "    if lst.count == 0 {\n        return\
    \ lst\n    } else if lst.count == 1 {\n        return lst\n    } else {\n    \
    \    let remain = lst[1...lst.count - 1]\n        let min = lst.min()!\n     \
    \   let max = remain.max()!\n        let minIdx = lst.index(of: min)!\n      \
    \  let maxIdx = lst.index(of: max)!\n        if maxIdx < minIdx {\n          \
    \  return [min, max] + strange_sort_list(lst: remain.filter({$0 != max}))\n  \
    \      } else {\n            return [min] + strange_sort_list(lst: remain.filter({$0\
    \ != min})) + [max]\n        }\n    }", "    guard lst.count > 0 else { return\
    \ lst }\n    var mutableLst = lst\n    for i in 0..<mutableLst.count {\n     \
    \   mutableLst.sort { $0 < $1 }\n        let min = mutableLst.removeFirst()\n\
    \        mutableLst.sort { $0 > $1 }\n        let max = mutableLst.removeFirst()\n\
    \        mutableLst.insert(min, at: i)\n        mutableLst.insert(max, at: i +\
    \ 1)\n    }\n    return mutableLst", "    if lst.count < 2 {\n        return lst\n\
    \    }\n    var newlst = lst\n    var sorted = [Int]()\n    while newlst.count\
    \ > 0 {\n        var min = 0\n        var max = 0\n        for i in 1..<newlst.count\
    \ {\n            if newlst[i] < newlst[min] {\n                min = i\n     \
    \       }\n            if newlst[i] > newlst[max] {\n                max = i\n\
    \            }\n        }\n        sorted.append(newlst[min])\n        newlst.remove(at:\
    \ min)\n        if newlst.count == 0 {\n            break\n        }\n       \
    \ sorted.append(newlst[max])\n        newlst.remove(at: max)\n    }\n    return\
    \ sorted", "\tguard lst.count > 1 else { return lst }\n\tvar result: [Int] = []\n\
    \tvar buffer: [Int] = lst\n\twhile buffer.count > 0 {\n\t\tguard let max = buffer.max(),\
    \ let min = buffer.min() else { return [] }\n\t\tif max != min {\n\t\t\tresult.append(min)\n\
    \t\t\tresult.append(max)\n\t\t\tbuffer.remove(at: buffer.index(of: min)!)\n\t\t\
    \tbuffer.remove(at: buffer.index(of: max)!)\n\t\t} else {\n\t\t\tresult.append(max)\n\
    \t\t\tbuffer.remove(at: buffer.index(of: max)!)\n\t\t}\n\t}\n\treturn result",
  "    let sortedLst = lst.sorted()\n    var strangedLst: [Int] = []\n    var asc\
    \ = true\n    while sortedLst.count > 0 {\n        if asc {\n            strangedLst.append(sortedLst.first!)\n\
    \            sortedLst.removeFirst()\n        } else {\n            strangedLst.append(sortedLst.last!)\n\
    \            sortedLst.removeLast()\n        }\n        asc = !asc\n    }\n  \
    \  return strangedLst", "  var lst = lst.sorted(), res = [Int]()\n  while !lst.isEmpty\
    \ {\n    res.append(lst.removeFirst())\n    if !lst.isEmpty {\n      res.append(lst.removeLast())\n\
    \    }\n  }\n  return res", "    if lst.count == 0 {\n        return []\n    }\n\
    \    var result: [Int] = []\n    let sorted_lst = lst.sorted()\n    var i = 0\n\
    \    var j = sorted_lst.count - 1\n    while i <= j {\n        result.append(sorted_lst[i])\n\
    \        i += 1\n        if i <= j {\n            result.append(sorted_lst[j])\n\
    \            j -= 1\n        }\n    }\n    return result", "    var sortedArray\
    \ = lst.sorted()\n    var resultArray = [Int]()\n    for i in 0..<sortedArray.count\
    \ {\n        if i % 2 == 0 {\n            resultArray.append(sortedArray.removeFirst())\n\
    \        } else {\n            resultArray.append(sortedArray.removeLast())\n\
    \        }\n    }\n    return resultArray", "    let copy = lst.sorted()\n   \
    \ var result = [Int]()\n    var smaller = copy.startIndex\n    var bigger = copy.endIndex\
    \ - 1\n    while smaller <= bigger {\n        result.append(copy[smaller])\n \
    \       smaller += 1\n        if smaller <= bigger {\n            result.append(copy[bigger])\n\
    \            bigger -= 1\n        }\n    }\n    return result", "    guard !lst.isEmpty\
    \ else { return [] }\n    let sorted = lst.sorted()\n    var odd = Array(sorted[1..<sorted.count])\n\
    \    var even = Array(sorted[0..<sorted.count-1])\n    var result = [Int]()\n\
    \    var isOdd = true\n    for _ in 0..<lst.count {\n        if isOdd {\n    \
    \        result.append(sorted[0])\n            if !odd.isEmpty {\n           \
    \     result.append(odd.popLast()!)\n            }\n        } else {\n       \
    \     result.append(sorted[sorted.count-1])\n            if !even.isEmpty {\n\
    \                result.append(even.popLast()!)\n            }\n        }\n  \
    \      isOdd = !isOdd\n    }\n    return result", "  let sorted = lst.sorted()\n\
    \  var smallIndex = 0\n  var largeIndex = sorted.count - 1\n  var result = [Int]()\n\
    \  while smallIndex <= largeIndex {\n    result.append(sorted[smallIndex])\n \
    \   smallIndex += 1\n    if smallIndex <= largeIndex {\n      result.append(sorted[largeIndex])\n\
    \      largeIndex -= 1\n    }\n  }\n  return result", "    var result = [Int]()\n\
    \    var min = lst.min()\n    var max = lst.max()\n    var rest = lst\n    for\
    \ _ in 0...(lst.count / 2) {\n        result.append(min!)\n        result.append(max!)\n\
    \        rest.removeAll { (i) -> Bool in i == min! || i == max! }\n        min\
    \ = rest.min()\n        max = rest.max()\n    }\n    return result", "    let\
    \ lst = lst.sorted()\n    var lstResult = lst\n    var i = 1\n    while i < lst.count\
    \ {\n        lstResult.insert(lst[i], at: i)\n        i += 2\n    }\n    return\
    \ lstResult", "    var res = [Int]()\n    var lst = lst\n    while lst.count >\
    \ 0 {\n        var min = lst[0]\n        var minIndex = 0\n        var max = lst[0]\n\
    \        var maxIndex = 0\n        for i in 0..<lst.count {\n            if min\
    \ > lst[i] {\n                min = lst[i]\n                minIndex = i\n   \
    \         }\n            if max < lst[i] {\n                max = lst[i]\n   \
    \             maxIndex = i\n            }\n        }\n        res.append(min)\n\
    \        lst.remove(at: minIndex)\n        if maxIndex > minIndex {\n        \
    \    maxIndex -= 1\n        }\n        res.append(max)\n        lst.remove(at:\
    \ maxIndex)\n    }\n    return res", '    return lst', "    var arr = lst.sorted()\n\
    \    var result = [Int]()\n    while !arr.isEmpty {\n        result.append(arr.removeFirst())\n\
    \        if !arr.isEmpty {\n            result.append(arr.removeLast())\n    \
    \    }\n    }\n    return result", "    var arr = lst\n    var result = [Int]()\n\
    \    var idx = 0\n    while !arr.isEmpty {\n        if idx % 2 == 0 {\n      \
    \      result.append(arr.remove(at: arr.index(of: arr.min()!)!))\n        } else\
    \ {\n            result.append(arr.remove(at: arr.index(of: arr.max()!)!))\n \
    \       }\n        idx += 1\n    }\n    return result", "    let sorted = lst.sorted()\n\
    \    var i = 0\n    var j = sorted.count - 1\n    var result = [Int]()\n    while\
    \ i <= j {\n        result.append(sorted[i])\n        i += 1\n        if i <=\
    \ j {\n            result.append(sorted[j])\n            j -= 1\n        }\n \
    \   }\n    return result", "    guard lst.count > 1 else { return lst }\n    var\
    \ odd = false\n    var newList = lst.sorted()\n    var result = [Int]()\n    while\
    \ !newList.isEmpty {\n        let element = odd ? newList.removeLast() : newList.removeFirst()\n\
    \        result.append(element)\n        odd = !odd\n    }\n    return result",
  "    var array = lst\n    var answer: [Int] = []\n    array.sort()\n    for _ in\
    \ 0..<array.count {\n        answer.append(array.removeFirst())\n        if array.count\
    \ > 0 {\n            answer.append(array.removeLast())\n        }\n    }\n   \
    \ return answer", "    if lst.count <= 1 {\n        return lst\n    }\n    var\
    \ arr = lst\n    var result = [Int]()\n    while arr.count > 0 {\n        if let\
    \ min = arr.min(), let max = arr.max() {\n            result.append(min)\n   \
    \         result.append(max)\n            arr.remove(at: arr.index(of: min)!)\n\
    \            arr.remove(at: arr.index(of: max)!)\n        }\n    }\n    return\
    \ result", "  var arr = lst.sort()\n  for i in 0.stride(to: lst.count - 1, by:\
    \ 2) {\n    arr.append(arr.removeAtIndex(i))\n  }\n  return arr", "    var (min,\
    \ max) = (lst.first ?? 0, lst.last ?? 0)\n    var index = 0\n    var newLst =\
    \ [Int]()\n    newLst.append(min)\n    for _ in 0..<lst.count - 1 {\n        if\
    \ index % 2 == 0 {\n            newLst.append(max)\n            index += 1\n \
    \       } else {\n            newLst.append(min)\n            index += 1\n   \
    \     }\n    }\n    return newLst", "    var min_queue = [Int]()\n    var max_queue\
    \ = [Int]()\n    for elem in lst {\n        min_queue.append(elem)\n        max_queue.append(elem)\n\
    \    }\n    sort(&min_queue)\n    sort(&max_queue, { (first, second) -> Bool in\n\
    \        first > second\n    })\n    var ans = [Int]()\n    var is_min = true\n\
    \    while !min_queue.isEmpty {\n        if is_min {\n            ans.append(min_queue.removeFirst())\n\
    \        } else {\n            ans.append(max_queue.removeFirst())\n        }\n\
    \        is_min = !is_min\n    }\n    return ans", "    guard lst.count > 0 else\
    \ { return [] }\n    var newList = lst\n    var result = [Int]()\n    var min\
    \ = Int.max\n    var max = Int.min\n    for item in newList {\n        if item\
    \ < min {\n            min = item\n        }\n        if item > max {\n      \
    \      max = item\n        }\n    }\n    result.append(min)\n    newList.remove(at:\
    \ newList.index(of: min)!)\n    while newList.count > 0 {\n        min = Int.max\n\
    \        max = Int.min\n        for item in newList {\n            if item < min\
    \ {\n                min = item\n            }\n            if item > max {\n\
    \                max = item\n            }\n        }\n        result.append(max)\n\
    \        newList.remove(at: newList.index(of: max)!)\n        if newList.count\
    \ > 0 {\n            result.append(min)\n            newList.remove(at: newList.index(of:\
    \ min)!)\n        }\n    }\n    return result", "  guard lst.count > 0 else {\
    \ return [] }\n  var result = lst\n  var min = result.min()!\n  var max = result.max()!\n\
    \  result.remove(at: result.index(of: min)!)\n  result.remove(at: result.index(of:\
    \ max)!)\n  var newLst = [min, max]\n  while result.count > 0 {\n    min = result.min()!\n\
    \    max = result.max()!\n    result.remove(at: result.index(of: min)!)\n    result.remove(at:\
    \ result.index(of: max)!)\n    newLst.append(min)\n    newLst.append(max)\n  }\n\
    \  return newLst", "    guard !lst.isEmpty else { return [] }\n    var result\
    \ = [Int]()\n    var numbers = lst\n    while !numbers.isEmpty {\n        if numbers.count\
    \ == 1 {\n            result.append(numbers.first!)\n            break\n     \
    \   }\n        result.append(numbers.min()!)\n        result.append(numbers.max()!)\n\
    \        numbers.removeAll { $0 == numbers.min() || $0 == numbers.max() }\n  \
    \  }\n    return result", "    guard !lst.isEmpty else { return [] }\n    var\
    \ lst = lst.sorted()\n    var result = [Int]()\n    while !lst.isEmpty {\n   \
    \     let min = lst.removeFirst()\n        let max = lst.removeLast()\n      \
    \  result.append(min)\n        result.append(max)\n    }\n    return result",
  "    var lst = lst\n    var result = [Int]()\n    for i in 0..<lst.count {\n   \
    \     if i % 2 == 0 {\n            let minVal = lst.min()!\n            result.append(minVal)\n\
    \            lst.remove(at: lst.index(of: minVal)!)\n        } else {\n      \
    \      let maxVal = lst.max()!\n            result.append(maxVal)\n          \
    \  lst.remove(at: lst.index(of: maxVal)!)\n        }\n    }\n    return result",
  "    // we don't want to alter original list\n    var lst = lst\n    var res = [Int]()\n\
    \    // sort list to ascend order\n    lst.sort()\n    // take from the beginning\
    \ to the middle\n    while !lst.isEmpty {\n        res.append(lst.removeFirst())\n\
    \        // if we have no more items return result\n        if lst.isEmpty {\n\
    \            return res\n        }\n        // take from the end to the middle\n\
    \        res.append(lst.removeLast())\n    }\n    return res", "    if lst.count\
    \ <= 1 {\n        return lst\n    }\n    var odd = [Int]()\n    var even = [Int]()\n\
    \    for (index, num) in lst.enumerated() {\n        if index % 2 == 0 {\n   \
    \         odd.append(num)\n        } else {\n            even.append(num)\n  \
    \      }\n    }\n    return odd + even", "    var arr = lst\n    arr.sort()\n\
    \    var result = [Int]()\n    let count = arr.count\n    if count % 2 == 0 {\n\
    \        var i = 0\n        while i < count {\n            result.append(arr[i])\n\
    \            result.append(arr[count - i - 1])\n            i += 1\n        }\n\
    \    } else {\n        var i = 0\n        while i < count - 1 {\n            result.append(arr[i])\n\
    \            result.append(arr[count - i - 1])\n            i += 1\n        }\n\
    \        result.append(arr[count - 1])\n    }\n    return result", "    if lst.count\
    \ < 2 {\n        return lst\n    }\n    var sortedArray = lst.sorted()\n    var\
    \ sortedArrayResult = [Int]()\n    var increasing = true\n    while !sortedArray.isEmpty\
    \ {\n        let element = sortedArray.removeFirst()\n        sortedArrayResult.append(element)\n\
    \        if increasing {\n            sortedArray = sortedArray.reversed()\n \
    \       }\n        increasing = !increasing\n    }\n    return sortedArrayResult",
  '    return []', "    let count = lst.count\n    var minimum = lst.min()\n    var\
    \ res = [Int]()\n    var lst = lst\n    var min_idx = 0\n    var max_idx = 0\n\
    \    for _ in 0..<count {\n        if minimum == lst.max() {\n            max_idx\
    \ = lst.index(of: lst.max()!)!\n            res.append(lst[max_idx])\n       \
    \     lst.remove(at: max_idx)\n        } else {\n            min_idx = lst.index(of:\
    \ lst.min()!)!\n            res.append(lst[min_idx])\n            lst.remove(at:\
    \ min_idx)\n        }\n        minimum = lst.min()\n    }\n    return res", " \
    \   if lst.count <= 1 {\n        return lst\n    }\n    var odd = [Int]()\n  \
    \  var even = [Int]()\n    var counter = 0\n    var result = [Int]()\n    while\
    \ counter < lst.count {\n        if counter % 2 == 0 {\n            odd.append(lst[counter])\n\
    \        } else {\n            even.append(lst[counter])\n        }\n        counter\
    \ += 1\n    }\n    odd.sort()\n    even.sort()\n    counter = 0\n    while counter\
    \ < odd.count {\n        result.append(odd[counter])\n        if counter < even.count\
    \ {\n            result.append(even[counter])\n        }\n        counter += 1\n\
    \    }\n    return result", "    var ascending = lst.sorted(by: <)\n    var descending\
    \ = lst.sorted(by: >)\n    var result = [Int]()\n    while !ascending.isEmpty\
    \ && !descending.isEmpty {\n        result.append(ascending.removeFirst())\n \
    \       result.append(descending.removeFirst())\n    }\n    return result", " \
    \   // your code here\n    return lst", "    var lst = lst\n    var sortedLst\
    \ = [Int]()\n    while !lst.isEmpty {\n        sortedLst.append(lst.remove(at:\
    \ 0))\n        if !lst.isEmpty {\n            sortedLst.append(lst.remove(at:\
    \ lst.count - 1))\n        }\n    }\n    return sortedLst", "  let sorted = lst.sorted()\n\
    \  return sorted.enumerated().reduce([Int]()) {\n    $0 + [sorted[$1.offset],\
    \ sorted[sorted.count - $1.offset - 1]]\n  }", "    var list = lst\n    var s\
    \ = lst.count - 1\n    var f = 0\n    var result = [Int]()\n    while s >= f {\n\
    \        result.append(list[f])\n        if f != s {\n            result.append(list[s])\n\
    \        }\n        f += 1\n        s -= 1\n    }\n    return result", "    var\
    \ result: [Int] = []\n    var lst_tmp = lst\n    var start_min: Bool = true\n\
    \    while !lst_tmp.isEmpty {\n        var max: Int = 0\n        var index: Int\
    \ = 0\n        var min: Int = Int.max\n        var index2: Int = 0\n        for\
    \ (i, j) in lst_tmp.enumerated() {\n            if start_min {\n             \
    \   if j < min {\n                    min = j\n                    index2 = i\n\
    \                }\n            } else {\n                if j > max {\n     \
    \               max = j\n                    index = i\n                }\n  \
    \          }\n        }\n        if start_min {\n            result.append(min)\n\
    \            lst_tmp.remove(at: index2)\n        } else {\n            result.append(max)\n\
    \            lst_tmp.remove(at: index)\n        }\n        start_min = !start_min\n\
    \    }\n    return result", "    guard lst.count > 0 else {\n        return []\n\
    \    }\n    let lst = lst.sorted()\n    var lst2 = lst\n    lst2.remove(at: 0)\n\
    \    if lst2.count == 0 {\n        return lst\n    }\n    lst2.reverse()\n   \
    \ let lst3 = zip(lst, lst2).flatMap { [$0.0, $0.1] }\n    return lst3", "    if\
    \ lst.count < 2 {\n        return lst\n    }\n    var mx = lst.max()!\n    var\
    \ mn = lst.min()!\n    var rst = [Int]()\n    for _ in 0..<lst.count {\n     \
    \   rst.append(mn)\n        rst.append(mx)\n        mx -= 1\n        mn += 1\n\
    \    }\n    return Array(rst.dropLast())", "    if lst.count < 2 {\n        return\
    \ lst\n    }\n    var res = [Int]()\n    let sorted = lst.sorted()\n    var (s,\
    \ b) = (0, sorted.count - 1)\n    while s <= b {\n        res.append(sorted[s])\n\
    \        if s != b {\n            res.append(sorted[b])\n        }\n        s\
    \ += 1\n        b -= 1\n    }\n    return res", '  return lst', "    var res =\
    \ [Int]()\n    var newList = lst\n    while newList.count > 0 {\n        if let\
    \ min = newList.min() {\n            res.append(min)\n            newList.remove(at:\
    \ newList.index(of: min)!)\n        }\n        if let max = newList.max() {\n\
    \            res.append(max)\n            newList.remove(at: newList.index(of:\
    \ max)!)\n        }\n    }\n    return res", "    guard lst.count > 1 else { return\
    \ lst }\n    var result = [Int]()\n    var isUp = true\n    let sorted = lst.sorted()\n\
    \    for (i, _) in sorted.enumerated() {\n        if isUp {\n            result.append(sorted[i])\n\
    \        } else {\n            result.append(sorted[sorted.count - 1 - i])\n \
    \       }\n        isUp = !isUp\n    }\n    return result", "    if lst.count\
    \ <= 2 {\n        return lst\n    }\n    var lst = lst\n    var res: [Int] = []\n\
    \    for _ in lst {\n        res.append(lst.min()!)\n        lst.remove(at: lst.index(of:\
    \ lst.min()!)!)\n        if lst.count == 0 {\n            break\n        }\n \
    \       res.append(lst.max()!)\n        lst.remove(at: lst.index(of: lst.max()!)!)\n\
    \    }\n    return res", "    var list = lst\n    var sortedList = [Int]()\n \
    \   while list.count > 0 {\n        let min = list.min()!\n        let max = list.max()!\n\
    \        if min != max {\n            sortedList.append(min)\n            sortedList.append(max)\n\
    \        } else {\n            sortedList.append(min)\n        }\n        list.remove(element:\
    \ min)\n        list.remove(element: max)\n    }\n    return sortedList", "  \
    \  if lst.count < 2 {\n        return lst\n    }\n    var left = lst.min()!\n\
    \    var right = lst.max()!\n    var result = [Int]()\n    var i = 0\n    while\
    \ i < lst.count {\n        if i % 2 == 0 {\n            result.append(left)\n\
    \            left += 1\n        } else {\n            result.append(right)\n \
    \           right -= 1\n        }\n        i += 1\n    }\n    return result",
  "    var result: [Int] = []\n    var min: Int = Int.min\n    var max: Int = Int.max\n\
    \    let base = lst.count\n    if base == 0 {\n        return result\n    }\n\
    \    var sortedLst = lst.sorted()\n    var n = 0\n    var increment = true\n \
    \   while n < base {\n        if sortedLst.count == 0 {\n            break\n \
    \       }\n        if increment {\n            if sortedLst.count == 1 {\n   \
    \             result.append(sortedLst[0])\n                sortedLst.remove(at:\
    \ 0)\n                increment = false\n            } else {\n              \
    \  result.append(sortedLst[0])\n                sortedLst.remove(at: 0)\n    \
    \            increment = false\n            }\n        } else {\n            if\
    \ sortedLst.count == 1 {\n                result.append(sortedLst[0])\n      \
    \          sortedLst.remove(at: 0)\n                increment = true\n       \
    \     } else {\n                result.append(sortedLst[sortedLst.count - 1])\n\
    \                sortedLst.remove(at: sortedLst.count - 1)\n                increment\
    \ = true\n            }\n        }\n        n += 1\n    }\n    return result",
  "    if lst.count == 0 {\n        return []\n    }\n    let sortedLst = lst.sorted()\n\
    \    var newArr = [Int]()\n    var i = 0\n    var j = sortedLst.count - 1\n  \
    \  while i <= j {\n        newArr.append(sortedLst[i])\n        i += 1\n     \
    \   if i > j {\n            break\n        }\n        newArr.append(sortedLst[j])\n\
    \        j -= 1\n    }\n    return newArr", "  var result: [Int] = []\n  var isMax\
    \ = true\n  lst.sorted().forEach {\n    if result.count == 0 {\n      result.append($0)\n\
    \    } else {\n      if isMax {\n        result.append(result.removeLast())\n\
    \        result.append($0)\n      } else {\n        result.append($0)\n      }\n\
    \      isMax = !isMax\n    }\n  }\n  return result", "    if lst.count <= 1 {\n\
    \        return lst\n    }\n    var mutableList = lst\n    var result: [Int] =\
    \ []\n    var min = mutableList.min()!\n    var max = mutableList.max()!\n   \
    \ mutableList.removeAll { (number) -> Bool in\n        return number == min ||\
    \ number == max\n    }\n    let bool = true\n    for _ in 0..<lst.count {\n  \
    \      if bool {\n            result.append(min)\n            min = mutableList.min()!\n\
    \            mutableList.removeAll { (number) -> Bool in\n                return\
    \ number == min\n            }\n        } else {\n            result.append(max)\n\
    \            max = mutableList.max()!\n            mutableList.removeAll { (number)\
    \ -> Bool in\n                return number == max\n            }\n        }\n\
    \    }\n    return result", "    guard lst.count > 1 else {\n        return lst\n\
    \    }\n    var result = [Int]()\n    var temp = lst\n    while temp.count > 0\
    \ {\n        result.append(temp.remove(at: temp.minIndex()))\n        if temp.count\
    \ > 0 {\n            result.append(temp.remove(at: temp.maxIndex()))\n       \
    \ }\n    }\n    return result", '    return [Int]()', "    let sorted = lst.sorted()\n\
    \    var result = [Int]()\n    var i = 0\n    var j = sorted.count - 1\n    while\
    \ i <= j {\n        result.append(sorted[i])\n        i += 1\n        if i <=\
    \ j {\n            result.append(sorted[j])\n            j -= 1\n        }\n \
    \   }\n    return result", "    var sorted: [Int] = []\n    let max = lst.max()\
    \ ?? 1\n    var min = lst.min() ?? 1\n    while !lst.isEmpty {\n        if sorted.count.isMultiple(of:\
    \ 2) {\n            min = lst.filter { $0 > min }.min() ?? 1\n            sorted.append(min)\n\
    \        } else {\n            max = lst.filter { $0 < max }.max() ?? 1\n    \
    \        sorted.append(max)\n        }\n    }\n    return sorted", "    // your\
    \ code here\n    var sorted_list: [Int] = []\n    var remaining: [Int] = lst\n\
    \    while remaining.count > 0 {\n        let min = remaining.min()!\n       \
    \ sorted_list.append(min)\n        remaining.remove(at: remaining.index(of: min)!)\n\
    \        if remaining.count > 0 {\n            let max = remaining.max()!\n  \
    \          sorted_list.append(max)\n            remaining.remove(at: remaining.index(of:\
    \ max)!)\n        }\n    }\n    return sorted_list", '    return [1, 4, 2, 3]',
  "    if lst.count <= 1 {\n        return lst\n    }\n    let sorted = lst.sorted()\n\
    \    let mid = sorted.count / 2\n    let left = Array(sorted[0..<mid])\n    let\
    \ right = Array(sorted[mid..<sorted.count])\n    var newList = Array(repeating:\
    \ 0, count: lst.count)\n    var leftIndex = 0\n    var rightIndex = 0\n    for\
    \ i in 0..<lst.count {\n        if i % 2 == 0 {\n            newList[i] = left[leftIndex]\n\
    \            leftIndex += 1\n        } else {\n            newList[i] = right[rightIndex]\n\
    \            rightIndex += 1\n        }\n    }\n    return newList", "    var\
    \ lst = lst\n    var res: [Int] = []\n    var flag = true\n    while lst.count\
    \ > 0 {\n        if flag {\n            let min = lst.min()!\n            res.append(min)\n\
    \            lst.remove(at: lst.index(of: min)!)\n        } else {\n         \
    \   let max = lst.max()!\n            res.append(max)\n            lst.remove(at:\
    \ lst.index(of: max)!)\n        }\n        flag = !flag\n    }\n    return res",
  "    var lst = lst\n    var strangedArray = [Int]()\n    if lst.count == 0 {\n \
    \       return strangedArray\n    }\n    var min = lst.min()\n    var max = lst.max()\n\
    \    var current: Int\n    var counter = 0\n    for _ in lst {\n        current\
    \ = counter % 2 == 0 ? min! : max!\n        lst.count == 1 ? strangedArray.append(current)\
    \ : strangedArray.append(current)\n        lst.removeFirst(where: {$0 == current})\n\
    \        min = lst.min()\n        max = lst.max()\n        counter += 1\n    }\n\
    \    return strangedArray", "    var result = [Int]()\n    guard lst.count > 0\
    \ else {\n        return result\n    }\n    if lst.count == 1 {\n        return\
    \ lst\n    }\n    var array = lst\n    var sorted = false\n    var sign = true\n\
    \    let tempMax = array.max()!\n    let tempMin = array.min()!\n    while !sorted\
    \ {\n        if sign {\n            result.append(tempMin)\n            array.remove(at:\
    \ array.index(of: tempMin)!)\n        } else {\n            result.append(tempMax)\n\
    \            array.remove(at: array.index(of: tempMax)!)\n        }\n        sign\
    \ = !sign\n        if array.count == 0 {\n            sorted = true\n        }\n\
    \    }\n    return result", "    var lst = lst\n    if lst.count == 0 {\n    \
    \    return []\n    }\n    for i in 0..<lst.count/2 {\n        if lst.count %\
    \ 2 == 0 && i == lst.count/2 - 1 {\n            return lst\n        }\n      \
    \  if lst.count % 2 != 0 && i == lst.count/2 {\n            return lst\n     \
    \   }\n        lst.insert(lst.remove(at: lst.index(of: lst.max()!)!), at: lst.index(of:\
    \ lst.min()!)!)\n    }\n    return lst", "    // your code here\n    return lst",
  "    var out = [Int]()\n    var lessArr = [Int]()\n    var greaterArr = [Int]()\n\
    \    let min = lst.min()\n    let max = lst.max()\n    for item in lst {\n   \
    \     if item > min! {\n            greaterArr.append(item)\n        } else if\
    \ item < max! {\n            lessArr.append(item)\n        }\n    }\n    var count\
    \ = 0\n    for _ in 0...lst.count {\n        if count < lst.count {\n        \
    \    out.append(min!)\n            count += 1\n        }\n        if count < lst.count\
    \ {\n            out.append(max!)\n            count += 1\n        }\n    }\n\
    \    return out", "    var array = lst\n    var count = array.count - 1\n    array.sort()\n\
    \    var newArray = [Int]()\n    var index = 0\n    while count > 0 {\n      \
    \  newArray.append(array[index])\n        newArray.append(array[count])\n    \
    \    index += 1\n        count -= 1\n    }\n    if count == 0 {\n        newArray.append(array[index])\n\
    \    }\n    return newArray", "    guard lst.count > 1 else { return lst }\n \
    \   var list = lst\n    var sorted = [Int]()\n    var copy = list\n    let i =\
    \ copy.remove(at: copy.count.arc4random)\n    sorted.append(i)\n    var min =\
    \ min_val(arr: copy)\n    var max = max_val(arr: copy)\n    while list.count >\
    \ 0 {\n        if min != nil {\n            sorted.append(min!)\n            list.remove(at:\
    \ list.index(of: min!)!)\n            copy = list\n            min = min_val(arr:\
    \ copy)\n            max = max_val(arr: copy)\n        }\n        if max != nil\
    \ {\n            sorted.append(max!)\n            list.remove(at: list.index(of:\
    \ max!)!)\n            copy = list\n            min = min_val(arr: copy)\n   \
    \         max = max_val(arr: copy)\n        }\n    }\n    return sorted", "  \
    \  guard !lst.isEmpty else { return [] }\n    var result = [Int]()\n    var min\
    \ = Int.max\n    var max = Int.min\n    var count = 0\n    var sign = 1\n    var\
    \ lstCopy = lst\n    while !lstCopy.isEmpty {\n        let el = lstCopy.remove(at:\
    \ 0)\n        min = min < el ? min : el\n        max = max > el ? max : el\n \
    \   }\n    while count < lst.count {\n        if count == 0 {\n            result.append(min)\n\
    \            count += 1\n            sign = -1\n        } else if count == 1 {\n\
    \            result.append(max)\n            count += 1\n            sign = 1\n\
    \        } else {\n            if sign > 0 {\n                let el = lstCopy.remove(at:\
    \ 0)\n                if el != max {\n                    result.append(el)\n\
    \                    count += 1\n                    sign = -1\n             \
    \   }\n            } else {\n                let el = lstCopy.remove(at: lstCopy.count\
    \ - 1)\n                if el != min {\n                    result.append(el)\n\
    \                    count += 1\n                    sign = 1\n              \
    \  }\n            }\n        }\n    }\n    return result", "  var result = [Int]()\n\
    \  var lst = lst\n  if lst.count > 0 {\n    var maximum = lst.max()!\n    var\
    \ minimum = lst.min()!\n    while lst.count > 0 {\n      result.append(minimum)\n\
    \      result.append(maximum)\n      lst.removeFirst(lst.firstIndex(of: minimum)!)\n\
    \      lst.removeFirst(lst.firstIndex(of: maximum)!)\n      if lst.count > 0 {\n\
    \        maximum = lst.max()!\n        minimum = lst.min()!\n      }\n    }\n\
    \  }\n  return result", "    if lst.count <= 1 {\n        return lst\n    }\n\
    \    var newList = lst\n    var first = lst.min()!\n    var second = newList.filter\
    \ { $0 != first }.max()!\n    newList.remove(at: newList.index(of: first)!)\n\
    \    newList.remove(at: newList.index(of: second)!)\n    newList.insert(first,\
    \ at: 0)\n    newList.insert(second, at: newList.count)\n    return newList",
  "\tif lst.count == 0 {\n\t\treturn []\n\t}\n\tvar sorted_list = [Int]()\n\tvar other_list\
    \ = lst\n\tvar step = 1\n\twhile other_list.count > 0 {\n\t\tif step % 2 == 1\
    \ {\n\t\t\tsorted_list.append(other_list.min()!)\n\t\t\tother_list.remove(at:\
    \ other_list.index(of: other_list.min()!)!)\n\t\t} else {\n\t\t\tsorted_list.append(other_list.max()!)\n\
    \t\t\tother_list.remove(at: other_list.index(of: other_list.max()!)!)\n\t\t}\n\
    \t\tstep += 1\n\t}\n\treturn sorted_list", "  guard lst.count > 1 else { return\
    \ lst }\n  let sortedList = lst.sorted()\n  var result: [Int] = []\n  let increment\
    \ = sortedList.count % 2 == 0 ? 2 : 1\n  var index = sortedList.count - 1\n  while\
    \ result.count < sortedList.count {\n    let min = sortedList[result.count]\n\
    \    let max = sortedList[index]\n    result.append(min)\n    result.append(max)\n\
    \    index -= increment\n  }\n  return result", "\tguard !lst.isEmpty else { return\
    \ [] }\n\tguard lst.count > 1 else { return lst }\n\tlet sorted = lst.sorted()\n\
    \tvar min = 0\n\tvar max = sorted.count - 1\n\tvar i = 0\n\tvar tmp = 0\n\tvar\
    \ arr = [Int](repeating: 0, count: sorted.count)\n\twhile i < sorted.count {\n\
    \t\tarr[i] = sorted[min]\n\t\ti += 1\n\t\tarr[i] = sorted[max]\n\t\ti += 1\n\t\
    \ttmp = min\n\t\tmin = max + 1\n\t\tmax = tmp - 1\n\t}\n\treturn arr", "    guard\
    \ lst.count > 0 else { return lst }\n    var min_val = min(lst)\n    var max_val\
    \ = max(lst)\n    var new_lst = [Int]()\n    var inc = 1\n    for _ in 0..<lst.count\
    \ {\n        if inc == 1 {\n            new_lst.append(min_val)\n            min_val\
    \ += 1\n            inc += 1\n        } else {\n            new_lst.append(max_val)\n\
    \            max_val -= 1\n            inc -= 1\n        }\n    }\n    return\
    \ new_lst", "    let srt = lst.sorted()\n    var res: [Int] = []\n    var i =\
    \ 0\n    var j = srt.count - 1\n    while i < j {\n        res.append(srt[i])\n\
    \        res.append(srt[j])\n        i += 1\n        j -= 1\n    }\n    if i ==\
    \ j {\n        res.append(srt[i])\n    }\n    return res"]
stop_tokens:
- "\n}"
