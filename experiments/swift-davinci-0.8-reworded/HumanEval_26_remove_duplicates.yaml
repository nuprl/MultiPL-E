name: HumanEval_26_remove_duplicates
language: swift
prompt: "\n/// From an array of integers, remove all elements that occur more than\
  \ once.\n/// Keep order of elements left the same as in the input.\n/// >>> remove_duplicates(numbers:\
  \ [1, 2, 3, 2, 4])\n/// [1, 3, 4]\nfunc remove_duplicates(numbers: [Int]) -> [Int]\
  \ {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(remove_duplicates(numbers: [] as [Int])\
  \ == [] as [Int])\nassert(remove_duplicates(numbers: [1, 2, 3, 4]) == [1, 2, 3,\
  \ 4])\nassert(remove_duplicates(numbers: [1, 2, 3, 2, 4, 3, 5]) == [1, 4, 5])"
completions: ["    return numbers.reduce(into: [Int]()) { (unique: inout [Int], item:\
    \ Int) in\n        if !unique.contains(item) {\n            unique.append(item)\n\
    \        }\n    }", "    var array = numbers\n    var tempArray = [Int]()\n  \
    \  var index = 0\n    for i in array {\n        for j in array {\n           \
    \ if j == i {\n                index += 1\n            }\n        }\n        if\
    \ index == 1 {\n            tempArray.append(i)\n        }\n        index = 0\n\
    \    }\n    return tempArray", "    let set = Set(numbers)\n    let array = Array(set)\n\
    \    return array", '    return Array(Set(numbers))', '  return [Int]()', "  \
    \  var numbers = numbers\n    for number in numbers {\n        if (numbers.filter\
    \ { $0 == number }).count > 1 {\n            numbers.remove(at: numbers.firstIndex(of:\
    \ number)!)\n        }\n    }\n    return numbers", "    var seen = Set<Int>()\n\
    \    var result = [Int]()\n    for number in numbers {\n        if !seen.contains(number)\
    \ {\n            seen.insert(number)\n            result.append(number)\n    \
    \    }\n    }\n    return result", "    var uniqueElements = Set<Int>()\n    var\
    \ uniqueElementsArray = [Int]()\n    for element in numbers {\n        if uniqueElements.contains(element)\
    \ {\n            continue\n        } else {\n            uniqueElements.insert(element)\n\
    \            uniqueElementsArray.append(element)\n        }\n    }\n    return\
    \ uniqueElementsArray", "    var dict: [Int: Bool] = [:]\n    var result: [Int]\
    \ = []\n    for number in numbers {\n        if dict[number] == nil {\n      \
    \      dict[number] = true\n            result.append(number)\n        }\n   \
    \ }\n    return result", "    var numbers = numbers\n    let count = numbers.count\n\
    \    var i = 0\n    var j = 0\n    while i < count {\n        j = i + 1\n    \
    \    while j < count {\n            if numbers[i] == numbers[j] {\n          \
    \      numbers.remove(at: j)\n            } else {\n                j += 1\n \
    \           }\n        }\n        i += 1\n    }\n    return numbers", '    return
    []', "    var result: [Int] = []\n    for num in numbers {\n        if !result.contains(num)\
    \ {\n            result.append(num)\n        }\n    }\n    return result", '    return
    Array(Set(numbers))', "    var result: [Int] = []\n    var set: Set<Int> = []\n\
    \    for n in numbers {\n        if set.contains(n) {\n            continue\n\
    \        }\n        set.insert(n)\n        result.append(n)\n    }\n    return\
    \ result", "    var dict:[Int:Int] = [:]\n    var result:[Int] = []\n    for number\
    \ in numbers {\n        if dict[number] == nil {\n            dict[number] = 1\n\
    \            result.append(number)\n        } else {\n            dict[number]!\
    \ += 1\n        }\n    }\n    print(dict)\n    return result", "    var numberSet\
    \ = Set<Int>()\n    var result = [Int]()\n    for n in numbers {\n        if !numberSet.contains(n)\
    \ {\n            numberSet.insert(n)\n            result.append(n)\n        }\n\
    \    }\n    return result", "    var duplicateNumbers = [Int]()\n    for number\
    \ in numbers {\n        if duplicateNumbers.contains(number) {\n            continue\n\
    \        }\n        duplicateNumbers.append(number)\n    }\n    return duplicateNumbers",
  "  var uniqueNumbers = [Int]()\n  var seenNumbers = [Int]()\n  \n  for number in\
    \ numbers {\n    if seenNumbers.contains(number) {\n      continue\n    }\n  \
    \  \n    seenNumbers.append(number)\n    uniqueNumbers.append(number)\n  }\n \
    \ \n  return uniqueNumbers", "    \n    var dict = [Int: Int]()\n    var singleNumbers\
    \ = [Int]()\n    \n    for number in numbers {\n        dict[number] = (dict[number]\
    \ ?? 0) + 1\n    }\n    \n    for (key, value) in dict {\n        if value ==\
    \ 1 {\n            singleNumbers.append(key)\n        }\n    }\n    \n    return\
    \ singleNumbers", "    let unique = Set(numbers)\n    return unique.sorted()",
  "    var result: [Int] = []\n    for num in numbers {\n        if !result.contains(num)\
    \ {\n            result.append(num)\n        }\n    }\n    return result", " \
    \   \n    var newNumbers = [Int]()\n    var countArray = [Int](repeating: 0, count:\
    \ numbers.count)\n    \n    for i in 0...numbers.count - 1 {\n        for j in\
    \ 0...numbers.count - 1 {\n            if (numbers[i] == numbers[j]) {\n     \
    \           countArray[i] += 1\n            }\n        }\n    }\n    \n    for\
    \ i in 0...numbers.count - 1 {\n        if (countArray[i] == 1) {\n          \
    \  newNumbers.append(numbers[i])\n        }\n    }\n    \n    return newNumbers",
  "    \n    return [Int]()", "    var uniqueNumbers = [Int]()\n    for number in\
    \ numbers {\n        if !uniqueNumbers.contains(number) {\n            uniqueNumbers.append(number)\n\
    \        }\n    }\n    return uniqueNumbers", "    var arr = [Int]()\n    for\
    \ (i,_) in numbers.enumerated() {\n        if !arr.contains(numbers[i]) {\n  \
    \          arr.append(numbers[i])\n        }\n    }\n    return arr", '  return
    Array(Set(numbers))', "  let set = Set(numbers)\n  return Array(set)", "    //\
    \ Add your implementation here\n    var unique = [Int]()\n    for number in numbers\
    \ {\n        if unique.contains(number) {\n            unique.remove(at: unique.index(of:\
    \ number)!)\n        } else {\n            unique.append(number)\n        }\n\
    \    }\n    return unique", "    var uniqueNumbers = [Int]()\n    for number in\
    \ numbers {\n        if uniqueNumbers.contains(number) {\n            continue\n\
    \        }\n        uniqueNumbers.append(number)\n    }\n    return uniqueNumbers",
  "    var memo: [Int: Int] = [:]\n    for n in numbers {\n        memo[n] = (memo[n]\
    \ ?? 0) + 1\n    }\n    return numbers.filter { memo[$0] == 1 }", "    //TODO\n\
    \    return []", '    return [1, 3, 4]', '    return []', "    var sorted = numbers.sorted()\n\
    \    var result = [Int]()\n    for i in 0..<sorted.count {\n        if sorted[i]\
    \ != sorted[i + 1] {\n            result.append(sorted[i])\n        }\n    }\n\
    \    return result", "  var set = Set<Int>()\n  return numbers.filter { set.insert($0).inserted\
    \ }", '    return []', "    var seen: [Int: Int] = [:]\n    return numbers.filter\
    \ { seen.updateValue((seen[$0] ?? 0) + 1, forKey: $0) == 1 }", "    var newNumbers\
    \ = numbers\n    var checkDict = [Int:Int]()\n    for num in numbers {\n     \
    \   if (checkDict[num] == nil) {\n            checkDict[num] = 1\n        } else\
    \ {\n            checkDict[num]! += 1\n        }\n    }\n    for (key, value)\
    \ in checkDict {\n        if (value > 1) {\n            newNumbers = newNumbers.filter({$0\
    \ != key})\n        }\n    }\n    return newNumbers", "    var result: [Int] =\
    \ []\n    var checkedNums: [Int] = []\n    for num in numbers {\n        if !checkedNums.contains(num)\
    \ {\n            result.append(num)\n            checkedNums.append(num)\n   \
    \     }\n    }\n    return result", "    var newArray = [Int]()\n    for number\
    \ in numbers {\n        if !newArray.contains(number) {\n            newArray.append(number)\n\
    \        }\n    }\n    return newArray", "    var uniqueNumbers = [Int]()\n  \
    \  for number in numbers {\n        if uniqueNumbers.contains(number) {\n    \
    \        continue\n        }\n        uniqueNumbers.append(number)\n    }\n  \
    \  return uniqueNumbers", '  return Array(Set(numbers))', "    var uniqueNumbers\
    \ = [Int]()\n    var uniqueSet = Set<Int>()\n    for number in numbers {\n   \
    \     if !uniqueSet.contains(number) {\n            uniqueNumbers.append(number)\n\
    \            uniqueSet.insert(number)\n        }\n    }\n    return uniqueNumbers",
  "    var unique = [Int]()\n    for number in numbers {\n        if unique.contains(number)\
    \ {\n            continue\n        }\n        unique.append(number)\n    }\n \
    \   return unique", "    // implement me :)\n    return []", "    \n    var array\
    \ = numbers\n    for number in numbers {\n        if array.contains(number) {\n\
    \            array.remove(at: array.firstIndex(of: number)!)\n        }\n    }\n\
    \    return array", '    return Array(Set(numbers))', "    var result: [Int] =\
    \ []\n    for number in numbers {\n        if !result.contains(number) {\n   \
    \         result.append(number)\n        }\n    }\n    return result", "    var\
    \ done: [Int] = []\n    for number in numbers {\n        if done.contains(number)\
    \ {\n            continue\n        }\n        done.append(number)\n    }\n   \
    \ return done", "    var result: [Int] = []\n    var set: Set<Int> = []\n    for\
    \ n in numbers {\n        if set.contains(n) {\n            continue\n       \
    \ }\n        set.insert(n)\n        result.append(n)\n    }\n    return result",
  '    return Array(Set(numbers))', "    var filtered_values: [Int] = []\n    for\
    \ number in numbers {\n        if (!filtered_values.contains(number)) {\n    \
    \        filtered_values.append(number)\n        }\n    }\n    return filtered_values",
  "    var seen = Set<Int>()\n    var seenAgain = Set<Int>()\n    var result = [Int]()\n\
    \    for number in numbers {\n        if seen.contains(number) {\n           \
    \ seenAgain.insert(number)\n        } else {\n            seen.insert(number)\n\
    \        }\n    }\n    for number in numbers {\n        if !seenAgain.contains(number)\
    \ {\n            result.append(number)\n        }\n    }\n    return result",
  '    return []', "    var unique_numbers = [Int]()\n    var numbers_counts = [Int:\
    \ Int]()\n    \n    for number in numbers {\n        numbers_counts[number] =\
    \ (numbers_counts[number] ?? 0) + 1\n    }\n    \n    for number in numbers {\n\
    \        if numbers_counts[number] == 1 {\n            unique_numbers.append(number)\n\
    \        }\n    }\n    \n    return unique_numbers", "    var dict = [Int: Int]()\n\
    \    var output = [Int]()\n    for n in numbers {\n        dict[n] = (dict[n]\
    \ ?? 0) + 1\n    }\n    for key in dict.keys {\n        if dict[key] == 1 {\n\
    \            output.append(key)\n        }\n    }\n    return output", "    let\
    \ c = NSCountedSet(array: numbers)\n    return numbers.filter { c.count(for: $0)\
    \ == 1 }", "    var result = [Int]()\n    var seen = Set<Int>()\n    for number\
    \ in numbers {\n        if !seen.contains(number) {\n            result.append(number)\n\
    \            seen.insert(number)\n        }\n    }\n    return result", "    var\
    \ uniq = [Int]()\n    var dict = [Int:Int]()\n    for number in numbers {\n  \
    \      if let _ = dict[number] {\n            dict[number] = dict[number]! + 1\n\
    \        } else {\n            dict[number] = 1\n        }\n    }\n    for number\
    \ in numbers {\n        if dict[number] == 1 {\n            uniq.append(number)\n\
    \        }\n    }\n    return uniq", '    return []', '    return Array(Set(numbers))',
  "    var newArr = [Int]()\n    for num in numbers {\n        if !newArr.contains(num)\
    \ {\n            newArr.append(num)\n        }\n    }\n    return newArr", '    return
    []', '    return Array(Set(numbers))', "    let sortedNumbers = numbers.sorted()\n\
    \    var result = [Int]()\n    var last: Int?\n    for number in sortedNumbers\
    \ {\n        if number != last {\n            result.append(number)\n        \
    \    last = number\n        }\n    }\n    return result", "    var dict: [Int:\
    \ Int] = [:]\n    numbers.forEach {\n        if let _ = dict[$0] {\n         \
    \   dict[$0] = dict[$0]! + 1\n        } else {\n            dict[$0] = 1\n   \
    \     }\n    }\n    return numbers.filter { dict[$0] == 1 }", "    var set = Set<Int>()\n\
    \    var result = [Int]()\n    for number in numbers {\n        if !set.contains(number)\
    \ {\n            set.insert(number)\n            result.append(number)\n     \
    \   }\n    }\n    return result", "    \n    var result = [Int]()\n    var numbersSet\
    \ = Set<Int>()\n    \n    for i in numbers {\n        if numbersSet.contains(i)\
    \ {\n            continue\n        }\n        result.append(i)\n        numbersSet.insert(i)\n\
    \    }\n    \n    return result", "    var dict = [Int: Int]()\n    var result\
    \ = [Int]()\n    for n in numbers {\n        if let count = dict[n] {\n      \
    \      dict[n] = count + 1\n        } else {\n            dict[n] = 1\n      \
    \  }\n    }\n    for n in numbers {\n        if dict[n] == 1 {\n            result.append(n)\n\
    \        }\n    }\n    return result", "    var dict: [Int: Int] = [:]\n    var\
    \ result: [Int] = []\n    for number in numbers {\n        if dict[number] ==\
    \ nil {\n            dict[number] = 1\n            result.append(number)\n   \
    \     } else {\n            dict[number]! += 1\n        }\n    }\n    return result",
  "  var numberCounts = [Int: Int]()\n  var result = [Int]()\n  for number in numbers\
    \ {\n    let count = numberCounts[number] ?? 0\n    numberCounts[number] = count\
    \ + 1\n  }\n  for number in numbers {\n    if numberCounts[number] == 1 {\n  \
    \    result.append(number)\n    }\n  }\n  return result", "    var nums : [Int]\
    \ = []\n    for element in numbers {\n        if !nums.contains(element) {\n \
    \           nums.append(element)\n        }\n    }\n    return nums", "    //\
    \ TODO\n    var result = [Int]()\n    var dict = [Int: Int]()\n    for number\
    \ in numbers {\n        if let _ = dict[number] {\n            dict[number]! +=\
    \ 1\n        } else {\n            dict[number] = 1\n        }\n    }\n    for\
    \ number in numbers {\n        if dict[number] == 1 {\n            result.append(number)\n\
    \        }\n    }\n    return result", '    return []', "    var numbersCopy =\
    \ numbers\n    for num in numbers {\n        numbersCopy.removeAll { $0 == num\
    \ }\n    }\n    return numbersCopy", "    var output: [Int] = []\n    var memory:\
    \ [Int: Int] = [:]\n    \n    for number in numbers {\n        if let _ = memory[number]\
    \ {\n            continue\n        }\n        \n        memory[number] = 1\n \
    \       output.append(number)\n    }\n    \n    return output", "    return numbers.reduce(into:\
    \ []) { result, number in\n        if !result.contains(number) {\n           \
    \ result.append(number)\n        }\n    }", "    var numbers = numbers\n    let\
    \ count = numbers.count\n    var index = 0\n    while index < count {\n      \
    \  if let removedIndex = numbers.firstIndex(of: numbers[index]) {\n          \
    \  if removedIndex != index {\n                numbers.remove(at: removedIndex)\n\
    \            } else {\n                index += 1\n            }\n        }\n\
    \    }\n    return numbers", '    return Set(numbers).sorted()', '    return []',
  "    var new_numbers = numbers\n    var occurences = [Int: Int]()\n    for number\
    \ in numbers {\n        if let n = occurences[number] {\n            occurences[number]\
    \ = n + 1\n        } else {\n            occurences[number] = 1\n        }\n \
    \   }\n    for (key, value) in occurences {\n        if value > 1 {\n        \
    \    new_numbers = new_numbers.filter { $0 != key }\n        }\n    }\n    return\
    \ new_numbers", "    var result = [Int]()\n    for number in numbers {\n     \
    \   if !result.contains(number) {\n            result.append(number)\n       \
    \ }\n    }\n    return result", "    var countedNumbers = [Int: Int]()\n    numbers.forEach\
    \ {\n        if countedNumbers[$0] == nil {\n            countedNumbers[$0] =\
    \ 1\n        } else {\n            countedNumbers[$0]! += 1\n        }\n    }\n\
    \    return countedNumbers.filter { $0.value == 1 }.map { $0.key }", "    var\
    \ found = [Int: Bool]()\n    return numbers.filter { found.updateValue(true, forKey:\
    \ $0) == nil }", "    \n    // Create an empty set to hold unique numbers.\n \
    \   var uniqueNumbers = Set<Int>()\n    \n    // Loop through the input numbers,\
    \ adding each unique number to the set.\n    for number in numbers {\n       \
    \ uniqueNumbers.insert(number)\n    }\n    \n    // Create an empty array to hold\
    \ the output numbers.\n    var newNumbers = [Int]()\n    \n    // Loop through\
    \ the set of unique numbers, adding each number to the output array.\n    for\
    \ number in uniqueNumbers {\n        newNumbers.append(number)\n    }\n    \n\
    \    // Return the output array.\n    return newNumbers", "    var sorted = numbers.sorted()\n\
    \    var to_delete = [Int]()\n    var previous: Int? = nil\n    for n in sorted\
    \ {\n        if n == previous {\n            to_delete.append(n)\n        }\n\
    \        previous = n\n    }\n    return sorted.filter {!to_delete.contains($0)}",
  "    let set = Set(numbers)\n    return set.filter { (number) -> Bool in\n     \
    \   return numbers.filter { (num) -> Bool in\n            return num == number\n\
    \        }.count == 1\n    }", "    var arr = numbers\n    var dict = [Int: Int]()\n\
    \    for number in arr {\n        if dict[number] == nil {\n            dict[number]\
    \ = 1\n        } else {\n            dict[number]! += 1\n        }\n    }\n  \
    \  arr = arr.filter { dict[$0] == 1 }\n    return arr", "    var list: [Int] =\
    \ []\n    for i in numbers {\n        if list.contains(i) {\n            list.removeFirst()\n\
    \        } else {\n            list.append(i)\n        }\n    }\n    return list",
  '    return Array(Set(numbers))', "  var nums = numbers\n  nums.sort()\n  var result:\
    \ [Int] = []\n  var previous: Int?\n  for number in nums {\n    if number != previous\
    \ {\n      result.append(number)\n    }\n    previous = number\n  }\n  return\
    \ result", "    let set = Set(numbers)\n    return Array(set)", "    // COMPLETE\
    \ ME\n    return [Int]()", "    var results: [Int] = []\n    for number in numbers\
    \ {\n        if !results.contains(number) {\n            results.append(number)\n\
    \        }\n    }\n    return results", "    var result = [Int]()\n    var set\
    \ = Set<Int>()\n    for number in numbers {\n        if set.contains(number) {\n\
    \            continue\n        }\n        result.append(number)\n        set.insert(number)\n\
    \    }\n    return result", "    var result: [Int] = []\n    let count_dictionary\
    \ = numbers.reduce(into: [:]) { count, number in\n        count[number, default:\
    \ 0] += 1\n    }\n    for (number, count) in count_dictionary {\n        if count\
    \ == 1 {\n            result.append(number)\n        }\n    }\n    return result",
  "  var counts: [Int: Int] = [:]\n  numbers.forEach { counts[$0] = (counts[$0] ??\
    \ 0) + 1 }\n  return numbers.filter { counts[$0] == 1 }", "    var dictionary\
    \ = [Int: Int]()\n    for (index, value) in numbers.enumerated() {\n        dictionary[value]\
    \ = (dictionary[value] ?? 0) + 1\n    }\n    var result = [Int]()\n    for number\
    \ in numbers {\n        if dictionary[number] == 1 {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var dict: [Int: Int] = [:]\n    numbers.forEach\
    \ { dict[$0] = (dict[$0] ?? 0) + 1 }\n    return numbers.filter { dict[$0] ==\
    \ 1 }", '    return Array(Set(numbers))', '    return Array(Set(numbers))', " \
    \   var result = [Int]()\n    for number in numbers {\n        if !result.contains(number)\
    \ {\n            result.append(number)\n        }\n    }\n    return result",
  "    var uniques = [Int]()\n    var numbersUniques = [Int]()\n    for number in\
    \ numbers {\n        if !uniques.contains(number) {\n            uniques.append(number)\n\
    \            numbersUniques.append(number)\n        }\n    }\n    return numbersUniques",
  "    var result: [Int] = []\n    var tracker: [Int: Int] = [:]\n    for number in\
    \ numbers {\n        if tracker[number] == nil {\n            tracker[number]\
    \ = 1\n            result.append(number)\n        } else {\n            tracker[number]!\
    \ += 1\n        }\n    }\n    return result", "    var output = [Int]()\n    var\
    \ seen = Set<Int>()\n    for num in numbers {\n        if !seen.contains(num)\
    \ {\n            output.append(num)\n            seen.insert(num)\n        }\n\
    \    }\n    return output", "    \n    let reduced = numbers.reduce(into: [:])\
    \ { counts, number in counts[number, default: 0] += 1 }\n    return numbers.filter\
    \ { reduced[$0] == 1 }", "    var seen = Set<Int>()\n    var uniques = [Int]()\n\
    \    for number in numbers {\n        if !seen.contains(number) {\n          \
    \  uniques.append(number)\n            seen.insert(number)\n        }\n    }\n\
    \    return uniques", '    return []', "    let sortedNumbers = numbers.sorted()\n\
    \    var newArray: [Int] = []\n    var lastElement: Int = 0\n    var secondLastElement:\
    \ Int = 0\n    for number in sortedNumbers {\n        if number != lastElement\
    \ {\n            if number != secondLastElement {\n                newArray.append(number)\n\
    \            }\n            secondLastElement = lastElement\n            lastElement\
    \ = number\n        }\n    }\n    return newArray", "    var dict = [Int: Int]()\n\
    \    var result = [Int]()\n    for n in numbers {\n        dict[n] = dict[n, default:\
    \ 0] + 1\n    }\n    for n in numbers {\n        if dict[n] == 1 {\n         \
    \   result.append(n)\n        }\n    }\n    return result", "    var ret = [Int]()\n\
    \    var dict = [Int: Int]()\n    for n in numbers {\n        dict[n] = (dict[n]\
    \ ?? 0) + 1\n    }\n    for k in dict.keys {\n        if dict[k] == 1 {\n    \
    \        ret.append(k)\n        }\n    }\n    return ret", '    return []', " \
    \   var arr = [Int]()\n    for (key, value) in numbers.enumerated() {\n      \
    \  if key == numbers.index(of: value) {\n            arr.append(value)\n     \
    \   }\n    }\n    return arr", "  var result = [Int]()\n  var found = Set<Int>()\n\
    \  var dupes = Set<Int>()\n  for n in numbers {\n    if !found.contains(n) {\n\
    \      found.insert(n)\n      result.append(n)\n    } else {\n      dupes.insert(n)\n\
    \    }\n  }\n  return result", "    var result: [Int] = []\n    var dict: [Int:\
    \ Int] = [:]\n    for number in numbers {\n        dict[number] = (dict[number]\
    \ ?? 0) + 1\n    }\n    for number in numbers {\n        if dict[number]! < 2\
    \ {\n            result.append(number)\n        }\n    }\n    return result",
  "    var uniqueArray = [Int]()\n    for element in numbers {\n        if !uniqueArray.contains(element)\
    \ {\n            uniqueArray.append(element)\n        }\n    }\n    return uniqueArray",
  "  // Your solution here\n  var numbersSet = Set<Int>()\n  var numbersNoDuplicates\
    \ = [Int]()\n  for number in numbers {\n    if !numbersSet.contains(number) {\n\
    \      numbersSet.insert(number)\n      numbersNoDuplicates.append(number)\n \
    \   }\n  }\n  return numbersNoDuplicates", '    return Array(Set(numbers))', " \
    \   var unique = [Int]()\n    for num in numbers {\n        if !unique.contains(num)\
    \ {\n            unique.append(num)\n        }\n    }\n    return unique", " \
    \   var result: [Int] = []\n    var existNumbers: [Int] = []\n    numbers.forEach\
    \ { number in\n        if !existNumbers.contains(number) {\n            existNumbers.append(number)\n\
    \            result.append(number)\n        }\n    }\n    return result", "  \
    \  var result = [Int]()\n    for number in numbers {\n        if !result.contains(number)\
    \ {\n            result.append(number)\n        }\n    }\n    return result",
  "    var numbersSet = Set<Int>()\n    var numbersList = [Int]()\n    for n in numbers\
    \ {\n        if !numbersSet.contains(n) {\n            numbersSet.insert(n)\n\
    \            numbersList.append(n)\n        }\n    }\n    return numbersList",
  "    var result = [Int]()\n    var count = [Int: Int]()\n    for number in numbers\
    \ {\n        count[number] = (count[number] ?? 0) + 1\n    }\n    for number in\
    \ numbers {\n        if count[number] == 1 {\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var array: [Int] = []\n    var dictionary:\
    \ [Int: Int] = [:]\n    for number in numbers {\n        if let oldValue = dictionary[number]\
    \ {\n            dictionary[number] = oldValue + 1\n        } else {\n       \
    \     dictionary[number] = 1\n        }\n    }\n    for number in numbers {\n\
    \        if dictionary[number] == 1 {\n            array.append(number)\n    \
    \    }\n    }\n    return array", "    var unique_ints = [Int]()\n    var appeared_ints\
    \ = [Int]()\n    for number in numbers {\n        if !appeared_ints.contains(number)\
    \ {\n            unique_ints.append(number)\n            appeared_ints.append(number)\n\
    \        }\n    }\n    return unique_ints", "    var result: [Int] = []\n    var\
    \ duplicates: [Int] = []\n    for number in numbers {\n        if duplicates.contains(number)\
    \ {\n            continue\n        }\n        if result.contains(number) {\n \
    \           duplicates.append(number)\n            continue\n        }\n     \
    \   result.append(number)\n    }\n    return result", "    var occurrences = [Int:\
    \ Int]()\n    for i in numbers {\n        if occurrences[i] == nil {\n       \
    \     occurrences[i] = 1\n        } else {\n            occurrences[i]! += 1\n\
    \        }\n    }\n    var result = [Int]()\n    for number in numbers {\n   \
    \     if occurrences[number] == 1 {\n            result.append(number)\n     \
    \   }\n    }\n    return result", "    return numbers.reduce(into: [Int]()) {\
    \ (result, number) in\n        if !result.contains(number) {\n            result.append(number)\n\
    \        }\n    }", "    var result = [Int]()\n    var appearedNumbers = Set<Int>()\n\
    \    for number in numbers {\n        if !appearedNumbers.contains(number) {\n\
    \            result.append(number)\n            appearedNumbers.insert(number)\n\
    \        }\n    }\n    return result", "  var counts: [Int: Int] = [:]\n  var\
    \ removed: [Int] = []\n  for number in numbers {\n    counts[number] = (counts[number]\
    \ ?? 0) + 1\n  }\n  for number in numbers {\n    if counts[number] == 1 {\n  \
    \    removed.append(number)\n    }\n  }\n  return removed", "    \n    let numberDict\
    \ = Dictionary(grouping: numbers, by: { $0 })\n    let filtered = numberDict.filter({\
    \ $0.value.count == 1 })\n    let values = filtered.map({ $0.value })\n    let\
    \ result = values.flatMap { $0 }\n    return result", "    var result = [Int]()\n\
    \    var dict = [Int: Bool]()\n    for number in numbers {\n        if dict[number]\
    \ == nil {\n            dict[number] = true\n            result.append(number)\n\
    \        }\n    }\n    return result", "    var numbers_set = Set<Int>()\n   \
    \ var result = [Int]()\n    for n in numbers {\n        if !numbers_set.contains(n)\
    \ {\n            numbers_set.insert(n)\n            result.append(n)\n       \
    \ }\n    }\n    return result", "    var nums = [Int: Bool]()\n    for n in numbers\
    \ {\n        nums[n] = true\n    }\n    return Array(nums.keys)", "    var numbersCopy\
    \ = numbers\n    var duplicates: [Int] = []\n    for value in numbers {\n    \
    \    if numbersCopy.contains(value) {\n            numbersCopy.removeFirst()\n\
    \        } else {\n            duplicates.append(value)\n        }\n    }\n  \
    \  return duplicates", "    //build set of unique numbers\n    var unique: Set<Int>\
    \ = []\n    for num in numbers {\n        unique.insert(num)\n    }\n    //build\
    \ array from the set, keeping the order\n    var result: [Int] = []\n    for num\
    \ in numbers {\n        if (unique.contains(num)) {\n            result.append(num)\n\
    \            unique.remove(num)\n        }\n    }\n    return result", "    return\
    \ numbers.filter { (value) -> Bool in\n        return numbers.filter { $0 == value\
    \ }.count == 1\n    }", "    var result = [Int]()\n    var set = Set<Int>()\n\
    \    for number in numbers {\n        if !set.contains(number) {\n           \
    \ result.append(number)\n            set.insert(number)\n        }\n    }\n  \
    \  return result", '    return Array(Set(numbers))', "    var visited = [Int]()\n\
    \    var result = [Int]()\n    for number in numbers {\n        if (!visited.contains(number))\
    \ {\n            visited.append(number)\n            result.append(number)\n \
    \       }\n    }\n    return result", "    var dict = [Int:Int]()\n    numbers.forEach\
    \ { dict[$0] = dict[$0, default: 0] + 1 }\n    return dict.filter { $0.value ==\
    \ 1 }.map { $0.key }", "    var uniqueNumbers = Set<Int>()\n    var uniqueNumbersArray\
    \ = [Int]()\n    for number in numbers {\n        if !uniqueNumbers.contains(number)\
    \ {\n            uniqueNumbers.insert(number)\n            uniqueNumbersArray.append(number)\n\
    \        }\n    }\n    return uniqueNumbersArray", "    var result = [Int]()\n\
    \    var array = [Int]()\n    for number in numbers {\n        if array.contains(number)\
    \ {\n            continue\n        }\n        array.append(number)\n        result.append(number)\n\
    \    }\n    return result", "    var set = Set<Int>()\n    var result = [Int]()\n\
    \    for number in numbers {\n        if !set.contains(number) {\n           \
    \ set.insert(number)\n            result.append(number)\n        }\n    }\n  \
    \  return result", "    var seen = Set<Int>()\n    var distinct = [Int]()\n  \
    \  for number in numbers {\n        if !seen.contains(number) {\n            seen.insert(number)\n\
    \            distinct.append(number)\n        }\n    }\n    return distinct",
  "    var ary = numbers\n    var n = ary.count\n    var i = 0\n    var j = 1\n  \
    \  while (i < n - 1) {\n        while (j < n) {\n            if (ary[i] == ary[j])\
    \ {\n                var k = j\n                while (k < n - 1) {\n        \
    \            ary[k] = ary[k + 1]\n                    k += 1\n               \
    \ }\n                n -= 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        i += 1\n        j = i + 1\n    }\n    return\
    \ ary", "    var filteredNumbers = [Int]()\n    for number in numbers {\n    \
    \    if !filteredNumbers.contains(number) {\n            filteredNumbers.append(number)\n\
    \        }\n    }\n    return filteredNumbers", "    var toReturn: [Int] = []\n\
    \    var x: Int = 0\n    var y: Int = 0\n    while x < numbers.count {\n     \
    \   while y < numbers.count {\n            if numbers[x] == numbers[y] && x !=\
    \ y {\n                y = numbers.count\n            }\n            else if y\
    \ == numbers.count - 1 {\n                toReturn.append(numbers[x])\n      \
    \      }\n            y += 1\n        }\n        x += 1\n        y = 0\n    }\n\
    \    return toReturn", "    var result: [Int] = []\n    for number in numbers\
    \ {\n        if result.contains(number) {\n            continue\n        }\n \
    \       result.append(number)\n    }\n    return result", "    var uniqueNumbers\
    \ = [Int]()\n    for number in numbers {\n        if !uniqueNumbers.contains(number)\
    \ {\n            uniqueNumbers.append(number)\n        }\n    }\n    return uniqueNumbers",
  "    var uniqueArray: [Int] = []\n    for number in numbers {\n        if uniqueArray.contains(number)\
    \ {\n            uniqueArray.removeAll(where: {$0 == number})\n        } else\
    \ {\n            uniqueArray.append(number)\n        }\n    }\n    return uniqueArray",
  "    var result: [Int] = []\n    for num in numbers {\n        if !result.contains(num)\
    \ {\n            result.append(num)\n        }\n    }\n    return result", " \
    \   var result: [Int] = []\n    var flag: [Int] = []\n    for item in numbers\
    \ {\n        if !flag.contains(item) {\n            result.append(item)\n    \
    \        flag.append(item)\n        }\n    }\n    return result", "  var numbersSet\
    \ = Set<Int>()\n  var result = [Int]()\n  for number in numbers {\n    if !numbersSet.contains(number)\
    \ {\n      result.append(number)\n      numbersSet.insert(number)\n    }\n  }\n\
    \  return result", "    var uniques = [Int]()\n    for number in numbers {\n \
    \       if !uniques.contains(number) {\n            uniques.append(number)\n \
    \       }\n    }\n    return uniques", "    var dict: [Int: Int] = [:]\n    for\
    \ n in numbers {\n        dict[n] = dict[n, default: 0] + 1\n    }\n    return\
    \ dict.filter { $0.value == 1 }.map { $0.key }", "    let groups = Dictionary(grouping:\
    \ numbers, by: { $0 })\n    let filteredGroups = groups.filter { $0.value.count\
    \ == 1 }\n    let keys = filteredGroups.map { $0.key }\n    return keys", "  \
    \  guard numbers.count > 0 else { return [] }\n    var copy = numbers\n    copy.sort()\n\
    \    var result = [Int]()\n    result.append(copy[0])\n    for i in 1..<copy.count\
    \ {\n        if copy[i] != copy[i - 1] {\n            result.append(copy[i])\n\
    \        }\n    }\n    return result", '    return Array(Set(numbers))', "   \
    \ var newArray = [Int]()\n    for number in numbers {\n        if !newArray.contains(number)\
    \ {\n            newArray.append(number)\n        }\n    }\n    return newArray",
  "    \n    var mutableNumbers = numbers\n    var result : [Int] = []\n    \n   \
    \ for number in mutableNumbers {\n        let count = mutableNumbers.filter {\
    \ $0 == number }.count\n        if count == 1 {\n            result.append(number)\n\
    \        }\n    }\n    \n    return result", "    // Complete\n    return []",
  "    var result: [Int] = []\n    var set: Set<Int> = []\n    for n in numbers {\n\
    \        if !set.contains(n) {\n            result.append(n)\n            set.insert(n)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    var histogram\
    \ = [Int: Int]()\n    for number in numbers {\n        histogram[number] = (histogram[number]\
    \ ?? 0) + 1\n    }\n    for number in numbers {\n        if histogram[number]\
    \ == 1 {\n            result.append(number)\n        }\n    }\n    return result",
  "    let unique = Set(numbers)\n    return Array(unique)", "    // Implement your\
    \ solution here\n    return []", "    var dic = [Int: Int]()\n    for num in numbers\
    \ {\n        dic[num] = (dic[num] ?? 0) + 1\n    }\n    return numbers.filter\
    \ { dic[$0]! == 1 }", "    var dict = [Int: Int]()\n    numbers.forEach { dict[$0]\
    \ = (dict[$0] ?? 0) + 1 }\n    return dict.filter { $0.value == 1 }.map { $0.key\
    \ }", "    var unique = [Int]()\n    for x in numbers {\n        if !unique.contains(x)\
    \ {\n            unique.append(x)\n        }\n    }\n    return unique", "   \
    \ var result = [Int]()\n    var isDup = false\n    for number in numbers {\n \
    \       for resultNumber in result {\n            if number == resultNumber {\n\
    \                isDup = true\n                break\n            }\n        }\n\
    \        if !isDup {\n            result.append(number)\n        }\n        isDup\
    \ = false\n    }\n    return result", "    let set = Set(numbers)\n    let sorted_set\
    \ = set.sorted()\n    return sorted_set", "    var dictionary = [Int: Int]()\n\
    \    for number in numbers {\n        if let count = dictionary[number] {\n  \
    \          dictionary[number] = count + 1\n        } else {\n            dictionary[number]\
    \ = 1\n        }\n    }\n    var newArray = [Int]()\n    for number in numbers\
    \ {\n        if let count = dictionary[number], count == 1 {\n            newArray.append(number)\n\
    \        }\n    }\n    return newArray", "    var result = [Int]()\n    for value\
    \ in numbers {\n        if !result.contains(value) {\n            result.append(value)\n\
    \        }\n    }\n    return result", "    var result = [Int]()\n    var count_dict\
    \ = [Int: Int]()\n    for number in numbers {\n        count_dict[number] = (count_dict[number]\
    \ ?? 0) + 1\n    }\n    for number in numbers {\n        if count_dict[number]\
    \ == 1 {\n            result.append(number)\n        }\n    }\n    return result",
  "    var set = Set<Int>()\n    var result = [Int]()\n    for n in numbers {\n  \
    \      if !set.contains(n) {\n            set.insert(n)\n            result.append(n)\n\
    \        }\n    }\n    return result", '    return [1, 3, 4]', "    var set: Set<Int>\
    \ = []\n    var result: [Int] = []\n    for number in numbers {\n        if !set.contains(number)\
    \ {\n            set.insert(number)\n            result.append(number)\n     \
    \   }\n    }\n    return result", "    var array = [Int]()\n    for i in numbers\
    \ {\n        if array.count == 0 {\n            array.append(i)\n        } else\
    \ {\n            if array.contains(i) {\n                array.remove(at: array.index(of:\
    \ i)!)\n            } else {\n                array.append(i)\n            }\n\
    \        }\n    }\n    return array", "    var numbers_array = [Int]()\n    for\
    \ num in numbers {\n        if numbers_array.contains(num) {\n            continue\n\
    \        } else {\n            numbers_array.append(num)\n        }\n    }\n \
    \   return numbers_array", "    var numberSet = Set<Int>()\n    var numberArray\
    \ = [Int]()\n    for number in numbers {\n        if !numberSet.contains(number)\
    \ {\n            numberSet.insert(number)\n            numberArray.append(number)\n\
    \        }\n    }\n    return numberArray", "    var seen: [Int: Bool] = [:]\n\
    \    var result: [Int] = []\n    for number in numbers {\n        if seen[number]\
    \ == nil {\n            seen[number] = true\n            result.append(number)\n\
    \        }\n    }\n    return result", "  var result: [Int] = []\n  var dic: [Int:\
    \ Bool] = [:]\n  for n in numbers {\n    if dic[n] == nil {\n      dic[n] = true\n\
    \      result.append(n)\n    }\n  }\n  return result", "    let arr = numbers.sorted()\n\
    \    var result = [Int]()\n    var index = 0\n    while index < arr.count {\n\
    \        if index == arr.count - 1 {\n            result.append(arr[index])\n\
    \            break\n        }\n        if arr[index] != arr[index + 1] {\n   \
    \         result.append(arr[index])\n        }\n        index += 1\n    }\n  \
    \  return result", "    var numbersSet = Set<Int>()\n    var numbersList = [Int]()\n\
    \    for n in numbers {\n        if !numbersSet.contains(n) {\n            numbersSet.insert(n)\n\
    \            numbersList.append(n)\n        }\n    }\n    return numbersList",
  "    var integers = [Int]()\n    for num in numbers {\n        if integers.contains(num)\
    \ {\n            continue\n        }\n        integers.append(num)\n    }\n  \
    \  return integers", "    var arr = [Int]()\n    for number in numbers {\n   \
    \     if !arr.contains(number) {\n            arr.append(number)\n        }\n\
    \    }\n    return arr", "    var dictionary = [Int: Int]()\n    for element in\
    \ numbers {\n        dictionary[element] = (dictionary[element] ?? 0) + 1\n  \
    \  }\n    var newNumbers = [Int]()\n    for element in numbers {\n        if dictionary[element]\
    \ == 1 {\n            newNumbers.append(element)\n        }\n    }\n    return\
    \ newNumbers", "    // O(n^2)\n    // var numbers = numbers\n    // var idx =\
    \ 0\n    // while idx < numbers.count {\n    //     var del_idx = idx + 1\n  \
    \  //     while del_idx < numbers.count {\n    //         if numbers[idx] == numbers[del_idx]\
    \ {\n    //             numbers.remove(at: del_idx)\n    //         } else {\n\
    \    //             del_idx += 1\n    //         }\n    //     }\n    //     idx\
    \ += 1\n    // }\n    // return numbers\n\n    // O(n)\n    var numbers_counts\
    \ = [Int: Int]()\n    for num in numbers {\n        if let count = numbers_counts[num]\
    \ {\n            numbers_counts[num] = count + 1\n        } else {\n         \
    \   numbers_counts[num] = 1\n        }\n    }\n    var numbers_counts_filtered\
    \ = [Int: Int]()\n    for (num, count) in numbers_counts {\n        if count ==\
    \ 1 {\n            numbers_counts_filtered[num] = count\n        }\n    }\n  \
    \  return Array(numbers_counts_filtered.keys)", "    var result = [Int]()\n  \
    \  var dict = [Int: Int]()\n    for num in numbers {\n        dict[num] = (dict[num]\
    \ ?? 0) + 1\n    }\n    for key in dict.keys {\n        if dict[key] == 1 {\n\
    \            result.append(key)\n        }\n    }\n    return result", "    return\
    \ numbers.reduce(into: [Int]()) { results, number in\n        if !results.contains(number)\
    \ {\n            results.append(number)\n        }\n    }", "    var array: [Int]\
    \ = []\n    var dict: [Int: Int] = [:]\n    for number in numbers {\n        if\
    \ let count = dict[number] {\n            dict[number] = count + 1\n        }\
    \ else {\n            dict[number] = 1\n        }\n    }\n    for number in numbers\
    \ {\n        if dict[number] == 1 {\n            array.append(number)\n      \
    \  }\n    }\n    return array", "    var uniqueNumbers = [Int]()\n    var uniqueNumberCount\
    \ = 0\n    for number in numbers {\n        if uniqueNumbers.contains(number)\
    \ {\n            continue\n        }\n        uniqueNumbers.append(number)\n \
    \       uniqueNumberCount += 1\n    }\n    uniqueNumbers.sort()\n    return uniqueNumbers",
  "    // Write your solution here\n    var result: [Int] = []\n    for num in numbers\
    \ {\n        if !result.contains(num) {\n            result.append(num)\n    \
    \    }\n    }\n    return result", "    var set = Set<Int>()\n    var result =\
    \ [Int]()\n    for x in numbers {\n        if !set.contains(x) {\n           \
    \ set.insert(x)\n            result.append(x)\n        }\n    }\n    return result",
  "    let uniqueNumbers = Set(numbers)\n    return Array(uniqueNumbers)", '    return
    Array(Set(numbers))', '  return Array(Set(numbers))', "    var set = Set<Int>()\n\
    \    var result = [Int]()\n    for number in numbers {\n        if !set.contains(number)\
    \ {\n            set.insert(number)\n            result.append(number)\n     \
    \   }\n    }\n    return result", "    var remaining = [Int]()\n    for (index,\
    \ num) in numbers.enumerated() {\n        if numbers.index(of: num) == index {\n\
    \            remaining.append(num)\n        }\n    }\n    return remaining", " \
    \   var new_numbers = [Int]()\n    for number in numbers {\n        if !new_numbers.contains(number)\
    \ {\n            new_numbers.append(number)\n        }\n    }\n    return new_numbers"]
stop_tokens:
- "\n}"
