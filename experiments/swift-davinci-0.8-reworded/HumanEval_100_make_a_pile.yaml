name: HumanEval_100_make_a_pile
language: swift
prompt: "\n/// Given a positive integer n, you have to make a pile of n levels of\
  \ stones.\n/// The first level has n stones.\n/// The number of stones in the next\
  \ level is:\n/// - the next odd number if n is odd.\n/// - the next even number\
  \ if n is even.\n/// Return the number of stones in each level in an array, where\
  \ element at index\n/// i represents the number of stones in the level (i+1).\n\
  /// Examples:\n/// >>> make_a_pile(n: 3)\n/// [3, 5, 7]\nfunc make_a_pile(n: Int)\
  \ -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(make_a_pile(n: 3) == [3, 5, 7])\nassert(make_a_pile(n:\
  \ 4) == [4, 6, 8, 10])\nassert(make_a_pile(n: 5) == [5, 7, 9, 11, 13])\nassert(make_a_pile(n:\
  \ 6) == [6, 8, 10, 12, 14, 16])\nassert(make_a_pile(n: 8) == [8, 10, 12, 14, 16,\
  \ 18, 20, 22])"
completions: ["    var xs = [Int]()\n    var y = n\n    while y > 0 {\n        xs.append(y)\n\
    \        y = next_number(n: y)\n    }\n    return xs", "  var a = [n]\n  for _\
    \ in 0..<n-1 {\n    a.append(a.last! - (a.last! & 1) + (n & 1))\n  }\n  return\
    \ a", "    if n == 1 {\n        return [1]\n    } else {\n        let last = make_a_pile(n:\
    \ n - 1).last!\n        return make_a_pile(n: n - 1) + [(last + (last % 2 + 1))]\n\
    \    }", "  var ret = [Int]()\n  var current_n = n\n  while current_n > 0 {\n\
    \    ret.append(current_n)\n    if current_n % 2 == 0 {\n      current_n += 1\n\
    \    } else {\n      current_n += 2\n    }\n  }\n  return ret", "    let inc =\
    \ n % 2 == 0 ? 2 : 1\n    return (1...n).map { $0 + $0 * inc }", "    if n < 0\
    \ {\n        return []\n    }\n    var array = [n]\n    var last = n\n    while\
    \ last != 1 {\n        last = next_stones(last)\n        array.append(last)\n\
    \    }\n    return array", "    var stones = [Int]()\n    var num = n\n    while\
    \ stones.count < n {\n        stones.append(num)\n        if num % 2 == 0 {\n\
    \            num += 1\n        } else {\n            num += 2\n        }\n   \
    \ }\n    return stones", '  return (1...n).map { $0 == 1 ? n : n.sign() * ($0.isEven
    ? $0 + 1 : $0 - 1) }', "    var stones = [Int]()\n    var tmp = n\n    while tmp\
    \ > 0 {\n        stones.append(tmp)\n        if tmp % 2 == 0 {\n            tmp\
    \ += 1\n        } else {\n            tmp += 2\n        }\n    }\n    return stones",
  "    var stones: [Int] = []\n    var next_level = n\n    while next_level > 0 {\n\
    \        stones.append(next_level)\n        next_level = next_level % 2 == 0 ?\
    \ next_level - 1 : next_level - 2\n    }\n    return stones", "    var result\
    \ = [n]\n    var m = n\n    while m > 1 {\n        m -= 1\n        if m % 2 ==\
    \ 0 {\n            result.append(m - 1)\n        } else {\n            result.append(m\
    \ + 1)\n        }\n    }\n    return result", "    var result = [Int]()\n    var\
    \ nStones = n\n    while nStones > 0 {\n        result.append(nStones)\n     \
    \   if nStones % 2 == 0 {\n            nStones -= 1\n        } else {\n      \
    \      nStones -= 2\n        }\n    }\n    return result", "    precondition(n\
    \ > 0)\n    var pile = [Int]()\n    var last = n\n    while last > 0 {\n     \
    \   pile.append(last)\n        last += (last % 2 == 0) ? 2 : 1\n    }\n    return\
    \ pile", "    var result = [Int]()\n    var next = n\n    while next > 0 {\n \
    \       result.append(next)\n        next = next % 2 == 0 ? next + 1 : next +\
    \ 2\n    }\n    return result", "    // YOUR CODE HERE\n    var y = [Int]()\n\
    \    y.append(n)\n    var x = n\n    while x != 0 {\n        if x % 2 == 0 {\n\
    \            x = x / 2\n            x += 1\n            y.append(x)\n        }\
    \ else {\n            x = x / 2\n            x += 2\n            y.append(x)\n\
    \        }\n    }\n    y.removeLast()\n    return y", '  return Array(0..<n).map
    { $0 + 1 }.reversed()', '    return []', "    // your code here\n    var output\
    \ = [n]\n    while n > 1 {\n        n = n % 2 == 0 ? n/2 : n/2 + 1\n        output.append(n)\n\
    \    }\n    return output", "    var result = [Int]()\n    var currentLevelCount\
    \ = n\n    while currentLevelCount > 0 {\n        result.append(currentLevelCount)\n\
    \        currentLevelCount = currentLevelCount.isMultiple(of: 2) ? currentLevelCount\
    \ + 1 : currentLevelCount + 2\n    }\n    return result", '    return (1...n).map
    { ($0 % 2 == 0) ? ($0 + 1) : ($0 + 2) }', "    guard n > 0 else {\n        return\
    \ []\n    }\n    var result = [n]\n    var new_stones_in_next_level = n\n    while\
    \ true {\n        new_stones_in_next_level = (new_stones_in_next_level % 2 ==\
    \ 0) ?\n            new_stones_in_next_level + 2 : new_stones_in_next_level +\
    \ 1\n        result.append(new_stones_in_next_level)\n        if new_stones_in_next_level\
    \ >= n {\n            break\n        }\n    }\n    return result", '    return
    make_a_pile(n: n, arr: [n])', "    var result = [Int]()\n    var num = n\n   \
    \ while num != 0 {\n        result.append(num)\n        if num % 2 == 0 {\n  \
    \          num += 1\n        } else {\n            num += 2\n        }\n    }\n\
    \    return result", "    var stones = [Int]()\n    var current = n\n    while\
    \ current > 0 {\n        stones.append(current)\n        if current % 2 == 0 {\n\
    \            current -= 1\n        } else {\n            current -= 2\n      \
    \  }\n    }\n    return stones.reversed()", "    var pile = [n]\n    var i = 1\n\
    \    while i < n {\n        if n % 2 == 0 {\n            pile.append(pile[i-1]\
    \ + 2)\n        } else {\n            pile.append(pile[i-1] + 1)\n        }\n\
    \        i += 1\n    }\n    return pile", "    var res = [n]\n    while n > 1\
    \ {\n        res.append(n % 2 == 0 ? n + 2 : n + 1)\n        n -= 1\n    }\n \
    \   return res", "    let level = n\n    var stones = [Int]()\n    for i in 1...level\
    \ {\n        if i % 2 == 0 {\n            stones.append(i + 1)\n        } else\
    \ {\n            stones.append(i)\n        }\n    }\n    return stones", "   \
    \ // your code here\n    var result = [n]\n    var num = n\n    while num > 1\
    \ {\n        if num % 2 == 0 {\n            num -= 1\n        } else {\n     \
    \       num -= 2\n        }\n        result.append(num)\n    }\n    return result",
  "    let result =\n        Array(1...n)\n            .map { value in\n         \
    \       value % 2 == 0 ? value + 1 : value\n            }\n    return result",
  "    var arr: [Int] = []\n    var level: Int = n\n    while level > 0 {\n      \
    \  arr.append(level)\n        if level % 2 == 0 {\n            level += 1\n  \
    \      } else {\n            level += 2\n        }\n    }\n    return arr", " \
    \   precondition(n > 0)\n    var result = [n]\n    var currentNumber = n\n   \
    \ while currentNumber > 1 {\n        currentNumber -= 1\n        if n % 2 == 0\
    \ {\n            result.append(currentNumber + 2)\n        } else {\n        \
    \    result.append(currentNumber + 1)\n        }\n    }\n    return result", " \
    \   \n    return [Int](1...n).map{i in\n        if i % 2 == 0 {\n            return\
    \ i + 1\n        } else {\n            return i\n        }\n    }", "    var pile\
    \ = [Int]()\n    var i = n\n    while i > 0 {\n        pile.append(i)\n      \
    \  i += i % 2 == 0 ? 2 : 1\n    }\n    return pile", "    assert(n > 0)\n    var\
    \ values = [n]\n    var current = n\n    while current > 1 {\n        current\
    \ = current % 2 == 0 ? current - 1 : current - 2\n        values.append(current)\n\
    \    }\n    return values", "    if n == 1 {\n        return [1]\n    } else {\n\
    \        let nextLevel = n + (n % 2 == 0 ? 2 : 1)\n        return [n] + make_a_pile(n:\
    \ nextLevel)\n    }", "    if n == 1 {\n        return [1]\n    }\n    if n %\
    \ 2 == 0 {\n        return [n] + make_a_pile(n: n-1)\n    } else {\n        return\
    \ [n] + make_a_pile(n: n+1)\n    }", "    var n = n\n    var res = [Int]()\n \
    \   while n > 0 {\n        res.append(n)\n        n = n % 2 == 0 ? n / 2 : (n\
    \ - 1) / 2\n    }\n    return res", "    var count = n\n    var output = [Int]()\n\
    \    while count > 0 {\n        output.append(count)\n        if count % 2 ==\
    \ 0 {\n            count -= 1\n        } else {\n            count -= 2\n    \
    \    }\n    }\n    return output.reversed()", "    return (1...n).map { n in\n\
    \        n == 1 ? n : n % 2 == 0 ? n + 1 : n + 2\n    }", "    let stones = Array(1...n)\n\
    \    return stones.map {\n        ($0 % 2 == 0) ?\n            $0 + 1 :\n    \
    \        $0 + 2\n    }", "    var result = [n]\n    while n > 0 {\n        n -=\
    \ 1\n        if n == 0 {\n            break\n        }\n        result.append(n\
    \ % 2 == 0 ? n + 2 : n + 1)\n    }\n    return result", "    var result = [n]\n\
    \    while true {\n        let n = n % 2 == 0 ? n + 2 : n + 1\n        if n <=\
    \ 1 { break }\n        result.append(n)\n    }\n    return result", "    var levels\
    \ = [Int]()\n    var next = n\n    while next > 0 {\n        levels.append(next)\n\
    \        next = next.next_level()\n    }\n    return levels", "    var result\
    \ = [n]\n    for x in stride(from: n, to: 0, by: -1) {\n        let next = result.last!\n\
    \        if next % 2 == 0 {\n            result.append(next - 1)\n        } else\
    \ {\n            result.append(next - 2)\n        }\n    }\n    return result",
  "    guard n > 0 else {\n        return []\n    }\n    var pile = [n]\n    var current\
    \ = n\n    while current != 1 {\n        if current % 2 == 0 {\n            current\
    \ += 1\n        } else {\n            current += 2\n        }\n        pile.append(current)\n\
    \    }\n    return pile", "    return Array(stride(from: n, to: 0, by: -2)).map\
    \ { (num: Int) -> Int in\n        return num * 2 - 1\n    }", "    var array:\
    \ [Int] = []\n    if n > 0 {\n        array.append(n)\n        for i in 1..<n\
    \ {\n            if n % 2 == 0 {\n                array.append(n + i * 2)\n  \
    \          } else {\n                array.append(n + i * 2 - 1)\n           \
    \ }\n        }\n    }\n    return array", "    guard n > 0 else { return [] }\n\
    \    var res = [n]\n    var level = n\n    while level > 1 {\n        if level\
    \ % 2 == 0 {\n            level /= 2\n        } else {\n            level = (level\
    \ + 1) / 2\n        }\n        res.append(level)\n    }\n    return res", "  \
    \  var l = n\n    var r = [Int]()\n    while l > 0 {\n        r.append(l)\n  \
    \      l = (l % 2 == 0) ? l + 1 : l + 2\n    }\n    return r", "    var results\
    \ = [Int]()\n    results.append(n)\n    var next_odd_value = n + 2\n    var next_even_value\
    \ = n + 1\n    while next_odd_value <= n * 2 - 1 || next_even_value <= n * 2 {\n\
    \        if n % 2 == 0 {\n            if next_even_value <= n * 2 {\n        \
    \        results.append(next_even_value)\n                next_even_value += 2\n\
    \            }\n            if next_odd_value <= n * 2 - 1 {\n               \
    \ results.append(next_odd_value)\n                next_odd_value += 2\n      \
    \      }\n        } else {\n            if next_odd_value <= n * 2 - 1 {\n   \
    \             results.append(next_odd_value)\n                next_odd_value +=\
    \ 2\n            }\n            if next_even_value <= n * 2 {\n              \
    \  results.append(next_even_value)\n                next_even_value += 2\n   \
    \         }\n        }\n    }\n    return results", "    var list = [Int]()\n\
    \    var next = n\n    list.append(next)\n    while next != 1 {\n        if next\
    \ % 2 == 0 {\n            next -= 1\n        } else {\n            next -= 2\n\
    \        }\n        list.append(next)\n    }\n    return list", "    var result\
    \ = [Int]()\n    for i in 1...n {\n        result.append(n + 2 * i - 1)\n    }\n\
    \    return result", "  func next(_ num: Int) -> Int {\n    return num % 2 ==\
    \ 0 ? num + 2 : num + 1\n  }\n  var result = [n]\n  var current = n\n  for _ in\
    \ 1..<n {\n    current = next(current)\n    result.append(current)\n  }\n  return\
    \ result", "    guard n > 0 else {\n        return []\n    }\n    var result =\
    \ [n]\n    var i = n + (n % 2 == 0 ? 1 : 2)\n    while i <= n * 2 {\n        result.append(i)\n\
    \        i += 2\n    }\n    return result", "    // TODO: Write some code to solve\
    \ this coding challenge\n    return []", "    var arr = [Int]()\n    var i = n\n\
    \    while i >= 1 {\n        arr.append(i)\n        if i % 2 == 0 {\n        \
    \    i += 1\n        } else {\n            i += 2\n        }\n    }\n    return\
    \ arr", "    var pile = [Int]()\n    pile.append(n)\n    var next = n\n\n    while\
    \ next != 1 {\n        if next % 2 == 0 {\n            next = next - 1\n     \
    \   } else {\n            next = next / 2\n        }\n        pile.append(next)\n\
    \    }\n\n    return pile", "    var result = [n]\n    var next = n % 2 == 0 ?\
    \ n + 2 : n + 1\n    while next <= n * 2 {\n        result.append(next)\n    \
    \    next += 2\n    }\n    return result", "    var n = n\n    var r = [n]\n \
    \   while n > 1 {\n        n = (n & 1) == 0 ? n/2 : (n+1)/2\n        r.append(n)\n\
    \    }\n    return r", "    var stones: [Int] = []\n    var numberOfStones = n\n\
    \    while numberOfStones > 0 {\n        stones.append(numberOfStones)\n     \
    \   if numberOfStones % 2 == 0 {\n            numberOfStones -= 1\n        } else\
    \ {\n            numberOfStones -= 2\n        }\n    }\n    return stones.reversed()",
  '    return []', "    if n == 1 {\n        return [1]\n    }\n    if n == 2 {\n\
    \        return [2, 3]\n    }\n    var ret = [n]\n    if n % 2 == 0 {\n      \
    \  ret.append(contentsOf: make_a_pile(n: n / 2))\n    } else {\n        ret.append(contentsOf:\
    \ make_a_pile(n: (n - 1) / 2))\n    }\n    return ret", "    return (1..<n).reduce([n])\
    \ { (acc, n) in\n        acc + [acc.last! + (acc.last! % 2 == 0 ? 2 : 1)]\n  \
    \  }", "    assert(n > 0)\n    var result = [n]\n    var cnt = n\n    while cnt\
    \ > 1 {\n        if cnt % 2 == 0 {\n            cnt = cnt / 2\n        } else\
    \ {\n            cnt = (cnt + 1) / 2\n        }\n        result.append(cnt)\n\
    \    }\n    return result", "    guard n > 0 else {\n        return []\n    }\n\
    \    var result = [n]\n    let nextLevel = n.isMultiple(of: 2) ? n + 1 : n + 2\n\
    \    result.append(contentsOf: make_a_pile(n: nextLevel))\n    return result",
  "    var result = [n]\n    var current = n\n    while current > 0 {\n        if\
    \ current % 2 == 0 {\n            current += 1\n        } else {\n           \
    \ current += 2\n        }\n        result.append(current)\n    }\n    return result",
  "    return Array(1...n).map {\n        $0 % 2 == 0 ? $0 + 1 : $0\n    }", "   \
    \ if n < 1 {\n        return []\n    }\n    return (1...n).map({ $0 + n }).map({\
    \ $0 % 2 == 0 ? $0 + 1 : $0 })", "    \n    guard n > 0 else { return [] }\n \
    \   \n    var array = [n]\n    var next = n\n    \n    for _ in 1...n {\n    \
    \    if next % 2 == 0 {\n            next += 2\n        } else {\n           \
    \ next += 1\n        }\n        array.append(next)\n    }\n    \n    return array",
  "    return (1...n).reduce(into: []) {\n        $0.append($0.last ?? n + 1)\n  \
    \      $0.append($0.last! + $0.last! % 2 + 1)\n    }", "    var level_stones =\
    \ [Int]()\n    var current_level = n\n    while (current_level > 0) {\n      \
    \  level_stones.append(current_level)\n        if (current_level % 2 == 0) {\n\
    \            current_level -= 1\n        } else {\n            current_level -=\
    \ 2\n        }\n    }\n    return level_stones", "    var res = [Int]()\n    var\
    \ num = n\n    while num > 0 {\n        res.append(num)\n        num += (num %\
    \ 2 == 0) ? 2 : 1\n    }\n    return res", "    var result = [n]\n    var i =\
    \ n + (n % 2 == 0 ? 1 : 2)\n    while i <= n*2 {\n        result.append(i)\n \
    \       i += 2\n    }\n    return result", "    if n == 1 {\n        return [1]\n\
    \    }\n    if n % 2 == 0 {\n        return [n] + make_a_pile(n: n + 1)\n    }\
    \ else {\n        return [n] + make_a_pile(n: n + 2)\n    }", "    var result\
    \ = [n]\n    var i = n\n    var next = i % 2 == 0 ? i + 2 : i + 1\n    while next\
    \ < i * 2 {\n        result.append(next)\n        i = next\n        next = i %\
    \ 2 == 0 ? i + 2 : i + 1\n    }\n    return result", "    let output = [Int](1...n).map\
    \ { n in n % 2 == 0 ? (n + 1) : (n + 2) }\n    return output", "  var result =\
    \ [Int]()\n  var count = n\n  while count > 0 {\n    result.append(count)\n  \
    \  if count % 2 == 0 {\n      count += 1\n    } else {\n      count += 2\n   \
    \ }\n  }\n  return result", "    var result = [Int]()\n    var next = n\n    while\
    \ next > 0 {\n        result.append(next)\n        next = next.isMultiple(of:\
    \ 2) ? next + 1 : next + 2\n    }\n    return result", "    var arr = [Int]()\n\
    \    var lastLevel = n\n    while n > 0 {\n        arr.append(lastLevel)\n   \
    \     lastLevel = n % 2 == 0 ? lastLevel + 2 : lastLevel + 1\n        n -= 1\n\
    \    }\n    return arr", "    var stones = [Int]()\n    stones.append(n)\n   \
    \ for i in 1..<n {\n        stones.append(stones[i-1] % 2 == 0 ? stones[i-1] +\
    \ 2 : stones[i-1] + 1)\n    }\n    return stones", "    var pile = [n]\n    for\
    \ i in (1..<n) {\n        pile.append(n + 2 * i)\n    }\n    return pile", " \
    \   var n = n\n    var nn = [n]\n    while n > 1 {\n        if n % 2 == 0 {\n\
    \            n = n / 2\n        } else {\n            n = n - 1\n        }\n \
    \       nn.append(n)\n    }\n    return nn", "    var result = [n]\n    var next_n\
    \ = n\n    while true {\n        if next_n % 2 == 0 {\n            next_n += 2\n\
    \        } else {\n            next_n += 1\n        }\n        if next_n == n\
    \ {\n            break\n        }\n        result.append(next_n)\n    }\n    return\
    \ result", "    let result = (1...n).map { (i) -> Int in\n        let first =\
    \ i * 2 - 1\n        if i % 2 == 0 {\n            return first + 1\n        }\
    \ else {\n            return first\n        }\n    }\n    return result", "  \
    \  var pile = [Int]()\n    var level = n\n    while level > 0 {\n        pile.append(level)\n\
    \        level += (level % 2 == 0) ? 2 : 1\n    }\n    return pile", "    var\
    \ rowOfStones = [n]\n    var currentNumberOfStones = n\n    while currentNumberOfStones\
    \ > 1 {\n        if currentNumberOfStones % 2 == 0 {\n            currentNumberOfStones\
    \ -= 1\n        } else {\n            currentNumberOfStones -= 2\n        }\n\
    \        rowOfStones.append(currentNumberOfStones)\n    }\n    return rowOfStones",
  "    var stones: [Int] = []\n    for i in 1...n {\n        if n % 2 == 0 {\n   \
    \         stones.append(i * 2)\n        } else {\n            stones.append(i\
    \ * 2 - 1)\n        }\n    }\n    return stones", "    guard n > 0 else { return\
    \ [] }\n    var pile = [Int]()\n    var stones = n\n    while stones > 0 {\n \
    \       pile.append(stones)\n        stones = n % 2 == 0 ? stones - 1 : stones\
    \ + 1\n    }\n    return pile", "    let remainder = n % 2\n    var result = [Int]()\n\
    \    for i in 0...n {\n        result.append(n + i + remainder)\n    }\n    return\
    \ result", "    var m = n\n    var results = [Int]()\n    while m > 0 {\n    \
    \    results.append(m)\n        m += m % 2 == 0 ? 2 : 1\n    }\n    return results",
  "    var result = [Int]()\n    var i = n\n    while i > 0 {\n        result.append(i)\n\
    \        i = (i % 2 == 0) ? i + 1 : i + 2\n    }\n    return result", '    return
    (1...n).map { $0 * n }', "    var a = [n]\n    while a.last! > 1 {\n        a.append(a.last!\
    \ + ((a.last! + 1) % 2 == 0 ? 1 : 2))\n    }\n    return a", "    let base: Int\
    \ = n + (n % 2 == 0 ? 0 : 1)\n    var result: [Int] = [n]\n    for i in stride(from:\
    \ base, to: n, by: 2) {\n        result.append(i)\n    }\n    return result",
  "    var stones = [n]\n    var stone = n\n    while stone > 1 {\n        stone =\
    \ stone.isMultiple(of: 2) ? stone / 2 : (stone + 1) / 2\n        stones.append(stone)\n\
    \    }\n    return stones", "    var pile = [Int]()\n    pile.append(n)\n    var\
    \ top = n\n    while top != 1 {\n        if top % 2 == 0 {\n            top =\
    \ top - 1\n        } else {\n            top = top - 2\n        }\n        pile.append(top)\n\
    \    }\n    return pile", "    // your code here\n    return Array<Int>()", " \
    \   precondition(n > 0)\n    var stones_in_level = n\n    var nxt_stones_in_level\
    \ = stones_in_level + ((stones_in_level % 2 == 0) ? 2 : 1)\n    var pile = [stones_in_level]\n\
    \    while nxt_stones_in_level < n * 3 {\n        pile.append(nxt_stones_in_level)\n\
    \        stones_in_level = nxt_stones_in_level\n        nxt_stones_in_level =\
    \ stones_in_level + ((stones_in_level % 2 == 0) ? 2 : 1)\n    }\n    return pile",
  "    var result = [n]\n    var current = n\n    while current > 1 {\n        if\
    \ current % 2 == 0 {\n            current += 1\n        } else {\n           \
    \ current += 2\n        }\n        result.append(current)\n    }\n    return result",
  "    var result = [Int]()\n    for i in 0..<n {\n        if i % 2 == 0 {\n     \
    \       result.append(n + i)\n        } else {\n            result.append(n +\
    \ i + 1)\n        }\n    }\n    return result", "    var list: [Int] = []\n  \
    \  var i = n\n    while i > 0 {\n        list.append(i)\n        if i % 2 == 0\
    \ {\n            i -= 1\n        } else {\n            i -= 2\n        }\n   \
    \ }\n    return list", '    return (1..<n).map { $0 + n }', "    var levels =\
    \ [n]\n    while levels.last! > 1 {\n        levels.append(levels.last! & 1 ==\
    \ 0 ? levels.last! / 2 : levels.last! * 3 + 1)\n    }\n    return levels", " \
    \   var arr = [Int]()\n    var i = n\n    while i > 0 {\n        arr.append(i)\n\
    \        if i%2 == 0 {\n            i += 1\n        } else {\n            i +=\
    \ 2\n        }\n    }\n    return arr", "  var result = [Int]()\n  var k = n\n\
    \  while k > 0 {\n    result.append(k)\n    k = k % 2 == 0 ? k - 1 : k - 2\n \
    \ }\n  return result", "    var result = [n]\n    var next_value = n - 1\n   \
    \ while next_value > 0 {\n        result.append(next_value)\n        next_value\
    \ = next_value % 2 == 0 ? next_value - 2 : next_value - 1\n    }\n    return result",
  "    if n < 1 {\n        return []\n    }\n    var stones: [Int] = [n]\n    var\
    \ next_stones = n % 2 == 0 ? n + 2 : n + 1\n    while next_stones <= n * 2 {\n\
    \        stones.append(next_stones)\n        next_stones = next_stones % 2 ==\
    \ 0 ? next_stones + 2 : next_stones + 1\n    }\n    return stones", '    return
    Array(1...n).map { $0 * 2 - 1 }', "    var result = [n]\n    var x = n\n    while\
    \ (x > 0) {\n        if x % 2 == 0 {\n            x += 1\n        } else {\n \
    \           x += 2\n        }\n        result.append(x)\n    }\n    return result",
  "    var result = [n]\n    var x = 1\n    while x < n {\n        if result.last!\
    \ % 2 == 0 {\n            result.append(result.last! + 2)\n        } else {\n\
    \            result.append(result.last! + 1)\n        }\n        x += 1\n    }\n\
    \    return result", "    precondition(n > 0)\n    let initialLevel = n\n    let\
    \ isEven = n % 2 == 0\n    var nextNumber = isEven ? (n + 2) : (n + 1)\n    return\
    \ (1...n).map { _ in\n        let currentLevel = nextNumber\n        nextNumber\
    \ = isEven ? (nextNumber + 2) : (nextNumber + 1)\n        return currentLevel\n\
    \    }", "    return Array(1...n).map { n in\n        if n.isMultiple(of: 2) {\n\
    \            return n * 2\n        } else {\n            return n * 2 - 1\n  \
    \      }\n    }", "    let initial: [Int] = [n]\n    return (1..<n).reduce(initial)\
    \ { a, _ in\n        if a.last! % 2 == 0 {\n            return a + [a.last! +\
    \ 2]\n        } else {\n            return a + [a.last! + 1]\n        }\n    }",
  "    var array: [Int] = []\n    var i = 1\n    while array.count < n {\n       \
    \ if i % 2 == 0 {\n            array.append(i + 1)\n        } else {\n       \
    \     array.append(i)\n        }\n        i += 1\n    }\n    return array", " \
    \ var stones: [Int] = []\n  var x = n\n  while x > 0 {\n    stones.append(x)\n\
    \    x = (x % 2 == 0) ? x - 1 : x - 2\n  }\n  return stones", "    if n < 1 {\n\
    \        return []\n    }\n    var result = [Int]()\n    result.append(n)\n  \
    \  var current = n\n    while current > 1 {\n        current = (current % 2 ==\
    \ 0) ? current / 2 : current / 2 + 1\n        result.append(current)\n    }\n\
    \    return result", "  var result = [Int]()\n  var stone = n\n  while stone >\
    \ 0 {\n    result.append(stone)\n    stone += (stone % 2 == 0) ? 2 : 1\n  }\n\
    \  return result", '    return [Int](1...n).map { ($0 + n) / 2 * 2 }', "    guard\
    \ n > 0 else {\n        return []\n    }\n    var pile = [n]\n    var idx = 0\n\
    \    var i = n - 1\n    while i > 0 {\n        if n % 2 == 0 {\n            if\
    \ i % 2 == 0 {\n                pile.append(i)\n                idx += 1\n   \
    \             i -= 1\n            } else {\n                i -= 1\n         \
    \   }\n        } else {\n            if i % 2 == 0 {\n                i -= 1\n\
    \            } else {\n                pile.append(i)\n                idx +=\
    \ 1\n                i -= 1\n            }\n        }\n    }\n    return pile",
  "    var result = [Int]()\n    var stones = n\n    while stones > 0 {\n        result.append(stones)\n\
    \        if stones % 2 == 0 {\n            stones += 1\n        } else {\n   \
    \         stones += 2\n        }\n    }\n    return result", '    return []',
  "    var result = [n]\n    for i in 1..<n {\n        result.append(n - i)\n    }\n\
    \    return result", "    var arr = [n]\n    while arr.last! > 0 {\n        if\
    \ arr.last! % 2 == 0 {\n            arr.append(arr.last! / 2)\n        } else\
    \ {\n            arr.append((arr.last! + 1) / 2)\n        }\n    }\n    return\
    \ arr", "    return Array(1...n).map {\n        if $0 % 2 == 0 {\n           \
    \ return $0 + 1\n        } else {\n            return $0 + 2\n        }\n    }",
  "    var arr = [Int]()\n    arr.append(n)\n    var count = n + 2\n    while count\
    \ < (n * 2) {\n        arr.append(count)\n        count += 2\n    }\n    return\
    \ arr", "    guard n > 0 else { return [] }\n    var nums = [n]\n    var next\
    \ = n % 2 == 0 ? n + 2 : n + 1\n    while next <= n * 2 {\n        nums.append(next)\n\
    \        next += next % 2 == 0 ? 2 : 1\n    }\n    return nums", "    var ans\
    \ = [n]\n    while ans.last! > 1 {\n        let next = ans.last! % 2 == 0 ? ans.last!\
    \ / 2 : ans.last! / 2 + 1\n        ans.append(next)\n    }\n    return ans", " \
    \   var temp = n\n    var res = [n]\n    while temp != 1 {\n        if temp %\
    \ 2 == 0 {\n            temp /= 2\n        } else {\n            temp = (temp\
    \ - 1) / 2\n        }\n        res.append(temp)\n    }\n    return res", "   \
    \ var res = [Int]()\n    var n = n\n    while n > 0 {\n        res.append(n)\n\
    \        n = n % 2 == 0 ? n - 1 : n - 2\n    }\n    return res", "  var n = n\n\
    \  var res = [Int]()\n  while n > 0 {\n    res.append(n)\n    n = (n % 2 == 0)\
    \ ? n + 1 : n + 2\n  }\n  return res", "    var res = [Int]()\n    var i = n\n\
    \    while i > 0 {\n        res.append(i)\n        if i % 2 == 0 {\n         \
    \   i -= 1\n        } else {\n            i -= 2\n        }\n    }\n    return\
    \ res", "    guard n > 0 else { return [] }\n    return (1...n).reduce(into: [])\
    \ {\n        $0.append($0.last ?? n)\n        $0.append($0.last! + 2 * ($0.count\
    \ % 2))\n    }", "    var result = [n]\n    for i in stride(from: n, to: 0, by:\
    \ -1) {\n        if i % 2 == 0 {\n            result.append(i + 2)\n        }\
    \ else {\n            result.append(i + 1)\n        }\n    }\n    return result",
  "    var result = [Int]()\n    for i in 0..<n {\n        result.append(n + 2 * i)\n\
    \    }\n    return result", '    return []', "    guard n > 0 else { return []\
    \ }\n    let first = n\n    let last = n % 2 == 0 ? n + 2 : n + 1\n    let middle\
    \ = (last - first) / 2\n    return Array(first...last).map { $0 - middle }", '    return
    (1..<n).map { $0 % 2 == 0 ? n + $0 : n + $0 + 1 }', "  if n == 1 {\n    return\
    \ [1]\n  }\n  if n % 2 == 0 {\n    return [n] + make_a_pile(n: n - 1)\n  } else\
    \ {\n    return [n] + make_a_pile(n: n + 1)\n  }", "    var arr = [n]\n    for\
    \ i in 1..<n {\n        if n % 2 == 0 {\n            arr.append(n + 2 * i)\n \
    \       } else {\n            arr.append(n + 2 * i - 1)\n        }\n    }\n  \
    \  return arr", "    var m = n\n    var result = [n]\n    while m > 1 {\n    \
    \    if m % 2 == 0 {\n            m = m / 2\n        } else {\n            m =\
    \ m / 2 + 1\n        }\n        result.append(2 * m)\n    }\n    return result",
  "    var result = [Int]()\n    var num = n\n    while num > 0 {\n        result.append(num)\n\
    \        num = next_num(num)\n    }\n    return result", "    var next = [n]\n\
    \    var n = n\n    while n > 1 {\n        n = n%2 == 0 ? n/2 : n/2 + 1\n    \
    \    next.append(n)\n    }\n    return next", "    var result = [Int]()\n    for\
    \ i in stride(from: n, to: 0, by: -1) {\n        result.append(i)\n    }\n   \
    \ return result", "  var result = [Int]()\n  for i in 0..<n {\n    if i % 2 ==\
    \ 0 {\n      result.append(n + 2 * i)\n    } else {\n      result.append(n + 2\
    \ * i + 1)\n    }\n  }\n  return result", "  var pile = [Int]()\n  var current\
    \ = n\n  while current > 0 {\n    pile.append(current)\n    current = next_even_or_odd(current)\n\
    \  }\n  return pile", "    var stones: [Int] = []\n    var i = n\n\n    while\
    \ i > 0 {\n        stones.append(i)\n        i = i % 2 == 0 ? i - 1 : i - 2\n\
    \    }\n\n    return stones.reversed()", "    var result = [n]\n    if n > 1 {\n\
    \        var number = n + (n % 2 == 0 ? 2 : 1)\n        for _ in 0..<n - 1 {\n\
    \            result.append(number)\n            number += (number % 2 == 0 ? 2\
    \ : 1)\n        }\n    }\n    return result", "    var pile = [Int]()\n    for\
    \ level in 0..<n {\n        pile.append(n + 2 * level)\n    }\n    return pile",
  "    var result = [Int]()\n    var level = n\n    while level > 0 {\n        result.append(level)\n\
    \        level = n%2 == 0 ? n-1 : n+1\n        n = level\n    }\n    return result",
  "    var i = 0\n    var next_level = [Int]()\n    while i < n {\n        next_level.append(i+1)\n\
    \        i += 1\n    }\n    return next_level", '    return [Int](0...n).map({
    $0 + n })', "    var result = [Int]()\n    var m = n\n    while m > 0 {\n    \
    \    result.append(m)\n        m += (m % 2 == 0) ? 2 : 1\n    }\n    return result",
  "    if n == 1 {\n        return [1]\n    } else {\n        var result = make_a_pile(n:\
    \ n - 1)\n        result.append(result.last! + (n % 2 == 0 ? 2 : 1))\n       \
    \ return result\n    }", "    precondition(n > 0)\n    var result = [Int]()\n\
    \    var n = n\n    var i = 0\n    while n > 0 {\n        result.append(n)\n \
    \       i += 1\n        if i % 2 == 0 {\n            n -= 1\n        } else {\n\
    \            n -= 2\n        }\n    }\n    return result", "    var result = [Int]()\n\
    \    var current = n\n    while current > 0 {\n        result.append(current)\n\
    \        current = current % 2 == 0 ? current + 1 : current + 2\n    }\n    return\
    \ result", "    guard n > 0 else { return [] }\n    var pile = [n]\n    while\
    \ pile.last! > 1 {\n        let lst = pile.last!\n        pile.append(lst.isMultiple(of:\
    \ 2) ? lst / 2 : (lst + 1) / 2)\n    }\n    return pile", "    var result = [Int]()\n\
    \    var remaining = n\n    while remaining > 0 {\n        result.append(remaining)\n\
    \        remaining -= remaining % 2 == 0 ? 2 : 1\n    }\n    return result", " \
    \   // Your code here\n    return []", "  var pile = [n]\n  var next = n % 2 ==\
    \ 0 ? n + 2 : n + 1\n  for _ in 1..<n {\n    pile.append(next)\n    next += 2\n\
    \  }\n  return pile", "    assert(n > 0)\n    var result = [Int]()\n    var current\
    \ = n\n    while current > 0 {\n        result.append(current)\n        current\
    \ = n % 2 == 0 ? current + 2 : current + 1\n    }\n    return result", "    if\
    \ n < 1 {\n        return []\n    }\n    var result = [n]\n    var current = n\n\
    \    while current > 1 {\n        current = current.isEven ? current/2 : current/2\
    \ + 1\n        result.append(current)\n    }\n    return result", "    return\
    \ (1...n).map {\n        var stones = n\n        if n % 2 == 0 {\n           \
    \ stones += 2 * $0\n        } else {\n            stones += 2 * $0 - 1\n     \
    \   }\n        return stones\n    }", "    var n = n\n    var array = [Int]()\n\
    \    while n > 0 {\n        array.append(n)\n        if n % 2 == 0 {\n       \
    \     n -= 1\n        } else {\n            n -= 2\n        }\n    }\n    return\
    \ array", "    // TODO: Implement Function\n    var result: [Int] = []\n    var\
    \ i = 1\n    while i <= n {\n        result.append(i)\n        if i % 2 == 0 {\n\
    \            i += 1\n        } else {\n            i += 2\n        }\n    }\n\
    \    return result", "  return [Int](1...n).map({ (n) -> Int in\n    let next\
    \ = (n % 2 == 0) ? n + 1 : n + 2\n    return next\n  })", "    var array = [n]\n\
    \    var i = n - 1\n    while i >= 1 {\n        if i % 2 == 0 {\n            array.append(i\
    \ + 1)\n        } else {\n            array.append(i - 1)\n        }\n       \
    \ i -= 1\n    }\n    return array", "    let maxLevel = (n * 2) - 1\n    var levels\
    \ = [Int]()\n    for level in 1...maxLevel {\n        let numStones = level *\
    \ 2 - 1\n        levels.append(numStones)\n    }\n    return levels", "    if\
    \ n < 1 {\n        return []\n    }\n    var list = [n]\n    var prev = n\n\n\
    \    while let next = next_element(n: prev) {\n        list.append(next)\n   \
    \     prev = next\n    }\n\n    return list", "    precondition(n > 0)\n    var\
    \ array = [n]\n    var n = n\n    while n > 1 {\n        n = n.isMultiple(of:\
    \ 2) ? n / 2 : n * 3 + 1\n        array.append(n)\n    }\n    return array", " \
    \   guard n > 0 else { return [] }\n    return make_a_pile(n: n-1) + [n + (n %\
    \ 2 == 0 ? 1 : 2)]", "    var results = [Int]()\n    var currentLevel = n\n  \
    \  while currentLevel > 0 {\n        results.append(currentLevel)\n        currentLevel\
    \ += currentLevel % 2 == 0 ? 2 : 1\n    }\n    return results.reversed()", '    return
    []', "    var x = n\n    var levels = [Int]()\n    while x > 0 {\n        levels.append(x)\n\
    \        if x % 2 == 0 {\n            x -= 1\n        } else {\n            x\
    \ -= 2\n        }\n    }\n    return levels", "    var result = [Int]()\n    var\
    \ number = n\n    while n > 0 {\n        result.append(number)\n        if number\
    \ % 2 == 0 {\n            number += 1\n        } else {\n            number +=\
    \ 2\n        }\n        n -= 1\n    }\n    return result", "    var stones = [n]\n\
    \    for _ in 1..<n {\n        stones.append(stones.last! + 2)\n    }\n    return\
    \ stones", "    var arr = [n]\n    for _ in 0..<n - 1 {\n        arr.append(arr.last!\
    \ + (arr.last! & 1 == 0 ? 2 : 1))\n    }\n    return arr", '    return []', " \
    \   var pile = [Int]()\n    var level = n\n    while level > 0 {\n        pile.append(level)\n\
    \        level = next_level(level)\n    }\n    return pile", "    if n == 1 {\n\
    \        return [1]\n    }\n    if n % 2 == 0 {\n        return [n] + make_a_pile(n:\
    \ n + 1)\n    } else {\n        return [n] + make_a_pile(n: n + 2)\n    }", " \
    \   guard n > 0 else { return [] }\n    return Array(0..<n).reduce([n]) { (acc,\
    \ _) in\n        let last = acc.last!\n        let next = last.isMultiple(of:\
    \ 2) ? last + 1 : last + 2\n        return acc + [next]\n    }", "    var answer\
    \ = [Int]()\n    for i in stride(from: n, to: 0, by: -1) {\n        answer.append(i)\n\
    \    }\n    return answer", "    // write your solution here\n    var res = [Int]()\n\
    \    var i = n\n    while i > 0 {\n        res.append(i)\n        if i % 2 ==\
    \ 0 {\n            i = i / 2\n        } else {\n            i = (i - 1) / 2\n\
    \        }\n    }\n    return res", "    var result = [n]\n    let next: (Int)\
    \ -> Int = n % 2 == 0 ? even_successor : odd_successor\n    var i = next(n)\n\
    \    while i > 0 {\n        result.append(i)\n        i = next(i)\n    }\n   \
    \ return result", '    return []', "    var prev_n = n\n    var result = [n]\n\
    \    while prev_n > 0 {\n        let next_level_n = (prev_n % 2 == 0) ? (prev_n\
    \ + 2) : (prev_n + 1)\n        result.append(next_level_n)\n        prev_n = next_level_n\n\
    \    }\n    return result", "    var n = n\n    var arr = [Int]()\n    while n\
    \ > 0 {\n        arr.append(n)\n        n += n % 2 == 0 ? 2 : 1\n    }\n    return\
    \ arr", "    return Array(1...n).map { (i) -> Int in\n        i % 2 == 0 ? i +\
    \ 1 : i\n    }", "    var result = [Int]()\n    var i = n\n    while i > 0 {\n\
    \        result.append(i)\n        i = i % 2 == 0 ? i + 1 : i + 2\n    }\n   \
    \ return result", '    return (0...n-1).map { (n - $0) + $0%2 }', "  let next_odd\
    \ = { (n: Int) -> Int in\n    if n % 2 == 0 {\n      return n + 1\n    }\n   \
    \ return n + 2\n  }\n  let next_even = { (n: Int) -> Int in\n    if n % 2 == 0\
    \ {\n      return n + 2\n    }\n    return n + 1\n  }\n  var next_number = next_odd\n\
    \  var result = [n]\n  while n != result.last! {\n    result.append(next_number(result.last!))\n\
    \    next_number = n % 2 == 0 ? next_odd : next_even\n  }\n  return result", " \
    \   var stones = [Int]()\n    var x = n\n    while x > 0 {\n        stones.append(x)\n\
    \        if x % 2 == 0 {\n            x += 1\n        } else {\n            x\
    \ += 2\n        }\n    }\n    return stones", "  guard n > 0 else { return []\
    \ }\n  var result = [Int]()\n  for i in stride(from: n, to: 0, by: -1) {\n   \
    \ result.append(i)\n  }\n  return result", '    return []', "    var result =\
    \ [Int]()\n    var current = n\n    while current > 0 {\n        result.append(current)\n\
    \        current = next(n: current)\n    }\n    return result", "    var stones\
    \ = [Int]()\n    stones.append(n)\n    while n > 1 {\n        if n % 2 == 0 {\n\
    \            n -= 1\n        } else {\n            n += 1\n        }\n       \
    \ stones.append(n)\n    }\n    return stones", "    var pile = [Int]()\n    for\
    \ n in n...1 {\n        pile.append(n)\n    }\n    return pile", "    var result\
    \ = [n]\n    var n = n\n    while n > 0 {\n        n = n.isMultiple(of: 2) ? n\
    \ + 1 : n + 2\n        result.append(n)\n    }\n    return result", "    return\
    \ stride(from: n, to: 0, by: -1).map { n in\n        n % 2 == 0 ? n + 1 : n\n\
    \    }", '    return []', "    return Array(1...n).map { (i) -> Int in\n     \
    \   if i % 2 == 0 {\n            return i + 1\n        } else {\n            return\
    \ i + 2\n        }\n    }"]
stop_tokens:
- "\n}"
