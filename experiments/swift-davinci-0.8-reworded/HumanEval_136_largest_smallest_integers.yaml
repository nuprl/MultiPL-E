name: HumanEval_136_largest_smallest_integers
language: swift
prompt: "\n/// Create a function that returns a tuple (a, b), where 'a' is\n/// the\
  \ largest of negative integers, and 'b' is the smallest\n/// of positive integers\
  \ in an array.\n/// If there is no negative or positive integers, return them as\
  \ nil.\n/// Examples:\n/// >>> largest_smallest_integers(lst: [2, 4, 1, 3, 5, 7])\n\
  /// (nil, 1)\n/// >>> largest_smallest_integers(lst: [] as [Int])\n/// (nil, nil)\n\
  /// >>> largest_smallest_integers(lst: [0])\n/// (nil, nil)\nfunc largest_smallest_integers(lst:\
  \ [Int]) -> (Int?, Int?) {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(largest_smallest_integers(lst: [2, 4, 1,\
  \ 3, 5, 7]) == (nil, 1))\nassert(largest_smallest_integers(lst: [2, 4, 1, 3, 5,\
  \ 7, 0]) == (nil, 1))\nassert(largest_smallest_integers(lst: [1, 3, 2, 4, 5, 6,\
  \ -2]) == (-2, 1))\nassert(largest_smallest_integers(lst: [4, 5, 3, 6, 2, 7, -7])\
  \ == (-7, 2))\nassert(largest_smallest_integers(lst: [7, 3, 8, 4, 9, 2, 5, -9])\
  \ == (-9, 2))\nassert(largest_smallest_integers(lst: [] as [Int]) == (nil, nil))\n\
  assert(largest_smallest_integers(lst: [0]) == (nil, nil))\nassert(largest_smallest_integers(lst:\
  \ [-1, -3, -5, -6]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-1, -3,\
  \ -5, -6, 0]) == (-1, nil))\nassert(largest_smallest_integers(lst: [-6, -4, -4,\
  \ -3, 1]) == (-3, 1))\nassert(largest_smallest_integers(lst: [-6, -4, -4, -3, -100,\
  \ 1]) == (-3, 1))"
completions: ["    if lst.isEmpty {\n        return (nil, nil)\n    }\n    let pos\
    \ = lst.filter({ $0 > 0 }).sorted(by: { $0 < $1 })\n    let neg = lst.filter({\
    \ $0 < 0 }).sorted(by: { $0 > $1 })\n    return (neg.first, pos.first)", "   \
    \ var max = lst.max()\n    var min = lst.min()\n    if max! < 0 {\n        max\
    \ = nil\n    }\n    if min! > 0 {\n        min = nil\n    }\n    return (max,\
    \ min)", "    var minPositive = Int.max\n    var maxNegative = Int.min\n    for\
    \ n in lst {\n        if n > 0 && n < minPositive {\n            minPositive =\
    \ n\n        }\n        if n < 0 && n > maxNegative {\n            maxNegative\
    \ = n\n        }\n    }\n    return (maxNegative == Int.min ? nil : maxNegative,\
    \ minPositive == Int.max ? nil : minPositive)", "    // Write your code here\n\
    \    return (nil, nil)", '    return (nil, nil)', '    return (nil, nil)', " \
    \   var max = lst.max()\n    var min = lst.min()\n    if max! < 0 {\n        max\
    \ = nil\n    }\n    if min! > 0 {\n        min = nil\n    }\n    return (max,\
    \ min)", '    return (nil, nil)', "    var negatives = [Int]()\n    var positives\
    \ = [Int]()\n    var largest: Int?\n    var smallest: Int?\n    \n    for num\
    \ in lst {\n        if num < 0 {\n            negatives.append(num)\n        }\
    \ else if num > 0 {\n            positives.append(num)\n        }\n    }\n   \
    \ \n    if negatives.count > 0 {\n        largest = negatives.max()\n    }\n \
    \   \n    if positives.count > 0 {\n        smallest = positives.min()\n    }\n\
    \    \n    return (largest, smallest)", '    return (nil, nil)', "    let arr\
    \ = lst.sorted(by: <)\n    let res = (arr.first, arr.last)\n    return res", " \
    \   if lst.isEmpty {\n        return (nil, nil)\n    }\n    var maxNegative =\
    \ Int.min\n    var minPositive = Int.max\n    for i in lst {\n        if i < 0\
    \ {\n            maxNegative = max(maxNegative, i)\n        } else if i > 0 {\n\
    \            minPositive = min(minPositive, i)\n        }\n    }\n    return (maxNegative\
    \ == Int.min ? nil : maxNegative, minPositive == Int.max ? nil : minPositive)",
  "    var largestNegativeNumber: Int?\n    var smallestPositiveNumber: Int?\n   \
    \ \n    for number in lst {\n        if number < 0 {\n            if largestNegativeNumber\
    \ == nil {\n                largestNegativeNumber = number\n            } else\
    \ if number > largestNegativeNumber! {\n                largestNegativeNumber\
    \ = number\n            }\n        } else if number > 0 {\n            if smallestPositiveNumber\
    \ == nil {\n                smallestPositiveNumber = number\n            } else\
    \ if number < smallestPositiveNumber! {\n                smallestPositiveNumber\
    \ = number\n            }\n        }\n    }\n    \n    return (largestNegativeNumber,\
    \ smallestPositiveNumber)", "    let positive = lst.filter { $0 > 0 }\n    let\
    \ negative = lst.filter { $0 < 0 }\n    guard positive.count > 0 || negative.count\
    \ > 0 else { return (nil, nil) }\n    return (negative.max(), positive.min())",
  "    if lst.count == 0 {\n        return (nil, nil)\n    }\n    else {\n       \
    \ var largestNegative = lst[0]\n        var smallestPositive = lst[0]\n      \
    \  for i in lst {\n            if i < 0 && i > largestNegative {\n           \
    \     largestNegative = i\n            }\n            else if i > 0 && i < smallestPositive\
    \ {\n                smallestPositive = i\n            }\n        }\n        if\
    \ largestNegative < 0 {\n            return (largestNegative, smallestPositive)\n\
    \        }\n        else {\n            return (nil, smallestPositive)\n     \
    \   }\n    }", "    var largestNegativeInt: Int?\n    var smallestPositiveInt:\
    \ Int?\n    \n    for number in lst {\n        if number < 0 {\n            if\
    \ let largestNegativeInt = largestNegativeInt {\n                if number > largestNegativeInt\
    \ {\n                    largestNegativeInt = number\n                }\n    \
    \        } else {\n                largestNegativeInt = number\n            }\n\
    \        } else if number > 0 {\n            if let smallestPositiveInt = smallestPositiveInt\
    \ {\n                if number < smallestPositiveInt {\n                    smallestPositiveInt\
    \ = number\n                }\n            } else {\n                smallestPositiveInt\
    \ = number\n            }\n        }\n    }\n    \n    return (largestNegativeInt,\
    \ smallestPositiveInt)", "    \n    var largestNegative = Int.min\n    var smallestPositive\
    \ = Int.max\n    \n    for item in lst {\n        if item < 0 && item > largestNegative\
    \ {\n            largestNegative = item\n        }\n        if item > 0 && item\
    \ < smallestPositive {\n            smallestPositive = item\n        }\n    }\n\
    \    \n    return largestNegative == Int.min ? (nil, smallestPositive) : (largestNegative,\
    \ smallestPositive)", "    guard lst.count > 0 else {\n        return (nil, nil)\n\
    \    }\n    var min = 0\n    var max = 0\n    for item in lst {\n        if item\
    \ < min {\n            min = item\n        }\n        if item > max {\n      \
    \      max = item\n        }\n    }\n    if max < 0 {\n        return (max, nil)\n\
    \    }\n    if min > 0 {\n        return (nil, min)\n    }\n    return (nil, nil)",
  "    \n    var smallestPositive: Int?\n    var largestNegative: Int?\n    \n   \
    \ for i in lst {\n        if i < 0 {\n            if largestNegative == nil {\n\
    \                largestNegative = i\n            } else if i > largestNegative!\
    \ {\n                largestNegative = i\n            }\n        } else if i >\
    \ 0 {\n            if smallestPositive == nil {\n                smallestPositive\
    \ = i\n            } else if i < smallestPositive! {\n                smallestPositive\
    \ = i\n            }\n        }\n    }\n    \n    return (largestNegative, smallestPositive)",
  "  guard lst.count > 0 else { return (nil, nil) }\n  var largestNegative = lst[0]\n\
    \  var smallestPositive = lst[0]\n  var lnCount = 0\n  var spCount = 0\n  for\
    \ i in lst {\n    if i < 0 {\n      if i > largestNegative {\n        largestNegative\
    \ = i\n      }\n      lnCount += 1\n    } else if i > 0 {\n      if i < smallestPositive\
    \ {\n        smallestPositive = i\n      }\n      spCount += 1\n    }\n  }\n \
    \ if lnCount == 0 {\n    largestNegative = nil\n  }\n  if spCount == 0 {\n   \
    \ smallestPositive = nil\n  }\n  return (largestNegative, smallestPositive)",
  "    return (\n        lst.filter { $0 < 0 }.max(),\n        lst.filter { $0 > 0\
    \ }.min()\n    )", '    return (nil, nil)', "    var max_neg = Optional<Int>.none\n\
    \    var min_pos = Optional<Int>.none\n    for num in lst {\n        if num <\
    \ 0 {\n            if max_neg == nil {\n                max_neg = num\n      \
    \      } else if num > max_neg! {\n                max_neg = num\n           \
    \ }\n        } else if num > 0 {\n            if min_pos == nil {\n          \
    \      min_pos = num\n            } else if num < min_pos! {\n               \
    \ min_pos = num\n            }\n        }\n    }\n    return (max_neg, min_pos)",
  "    if lst.isEmpty {\n        return (nil, nil)\n    }\n    let negative_numbers\
    \ = lst.filter {$0 < 0}\n    let positive_numbers = lst.filter {$0 > 0}\n    if\
    \ negative_numbers.isEmpty {\n        return (nil, positive_numbers.min())\n \
    \   }\n    if positive_numbers.isEmpty {\n        return (negative_numbers.max(),\
    \ nil)\n    }\n    return (negative_numbers.max(), positive_numbers.min())", " \
    \   var largest_negative: Int? = nil\n    var smallest_positive: Int? = nil\n\
    \    for num in lst {\n        if num < 0 {\n            if largest_negative ==\
    \ nil {\n                largest_negative = num\n            } else if num > largest_negative!\
    \ {\n                largest_negative = num\n            }\n        } else if\
    \ num > 0 {\n            if smallest_positive == nil {\n                smallest_positive\
    \ = num\n            } else if num < smallest_positive! {\n                smallest_positive\
    \ = num\n            }\n        }\n    }\n    return (largest_negative, smallest_positive)",
  "    var negativeInteger: Int?\n    var positiveInteger: Int?\n    for i in lst\
    \ {\n        if i < 0 && (negativeInteger == nil || i > negativeInteger!) {\n\
    \            negativeInteger = i\n        } else if i > 0 && (positiveInteger\
    \ == nil || i < positiveInteger!) {\n            positiveInteger = i\n       \
    \ }\n    }\n    return (negativeInteger, positiveInteger)", '    return (nil,
    nil)', "    //YOUR CODE GOES HERE\n    let arr = lst.filter{$0 != 0}\n    if arr.count\
    \ == 0 {\n        return (nil, nil)\n    }\n    var neg: Int? = nil\n    var pos:\
    \ Int? = nil\n    for num in arr {\n        if num < 0 {\n            if neg ==\
    \ nil {\n                neg = num\n            } else if num > neg! {\n     \
    \           neg = num\n            }\n        } else {\n            if pos ==\
    \ nil {\n                pos = num\n            } else if num < pos! {\n     \
    \           pos = num\n            }\n        }\n    }\n    return (neg, pos)",
  "    var maxNegative: Int? = nil\n    var minPositive: Int? = nil\n    for item\
    \ in lst {\n        if item < 0 && (maxNegative == nil || item > maxNegative!)\
    \ {\n            maxNegative = item\n        }\n        if item > 0 && (minPositive\
    \ == nil || item < minPositive!) {\n            minPositive = item\n        }\n\
    \    }\n    return (maxNegative, minPositive)", "    // write code here\n    return\
    \ (nil, nil)", '    fatalError("Not implemented")', "    // your code goes here\n\
    \    return nil", '    return (nil, nil)', "    var smallestPositiveInt: Int?\n\
    \    var largestNegativeInt: Int?\n    \n    if !lst.isEmpty {\n        smallestPositiveInt\
    \ = lst.min()!\n        largestNegativeInt = lst.max()!\n        \n        if\
    \ smallestPositiveInt ?? 0 < 0 {\n            smallestPositiveInt = nil\n    \
    \    }\n        \n        if largestNegativeInt ?? 0 > 0 {\n            largestNegativeInt\
    \ = nil\n        }\n    }\n    \n    return (largestNegativeInt, smallestPositiveInt)",
  "    var pos = lst.filter({ $0 > 0 }).min()\n    var neg = lst.filter({ $0 < 0 }).max()\n\
    \    pos = pos == 0 ? nil : pos\n    neg = neg == 0 ? nil : neg\n    return (neg,\
    \ pos)", "    var largestNeg: Int? = nil\n    var smallestPos: Int? = nil\n  \
    \  for elem in lst {\n        if elem < 0 {\n            if largestNeg == nil\
    \ {\n                largestNeg = elem\n            } else if elem > largestNeg!\
    \ {\n                largestNeg = elem\n            }\n        } else if elem\
    \ > 0 {\n            if smallestPos == nil {\n                smallestPos = elem\n\
    \            } else if elem < smallestPos! {\n                smallestPos = elem\n\
    \            }\n        }\n    }\n    return (largestNeg, smallestPos)", "   \
    \ // TODO: Implement this function!\n    return (nil, nil)", "    let integers\
    \ = lst.filter({ $0 != 0 })\n    return (integers.max(), integers.min())", " \
    \   var neg_max: Int? = nil\n    var pos_min: Int? = nil\n    for i in lst {\n\
    \        if i < 0 {\n            if neg_max == nil {\n                neg_max\
    \ = i\n            } else if i > neg_max! {\n                neg_max = i\n   \
    \         }\n        } else if i > 0 {\n            if pos_min == nil {\n    \
    \            pos_min = i\n            } else if i < pos_min! {\n             \
    \   pos_min = i\n            }\n        }\n    }\n    return (neg_max, pos_min)",
  "    var largest = lst.filter { $0 < 0 }.max()\n    var smallest = lst.filter {\
    \ $0 > 0 }.min()\n    return (largest, smallest)", "    let negatives = lst.filter\
    \ { $0 < 0 }\n    let positives = lst.filter { $0 > 0 }\n    return (negatives.isEmpty\
    \ ? nil : negatives.max(), positives.isEmpty ? nil : positives.min())", '    return
    (nil, nil)', "    var maxNeg = Int.min\n    var minPos = Int.max\n    for i in\
    \ lst {\n        if i < 0 && i > maxNeg {\n            maxNeg = i\n        }\n\
    \        if i > 0 && i < minPos {\n            minPos = i\n        }\n    }\n\
    \    if minPos == Int.max {\n        minPos = nil\n    }\n    if maxNeg == Int.min\
    \ {\n        maxNeg = nil\n    }\n    return (maxNeg, minPos)", "    var positiveMinimum:\
    \ Int?\n    var negativeMaximum: Int?\n    for element in lst {\n        if positiveMinimum\
    \ == nil && element > 0 {\n            positiveMinimum = element\n        } else\
    \ if positiveMinimum != nil && element > 0 && element < positiveMinimum! {\n \
    \           positiveMinimum = element\n        }\n        if negativeMaximum ==\
    \ nil && element < 0 {\n            negativeMaximum = element\n        } else\
    \ if negativeMaximum != nil && element < 0 && element > negativeMaximum! {\n \
    \           negativeMaximum = element\n        }\n    }\n    return (negativeMaximum,\
    \ positiveMinimum)", "    \n    var largestNegativeNumber: Int?\n    var smallestPositiveNumber:\
    \ Int?\n    \n    for number in lst {\n        if largestNegativeNumber == nil,\
    \ number < 0 {\n            largestNegativeNumber = number\n        } else if\
    \ number < 0, number > largestNegativeNumber! {\n            largestNegativeNumber\
    \ = number\n        }\n        \n        if smallestPositiveNumber == nil, number\
    \ > 0 {\n            smallestPositiveNumber = number\n        } else if number\
    \ > 0, number < smallestPositiveNumber! {\n            smallestPositiveNumber\
    \ = number\n        }\n    }\n    \n    return (largestNegativeNumber, smallestPositiveNumber)",
  '    return (nil, nil)', '    return (lst.filter{$0 < 0}.max(), lst.filter{$0 >
    0}.min())', '    return (lst.filter{$0 < 0}.max(), lst.filter{$0 > 0}.min())',
  "    let positives = lst.filter({$0 > 0})\n    let negatives = lst.filter({$0 <\
    \ 0})\n    let smallest = positives.min()\n    let largest = negatives.max()\n\
    \    return (largest, smallest)", "    let negs = lst.filter { $0 < 0 }\n    let\
    \ posi = lst.filter { $0 > 0 }\n    return (negs.max(), posi.min())", "    //\
    \ TODO: Implement this function\n    var largestNegative: Int? = nil\n    var\
    \ smallestPositive: Int? = nil\n    for number in lst {\n        if number < 0\
    \ {\n            if largestNegative == nil {\n                largestNegative\
    \ = number\n            } else if number > largestNegative! {\n              \
    \  largestNegative = number\n            }\n        } else if number > 0 {\n \
    \           if smallestPositive == nil {\n                smallestPositive = number\n\
    \            } else if number < smallestPositive! {\n                smallestPositive\
    \ = number\n            }\n        }\n    }\n    return (largestNegative, smallestPositive)",
  '    return (nil, nil)', "    var neg: Int? = nil\n    var pos: Int? = nil\n   \
    \ for item in lst {\n        if item > 0 {\n            if pos == nil {\n    \
    \            pos = item\n            } else if item < pos! {\n               \
    \ pos = item\n            }\n        } else if item < 0 {\n            if neg\
    \ == nil {\n                neg = item\n            } else if item > neg! {\n\
    \                neg = item\n            }\n        }\n    }\n    return (neg,\
    \ pos)", "    \n    let sortedLst = lst.sorted()\n    let negatives = sortedLst.filter\
    \ { $0 < 0 }\n    let positives = sortedLst.filter { $0 > 0 }\n    \n    return\
    \ (negatives.last, positives.first)", "    if lst.count == 0 {\n        return\
    \ (nil, nil)\n    }\n    var posMin = lst[0]\n    var negMax = lst[0]\n    for\
    \ i in lst {\n        if i > 0 {\n            if i < posMin {\n              \
    \  posMin = i\n            }\n        } else {\n            if i > negMax {\n\
    \                negMax = i\n            }\n        }\n    }\n    return (negMax,\
    \ posMin)", '    return (nil, nil)', "    let arr = lst.filter({ $0 != 0 })\n\
    \    return (arr.min(), arr.max())", "    var largestNegative: Int? = nil\n  \
    \  var smallestPositive: Int? = nil\n    for i in lst {\n        if i < 0 {\n\
    \            if largestNegative == nil {\n                largestNegative = i\n\
    \            } else if i > largestNegative! {\n                largestNegative\
    \ = i\n            }\n        } else if i > 0 {\n            if smallestPositive\
    \ == nil {\n                smallestPositive = i\n            } else if i < smallestPositive!\
    \ {\n                smallestPositive = i\n            }\n        }\n    }\n \
    \   return (largestNegative, smallestPositive)", '    return (nil, nil)', "  \
    \  var minPositive: Int? = nil\n    var maxNegative: Int? = nil\n    for item\
    \ in lst {\n        if item > 0 {\n            if minPositive == nil {\n     \
    \           minPositive = item\n            } else if item < minPositive! {\n\
    \                minPositive = item\n            }\n        } else if item < 0\
    \ {\n            if maxNegative == nil {\n                maxNegative = item\n\
    \            } else if item > maxNegative! {\n                maxNegative = item\n\
    \            }\n        }\n    }\n    return (maxNegative, minPositive)", "  \
    \  var negativeList: [Int] = []\n    var positiveList: [Int] = []\n    for n in\
    \ lst {\n        if n > 0 {\n            positiveList.append(n)\n        } else\
    \ if n < 0 {\n            negativeList.append(n)\n        }\n    }\n    if positiveList.count\
    \ > 0 {\n        positiveList.sort(by: { $0 < $1 })\n    }\n    if negativeList.count\
    \ > 0 {\n        negativeList.sort(by: { $0 > $1 })\n    }\n    return (negativeList.first,\
    \ positiveList.first)", "  let tuple = lst.reduce((Int.min, Int.max)) {\n    if\
    \ $1 < 0 {\n      return ($1 > $0.0 ? $1 : $0.0, $0.1)\n    } else if $1 > 0 {\n\
    \      return ($0.0, $1 < $0.1 ? $1 : $0.1)\n    } else {\n      return $0\n \
    \   }\n  }\n  return (tuple.0 == Int.min ? nil : tuple.0, tuple.1 == Int.max ?\
    \ nil : tuple.1)", "    // Write your code here...\n    var lst = lst\n    guard\
    \ lst.count > 0 else { return (nil, nil) }\n    guard lst.min() != 0 else { return\
    \ (nil, nil) }\n    lst.sort()\n    var a: Int?\n    var b: Int?\n    var lstMin\
    \ = lst.filter{ $0 < 0 }\n    var lstMax = lst.filter{ $0 > 0 }\n    if lstMin.count\
    \ == 0 {\n        a = nil\n    } else {\n        a = lstMin.min()\n    }\n   \
    \ if lstMax.count == 0 {\n        b = nil\n    } else {\n        b = lstMax.max()\n\
    \    }\n    return (a, b)", "    var largest: Int? = nil\n    var smallest: Int?\
    \ = nil\n    for x in lst {\n        if largest == nil && x < 0 {\n          \
    \  largest = x\n        } else if smallest == nil && x > 0 {\n            smallest\
    \ = x\n        } else if let currentLargest = largest, x < currentLargest {\n\
    \            largest = x\n        } else if let currentSmallest = smallest, x\
    \ > currentSmallest {\n            smallest = x\n        }\n    }\n    return\
    \ (largest, smallest)", "    var largest: Int? = nil\n    var smallest: Int? =\
    \ nil\n    for int in lst {\n        if int > 0 {\n            if smallest ==\
    \ nil {\n                smallest = int\n            } else if int < smallest!\
    \ {\n                smallest = int\n            }\n        } else if int < 0\
    \ {\n            if largest == nil {\n                largest = int\n        \
    \    } else if int > largest! {\n                largest = int\n            }\n\
    \        }\n    }\n    return (largest, smallest)", "    // your code here\n \
    \   guard !lst.isEmpty else {\n        return (nil, nil)\n    }\n    var smallest\
    \ = lst[0]\n    var largest = lst[0]\n    for i in lst {\n        if i > largest\
    \ {\n            largest = i\n        }\n        if i < smallest {\n         \
    \   smallest = i\n        }\n    }\n    if largest > 0 && smallest < 0 {\n   \
    \     return (largest, smallest)\n    } else {\n        return (nil, nil)\n  \
    \  }", '    return (nil, nil)', "    var least : Int?\n    var greatest : Int?\n\
    \    for item in lst {\n        if item < 0 {\n            if greatest == nil\
    \ {\n                greatest = item\n            } else if item > greatest! {\n\
    \                greatest = item\n            }\n        } else if item > 0 {\n\
    \            if least == nil {\n                least = item\n            } else\
    \ if item < least! {\n                least = item\n            }\n        }\n\
    \    }\n    return (greatest, least)", "    if lst.isEmpty {\n        return (nil,\
    \ nil)\n    }\n    let positive = lst.filter { $0 > 0 }\n    let negative = lst.filter\
    \ { $0 < 0 }\n    let positiveMin = positive.min()\n    let negativeMax = negative.max()\n\
    \    return (negativeMax, positiveMin)", "    // your code here\n    var min:\
    \ Int? = nil\n    var max: Int? = nil\n    for number in lst {\n        if number\
    \ < 0 && (min == nil || number > min!) {\n            min = number\n        }\
    \ else if number > 0 && (max == nil || number < max!) {\n            max = number\n\
    \        }\n    }\n    return (min, max)", "    \n    return (nil, nil)", "  \
    \  if lst.isEmpty {\n        return (nil, nil)\n    }\n    var smallest = lst[0]\n\
    \    var largest = lst[0]\n    for i in 1..<lst.count {\n        if smallest >\
    \ lst[i] {\n            smallest = lst[i]\n        }\n        if largest < lst[i]\
    \ {\n            largest = lst[i]\n        }\n    }\n    if smallest > 0 {\n \
    \       smallest = nil\n    }\n    if largest < 0 {\n        largest = nil\n \
    \   }\n    return (largest, smallest)", '    return (nil, nil)', "    let sorted\
    \ = lst.sorted()\n    let pos = sorted.firstIndex { $0 > 0 }\n    let neg = sorted.lastIndex\
    \ { $0 < 0 }\n    return (neg.map { sorted[$0] }, pos.map { sorted[$0] })", " \
    \   //Possible solutions:\n    //1. a. Creating a function (getLargestSmallest())\
    \ that takes an array of ints and returns a tuple of optional ints. If the array\
    \ is empty or all elements are 0, then return (nil, nil).\n    //   b. The function\
    \ performs a for loop, and compares each integer to the previous value. If the\
    \ integer is larger or smaller than previous value, it replaces the previous value,\
    \ or if there is no previous value, it assigns the value.\n    //   c. If the\
    \ array has a positive and negative value, the function creates an array of optional\
    \ integers and stores the largest negative and the smallest positive value in\
    \ the array.\n    //   d. The function returns the array.\n    //   e. Call the\
    \ function in main().\n    //2. a. Create an optional array of ints (minMaxInts)\
    \ with the values of (nil, nil).\n    //   b. Create a for loop that goes through\
    \ each integer of the array, and replaces the values of the array if the integer\
    \ is larger than the first value and less than the second value.\n    //   c.\
    \ Return the array.\n    //   d. Call the function in main().\n    //3. a. Create\
    \ an array of optional ints (minMaxInts) with the values of (nil, nil).\n    //\
    \   b. Create a for loop that goes through each integer of the array, and replaces\
    \ the values of the array if the integer is larger than the first value and less\
    \ than the second value.\n    //   c. Return the array.\n    //   d. Call the\
    \ function in main().\n    //2.\n    var minMaxInts: (Int?, Int?) = (nil, nil)\n\
    \    for num in lst {\n        if num > minMaxInts.1 ?? 0 {\n            minMaxInts.1\
    \ = num\n        }\n        if num < minMaxInts.0 ?? 0 {\n            minMaxInts.0\
    \ = num\n        }\n    }\n    return minMaxInts", "    var maxNegative: Int?\
    \ = nil\n    var minPositive: Int? = nil\n    for number in lst {\n        if\
    \ number > 0 {\n            if minPositive == nil {\n                minPositive\
    \ = number\n            } else if number < minPositive! {\n                minPositive\
    \ = number\n            }\n        } else if number < 0 {\n            if maxNegative\
    \ == nil {\n                maxNegative = number\n            } else if number\
    \ > maxNegative! {\n                maxNegative = number\n            }\n    \
    \    }\n    }\n    return (maxNegative, minPositive)", '    return (nil, nil)',
  '    return (nil, nil)', '    return (lst.filter { $0 < 0 }.max(), lst.filter {
    $0 > 0 }.min())', "    guard lst.count > 0 else {\n        return (nil, nil)\n\
    \    }\n    let positives = lst.filter { $0 > 0 }\n    let negatives = lst.filter\
    \ { $0 < 0 }\n    guard positives.count > 0 || negatives.count > 0 else {\n  \
    \      return (nil, nil)\n    }\n    var largest: Int? = nil\n    var smallest:\
    \ Int? = nil\n    if negatives.count > 0 {\n        largest = negatives.max()\n\
    \    }\n    if positives.count > 0 {\n        smallest = positives.min()\n   \
    \ }\n    return (largest, smallest)", "    // For now, always return the same\
    \ result\n    return (nil, nil)", '    return (nil, nil)', '    return (nil, nil)',
  "    let sortedLst = lst.sorted {$0 < $1}\n    for i in sortedLst {\n        if\
    \ i > 0 {\n            let a = sortedLst.last\n            let b = sortedLst.first\n\
    \            return (a, b)\n        }\n    }\n    return (nil, nil)", "    //\
    \ your code goes here.\n    return (nil, nil)", "    let positive = lst.filter({$0\
    \ >= 0}).min()\n    let negative = lst.filter({$0 < 0}).max()\n    return (negative,\
    \ positive)", "    let positives = lst.filter {$0 > 0}\n    let negatives = lst.filter\
    \ {$0 < 0}\n    return (negatives.max(), positives.min())", '    return (nil,
    nil)', "    // your code here\n    return (nil, nil)", "    // Fill in the code\
    \ here\n    return (nil, nil)", "    // TODO: Implement this function\n    return\
    \ (nil, nil)", '    return (nil, nil)', "    var lgstNeg = Int.min\n    var smllPos\
    \ = Int.max\n    for num in lst {\n        if num < 0 {\n            if num >\
    \ lgstNeg {\n                lgstNeg = num\n            }\n        } else if num\
    \ > 0 {\n            if num < smllPos {\n                smllPos = num\n     \
    \       }\n        }\n    }\n    if lgstNeg == Int.min {\n        lgstNeg = nil\n\
    \    }\n    if smllPos == Int.max {\n        smllPos = nil\n    }\n    return\
    \ (lgstNeg, smllPos)", "    let positive = lst.filter { $0 > 0 }\n    let negative\
    \ = lst.filter { $0 < 0 }\n    return (negative.max(), positive.min())", '    return
    (nil, nil)', "    var min = lst.min()\n    var max = lst.max()\n    if min ==\
    \ 0 {\n        min = nil\n    }\n    if max == 0 {\n        max = nil\n    }\n\
    \    return (max, min)", "    var max: Int? = nil\n    var min: Int? = nil\n \
    \   for num in lst {\n        if num > 0 && (min == nil || num < min!) {\n   \
    \         min = num\n        } else if num < 0 && (max == nil || num > max!) {\n\
    \            max = num\n        }\n    }\n    return (max, min)", "    if lst.count\
    \ == 0 {\n        return (nil, nil)\n    }\n    var largest_negative = lst[0]\n\
    \    var smallest_positive = lst[0]\n    for number in lst {\n        if number\
    \ < 0 {\n            if number > largest_negative {\n                largest_negative\
    \ = number\n            }\n        } else if number > 0 {\n            if number\
    \ < smallest_positive {\n                smallest_positive = number\n        \
    \    }\n        }\n    }\n    if largest_negative < 0 {\n        if smallest_positive\
    \ > 0 {\n            return (largest_negative, smallest_positive)\n        } else\
    \ {\n            return (largest_negative, nil)\n        }\n    } else {\n   \
    \     if smallest_positive > 0 {\n            return (nil, smallest_positive)\n\
    \        } else {\n            return (nil, nil)\n        }\n    }", "    let\
    \ sorted = lst.sorted()\n    guard sorted.count > 0 else { return (nil, nil) }\n\
    \    guard let first = sorted.first, let last = sorted.last else { return (nil,\
    \ nil) }\n    if first < 0 {\n        if last > 0 {\n            return (first,\
    \ last)\n        } else {\n            return (first, nil)\n        }\n    } else\
    \ {\n        if last > 0 {\n            return (nil, last)\n        } else {\n\
    \            return (nil, nil)\n        }\n    }", '    return (nil, nil)', '  return
    (nil, nil)', "    // TODO: Implement largest_smallest_integers function\n    \n\
    \    return (nil, nil)", "    var largestNegative: Int? = nil\n    var smallestPositive:\
    \ Int? = nil\n    for num in lst {\n        if num < 0 {\n            if largestNegative\
    \ == nil {\n                largestNegative = num\n            } else if num >\
    \ largestNegative! {\n                largestNegative = num\n            }\n \
    \       } else if num > 0 {\n            if smallestPositive == nil {\n      \
    \          smallestPositive = num\n            } else if num < smallestPositive!\
    \ {\n                smallestPositive = num\n            }\n        }\n    }\n\
    \    return (largestNegative, smallestPositive)", "    let negatives = lst.filter\
    \ { $0 < 0 }\n    let positives = lst.filter { $0 > 0 }\n    return (negatives.max(),\
    \ positives.min())", "    if lst.isEmpty {\n        return (nil, nil)\n    }\n\
    \    var smallest: Int? = nil\n    var largest: Int? = nil\n    for element in\
    \ lst {\n        if largest == nil && element > 0 {\n            largest = element\n\
    \        }\n        if element > largest! && element > 0 {\n            largest\
    \ = element\n        }\n        if smallest == nil && element < 0 {\n        \
    \    smallest = element\n        }\n        if element < smallest! && element\
    \ < 0 {\n            smallest = element\n        }\n    }\n    return (smallest,\
    \ largest)", "    guard lst.count > 0 else { return (nil, nil) }\n    var smallest\
    \ = 0\n    var largest = 0\n    for elem in lst {\n        if elem >= 0 {\n  \
    \          if smallest == 0 {\n                smallest = elem\n            }\
    \ else if elem < smallest {\n                smallest = elem\n            }\n\
    \        } else {\n            if largest == 0 {\n                largest = elem\n\
    \            } else if elem > largest {\n                largest = elem\n    \
    \        }\n        }\n    }\n    return (largest == 0 ? nil : largest, smallest\
    \ == 0 ? nil : smallest)", "    var largestNegativeInt: Int?\n    var smallestPositiveInt:\
    \ Int?\n    \n    for item in lst {\n        if item < 0 {\n            if largestNegativeInt\
    \ == nil {\n                largestNegativeInt = item\n            } else if item\
    \ > largestNegativeInt! {\n                largestNegativeInt = item\n       \
    \     }\n        } else if item > 0 {\n            if smallestPositiveInt == nil\
    \ {\n                smallestPositiveInt = item\n            } else if item <\
    \ smallestPositiveInt! {\n                smallestPositiveInt = item\n       \
    \     }\n        }\n    }\n    \n    return (largestNegativeInt, smallestPositiveInt)",
  "    var result = (nil, nil)\n    for value in lst {\n        if let unwrapped_value\
    \ = result.0 {\n            if value < 0 && value > unwrapped_value {\n      \
    \          result.0 = value\n            }\n        } else {\n            if value\
    \ < 0 {\n                result.0 = value\n            }\n        }\n        if\
    \ let unwrapped_value = result.1 {\n            if value > 0 && value < unwrapped_value\
    \ {\n                result.1 = value\n            }\n        } else {\n     \
    \       if value > 0 {\n                result.1 = value\n            }\n    \
    \    }\n    }\n    return result", "    // TODO: Write some code to solve this\
    \ coding problem\n    return (nil, nil)", "    if lst.count == 0 {\n        return\
    \ (nil, nil)\n    }\n    var largest = lst[0]\n    var smallest = lst[0]\n   \
    \ for i in lst {\n        if i < 0 {\n            if i > largest {\n         \
    \       largest = i\n            }\n        } else if i > 0 {\n            if\
    \ i < smallest {\n                smallest = i\n            }\n        }\n   \
    \ }\n    if largest > 0 {\n        largest = nil\n    }\n    if smallest < 0 {\n\
    \        smallest = nil\n    }\n    return (largest, smallest)", "  // your code\
    \ here\n  return (nil, nil)", "    let sorted = lst.sorted()\n    guard !sorted.isEmpty\
    \ else { return (nil, nil) }\n    guard sorted[0] >= 0 else { return (sorted.last,\
    \ nil) }\n    guard sorted.last! <= 0 else { return (nil, sorted.first) }\n  \
    \  return (nil, nil)", "    let negatives = lst.filter({ $0 < 0 })\n    let positives\
    \ = lst.filter({ $0 > 0 })\n    return (negatives.max(), positives.min())", " \
    \   // TODO: Implement\n    var smallest = 0\n    var largest = 0\n    for i in\
    \ lst {\n        if i > 0 {\n            if smallest == 0 || i < smallest {\n\
    \                smallest = i\n            }\n        } else if i < 0 {\n    \
    \        if largest == 0 || i > largest {\n                largest = i\n     \
    \       }\n        }\n    }\n    if smallest == 0 {\n        smallest = nil\n\
    \    }\n    if largest == 0 {\n        largest = nil\n    }\n    return (largest,\
    \ smallest)", "    var max_neg: Int? = nil\n    var min_pos: Int? = nil\n    for\
    \ i in lst {\n        if i > 0 {\n            if min_pos == nil {\n          \
    \      min_pos = i\n            } else if i < min_pos! {\n                min_pos\
    \ = i\n            }\n        } else if i < 0 {\n            if max_neg == nil\
    \ {\n                max_neg = i\n            } else if i > max_neg! {\n     \
    \           max_neg = i\n            }\n        }\n    }\n    return (max_neg,\
    \ min_pos)", "    \n    var negatives : [Int] = []\n    var positives : [Int]\
    \ = []\n    \n    for element in lst {\n        if element > 0 {\n           \
    \ positives.append(element)\n        } else if element < 0 {\n            negatives.append(element)\n\
    \        }\n    }\n    \n    if negatives.count == 0 {\n        return (nil, positives.min())\n\
    \    } else if positives.count == 0 {\n        return (negatives.max(), nil)\n\
    \    } else {\n        return (negatives.max(), positives.min())\n    }", "  \
    \  var negativeNumbers = lst.filter{ $0 < 0 }\n    let positiveNumbers = lst.filter{\
    \ $0 > 0 }\n    if negativeNumbers.count == 0 {\n        negativeNumbers.append(Int.min)\n\
    \    }\n    if positiveNumbers.count == 0 {\n        return (nil, nil)\n    }\n\
    \    return (negativeNumbers.max(), positiveNumbers.min())", "  var largest: Int?\
    \ = nil\n  var smallest: Int? = nil\n  for x in lst {\n    if smallest == nil\
    \ && x > 0 {\n      smallest = x\n    }\n    if largest == nil && x < 0 {\n  \
    \    largest = x\n    }\n    if x > 0 && x < smallest! {\n      smallest = x\n\
    \    }\n    if x < 0 && x > largest! {\n      largest = x\n    }\n  }\n  return\
    \ (largest, smallest)", "    var max: Int? = nil\n    var min: Int? = nil\n  \
    \  for num in lst {\n        if num > 0 {\n            if min == nil {\n     \
    \           min = num\n            } else if num < min! {\n                min\
    \ = num\n            }\n        } else if num < 0 {\n            if max == nil\
    \ {\n                max = num\n            } else if num > max! {\n         \
    \       max = num\n            }\n        }\n    }\n    return (max, min)", " \
    \   var largestNegative: Int? = nil\n    var smallestPositive: Int? = nil\n  \
    \  for i in lst {\n        if i > 0 {\n            if smallestPositive == nil\
    \ {\n                smallestPositive = i\n            } else if i < smallestPositive!\
    \ {\n                smallestPositive = i\n            }\n        } else if i\
    \ < 0 {\n            if largestNegative == nil {\n                largestNegative\
    \ = i\n            } else if i > largestNegative! {\n                largestNegative\
    \ = i\n            }\n        }\n    }\n    return (largestNegative, smallestPositive)",
  "    \n    var positive:[Int] = []\n    var negative:[Int] = []\n    \n    for i\
    \ in lst {\n        if i < 0 {\n            negative.append(i)\n        }\n  \
    \      if i > 0 {\n            positive.append(i)\n        }\n    }\n    \n  \
    \  if positive.count == 0 {\n        return (nil, nil)\n    }\n    \n    if negative.count\
    \ == 0 {\n        return (nil, positive.min())\n    }\n    \n    if positive.count\
    \ > 0 && negative.count > 0 {\n        return (negative.max(), positive.min())\n\
    \    }\n    \n    return (nil, nil)", "    let least = lst.first { (val) -> Bool\
    \ in\n        return val > 0\n    }\n    let most = lst.first { (val) -> Bool\
    \ in\n        return val < 0\n    }\n    return (most, least)", "    var largest:\
    \ Int? = nil\n    var smallest: Int? = nil\n    for item in lst {\n        if\
    \ largest == nil && item < 0 {\n            largest = item\n        } else if\
    \ item < 0 && item > largest! {\n            largest = item\n        }\n     \
    \   if smallest == nil && item > 0 {\n            smallest = item\n        } else\
    \ if item > 0 && item < smallest! {\n            smallest = item\n        }\n\
    \    }\n    return (largest, smallest)", "    \n    var largest: Int?\n    var\
    \ smallest: Int?\n    \n    for number in lst {\n        if number < 0 {\n   \
    \         if largest == nil {\n                largest = number\n            }\
    \ else if number > largest! {\n                largest = number\n            }\n\
    \        } else if number > 0 {\n            if smallest == nil {\n          \
    \      smallest = number\n            } else if number < smallest! {\n       \
    \         smallest = number\n            }\n        }\n    }\n    \n    return\
    \ (largest, smallest)", "    // FIXME:\n    return (nil, nil)", "    let positive\
    \ = lst.filter { $0 > 0 }\n    let negative = lst.filter { $0 < 0 }\n    return\
    \ (negative.count > 0 ? negative.max() : nil, positive.count > 0 ? positive.min()\
    \ : nil)", "    if (lst.count == 0) {\n        return (nil, nil)\n    }\n    let\
    \ positives = lst.filter({$0 >= 0})\n    let negatives = lst.filter({$0 < 0})\n\
    \    if (positives.count == 0 || negatives.count == 0) {\n        return (nil,\
    \ nil)\n    }\n    return (negatives.max(), positives.min())", "    var result\
    \ = (nil, nil)\n    for e in lst {\n        if result.0 == nil && e < 0 {\n  \
    \          result.0 = e\n        }\n        if result.1 == nil && e > 0 {\n  \
    \          result.1 = e\n        }\n        if e < result.0! {\n            result.0\
    \ = e\n        }\n        if e > result.1! {\n            result.1 = e\n     \
    \   }\n    }\n    return result", "    let lst = lst.filter { (num) -> Bool in\n\
    \        num != 0\n    }\n    if lst.count == 0 {\n        return (nil, nil)\n\
    \    }\n    let max = lst.max()\n    let min = lst.min()\n    if max! > 0 && min!\
    \ < 0 {\n        return (max, min)\n    } else if max! > 0 && min! > 0 {\n   \
    \     return (nil, min)\n    } else if max! < 0 && min! < 0 {\n        return\
    \ (max, nil)\n    }\n    return (nil, nil)", "    var negative = Int.min\n   \
    \ var positive = Int.max\n    for int in lst {\n        if int > 0 {\n       \
    \     if int < positive {\n                positive = int\n            }\n   \
    \     } else if int < 0 {\n            if int > negative {\n                negative\
    \ = int\n            }\n        }\n    }\n    if negative != Int.min {\n     \
    \   if positive != Int.max {\n            return (negative, positive)\n      \
    \  } else {\n            return (negative, nil)\n        }\n    } else {\n   \
    \     if positive != Int.max {\n            return (nil, positive)\n        }\
    \ else {\n            return (nil, nil)\n        }\n    }", '    return (nil,
    nil)', '    return (nil, nil)', "    var largest_negative: Int? = nil\n    var\
    \ smallest_positive: Int? = nil\n    for n in lst {\n        if n < 0 {\n    \
    \        if largest_negative == nil {\n                largest_negative = n\n\
    \            } else if n > largest_negative! {\n                largest_negative\
    \ = n\n            }\n        } else if n > 0 {\n            if smallest_positive\
    \ == nil {\n                smallest_positive = n\n            } else if n < smallest_positive!\
    \ {\n                smallest_positive = n\n            }\n        }\n    }\n\
    \    return (largest_negative, smallest_positive)", "    let negativeLst = lst.filter({$0\
    \ < 0})\n    let positiveLst = lst.filter({$0 > 0})\n    if negativeLst.count\
    \ == 0 && positiveLst.count == 0 {\n        return (nil, nil)\n    } else if negativeLst.count\
    \ == 0 {\n        return (nil, positiveLst.min())\n    } else if positiveLst.count\
    \ == 0 {\n        return (negativeLst.max(), nil)\n    } else {\n        return\
    \ (negativeLst.max(), positiveLst.min())\n    }", "    var smallest: Int? = nil\n\
    \    var largest: Int? = nil\n    var is_positive = false\n    var is_negative\
    \ = false\n    for i in lst {\n        if i > 0 {\n            is_positive = true\n\
    \            if smallest == nil {\n                smallest = i\n            }\
    \ else if i < smallest! {\n                smallest = i\n            }\n     \
    \   } else if i < 0 {\n            is_negative = true\n            if largest\
    \ == nil {\n                largest = i\n            } else if i > largest! {\n\
    \                largest = i\n            }\n        }\n    }\n    return (is_negative\
    \ ? largest : nil, is_positive ? smallest : nil)", "    let negative_array = lst.filter({\
    \ n in n < 0 }).sorted(by: {$0 > $1})\n    let positive_array = lst.filter({ n\
    \ in n > 0 }).sorted(by: {$0 < $1})\n    let largest_negative = negative_array.first\n\
    \    let smallest_positive = positive_array.first\n    return (largest_negative,\
    \ smallest_positive)", "  // your code here\n    return (nil, nil)", '    return
    (nil, nil)', "    \n    let filtered_list = lst.filter {\n        $0 != 0\n  \
    \  }\n    \n    let sorted_list = filtered_list.sorted {\n        if $0 < 0 &&\
    \ $1 < 0 {\n            return $0 > $1\n        } else if $0 > 0 && $1 > 0 {\n\
    \            return $0 < $1\n        } else {\n            return $0 < $1\n  \
    \      }\n    }\n    \n    if sorted_list.count < 1 {\n        return (nil, nil)\n\
    \    } else if sorted_list.count == 1 {\n        if sorted_list[0] < 0 {\n   \
    \         return (sorted_list[0], nil)\n        } else {\n            return (nil,\
    \ sorted_list[0])\n        }\n    } else {\n        return (sorted_list[0], sorted_list[sorted_list.count\
    \ - 1])\n    }", "    var positive: Int? = nil\n    var negative: Int? = nil\n\
    \    for x in lst {\n        if x < 0 {\n            if negative == nil {\n  \
    \              negative = x\n            } else if x > negative! {\n         \
    \       negative = x\n            }\n        } else if x > 0 {\n            if\
    \ positive == nil {\n                positive = x\n            } else if x < positive!\
    \ {\n                positive = x\n            }\n        }\n    }\n    return\
    \ (negative, positive)", "    guard lst.count > 0 else {\n        return (nil,\
    \ nil)\n    }\n    let positive_numbers = lst.filter { $0 > 0 }\n    let negative_numbers\
    \ = lst.filter { $0 < 0 }\n    return (negative_numbers.max(), positive_numbers.min())",
  "    \n    var largestNegative: Int?\n    var smallestPostive: Int?\n    \n    for\
    \ num in lst {\n        // check for largest negative\n        if largestNegative\
    \ == nil && num < 0 {\n            largestNegative = num\n        } else if largestNegative\
    \ != nil && num < 0 && num > largestNegative! {\n            largestNegative =\
    \ num\n        }\n        \n        // check for smallest positive\n        if\
    \ smallestPostive == nil && num > 0 {\n            smallestPostive = num\n   \
    \     } else if smallestPostive != nil && num > 0 && num < smallestPostive! {\n\
    \            smallestPostive = num\n        }\n    }\n    \n    return (largestNegative,\
    \ smallestPostive)", "    let negatives = lst.filter({ $0 < 0 })\n    let positives\
    \ = lst.filter({ $0 > 0 })\n    let maxNegative = negatives.max()\n    let minPositive\
    \ = positives.min()\n    return (maxNegative, minPositive)", "    var largest:\
    \ Int? = nil\n    var smallest: Int? = nil\n    for i in lst {\n        if (i\
    \ > 0) {\n            if (smallest == nil) {\n                smallest = i\n \
    \           } else if (i < smallest!) {\n                smallest = i\n      \
    \      }\n        } else if (i < 0) {\n            if (largest == nil) {\n   \
    \             largest = i\n            } else if (i > largest!) {\n          \
    \      largest = i\n            }\n        }\n    }\n    return (largest, smallest)",
  "    var maxNegative = Int.min\n    var minPositive = Int.max\n    var isNegative\
    \ = false\n    var isPositive = false\n    for number in lst {\n        if number\
    \ < 0 {\n            isNegative = true\n            if number > maxNegative {\n\
    \                maxNegative = number\n            }\n        } else if number\
    \ > 0 {\n            isPositive = true\n            if number < minPositive {\n\
    \                minPositive = number\n            }\n        }\n    }\n    if\
    \ !isNegative {\n        maxNegative = nil\n    }\n    if !isPositive {\n    \
    \    minPositive = nil\n    }\n    return (maxNegative, minPositive)", "    var\
    \ smallest : Int? = nil\n    var largest : Int? = nil\n    for item in lst {\n\
    \        if item > 0 {\n            if smallest == nil {\n                smallest\
    \ = item\n            } else if item < smallest! {\n                smallest =\
    \ item\n            }\n        } else if item < 0 {\n            if largest ==\
    \ nil {\n                largest = item\n            } else if item > largest!\
    \ {\n                largest = item\n            }\n        }\n    }\n    return\
    \ (largest, smallest)", '    return (nil, nil)', "    \n    return (0, 0)", " \
    \   var min = lst.min()\n    var max = lst.max()\n    if min == 0 && max == 0\
    \ {\n        return (nil, nil)\n    }\n    if min == 0 && max != 0 {\n       \
    \ min = lst.filter { $0 > 0 }.min()\n    }\n    if max == 0 && min != 0 {\n  \
    \      max = lst.filter { $0 < 0 }.max()\n    }\n    return (max, min)", "   \
    \ let pos = lst.filter { $0 > 0 }.min()\n    let neg = lst.filter { $0 < 0 }.max()\n\
    \    return (neg, pos)", "    var min = lst.first\n    var max = lst.first\n \
    \   if lst.count < 1 {\n        return (nil, nil)\n    }\n    for (index, value)\
    \ in lst.enumerated() {\n        if value > 0 && (min == nil || value < min!)\
    \ {\n            min = value\n        }\n        if value < 0 && (max == nil ||\
    \ value > max!) {\n            max = value\n        }\n    }\n    return (max,\
    \ min)", '    return (nil, nil)', "    if lst.isEmpty {\n        return (nil,\
    \ nil)\n    }\n    var negative = Int.min\n    var positive = Int.max\n    for\
    \ n in lst {\n        if n < 0 {\n            negative = max(negative, n)\n  \
    \      } else if n > 0 {\n            positive = min(positive, n)\n        }\n\
    \    }\n    return (negative > Int.min ? negative : nil, positive < Int.max ?\
    \ positive : nil)", "    let n = lst.filter { $0 < 0 }.max()\n    let p = lst.filter\
    \ { $0 > 0 }.min()\n    return (n, p)", "    var s = [Int]()\n    var b = [Int]()\n\
    \    for x in lst {\n        if x > 0 {\n            s.append(x)\n        } else\
    \ if x < 0 {\n            b.append(x)\n        }\n    }\n    let result1 = s.min()\n\
    \    let result2 = b.max()\n    return (result2, result1)", "    var smallest\
    \ = Int.max\n    var largest = Int.min\n    var is_positive = false\n    var is_negative\
    \ = false\n    var i = 0\n    while i < lst.count {\n        if lst[i] < 0 {\n\
    \            is_negative = true\n            if lst[i] > largest {\n         \
    \       largest = lst[i]\n            }\n        } else if lst[i] > 0 {\n    \
    \        is_positive = true\n            if lst[i] < smallest {\n            \
    \    smallest = lst[i]\n            }\n        }\n        i += 1\n    }\n    if\
    \ is_negative {\n        return (largest, smallest)\n    } else if is_positive\
    \ {\n        return (nil, smallest)\n    } else {\n        return (nil, nil)\n\
    \    }", "    // TODO: Implement largest_smallest_integers function\n    return\
    \ (nil, nil)", '    return (lst.sorted(by: >).filter { $0 < 0 }.first, lst.sorted(by:
    <).filter { $0 > 0 }.first)', "    guard !lst.isEmpty else { return (nil, nil)\
    \ }\n    return (\n        lst.filter { $0 < 0 }.max(),\n        lst.filter {\
    \ $0 > 0 }.min()\n    )", "    // implement this function\n    return (nil, nil)",
  "    // Your code goes here\n    var max = 0, min = 0\n    var isFirstNegative =\
    \ true, isFirstPositive = true\n    for i in lst {\n        if i < 0 {\n     \
    \       isFirstNegative = false\n            if max < i {\n                max\
    \ = i\n            }\n        } else if i > 0 {\n            isFirstPositive =\
    \ false\n            if min > i {\n                min = i\n            }\n  \
    \      }\n    }\n    if isFirstNegative {\n        max = nil\n    }\n    if isFirstPositive\
    \ {\n        min = nil\n    }\n    return (max, min)", '    return (nil, nil)',
  "    if lst.isEmpty {\n        return (nil, nil)\n    }\n    let filteredLst = lst.filter\
    \ { $0 != 0 }\n    if filteredLst.isEmpty {\n        return (nil, nil)\n    }\n\
    \    let maxNeg = filteredLst.filter { $0 < 0 }.max()\n    let minPos = filteredLst.filter\
    \ { $0 > 0 }.min()\n    return (maxNeg, minPos)", "    // return (nil, nil)\n\
    \    if lst.isEmpty {\n        return (nil, nil)\n    }\n    var negs: [Int] =\
    \ []\n    var poss: [Int] = []\n    for i in lst {\n        if i < 0 {\n     \
    \       negs.append(i)\n        } else if i > 0 {\n            poss.append(i)\n\
    \        }\n    }\n    if negs.isEmpty {\n        if poss.isEmpty {\n        \
    \    return (nil, nil)\n        } else {\n            return (nil, poss.min())\n\
    \        }\n    } else {\n        if poss.isEmpty {\n            return (negs.max(),\
    \ nil)\n        } else {\n            return (negs.max(), poss.min())\n      \
    \  }\n    }", "    // Hint: The integers in the array are referred to as 'Int',\n\
    \    // (as opposed to Float or Double).\n    // Remember to use 'guard' to handle\
    \ the corner cases in which\n    // no negative and/or positive integers are available.\n\
    \    // Hint: You may want to initialize two variables to hold the\n    // largest\
    \ negative and smallest positive integers.\n    // Then, loop through each item\
    \ in the array and\n    // update the variables if applicable.\n    // Finally,\
    \ return a tuple containing the variables.\n    var largest_negative_int: Int?\
    \ = nil\n    var smallest_positive_int: Int? = nil\n    for item in lst {\n  \
    \      if item < 0 {\n            largest_negative_int = item\n        }\n   \
    \     if item > 0 {\n            smallest_positive_int = item\n        }\n   \
    \ }\n    return (largest_negative_int, smallest_positive_int)", "    var largest\
    \ = Int.min\n    var smallest = Int.max\n    for num in lst {\n        if num\
    \ > 0 {\n            if num < smallest {\n                smallest = num\n   \
    \         }\n        } else if num < 0 {\n            if num > largest {\n   \
    \             largest = num\n            }\n        }\n    }\n    if largest ==\
    \ Int.min {\n        largest = nil\n    }\n    if smallest == Int.max {\n    \
    \    smallest = nil\n    }\n    return (largest, smallest)", "    var minNumber\
    \ = lst.min()\n    var maxNumber = lst.max()\n    for i in lst {\n        if i\
    \ < 0 && i > minNumber! {\n            minNumber = i\n        }\n        if i\
    \ > 0 && i < maxNumber! {\n            maxNumber = i\n        }\n    }\n    return\
    \ (minNumber, maxNumber)", '    fatalError("Not implemented")', "    if lst.isEmpty\
    \ {\n        return (nil, nil)\n    }\n    let positives = lst.filter { $0 > 0\
    \ }\n    let negatives = lst.filter { $0 < 0 }\n    if positives.isEmpty {\n \
    \       return (negatives.max(), nil)\n    }\n    if negatives.isEmpty {\n   \
    \     return (nil, positives.min())\n    }\n    return (negatives.max(), positives.min())",
  "    var a: Int? = nil\n    var b: Int? = nil\n    if lst.isEmpty {\n        return\
    \ (a, b)\n    }\n    for i in lst {\n        if i < 0 {\n            if a == nil\
    \ {\n                a = i\n            } else if i > a! {\n                a\
    \ = i\n            }\n        } else if i > 0 {\n            if b == nil {\n \
    \               b = i\n            } else if i < b! {\n                b = i\n\
    \            }\n        }\n    }\n    return (a, b)", '    fatalError("Unimplemented")',
  "    // Write your code here\n    \n    var min = Int.max\n    var max = Int.min\n\
    \    \n    for n in lst {\n        if n < 0 {\n            if n > max {\n    \
    \            max = n\n            }\n        } else {\n            if n < min\
    \ {\n                min = n\n            }\n        }\n    }\n    \n    return\
    \ (min == Int.max ? nil : min, max == Int.min ? nil : max)", "    // TODO: Implement\
    \ this function\n    // example:\n    // return (10, -10)\n    var max: Int?\n\
    \    var min: Int?\n    if lst.count == 0 {\n        return (nil, nil)\n    }\n\
    \    for i in lst {\n        if i >= 0 {\n            if min == nil {\n      \
    \          min = i\n            } else if i < min! {\n                min = i\n\
    \            }\n        } else {\n            if max == nil {\n              \
    \  max = i\n            } else if i > max! {\n                max = i\n      \
    \      }\n        }\n    }\n    return (max, min)", "    \n    var neg: Int? =\
    \ nil\n    var pos: Int? = nil\n    \n    for i in lst {\n        if i < 0 {\n\
    \            if neg == nil {\n                neg = i\n            } else if i\
    \ > neg! {\n                neg = i\n            }\n        } else if i > 0 {\n\
    \            if pos == nil {\n                pos = i\n            } else if i\
    \ < pos! {\n                pos = i\n            }\n        }\n    }\n    \n \
    \   return (neg, pos)", '    return (nil, nil)', "    let (a, b) = lst.reduce((Int.min,\
    \ Int.max)) {\n        ($0.0 >= $1 ? $0.0 : nil, $0.1 <= $1 ? $0.1 : nil)\n  \
    \  }\n    return (a > 0 ? nil : a, b < 0 ? nil : b)", "    var min = lst.min()\n\
    \    var max = lst.max()\n    if min == 0 {\n        min = nil\n    }\n    if\
    \ max == 0 {\n        max = nil\n    }\n    return (max, min)", "    let positive_numbers\
    \ = lst.filter({ $0 > 0 })\n    let negative_numbers = lst.filter({ $0 < 0 })\n\
    \    if positive_numbers.count == 0 {\n        return (nil, nil)\n    }\n    let\
    \ max_negative = negative_numbers.count == 0 ? nil : negative_numbers.max()\n\
    \    let min_positive = positive_numbers.min()\n    return (max_negative, min_positive)",
  "    var positive: Int? = nil\n    var negative: Int? = nil\n    for i in lst {\n\
    \        if i < 0 {\n            if negative == nil {\n                negative\
    \ = i\n            } else if i > negative! {\n                negative = i\n \
    \           }\n        } else if i > 0 {\n            if positive == nil {\n \
    \               positive = i\n            } else if i < positive! {\n        \
    \        positive = i\n            }\n        }\n    }\n    return (negative,\
    \ positive)", '    fatalError("function is not implemented yet")', "  var smallest_pos_int:\
    \ Int? = nil\n  var largest_neg_int: Int? = nil\n  for i in lst {\n    if i >\
    \ 0 {\n      if let tmp = smallest_pos_int {\n        if i < tmp {\n         \
    \ smallest_pos_int = i\n        }\n      } else {\n        smallest_pos_int =\
    \ i\n      }\n    } else if i < 0 {\n      if let tmp = largest_neg_int {\n  \
    \      if i > tmp {\n          largest_neg_int = i\n        }\n      } else {\n\
    \        largest_neg_int = i\n      }\n    }\n  }\n  return (largest_neg_int,\
    \ smallest_pos_int)", '    return (nil, nil)', "    // write your code here\n\
    \    var tuple: (Int?, Int?) = (nil, nil)\n    if lst.count == 0 {\n        return\
    \ tuple\n    }\n    let negative = lst.filter({$0 < 0})\n    let positive = lst.filter({$0\
    \ > 0})\n    if !negative.isEmpty {\n        tuple.0 = negative.sorted(by: >)[0]\n\
    \    }\n    if !positive.isEmpty {\n        tuple.1 = positive.sorted(by: <)[0]\n\
    \    }\n    return tuple", "    \n    if lst.count == 0 {\n        return (nil,\
    \ nil)\n    }\n    \n    var max: Int?\n    var min: Int?\n    \n    for i in\
    \ lst {\n        if i > 0 {\n            if min == nil {\n                min\
    \ = i\n            } else if i < min! {\n                min = i\n           \
    \ }\n        } else if i < 0 {\n            if max == nil {\n                max\
    \ = i\n            } else if i > max! {\n                max = i\n           \
    \ }\n        }\n    }\n    \n    return (max, min)", "    if lst.isEmpty {\n \
    \       return (nil, nil)\n    }\n    return (lst.filter{$0 < 0}.max(), lst.filter{$0\
    \ > 0}.min())", "    let lst = lst.filter { $0 != 0 }\n    guard !lst.isEmpty\
    \ else { return (nil, nil) }\n    let result = lst.map { (maxNegative: lst.filter\
    \ { $0 < 0 }.max(), minPositive: lst.filter { $0 > 0 }.min()) }\n    return result.first!",
  "    // TODO: implement this function\n    return (nil, nil)", '    return (nil,
    nil)', "    \n    if lst.count == 0 {\n        return (nil, nil)\n    }\n    \n\
    \    if lst.allSatisfy({$0 == 0}) {\n        return (nil, nil)\n    }\n    \n\
    \    if lst.contains(where: {$0 > 0}) && lst.contains(where: {$0 < 0}) {\n   \
    \     let positives = lst.filter({$0 > 0})\n        let negatives = lst.filter({$0\
    \ < 0})\n        return (negatives.max(), positives.min())\n    }\n    \n    if\
    \ lst.contains(where: {$0 > 0}) {\n        let positives = lst.filter({$0 > 0})\n\
    \        return (nil, positives.min())\n    }\n    \n    if lst.contains(where:\
    \ {$0 < 0}) {\n        let negatives = lst.filter({$0 < 0})\n        return (negatives.max(),\
    \ nil)\n    }\n    \n    return (nil, nil)", "    \n    let filteredList = lst.filter({\
    \ (num) -> Bool in\n        return num < 0 || num > 0\n    })\n    \n    let largest\
    \ = filteredList.max()\n    let smallest = filteredList.min()\n    \n    return\
    \ (largest, smallest)", "    \n    let negative: [Int] = lst.filter { $0 < 0 }\n\
    \    let positive: [Int] = lst.filter { $0 > 0 }\n    \n    if negative.count\
    \ == 0 && positive.count == 0 {\n        return (nil, nil)\n    }\n    \n    let\
    \ largestNegative: Int? = negative.count > 0 ? negative.max() : nil\n    let smallestPositive:\
    \ Int? = positive.count > 0 ? positive.min() : nil\n    \n    return (largestNegative,\
    \ smallestPositive)", "    var max, min: Int?\n    for i in lst {\n        if\
    \ i < 0 && (max == nil || i > max!) {\n            max = i\n        } else if\
    \ i > 0 && (min == nil || i < min!) {\n            min = i\n        }\n    }\n\
    \    return (max, min)", "    guard !lst.isEmpty else { return (nil, nil) }\n\
    \    var pos = Int.max\n    var neg = Int.min\n    for elem in lst {\n       \
    \ if elem < 0 {\n            if elem > neg {\n                neg = elem\n   \
    \         }\n        } else if elem < pos {\n            pos = elem\n        }\n\
    \    }\n    return (neg, pos)", "    var largestNeg = Int.min\n    var smallestPos\
    \ = Int.max\n    for num in lst {\n        if num > 0 && num < smallestPos {\n\
    \            smallestPos = num\n        } else if num < 0 && num > largestNeg\
    \ {\n            largestNeg = num\n        }\n    }\n    if largestNeg == Int.min\
    \ {\n        largestNeg = nil\n    }\n    if smallestPos == Int.max {\n      \
    \  smallestPos = nil\n    }\n    return (largestNeg, smallestPos)", "    // YOUR\
    \ CODE HERE\n    var min = 0\n    var max = 0\n    if lst.isEmpty{\n        return\
    \ (nil, nil)\n    }\n    else{\n        for item in lst{\n            if item\
    \ > 0{\n                if item < min{\n                    min = item\n     \
    \           }\n            }\n            else{\n                if item > max{\n\
    \                    max = item\n                }\n            }\n        }\n\
    \        if max == 0{\n            return (nil, min)\n        }\n        else\
    \ if min == 0{\n            return (max, nil)\n        }\n        else{\n    \
    \        return (max, min)\n        }\n    }", "    var largest_neg: Int? = nil\n\
    \    var smallest_pos: Int? = nil\n    for int in lst {\n        if int < 0 {\n\
    \            if largest_neg == nil {\n                largest_neg = int\n    \
    \        } else if int > largest_neg! {\n                largest_neg = int\n \
    \           }\n        } else if int > 0 {\n            if smallest_pos == nil\
    \ {\n                smallest_pos = int\n            } else if int < smallest_pos!\
    \ {\n                smallest_pos = int\n            }\n        }\n    }\n   \
    \ return (largest_neg, smallest_pos)", '    return (nil, nil)', "    var largest\
    \ = nil as Int?\n    var smallest = nil as Int?\n    for i in lst {\n        if\
    \ i > 0 {\n            if smallest == nil {\n                smallest = i\n  \
    \          } else if i < smallest! {\n                smallest = i\n         \
    \   }\n        } else if i < 0 {\n            if largest == nil {\n          \
    \      largest = i\n            } else if i > largest! {\n                largest\
    \ = i\n            }\n        }\n    }\n    return (largest, smallest)", "   \
    \ var smallest = Int.max\n    var largest = Int.min\n    for i in lst {\n    \
    \    if i > 0 && i < smallest {\n            smallest = i\n        }\n       \
    \ if i < 0 && i > largest {\n            largest = i\n        }\n    }\n    if\
    \ smallest == Int.max {\n        smallest = nil\n    }\n    if largest == Int.min\
    \ {\n        largest = nil\n    }\n    return (largest, smallest)", "    // Your\
    \ code here\n    return (nil, nil)"]
stop_tokens:
- "\n}"
