name: HumanEval_120_maximum
language: swift
prompt: "\n/// Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n/// of length k with the maximum k numbers in arr.\n/// Example 1:\n///\
  \ >>> maximum(arr: [-3, -4, 5], k: 3)\n/// [-4, -3, 5]\n/// Example 2:\n/// >>>\
  \ maximum(arr: [4, -4, 4], k: 2)\n/// [4, 4]\n/// Example 3:\n/// >>> maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1)\n/// [2]\n/// Note:\n/// 1. The length of the\
  \ array will be in the range of [1, 1000].\n/// 2. The elements in the array will\
  \ be in the range of [-1000, 1000].\n/// 3. 0 <= k <= len(arr)\nfunc maximum(arr:\
  \ [Int], k: Int) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(maximum(arr: [-3, -4, 5], k: 3) == [-4,\
  \ -3, 5])\nassert(maximum(arr: [4, -4, 4], k: 2) == [4, 4])\nassert(maximum(arr:\
  \ [-3, 2, 1, 2, -1, -2, 1], k: 1) == [2])\nassert(maximum(arr: [123, -123, 20, 0,\
  \ 1, 2, -3], k: 3) == [2, 20, 123])\nassert(maximum(arr: [-123, 20, 0, 1, 2, -3],\
  \ k: 4) == [0, 1, 2, 20])\nassert(maximum(arr: [5, 15, 0, 3, -13, -8, 0], k: 7)\
  \ == [-13, -8, 0, 0, 3, 5, 15])\nassert(maximum(arr: [-1, 0, 2, 5, 3, -10], k: 2)\
  \ == [3, 5])\nassert(maximum(arr: [1, 0, 5, -7], k: 1) == [5])\nassert(maximum(arr:\
  \ [4, -4], k: 2) == [-4, 4])\nassert(maximum(arr: [-10, 10], k: 2) == [-10, 10])\n\
  assert(maximum(arr: [1, 2, 3, -23, 243, -400, 0], k: 0) == [] as [Int])"
completions: ["    var copy = arr\n    copy.sort(by: >)\n    return Array(copy[0..<k])",
  "    var result = [Int]()\n    guard arr.count >= k else { return result }\n   \
    \ var window = [Int]()\n    // keep k values in window, discard smaller values\
    \ than the last window value\n    for i in 0..<arr.count {\n        while !window.isEmpty\
    \ && window.count + arr.count - i > k && arr[i] > window.last! {\n           \
    \ window.removeLast()\n        }\n        window.append(arr[i])\n    }\n    return\
    \ window", "    // We will use an index set to track the indices of elements in\
    \ the array.\n    // The index set will be sorted.\n    var indices = IndexSet()\n\
    \    // We will use a set to keep track of the maximum k elements in the array.\n\
    \    var maxValues = Set<Int>()\n    // Next we will store our sorted elements\
    \ in the array.\n    var sortedElements = [Int]()\n    // Loop through the elements\
    \ in the array.\n    for element in arr {\n        // Check if the index set is\
    \ empty.\n        if indices.isEmpty {\n            // Add the index of the element\
    \ to the index set.\n            indices.insert(element)\n            // Add the\
    \ element to the set.\n            maxValues.insert(element)\n        } else {\n\
    \            // Check if the element is less than the maximum element in the index\
    \ set.\n            if element < indices.max()! {\n                // Check if\
    \ the index set is greater than or equal to k.\n                if indices.count\
    \ >= k {\n                    // Remove the maximum index from the index set.\n\
    \                    indices.remove(indices.max()!)\n                    // Remove\
    \ the maximum element from the set.\n                    maxValues.remove(maxValues.max()!)\n\
    \                }\n                // Add the index of the element to the index\
    \ set.\n                indices.insert(element)\n                // Add the element\
    \ to the set.\n                maxValues.insert(element)\n            }\n    \
    \    }\n    }\n    // Loop through the set.\n    for element in maxValues {\n\
    \        // Append the element to the sorted elements array.\n        sortedElements.append(element)\n\
    \    }\n    // Return the sorted elements.\n    return sortedElements", "    if\
    \ arr.count == 0 { return arr }\n    var arr = arr\n    var sortedArr = [Int]()\n\
    \    var i = 0\n    while sortedArr.count < k {\n        var max = arr[i]\n  \
    \      var j = i\n        while j < arr.count {\n            if arr[j] > max {\n\
    \                max = arr[j]\n                i = j\n            }\n        \
    \    j += 1\n        }\n        sortedArr.append(max)\n        arr.remove(at:\
    \ i)\n    }\n    return sortedArr", "    var maxNums = [Int]()\n    var heap =\
    \ MinHeap<Int>()\n    if arr.count < k {\n        return maxNums\n    }\n    //\
    \ first loop to fill up the heap\n    for num in arr {\n        heap.insert(element:\
    \ num)\n        if heap.size > k {\n            heap.deleteMin()\n        }\n\
    \    }\n    // second loop to get the max k numbers\n    for _ in 1...k {\n  \
    \      maxNums.append(heap.deleteMin())\n    }\n    return maxNums", "    var\
    \ maximums = [Int]()\n    for i in 0..<k {\n        maximums.append(arr[i])\n\
    \    }\n    maximums.sort()\n    for i in k..<arr.count {\n        if arr[i] >\
    \ maximums[0] {\n            maximums[0] = arr[i]\n            maximums.sort()\n\
    \        }\n    }\n    return maximums", '    return []', "    if arr.count ==\
    \ 0 { return [] }\n    var ans = [Int]()\n    var result = [Int]()\n    for i\
    \ in 0..<arr.count {\n        if i < k {\n            ans.append(arr[i])\n   \
    \     } else {\n            for j in 0..<k {\n                if ans[j] < arr[i]\
    \ {\n                    ans.insert(arr[i], at: j)\n                    ans.removeLast()\n\
    \                    break\n                }\n            }\n        }\n    }\n\
    \    var start = 0\n    while start < k {\n        result.append(ans[start])\n\
    \        start += 1\n    }\n    return result", "    var result = [Int]()\n  \
    \  var numberOfElementsToRemove = arr.count - k\n    for index in 0..<arr.count\
    \ {\n        var maxIndex = index\n        for j in index+1..<arr.count {\n  \
    \          if arr[j] > arr[maxIndex] {\n                maxIndex = j\n       \
    \     }\n        }\n        if maxIndex != index {\n            swap(&arr[index],\
    \ &arr[maxIndex])\n        }\n        if numberOfElementsToRemove > 0 {\n    \
    \        numberOfElementsToRemove -= 1\n        } else {\n            result.append(arr[index])\n\
    \        }\n    }\n    return result", "    // This is a good practice: use `guard`\
    \ to handle special cases.\n    guard arr.count >= k else { return arr }\n   \
    \ // The `heap` is created with default size of 16 and max element number is set\
    \ to `k`.\n    // Please note that the `maxElementCount` is the max number of\
    \ elements allowed in the heap.\n    // It doesn't mean that the size of the heap\
    \ is fixed with the `maxElementCount`.\n    // `DPriorityQueue` has its own size\
    \ auto-extension mechanism and it will auto extend the size\n    // as needed.\n\
    \    let heap = DPriorityQueue<Int>(maxElementCount: k)\n    // Fill the `heap`\
    \ with elements in `arr`.\n    // This will take O(nlogk) since the max element\
    \ number of the heap is k.\n    for i in 0..<arr.count {\n        heap.enqueue(arr[i])\n\
    \    }\n    // Pop all the elements from the heap.\n    // This will take O(klogk)\
    \ since k elements are popped from the heap.\n    return (0..<k).map { _ in heap.dequeue()!\
    \ }", "    var result = [Int]()\n    let heap = Heap<Int>(sort: >)\n    for num\
    \ in arr {\n        heap.insert(num)\n        if heap.count > k {\n          \
    \  heap.remove()\n        }\n    }\n    while !heap.isEmpty {\n        result.append(heap.remove()!)\n\
    \    }\n    return result", "    var result = [Int]()\n    var stack = [Int]()\n\
    \    for i in 0..<arr.count {\n        while !stack.isEmpty && stack.count + arr.count\
    \ - i > k && arr[i] > stack.last! {\n            stack.removeLast()\n        }\n\
    \        if stack.count < k {\n            stack.append(arr[i])\n        }\n \
    \   }\n    return stack", "    var result = [Int]()\n    for i in 0..<k {\n  \
    \      var maxNum = Int.min\n        var maxIndex = 0\n        for j in i..<arr.count\
    \ {\n            if arr[j] > maxNum {\n                maxNum = arr[j]\n     \
    \           maxIndex = j\n            }\n        }\n        result.append(maxNum)\n\
    \        swap(&arr[i], &arr[maxIndex])\n    }\n    return result", '    return
    []', "    guard arr.count > 0 else { return [] }\n    guard arr.count > k else\
    \ { return arr }\n    var result = Array(repeating: Int.min, count: k)\n    for\
    \ i in 0..<arr.count {\n        if arr[i] > result[0] {\n            result[0]\
    \ = arr[i]\n            result.sort()\n        }\n    }\n    return result", '    return
    []', "    var result = [Int]()\n    var array = arr\n    while k > 0 {\n     \
    \   var maximum = -1001\n        var indexOfMaximum = -1\n        for i in 0..<array.count\
    \ {\n            if array[i] > maximum {\n                maximum = array[i]\n\
    \                indexOfMaximum = i\n            }\n        }\n        result.append(maximum)\n\
    \        array.remove(at: indexOfMaximum)\n        k -= 1\n    }\n    return result",
  "    var result = [Int]()\n    for i in 0..<k {\n        var index = i\n       \
    \ for j in i+1..<arr.count {\n            if arr[j] > arr[index] {\n         \
    \       index = j\n            }\n        }\n        result.append(arr[index])\n\
    \        let tmp = arr[i]\n        arr[i] = arr[index]\n        arr[index] = tmp\n\
    \    }\n    return result", "    if arr.count == 0 { return [] }\n    if arr.count\
    \ == 1 { return arr }\n    if k == 1 { return [arr.max()!] }\n    var newArr =\
    \ arr\n    for i in 0 ..< k {\n        for j in 0 ..< newArr.count - 1 {\n   \
    \         if newArr[j] > newArr[j + 1] {\n                newArr.swapAt(j, j +\
    \ 1)\n            }\n        }\n    }\n    return newArr[newArr.count - k ..<\
    \ newArr.count]", "    let n = arr.count\n    if n == 0 { return [] }\n    guard\
    \ k < n else { return arr }\n    var left = 0, right = n - 1\n    while left <=\
    \ right {\n        let partition = quickSort(&arr, left: left, right: right)\n\
    \        if partition == k - 1 {\n            return Array(arr[0..<k])\n     \
    \   } else if partition < k - 1 {\n            left = partition + 1\n        }\
    \ else {\n            right = partition - 1\n        }\n    }\n    return []",
  "    var output = [Int]()\n    let heap = Heap<Int>(type: .max)\n    for i in 0..<arr.count\
    \ {\n        if i < k {\n            heap.insert(arr[i])\n        } else {\n \
    \           if arr[i] > heap.peek()! {\n                heap.remove()\n      \
    \          heap.insert(arr[i])\n            }\n        }\n    }\n    while heap.peek()\
    \ != nil {\n        output.append(heap.remove()!)\n    }\n    return output",
  "    guard k <= arr.count else {\n        return arr\n    }\n    var mutableArr\
    \ = arr\n    var temp = 0\n    for i in 0..<k {\n        for j in i..<mutableArr.count\
    \ {\n            if mutableArr[j] > mutableArr[i] {\n                temp = mutableArr[i]\n\
    \                mutableArr[i] = mutableArr[j]\n                mutableArr[j]\
    \ = temp\n            }\n        }\n    }\n    var newArr = [Int]()\n    for i\
    \ in 0..<k {\n        newArr.append(mutableArr[i])\n    }\n    return newArr",
  "    var result = [Int]()\n    for i in 0..<k {\n        result.append(arr[i])\n\
    \    }\n    result.sort()\n    for i in k..<arr.count {\n        for j in 0..<k\
    \ {\n            if arr[i] > result[j] {\n                for l in (j..<k).reversed()\
    \ {\n                    result[l] = result[l - 1]\n                }\n      \
    \          result[j] = arr[i]\n                break\n            }\n        }\n\
    \    }\n    return result", "    guard arr.count > 0 else { return [] }\n    guard\
    \ arr.count > k else { return arr }\n    guard k > 0 else { return [] }\n    var\
    \ arr = arr\n    var left = 0\n    var right = arr.count - 1\n    while left <\
    \ right {\n        let pivotIndex = partition(&arr, left: left, right: right)\n\
    \        if pivotIndex == k - 1 {\n            break\n        } else if pivotIndex\
    \ < k - 1 {\n            left = pivotIndex + 1\n        } else {\n           \
    \ right = pivotIndex - 1\n        }\n    }\n    return Array(arr[0..<k])", '    return
    arr.heapSort(by: >)[0..<k]', "    guard arr.count > k else { return arr }\n  \
    \  var maxIndices = [Int]()\n    var minIndices = [Int]()\n    for i in 0..<k\
    \ {\n        maxIndices.append(i)\n        minIndices.append(arr.count - i - 1)\n\
    \    }\n    for i in k..<arr.count {\n        for j in 0..<k {\n            if\
    \ arr[i] > arr[maxIndices[j]] {\n                maxIndices[j] = i\n         \
    \       break\n            }\n        }\n        for j in 0..<k {\n          \
    \  if arr[i] < arr[minIndices[j]] {\n                minIndices[j] = i\n     \
    \           break\n            }\n        }\n    }\n    var maxNumbers = [Int]()\n\
    \    for i in 0..<k {\n        maxNumbers.append(arr[maxIndices[i]])\n    }\n\
    \    maxNumbers.sort()\n    var minNumbers = [Int]()\n    for i in 0..<k {\n \
    \       minNumbers.append(arr[minIndices[i]])\n    }\n    minNumbers.sort()\n\
    \    var res = [Int]()\n    var isLarger = true\n    while res.count < k {\n \
    \       if isLarger {\n            res.append(maxNumbers.removeLast())\n     \
    \   } else {\n            res.append(minNumbers.removeLast())\n        }\n   \
    \     isLarger = !isLarger\n    }\n    return res", "    var result = [Int]()\n\
    \    var res = [Int]()\n    var temp = [Int]()\n    var j = 1\n    result.append(arr[0])\n\
    \    while j < arr.count {\n        if arr[j] >= result[result.count - 1] {\n\
    \            result.append(arr[j])\n        } else {\n            result.append(result[result.count\
    \ - 1])\n        }\n        j += 1\n    }\n    for i in stride(from: arr.count\
    \ - 1, through: 0, by: -1) {\n        if i < k {\n            res.append(arr[i])\n\
    \        } else {\n            if result[i] != result[i - 1] {\n             \
    \   res.append(result[i - 1])\n            } else {\n                temp.append(arr[i])\n\
    \            }\n        }\n    }\n    res.append(contentsOf: temp)\n    return\
    \ res", "    // This is a very inefficient method.\n    // The array will be sorted\
    \ and then sliced.\n    // The solution has a runtime of O(n log n) and a space\
    \ complexity of O(n).\n    return arr.sorted(by: >).prefix(k).sorted()", "   \
    \ guard k <= arr.count else { return [] }\n    guard k != arr.count else { return\
    \ arr }\n    let heap = Heap(array: arr, sort: >)\n    var result = [Int]()\n\
    \    while result.count < k {\n        guard let max = heap.pop() else { break\
    \ }\n        result.append(max)\n    }\n    return result", "    var result =\
    \ [Int]()\n    let sortedArr = arr.sorted()\n    for i in 0..<k {\n        result.append(sortedArr[sortedArr.count\
    \ - i - 1])\n    }\n    return result", "    // \u91C7\u7528\u5FEB\u901F\u6392\
    \u5E8F\u7684\u601D\u60F3\uFF0C\u83B7\u53D6\u524Dk\u4E2A\u6700\u5927\u503C\n  \
    \  if arr.count == 0 || k <= 0 {\n        return []\n    }\n    var array = arr\n\
    \    array.partition(start: 0, end: array.count - 1, k: k)\n    return Array(array[0..<k])",
  "    let length = arr.count\n    guard length >= k else { return arr }\n    var\
    \ current = [Int]()\n    var result = [Int]()\n    var start = 0\n    for i in\
    \ 0..<length {\n        let num = arr[i]\n        let idx = binarySearch(list:\
    \ current, item: num)\n        if idx < k - 1 {\n            current.insert(num,\
    \ at: idx)\n        }\n        if current.count == k {\n            start = length\
    \ - k\n            break\n        }\n    }\n    while start < length {\n     \
    \   result.append(arr[start])\n        start += 1\n    }\n    return result",
  "    var result = [Int]()\n    guard arr.count >= k else { return result }\n   \
    \ let q = PriorityQueue<Int>(orderedBy: { $0 < $1 })\n    for num in arr {\n \
    \       q.enqueue(num)\n        if q.count > k {\n            q.dequeue()\n  \
    \      }\n    }\n    while !q.isEmpty {\n        result.append(q.dequeue()!)\n\
    \    }\n    return result", "    // O(n log n) solution\n    if arr.count == 0\
    \ { return [] }\n    if arr.count == 1 { return arr }\n    if k >= arr.count {\
    \ return arr.sorted() }\n    if k == 1 { return [arr.max()!] }\n    var result\
    \ = [Int]()\n    var sorted = arr.sorted()\n    var i = 0\n    while i < k {\n\
    \        result.append(sorted[sorted.count - 1 - i])\n        i += 1\n    }\n\
    \    return result", "    let n = arr.count\n    if n == 0 { return [] }\n   \
    \ if k == 0 { return [] }\n    if k == n { return arr }\n    var result = [Int]()\n\
    \    for _ in 0..<k {\n        let max = arr.max()!\n        result.append(max)\n\
    \        let index = arr.firstIndex(of: max)!\n        let prefix = Array(arr[0..<index])\n\
    \        let suffix = Array(arr[index+1..<n])\n        arr = prefix + suffix\n\
    \    }\n    return result", '    return []', "    guard k <= arr.count else {\
    \ return arr }\n    var res = Array(arr[0..<k])\n    res.sort()\n    for i in\
    \ k..<arr.count {\n        var j = k - 1\n        while j >= 0 {\n           \
    \ if arr[i] > res[j] {\n                res.insert(arr[i], at: j)\n          \
    \      res.removeLast()\n                break\n            }\n            j -=\
    \ 1\n        }\n    }\n    return res", "    var result = [Int]()\n    if k ==\
    \ 0 {\n        return result\n    }\n    var heap = MinHeap<Int>()\n    for i\
    \ in 0..<arr.count {\n        if heap.size() < k {\n            heap.insert(value:\
    \ arr[i])\n        } else if heap.peek() < arr[i] {\n            heap.removeRoot()\n\
    \            heap.insert(value: arr[i])\n        }\n    }\n    while !heap.isEmpty()\
    \ {\n        result.append(heap.removeRoot())\n    }\n    return result", "  \
    \  // return solution1(arr: arr, k: k)\n    return solution2(arr: arr, k: k)",
  "    var result = [Int]()\n    var stack = [Int]()\n    for i in 0..<arr.count {\n\
    \        if stack.count == 0 {\n            stack.append(arr[i])\n        } else\
    \ {\n            if stack.count == k {\n                if arr[i] > stack[stack.count\
    \ - 1] {\n                    while stack.count > 0 && arr[i] > stack[stack.count\
    \ - 1] {\n                        stack.removeLast()\n                    }\n\
    \                    stack.append(arr[i])\n                }\n            } else\
    \ {\n                if arr[i] > stack[stack.count - 1] {\n                  \
    \  stack.append(arr[i])\n                } else {\n                    var j =\
    \ 0\n                    while j < stack.count && arr[i] < stack[j] {\n      \
    \                  j += 1\n                    }\n                    stack.insert(arr[i],\
    \ at: j)\n                }\n            }\n        }\n    }\n    for i in 0..<stack.count\
    \ {\n        result.append(stack[i])\n    }\n    return result", "    var maxHeap\
    \ = MaxHeap(arr)\n    var kElements = [Int]()\n    while k > 0 {\n        kElements.append(maxHeap.pop()!)\n\
    \        k -= 1\n    }\n    return kElements", "    // Build a minHeap and pop\
    \ the elements not needed.\n    let minHeap = Heap<Int>(sort: <)\n    for item\
    \ in arr {\n        minHeap.insert(item)\n        if minHeap.count > k {\n   \
    \         minHeap.remove()\n        }\n    }\n    return minHeap.nodes", "   \
    \ var answer = [Int]()\n    var newArr = arr\n    for _ in 0..<k {\n        let\
    \ max = newArr.max()!\n        answer.append(max)\n        newArr.remove(at: newArr.firstIndex(of:\
    \ max)!)\n    }\n    return answer", "    var result = [Int]()\n    var arr =\
    \ arr\n    var k = k\n    while k > 0 {\n        var max = arr[0]\n        var\
    \ maxIndex = 0\n        for i in 1..<arr.count {\n            if arr[i] > max\
    \ {\n                max = arr[i]\n                maxIndex = i\n            }\n\
    \        }\n        result.append(max)\n        arr.remove(at: maxIndex)\n   \
    \     k -= 1\n    }\n    return result", "    guard arr.count > 0 else { return\
    \ arr }\n    guard arr.count > k else { return arr }\n    let maxStack = Stack<Int>()\n\
    \    var i = 0\n    while i < arr.count {\n        let num = arr[i]\n        if\
    \ maxStack.count < k {\n            maxStack.push(num)\n        } else {\n   \
    \         if let top = maxStack.peek(), top < num {\n                maxStack.pop()\n\
    \                maxStack.push(num)\n            }\n        }\n        i += 1\n\
    \    }\n    var result = [Int]()\n    while !maxStack.isEmpty {\n        if let\
    \ num = maxStack.pop() {\n            result.append(num)\n        }\n    }\n \
    \   return result.reversed()", "    var max = [Int]()\n    for i in 0..<k {\n\
    \        var index = 0\n        var maximum = Int.min\n        for j in i..<arr.count\
    \ {\n            if arr[j] > maximum {\n                maximum = arr[j]\n   \
    \             index = j\n            }\n        }\n        max.append(maximum)\n\
    \        arr.swapAt(i, index)\n    }\n    return max", "    // invalid input\n\
    \    guard arr.count > 0, k > 0 else { return [] }\n    // create a min heap\n\
    \    var heap = Heap<Int>(sort: { $0 < $1 })\n    // iterate the array and insert\
    \ elements into heap\n    for element in arr {\n        heap.insert(element)\n\
    \        // remove elements that are smaller than the peek element\n        while\
    \ heap.count > k {\n            heap.remove()\n        }\n    }\n    // return\
    \ the heap in sorted order\n    return heap.sorted()", "    var result = [Int]()\n\
    \    var arr = arr\n    for _ in 0..<k {\n        guard let max = arr.max() else\
    \ { return result }\n        arr.remove(at: arr.firstIndex(of: max)!)\n      \
    \  result.append(max)\n    }\n    return result", "    var arr = arr\n    var\
    \ start = 0\n    var end = arr.count - 1\n    while start < end {\n        let\
    \ pivot = partition(&arr, start: start, end: end)\n        if pivot < k {\n  \
    \          start = pivot + 1\n        } else if pivot > k {\n            end =\
    \ pivot - 1\n        } else {\n            break\n        }\n    }\n    return\
    \ Array(arr[0..<k])", "    if arr.count == 0 { return [] }\n    var result = arr\n\
    \    var i = 0\n    while i < k {\n        var index = i\n        var j = i\n\
    \        while j < result.count {\n            if result[j] > result[index] {\n\
    \                index = j\n            }\n            j += 1\n        }\n   \
    \     result.swapAt(i, index)\n        i += 1\n    }\n    return Array(result[0..<k])",
  "    let len = arr.count\n    var result = [Int]()\n    if k > len {\n        return\
    \ result\n    }\n    var heap = Heap(type: .max)\n    for i in 0..<k {\n     \
    \   heap.insert(arr[i])\n    }\n    for i in k..<len {\n        if heap.peek()\
    \ < arr[i] {\n            heap.extract()\n            heap.insert(arr[i])\n  \
    \      }\n    }\n    for _ in 0..<k {\n        result.append(heap.extract())\n\
    \    }\n    return result", "    var result = Array(repeating: 0, count: k)\n\
    \    var maxCount = 0\n    for i in 0..<arr.count {\n        result[maxCount]\
    \ = arr[i]\n        maxCount += 1\n        if maxCount == k {\n            var\
    \ j = maxCount - 1\n            while j > 0 {\n                if result[j] >\
    \ result[j - 1] {\n                    result.swapAt(j, j - 1)\n             \
    \   }\n                j -= 1\n            }\n            maxCount -= 1\n    \
    \    }\n    }\n    return result", "    var result = [Int]()\n    if k == 0 {\n\
    \        return result\n    }\n    for i in 0..<k {\n        var j = i\n     \
    \   while j > 0 && result[j - 1] < arr[i] {\n            j -= 1\n        }\n \
    \       result.insert(arr[i], at: j)\n    }\n    for i in k..<arr.count {\n  \
    \      for j in stride(from: k - 1, through: 0, by: -1) {\n            if result[j]\
    \ < arr[i] {\n                result.remove(at: j)\n                result.insert(arr[i],\
    \ at: j)\n                break\n            }\n        }\n    }\n    return result",
  "    var result = [Int]()\n    var res = [Int]()\n    var index = 0\n    for i in\
    \ arr {\n        if result.count < k {\n            result.append(i)\n       \
    \     for j in stride(from: result.count - 1, to: 0, by: -1) {\n             \
    \   if result[j] > result[j - 1] {\n                    result.swapAt(j, j - 1)\n\
    \                }\n            }\n        } else {\n            if i > result[0]\
    \ {\n                result[0] = i\n                for j in stride(from: result.count\
    \ - 1, to: 0, by: -1) {\n                    if result[j] > result[j - 1] {\n\
    \                        result.swapAt(j, j - 1)\n                    }\n    \
    \            }\n            }\n        }\n    }\n    return result", '    return
    arr.sorted().reversed().prefix(k).sorted()', "    \n    // 1\n    //    var heap\
    \ = Heap<Int>(max: true)\n    //    for num in arr {\n    //        heap.insert(num)\n\
    \    //    }\n    //    var result = [Int]()\n    //    for _ in 0..<k {\n   \
    \ //        result.append(heap.remove())\n    //    }\n    //    return result\n\
    \    \n    // 2\n    //    var heap = Heap<Int>(max: true)\n    //    heap.insert(contentsOf:\
    \ arr)\n    //    return heap.extractKLargest(k)\n    \n    // 3\n    var heap\
    \ = Heap<Int>(max: true)\n    for num in arr {\n        heap.insert(num)\n   \
    \     if heap.count > k {\n            heap.remove()\n        }\n    }\n    return\
    \ heap.array", "    let sortedArr = arr.sorted()\n    var result = [Int]()\n \
    \   for i in stride(from: arr.count - 1, through: arr.count - k, by: -1) {\n \
    \       result.append(sortedArr[i])\n    }\n    return result", '    return []',
  "    var result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        guard\
    \ let max = arr.max() else { break }\n        arr.remove(at: arr.firstIndex(of:\
    \ max)!)\n        result.append(max)\n    }\n    return result", "    var sortedArray\
    \ = [Int]()\n    for num in arr {\n        if sortedArray.count < k {\n      \
    \      sortedArray.append(num)\n            sortedArray.sort()\n        } else\
    \ {\n            if num > sortedArray[0] {\n                sortedArray.remove(at:\
    \ 0)\n                sortedArray.append(num)\n                sortedArray.sort()\n\
    \            }\n        }\n    }\n    return sortedArray", "    var result = [Int]()\n\
    \    var temp = [Int]()\n    temp.reserveCapacity(k)\n    for num in arr {\n \
    \       if temp.count == k {\n            temp.sort(by: >)\n            temp.removeFirst()\n\
    \        }\n        temp.append(num)\n    }\n    temp.sort(by: >)\n    temp.removeLast(temp.count\
    \ - k)\n    return temp", "    var result = [Int]()\n    for item in arr {\n \
    \       if result.count == 0 {\n            result.append(item)\n        } else\
    \ {\n            var count = 0\n            for i in result {\n              \
    \  if item > i {\n                    result.insert(item, at: count)\n       \
    \             break\n                }\n                count += 1\n         \
    \   }\n            if count == result.count {\n                result.append(item)\n\
    \            }\n        }\n        if result.count > k {\n            result.removeLast()\n\
    \        }\n    }\n    return result", "    var count = k\n    var max = Array(repeating:\
    \ 0, count: count)\n    var maxIndex = Array(repeating: 0, count: count)\n   \
    \ for i in 0..<arr.count {\n        if i < count {\n            max[i] = arr[i]\n\
    \            maxIndex[i] = i\n        } else {\n            for j in 0..<count\
    \ {\n                if arr[i] > max[j] {\n                    max[j] = arr[i]\n\
    \                    maxIndex[j] = i\n                    break\n            \
    \    }\n            }\n        }\n    }\n    for i in 0..<count {\n        for\
    \ j in i..<count {\n            if max[i] < max[j] {\n                (max[i],\
    \ max[j]) = (max[j], max[i])\n                (maxIndex[i], maxIndex[j]) = (maxIndex[j],\
    \ maxIndex[i])\n            }\n        }\n    }\n    return max", "    // 1. sort\
    \ array\n    // 2. slice k elements\n    return arr.sorted(by: >).prefix(k).sorted()",
  "    guard arr.count >= k else { return arr }\n    var result = Array(arr[0..<k])\n\
    \    heapify(&result)\n    for i in k..<arr.count {\n        if arr[i] > result[0]\
    \ {\n            result[0] = arr[i]\n            minHeapify(&result, index: 0)\n\
    \        }\n    }\n    return result", "    let pq = PriorityQueue<Int>(ascending:\
    \ false)\n    for i in 0..<arr.count {\n        pq.enqueue(arr[i])\n        if\
    \ pq.count > k {\n            pq.dequeue()\n        }\n    }\n    return pq.dequeueAll()",
  "    var result = [Int]()\n    var queue = [Int]()\n    for num in arr {\n     \
    \   if queue.count == k {\n            if let min = queue.min(), num > min {\n\
    \                queue.remove(at: queue.firstIndex(of: min)!)\n              \
    \  queue.append(num)\n            }\n        } else {\n            queue.append(num)\n\
    \        }\n    }\n    result = queue.sorted()\n    return result", "    var copy\
    \ = arr\n    copy.sort()\n    return Array(copy.suffix(k))", "    var result =\
    \ [Int]()\n    if arr.count == 0 || k == 0 {\n        return result\n    }\n \
    \   var heap = MinHeap(arr)\n    var i = 1\n    while i <= k {\n        result.append(heap.remove()!)\n\
    \        i += 1\n    }\n    return result", "    if arr.count == 0 { return []\
    \ }\n    var result = arr\n    for i in stride(from: k, to: 0, by: -1) {\n   \
    \     var maxIndex = 0\n        for j in stride(from: 1, to: i, by: 1) {\n   \
    \         if result[j] > result[maxIndex] {\n                maxIndex = j\n  \
    \          }\n        }\n        let temp = result[maxIndex]\n        result[maxIndex]\
    \ = result[i - 1]\n        result[i - 1] = temp\n    }\n    return Array(result[0..<k])",
  "    var result = [Int]()\n    var index = 0\n    var arrCopy = arr\n    while result.count\
    \ < k {\n        var maxValue = arrCopy[0]\n        for i in 1..<arrCopy.count\
    \ {\n            if arrCopy[i] > maxValue {\n                maxValue = arrCopy[i]\n\
    \                index = i\n            }\n        }\n        result.append(maxValue)\n\
    \        arrCopy.remove(at: index)\n    }\n    return result", "    // guard k\
    \ <= arr.count else { return [] }\n    var maxArray = arr.sorted(by: >).prefix(k)\n\
    \    return maxArray", "    var result = [Int]()\n    var len = arr.count\n  \
    \  guard len > 0 else { return result }\n    for i in 0..<k {\n        var max\
    \ = arr[i]\n        var index = i\n        for j in i..<len {\n            if\
    \ arr[j] > max {\n                max = arr[j]\n                index = j\n  \
    \          }\n        }\n        result.append(max)\n        arr.swapAt(i, index)\n\
    \    }\n    return result", "    var k = k\n    let n = arr.count\n    var result\
    \ = [Int]()\n    var i = 0\n    while k > 0 {\n        let part = arr[i..<n]\n\
    \        if let minIndex = part.minIndex {\n            result.append(arr[minIndex])\n\
    \            i = minIndex + 1\n            k -= 1\n        } else {\n        \
    \    break\n        }\n    }\n    return result", "    if arr.count == 0 { return\
    \ [] }\n    if arr.count == 1 { return arr }\n    if k == 1 { return [arr.max()!]\
    \ }\n    if k >= arr.count { return arr.sorted() }\n    var result = arr.sorted()\n\
    \    for i in 1..<k {\n        result.removeFirst()\n    }\n    return result",
  "    var newArr = arr.sorted()\n    var result = [Int]()\n    for i in 0..<k {\n\
    \        result.append(newArr[i])\n    }\n    return result", '    return arr.sorted(by:
    >).prefix(k).sorted()', "    var numbers = arr\n    return numbers.sorted(by:\
    \ >).prefix(k).sorted()", "    if arr.count == 0 { return [] }\n    var result\
    \ = [Int]()\n    var temp = arr\n    while result.count < k {\n        var max\
    \ = Int.min\n        var index = 0\n        for i in 0..<temp.count {\n      \
    \      if temp[i] > max {\n                max = temp[i]\n                index\
    \ = i\n            }\n        }\n        result.append(max)\n        temp.remove(at:\
    \ index)\n    }\n    return result", "    guard k > 0 else { return [] }\n   \
    \ var result = Array(arr[0..<k])\n    result.sort()\n    for i in k..<arr.count\
    \ {\n        if arr[i] > result[0] {\n            result.removeFirst()\n     \
    \       var j = result.count - 1\n            while j >= 0 && result[j] > arr[i]\
    \ {\n                result[j + 1] = result[j]\n                j -= 1\n     \
    \       }\n            result[j + 1] = arr[i]\n        }\n    }\n    return result",
  "    // Pick first k elements.\n    var candidates = arr[0..<k]\n    candidates.sort()\n\
    \    // Scan arr to find the maximum.\n    for i in k..<arr.count {\n        let\
    \ n = arr[i]\n        // In first k elements, find the candidate that's smaller\
    \ than n.\n        if let c = candidates.first(where: { $0 < n }) {\n        \
    \    // Update n.\n            if let index = candidates.firstIndex(of: c) {\n\
    \                candidates[index] = n\n            }\n            // Sort all\
    \ candidates.\n            candidates.sort()\n        }\n    }\n    return Array(candidates)",
  "    var nums = arr\n    nums.sort()\n    let count = nums.count\n    let start\
    \ = count - k\n    return Array(nums[start..<count])", "    var result = [Int]()\n\
    \    var end = arr.count - 1\n    var i = 0\n    while i < k {\n        result.append(arr[end])\n\
    \        end -= 1\n        i += 1\n    }\n    return result.sorted()", "    var\
    \ sorted = arr.sorted()\n    var result = [Int]()\n    for i in 0..<k {\n    \
    \    result.append(sorted[i])\n    }\n    return result", '    return [0]', " \
    \   let sortedArr = arr.sorted()\n    return Array(sortedArr.dropFirst(arr.count\
    \ - k))", "    guard k > 0 else { return [] }\n    guard k < arr.count else {\
    \ return arr }\n    var newArr = arr.map { $0 }\n    var maxIdx = k - 1\n    for\
    \ i in (0...maxIdx).reversed() {\n        for j in i+1...maxIdx {\n          \
    \  if newArr[i] < newArr[j] {\n                swap(&newArr[i], &newArr[j])\n\
    \            }\n        }\n    }\n    for i in k..<newArr.count {\n        for\
    \ j in k-1...maxIdx {\n            if newArr[i] > newArr[j] {\n              \
    \  for l in (0...j-1).reversed() {\n                    swap(&newArr[l], &newArr[l+1])\n\
    \                }\n                swap(&newArr[j], &newArr[i])\n           \
    \     break\n            }\n        }\n    }\n    return Array(newArr[0..<k])",
  "    var result = [Int]()\n    for i in 0..<k {\n        result.append(arr[i])\n\
    \    }\n    result.sort()\n    for i in k..<arr.count {\n        if arr[i] > result[0]\
    \ {\n            result[0] = arr[i]\n            result.sort()\n        }\n  \
    \  }\n    return result", "    var arr = arr\n    var res = [Int]()\n    while\
    \ k > 0 {\n        let max = arr.max()\n        res.append(max!)\n        arr.remove(at:\
    \ arr.firstIndex(of: max!)!)\n        k -= 1\n    }\n    return res", "    let\
    \ n = arr.count\n    var ans = [Int]()\n    for index in 0..<n {\n        while\
    \ ans.count > 0 && ans.count + n - index > k && arr[index] > ans.last! {\n   \
    \         ans.removeLast()\n        }\n        if ans.count < k {\n          \
    \  ans.append(arr[index])\n        }\n    }\n    return ans", "    var kElements\
    \ = [Int]()\n    var heap = Heap(elements: arr, priorityFunction: >)\n    while\
    \ kElements.count < k {\n        kElements.append(heap.remove()!)\n    }\n   \
    \ return kElements", "    guard k > 0 else { return [] }\n    guard k < arr.count\
    \ else { return arr }\n    let capacity = k + 1\n    var maxHeap = MaxHeap<Int>(capacity:\
    \ capacity)\n    for number in arr {\n        if maxHeap.count < capacity {\n\
    \            maxHeap.insert(number)\n        } else if number > maxHeap.peek()!\
    \ {\n            maxHeap.pop()\n            maxHeap.insert(number)\n        }\n\
    \    }\n    return maxHeap.toArray().sorted()", "    var stack = [Int]()\n   \
    \ for num in arr {\n        while !stack.isEmpty && num > stack.last! && stack.count\
    \ + arr.count - arr.firstIndex(of: num)! > k {\n            stack.removeLast()\n\
    \        }\n        stack.append(num)\n    }\n    return Array(stack.dropLast(stack.count\
    \ - k))", "    guard arr.count > 0 else { return arr }\n    var heap = Heap<Int>(arr,\
    \ sort: <)\n    var maxArr = [Int]()\n    for _ in 0..<k {\n        maxArr.append(heap.extractMax()!)\n\
    \    }\n    return maxArr", "    var stack = [Int]()\n    for i in 0..<arr.count\
    \ {\n        while !stack.isEmpty && arr[i] > stack.last! && stack.count + arr.count\
    \ - i > k {\n            stack.removeLast()\n        }\n        if stack.count\
    \ < k {\n            stack.append(arr[i])\n        }\n    }\n    return stack",
  "    var sortedArr = arr.sorted()\n    return Array(sortedArr.suffix(k))", "   \
    \ var arr = arr\n    arr.sort()\n    let start = arr.count - k\n    var max: [Int]\
    \ = []\n    for i in start..<arr.count {\n        max.append(arr[i])\n    }\n\
    \    return max", "    var arr = arr\n    let k = min(k, arr.count)\n    var result\
    \ = [Int]()\n    var heap = Heap<Int>(arr: arr, sort: >)\n    while result.count\
    \ < k {\n        result.append(heap.pop()!)\n    }\n    return result", '    return
    []', "    let n = arr.count\n    guard k < n else { return arr }\n    guard k\
    \ > 0 else { return [] }\n    var ans = [Int]()\n    for i in arr {\n        while\
    \ ans.count > 0 && ans.count + n - arr.firstIndex(of: i)! >= k && ans.last! <\
    \ i {\n            ans.removeLast()\n        }\n        ans.append(i)\n    }\n\
    \    return Array(ans.dropLast(ans.count - k))", "    var copy = arr\n    copy.sort(by:\
    \ >)\n    return Array(copy[0..<k])", '    return Heap.heapSort(from: arr, k:
    k)', "    var result = [Int]()\n    var maxHeap = Heap<Int>(sort: >)\n    for\
    \ i in 0..<arr.count {\n        if i < k {\n            maxHeap.insert(arr[i])\n\
    \        } else if arr[i] < maxHeap.peek()! {\n            maxHeap.insert(arr[i])\n\
    \            maxHeap.remove()\n        }\n    }\n    for _ in 0..<k {\n      \
    \  result.append(maxHeap.remove()!)\n    }\n    return result", "    var result\
    \ = [Int]()\n    var nums = arr\n    for _ in 0..<k {\n        guard let max =\
    \ nums.max() else { break }\n        result.append(max)\n        nums.removeAll(where:\
    \ { $0 == max })\n    }\n    return result", "    \n    // Time complexity: O(n*log(k))\n\
    \    // Space complexity: O(k)\n    \n    let length = arr.count\n    var result\
    \ = [Int]()\n    var queue = [Int]()\n    \n    for element in arr {\n       \
    \ if queue.count < k {\n            queue.append(element)\n            if queue.count\
    \ == k {\n                queue.sort()\n            }\n        } else {\n    \
    \        var index = k\n            for i in 0..<k {\n                if queue[i]\
    \ < element {\n                    index = i\n                    break\n    \
    \            }\n            }\n            if index < k {\n                queue.insert(element,\
    \ at: index)\n                queue.removeLast()\n            }\n        }\n \
    \   }\n    \n    return queue", "    var output = [Int]()\n    var heap = Heap(sort:\
    \ <, elements: arr)\n    for _ in 0..<k {\n        output.append(heap.remove()!)\n\
    \    }\n    return output", "    var result = [Int]()\n    for num in arr {\n\
    \        // Keep the result in ascending order.\n        while !result.isEmpty\
    \ && num > result.last! && result.count + arr.count - arr.firstIndex(of: num)!\
    \ > k {\n            result.removeLast()\n        }\n        result.append(num)\n\
    \    }\n    return Array(result.dropLast(result.count - k))", "    var numbers\
    \ = arr.sorted()\n    return Array(numbers[numbers.count - k..<numbers.count])",
  "    let sorted = arr.sorted()\n    return Array(sorted.suffix(k))", "    var result\
    \ = [Int]()\n    var pq = PriorityQueue<Int>(ascending: false)\n    arr.forEach\
    \ { (v) in\n        pq.enqueue(v)\n        if pq.count > k {\n            pq.dequeue()\n\
    \        }\n    }\n    while !pq.isEmpty {\n        result.append(pq.dequeue()!)\n\
    \    }\n    return result", "    var res = [Int]()\n    var heap = Heap<Int>(arr:\
    \ arr, sort: <)\n    for _ in 0..<k {\n        guard let val = heap.removeTop()\
    \ else { return res }\n        res.append(val)\n    }\n    return res", "    var\
    \ maxArr = arr\n    var k = k\n    for i in 0..<maxArr.count {\n        for j\
    \ in 0..<maxArr.count - 1 {\n            if maxArr[j] < maxArr[j + 1] {\n    \
    \            let temp = maxArr[j]\n                maxArr[j] = maxArr[j + 1]\n\
    \                maxArr[j + 1] = temp\n            }\n        }\n        k -=\
    \ 1\n        if k == 0 {\n            return maxArr\n        }\n    }\n    return\
    \ maxArr", "    var array = arr\n    var sorted = [Int]()\n    for _ in 0..<k\
    \ {\n        let max = array.max()!\n        let index = array.firstIndex(of:\
    \ max)!\n        sorted.append(max)\n        array.remove(at: index)\n    }\n\
    \    return sorted", "    guard arr.count >= k else { return arr }\n    var n\
    \ = arr.count - k\n    var ans = [Int]()\n    for i in 0..<arr.count {\n     \
    \   if ans.count == 0 {\n            ans.append(arr[i])\n        } else {\n  \
    \          while ans.count > 0 && n > 0 && ans.last! < arr[i] {\n            \
    \    ans.removeLast()\n                n -= 1\n            }\n            ans.append(arr[i])\n\
    \        }\n    }\n    return ans", "    guard k > 0 && k <= arr.count else {\n\
    \        return []\n    }\n    var result = [Int]()\n    var copy = arr\n    for\
    \ _ in 0..<k {\n        let max = copy.max()!\n        result.append(max)\n  \
    \      copy.remove(at: copy.firstIndex(of: max)!)\n    }\n    return result",
  "    var result = [Int]()\n    var priorityQueue = PriorityQueue<Int>(arr)\n   \
    \ for _ in 0..<k {\n        result.append(priorityQueue.pop()!)\n    }\n    return\
    \ result", "    var result = [Int]()\n    var max = [Int]()\n    for i in 0..<arr.count\
    \ {\n        while max.count > 0 && arr[i] > max.last! && max.count + arr.count\
    \ - i > k {\n            max.removeLast()\n        }\n        if max.count < k\
    \ {\n            max.append(arr[i])\n        }\n    }\n    return max", "    var\
    \ result = [Int]()\n    var arr = arr\n    for _ in 0..<k {\n        guard let\
    \ max = arr.max() else { break }\n        result.append(max)\n        arr.remove(at:\
    \ arr.firstIndex(of: max)!)\n    }\n    return result", "    guard arr.count >\
    \ 0 else { return [] }\n    guard arr.count > k else { return arr }\n    var result\
    \ = [Int]()\n    var max = Int.min\n    var dict = [Int: Int]()\n    for i in\
    \ 0..<arr.count {\n        if result.count < k {\n            result.append(arr[i])\n\
    \            max = max < arr[i] ? arr[i] : max\n            dict[arr[i]] = i\n\
    \        } else {\n            if arr[i] > max {\n                let oldIdx =\
    \ dict[max]\n                result[oldIdx!] = arr[i]\n                dict[arr[i]]\
    \ = oldIdx\n                max = arr[i]\n            }\n        }\n    }\n  \
    \  return result", "    var heap = Heap(arr: arr, sort: >)\n    for _ in 0..<k\
    \ {\n        heap.remove()\n    }\n    return heap.storage", "    guard arr.count\
    \ >= k else { return arr }\n    var maxNumbers = [Int]()\n    for number in arr\
    \ {\n        var index = 0\n        for (idx, maxNumber) in maxNumbers.enumerated()\
    \ {\n            if number > maxNumber {\n                index = idx\n      \
    \          break\n            }\n        }\n        maxNumbers.insert(number,\
    \ at: index)\n        if maxNumbers.count > k {\n            maxNumbers.removeLast()\n\
    \        }\n    }\n    return maxNumbers", "    var result = [Int]()\n    for\
    \ i in 0..<k {\n        var max = Int.min\n        var maxIndex = -1\n       \
    \ for j in i..<arr.count {\n            if arr[j] > max {\n                max\
    \ = arr[j]\n                maxIndex = j\n            }\n        }\n        result.append(max)\n\
    \        if maxIndex != i {\n            (arr[i], arr[maxIndex]) = (arr[maxIndex],\
    \ arr[i])\n        }\n    }\n    return result", "    var results = [Int]()\n\
    \    for i in 0..<k {\n        var max = arr[i]\n        var maxIndex = i\n  \
    \      for j in i+1..<arr.count {\n            if arr[j] > max {\n           \
    \     max = arr[j]\n                maxIndex = j\n            }\n        }\n \
    \       results.append(max)\n        arr.swapAt(i, maxIndex)\n    }\n    return\
    \ results", '    return [Int]()', "    guard k < arr.count else { return arr }\n\
    \    guard k > 0 else { return [] }\n    var sub = arr[0..<k]\n    sub.sort()\n\
    \    for i in k..<arr.count {\n        let idx = sub.firstIndex(where: { $0 >\
    \ arr[i] }) ?? k\n        sub.insert(arr[i], at: idx)\n        sub.removeFirst()\n\
    \    }\n    return Array(sub)", "    var result = [Int]()\n    var maxHeap = Heap<Int>(elements:\
    \ arr, sort: >)\n    for _ in 0..<k {\n        result.append(maxHeap.pop()!)\n\
    \    }\n    return result", "    guard arr.count > k else { return arr }\n   \
    \ var result = [Int]()\n    for i in 0..<k {\n        var maxIndex = 0\n     \
    \   for j in 1..<arr.count - i {\n            if arr[j] > arr[maxIndex] {\n  \
    \              maxIndex = j\n            }\n        }\n        result.append(arr[maxIndex])\n\
    \        arr.swapAt(maxIndex, arr.count - i - 1)\n    }\n    return result", " \
    \   var output = [Int]()\n    var max = Int.min\n    var start = 0\n    for i\
    \ in 0 ..< arr.count {\n        if arr[i] >= max {\n            max = arr[i]\n\
    \            start = i\n        }\n    }\n    for i in start + 1 ..< arr.count\
    \ {\n        if arr[i] == max {\n            start = i\n        }\n    }\n   \
    \ output.append(max)\n    for i in 1 ..< k {\n        var max = Int.min\n    \
    \    var stop = arr.count - 1\n        if start == 0 {\n            stop = start\
    \ + i\n        } else if start == arr.count - 1 {\n            stop = start -\
    \ i\n        } else {\n            stop = (start + i < arr.count - 1) ? start\
    \ + i : start - i\n        }\n        if stop < 0 {\n            stop = 0\n  \
    \      }\n        if stop >= arr.count {\n            stop = arr.count - 1\n \
    \       }\n        for j in 0 ... stop {\n            if arr[j] >= max {\n   \
    \             max = arr[j]\n            }\n        }\n        output.append(max)\n\
    \    }\n    return output", "    let count = arr.count\n    guard count >= k else\
    \ { return arr }\n    guard k != 0 else { return [] }\n    var result = Array(repeating:\
    \ 0, count: k)\n    var index = 0\n    for i in 0..<count {\n        while index\
    \ > 0 && result[index - 1] < arr[i] && index + count - i >= k {\n            index\
    \ -= 1\n        }\n        if index < k {\n            result[index] = arr[i]\n\
    \            index += 1\n        }\n    }\n    return result", "    // Implement\
    \ your code here\n    var result = [Int]()\n    if arr.count == k {\n        return\
    \ arr\n    }\n    if arr.count > k {\n        result = arr.sorted(by: {$0 > $1})\n\
    \        return Array(result[0..<k])\n    }\n    return result", "    if arr.count\
    \ == 0 { return [] }\n    var res = [Int]()\n    for n in arr {\n        // res.append(n)\n\
    \        // res.sort()\n        // res.removeLast()\n        while res.count >\
    \ 0 && res.last! < n {\n            res.removeLast()\n        }\n        res.append(n)\n\
    \        while res.count > k {\n            res.removeLast()\n        }\n    }\n\
    \    return res", "    if arr.count == 0 { return [] }\n    if arr.count == 1\
    \ { return arr }\n    if k == 0 { return [] }\n    if k == arr.count { return\
    \ arr }\n    var result = [Int]()\n    var max = 0\n    var max_i = 0\n    for\
    \ i in 0..<k {\n        max = arr[i]\n        max_i = i\n        for j in i..<arr.count\
    \ {\n            if arr[j] > max {\n                max = arr[j]\n           \
    \     max_i = j\n            }\n        }\n        result.append(max)\n      \
    \  arr.swapAt(i, max_i)\n    }\n    return result", "    if arr.count == 0 { return\
    \ [] }\n    var result = Array(repeating: 0, count: k)\n    for i in 0..<k {\n\
    \        var maxIndex = i\n        for j in i+1..<arr.count {\n            if\
    \ arr[j] > arr[maxIndex] {\n                maxIndex = j\n            }\n    \
    \    }\n        result[i] = arr[maxIndex]\n        let temp = arr[i]\n       \
    \ arr[i] = arr[maxIndex]\n        arr[maxIndex] = temp\n    }\n    return result",
  "    var sorted = arr.sorted()\n    if sorted.count <= k {\n        return sorted\n\
    \    }\n    var queue = [Int]()\n    for i in 0 ..< k {\n        queue.append(sorted[i])\n\
    \    }\n    var i = k\n    while i < sorted.count {\n        if queue[0] < sorted[i]\
    \ {\n            queue.removeFirst()\n            queue.append(sorted[i])\n  \
    \      }\n        i += 1\n    }\n    return queue", "    guard k <= arr.count\
    \ else { return arr }\n    var result = [Int]()\n    var temp = [Int]()\n    for\
    \ num in arr {\n        while let last = temp.last, last < num, temp.count + result.count\
    \ > k {\n            temp.removeLast()\n        }\n        if temp.count + result.count\
    \ < k {\n            temp.append(num)\n        } else {\n            result.append(num)\n\
    \        }\n    }\n    return temp + result", "    var result = [Int]()\n    for\
    \ i in arr {\n        if result.count < k {\n            result.append(i)\n  \
    \      } else {\n            for j in 0..<result.count {\n                if i\
    \ > result[j] {\n                    result.insert(i, at: j)\n               \
    \     result.removeLast()\n                    break\n                }\n    \
    \        }\n        }\n    }\n    return result", "    var res = [Int]()\n   \
    \ var max = 0\n    var index = 0\n    var temp = [Int]()\n    for i in stride(from:\
    \ 0, to: arr.count, by: 1) {\n        if k == 0 {\n            if arr[i] < res[max]\
    \ {\n                res[max] = arr[i]\n                for j in stride(from:\
    \ 0, to: res.count, by: 1) {\n                    if res[j] > res[max] {\n   \
    \                     max = j\n                    }\n                }\n    \
    \        }\n        } else {\n            res.append(arr[i])\n            k -=\
    \ 1\n            if k == 0 {\n                max = 0\n                for i in\
    \ stride(from: 0, to: res.count, by: 1) {\n                    if res[i] > res[max]\
    \ {\n                        max = i\n                    }\n                }\n\
    \            }\n        }\n    }\n    for i in stride(from: 0, to: res.count,\
    \ by: 1) {\n        for j in stride(from: i + 1, to: res.count, by: 1) {\n   \
    \         if res[i] > res[j] {\n                temp = res\n                res[i]\
    \ = temp[j]\n                res[j] = temp[i]\n            }\n        }\n    }\n\
    \    return res", "    var stack = Stack<Int>()\n    var ans = [Int]()\n    for\
    \ number in arr {\n        if ans.count < k {\n            ans.append(number)\n\
    \        } else {\n            if let max = ans.max() {\n                if number\
    \ > max {\n                    if let index = ans.firstIndex(of: max) {\n    \
    \                    ans.remove(at: index)\n                        ans.append(number)\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return ans.sorted()", "    let sorted = arr.sorted()\n    return Array(sorted.suffix(k))",
  "    // build a min-heap to maintain the largest k elements\n    var heap = Heap<Int>(array:\
    \ arr, sort: <)\n    // pop out the smallest k elements\n    for _ in 0..<arr.count\
    \ - k {\n        heap.pop()\n    }\n    // the remaining elements in the heap\
    \ is the k largest elements\n    return heap.array", "    var maximums = [Int]()\n\
    \    var currentArr = arr\n\n    while maximums.count < k {\n        let maximum\
    \ = currentArr.max()\n        if let maximum = maximum {\n            maximums.append(maximum)\n\
    \            currentArr.remove(element: maximum)\n        }\n    }\n\n    return\
    \ maximums", "    guard arr.count >= k else { return arr }\n    var result = [Int]()\n\
    \    for i in 0..<k {\n        result.append(arr[i])\n    }\n    var max = k -\
    \ 1\n    for i in k..<arr.count {\n        let num = arr[i]\n        for j in\
    \ 0..<k {\n            if num > result[j] {\n                max = j\n       \
    \         break\n            }\n        }\n        if max != k - 1 {\n       \
    \     result.insert(num, at: max)\n            result.removeLast()\n        }\n\
    \    }\n    return result", "    guard arr.count >= k else { return arr }\n  \
    \  var queue = [Int]()\n    for i in 0..<arr.count {\n        let value = arr[i]\n\
    \        if queue.count < k {\n            queue.append(value)\n            queue.sort()\n\
    \        } else {\n            for j in 0..<queue.count {\n                if\
    \ value > queue[j] {\n                    queue.insert(value, at: j)\n       \
    \             queue.removeLast()\n                    break\n                }\n\
    \            }\n        }\n    }\n    return queue", "    var temp = [Int]()\n\
    \    var result = [Int]()\n    for item in arr {\n        while !temp.isEmpty\
    \ && temp.last! < item && temp.count + arr.count - arr.firstIndex(of: item)! >\
    \ k {\n            temp.removeLast()\n        }\n        temp.append(item)\n \
    \   }\n    while result.count < k {\n        result.append(temp.removeLast())\n\
    \    }\n    return result", "    guard arr.count > k else { return arr }\n   \
    \ var maxs = [Int]()\n    var mins = [Int]()\n    var minElement = Int.max\n \
    \   var maxElement = Int.min\n    var k = k\n    for i in 0..<arr.count {\n  \
    \      let current = arr[i]\n        if current < minElement {\n            minElement\
    \ = current\n        }\n        if current > maxElement {\n            maxElement\
    \ = current\n        }\n        if k > 0 {\n            if maxs.count > 0 {\n\
    \                if current > maxs[0] {\n                    maxs.insert(current,\
    \ at: 0)\n                    mins.insert(maxs.removeLast(), at: 0)\n        \
    \        } else {\n                    mins.insert(current, at: 0)\n         \
    \       }\n            } else {\n                maxs.insert(current, at: 0)\n\
    \            }\n            k -= 1\n        } else {\n            if maxs.count\
    \ > 0 {\n                if current > maxs[0] {\n                    if current\
    \ > maxElement {\n                        maxElement = current\n             \
    \       }\n                    maxs.insert(current, at: 0)\n                 \
    \   mins.insert(maxs.removeLast(), at: 0)\n                } else if current >\
    \ mins[0] {\n                    mins.insert(current, at: 0)\n               \
    \ }\n            } else {\n                if current > maxElement {\n       \
    \             maxElement = current\n                }\n                maxs.insert(current,\
    \ at: 0)\n            }\n        }\n    }\n    return maxs + [maxElement]", " \
    \   var ans = [Int]()\n    if k == 0 {\n        return ans\n    }\n    var max:\
    \ Int = arr[0]\n    var index: Int = 0\n    for i in 0..<arr.count {\n       \
    \ if arr[i] > max {\n            max = arr[i]\n            index = i\n       \
    \ }\n    }\n    ans.append(max)\n    ans.append(contentsOf: maximum(arr: Array(arr[0..<index]),\
    \ k: k - 1))\n    ans.append(contentsOf: maximum(arr: Array(arr[index + 1..<arr.count]),\
    \ k: k - 1))\n    if ans.count > k {\n        ans.sort()\n        ans.removeLast()\n\
    \    }\n    return ans", "    let sorted = arr.sorted()\n    return sorted.suffix(k)",
  "    guard arr.count > k else { return arr }\n    var maxArray = [Int]()\n    for\
    \ i in 0..<k {\n        maxArray.append(arr[i])\n    }\n    for i in k..<arr.count\
    \ {\n        if let index = maxArray.index(where: { $0 < arr[i] }) {\n       \
    \     maxArray.remove(at: index)\n            maxArray.append(arr[i])\n      \
    \  }\n    }\n    return maxArray", "    var newArray = [Int]()\n    if k >= arr.count\
    \ {\n        return arr.sorted()\n    }\n    for i in 0..<k {\n        var max\
    \ = Int.min\n        var maxAt = -1\n        for j in i..<arr.count {\n      \
    \      if arr[j] > max {\n                max = arr[j]\n                maxAt\
    \ = j\n            }\n        }\n        newArray.append(max)\n        if maxAt\
    \ != i {\n            newArray[i] = arr[i]\n            newArray[maxAt] = max\n\
    \        }\n    }\n    return newArray", "    var result = [Int]()\n    var priorityQueue\
    \ = PriorityQueue<Int>(ascending: false)\n    for num in arr {\n        priorityQueue.enqueue(num)\n\
    \    }\n    for _ in 0..<k {\n        result.append(priorityQueue.dequeue()!)\n\
    \    }\n    return result", "    let n = arr.count\n    guard n > k else { return\
    \ arr }\n    var maxs = Array(repeating: 0, count: k)\n    var count = 0\n   \
    \ for i in 0..<n {\n        if count < k || maxs[0] < arr[i] {\n            let\
    \ p = maxs.index(where: { return $0 < arr[i] })\n            if let p = p {\n\
    \                count = min(count + 1, k)\n                for j in p..<count\
    \ {\n                    maxs[j] = arr[i]\n                }\n            }\n\
    \        }\n    }\n    return maxs", '    return []', "    if arr.count == 0 {\
    \ return [] }\n    if arr.count == 1 { return arr }\n    var minimumIndex = 0\n\
    \    var maximumIndex = arr.count - 1\n    let result: [Int] = []\n    for _ in\
    \ (0..<k) {\n        //find minimumIndex\n        for i in minimumIndex...maximumIndex\
    \ {\n            if arr[i] <= arr[minimumIndex] {\n                minimumIndex\
    \ = i\n            }\n        }\n        result.append(arr[minimumIndex])\n  \
    \      minimumIndex += 1\n    }\n    return result", "    var result = [Int]()\n\
    \    var arr = arr\n    var max = Int.min\n    var maxIndex = 0\n    for _ in\
    \ 0..<k {\n        for i in 0..<arr.count {\n            if arr[i] > max {\n \
    \               max = arr[i]\n                maxIndex = i\n            }\n  \
    \      }\n        result.append(max)\n        arr.remove(at: maxIndex)\n     \
    \   max = Int.min\n    }\n    return result", "    if arr.count == 0 { return\
    \ [] }\n    var arr = arr\n    var result = [Int]()\n    while result.count <\
    \ k {\n        var max = Int.min\n        var maxIndex = 0\n        for i in 0..<arr.count\
    \ {\n            if arr[i] > max {\n                max = arr[i]\n           \
    \     maxIndex = i\n            }\n        }\n        result.append(max)\n   \
    \     arr.remove(at: maxIndex)\n    }\n    return result", "    var result = [Int]()\n\
    \    var minIndex = 0\n    var maxIndex = arr.count - 1\n    var currentMax =\
    \ k - 1\n    while currentMax >= 0 {\n        var min = Int.min\n        var max\
    \ = Int.max\n        for i in minIndex...maxIndex {\n            if arr[i] > min\
    \ {\n                min = arr[i]\n                minIndex = i\n            }\n\
    \            if arr[i] < max {\n                max = arr[i]\n               \
    \ maxIndex = i\n            }\n        }\n        result.append(min)\n       \
    \ minIndex += 1\n        currentMax -= 1\n    }\n    return result", "    var\
    \ result = [Int]()\n    guard arr.count > 0 else { return result }\n    guard\
    \ arr.count > k else { return arr }\n    var index = arr.count - 1\n    while\
    \ index >= 0 {\n        if result.count == k {\n            break\n        }\n\
    \        if index == 0 {\n            result.append(arr[index])\n            break\n\
    \        }\n        if arr[index] >= arr[index - 1] {\n            result.append(arr[index])\n\
    \            index -= 1\n        } else {\n            result.append(arr[index\
    \ - 1])\n            index -= 2\n        }\n    }\n    return result", "    guard\
    \ arr.count > 0 else { return [] }\n    guard arr.count > k else { return arr\
    \ }\n    var temp = [Int]()\n    var index = 0\n    while index < k {\n      \
    \  var i = index\n        while i < arr.count {\n            let number = arr[i]\n\
    \            var insertIndex = 0\n            for (j, item) in temp.enumerated()\
    \ {\n                if number > item {\n                    insertIndex = j\n\
    \                    break\n                }\n            }\n            temp.insert(number,\
    \ at: insertIndex)\n            i += k\n        }\n        index += 1\n    }\n\
    \    temp.removeSubrange(k..<temp.count)\n    return temp", "    var ans = [Int]()\n\
    \    var minHeap = MinHeap<Int>()\n    for n in arr {\n        if minHeap.count\
    \ == k {\n            if n > minHeap.peek()! {\n                minHeap.pop()\n\
    \                minHeap.push(n)\n            }\n        } else {\n          \
    \  minHeap.push(n)\n        }\n    }\n    while !minHeap.isEmpty {\n        ans.append(minHeap.pop()!)\n\
    \    }\n    return ans.reversed()", "    if arr.count == 0 { return [] }\n   \
    \ var start = 0\n    var end = arr.count - 1\n    while start <= end {\n     \
    \   let pivot = partition(&arr, start: start, end: end)\n        if pivot == k\
    \ - 1 {\n            return Array(arr[0..<k])\n        } else if pivot > k - 1\
    \ {\n            end = pivot - 1\n        } else {\n            start = pivot\
    \ + 1\n        }\n    }\n    return arr", "    guard k > 0 else { return [] }\n\
    \    guard k < arr.count else { return arr }\n    var result = [Int]()\n    for\
    \ num in arr {\n        while !result.isEmpty && result.count + arr.count - arr.firstIndex(of:\
    \ num)! > k && result.last! < num {\n            result.removeLast()\n       \
    \ }\n        result.append(num)\n    }\n    return Array(result.dropLast(result.count\
    \ - k))", "    var result = Array(repeating: 0, count: k)\n    for num in arr\
    \ {\n        for i in 0..<k {\n            if result[i] < num {\n            \
    \    for j in (0...i).reversed() {\n                    result[j + 1] = result[j]\n\
    \                }\n                result[i] = num\n                break\n \
    \           }\n        }\n    }\n    return result", "    var numbers = arr\n\
    \    var max = [Int]()\n    for _ in 0..<k {\n        let m = numbers.max()!\n\
    \        max.append(m)\n        numbers.removeAll(where: { $0 == m })\n    }\n\
    \    return max", "    var res = [Int]()\n    for i in 0..<k {\n        res.append(arr[i])\n\
    \    }\n    for i in k..<arr.count {\n        if let firstIndex = res.firstIndex(where:\
    \ { $0 < arr[i] }) {\n            res.insert(arr[i], at: firstIndex)\n       \
    \     res.removeLast()\n        }\n    }\n    return res", "    var maxK = [Int]()\n\
    \    var maxK2 = [Int]()\n    for a in arr {\n        if maxK.count == k {\n \
    \           for i in 0..<k {\n                if a >= maxK[i] {\n            \
    \        maxK2.append(a)\n                    maxK2.append(contentsOf: maxK[i..<k])\n\
    \                    break\n                } else if i == k - 1 {\n         \
    \           maxK2.append(contentsOf: maxK[i..<k])\n                }\n       \
    \     }\n            maxK = maxK2\n            maxK2 = []\n        } else {\n\
    \            maxK.append(a)\n        }\n    }\n    return maxK", "    // Checking\
    \ if the size of the array is equal to k\n    if arr.count == k {\n        return\
    \ arr\n    }\n    // Creating an empty array of size k\n    var resultArray =\
    \ [Int](repeating: 0, count: k)\n    for i in 0..<arr.count {\n        // If i\
    \ is smaller than k, just insert the element.\n        if i < k {\n          \
    \  resultArray[i] = arr[i]\n        } else {\n            // If the last element\
    \ of the array is smaller than \n            // the current element in the iteration,\n\
    \            // remove the last element in the array.\n            if resultArray[k\
    \ - 1] < arr[i] {\n                resultArray.removeLast()\n                //\
    \ Insert the current element in the right place.\n                var j = k -\
    \ 2\n                while j >= 0 && resultArray[j] < arr[i] {\n             \
    \       resultArray[j + 1] = resultArray[j]\n                    j -= 1\n    \
    \            }\n                resultArray[j + 1] = arr[i]\n            }\n \
    \       }\n    }\n    return resultArray", "    var nums = arr\n    let mid =\
    \ quickSelect(&nums, start: 0, end: nums.count - 1, k: k)\n    var res = [Int]()\n\
    \    var j = 0\n    while j < k {\n        res.append(nums[j])\n        j += 1\n\
    \    }\n    return res", "    var res = [Int]()\n    var sorted = arr.sorted()\n\
    \    sorted.reverse()\n    for i in 0..<k {\n        res.append(sorted[i])\n \
    \   }\n    return res", "    // Convert arr to maxHeap\n    var heap = MaxHeap(arr)\n\
    \    var sortedArray = [Int]()\n    // The first k elements in maxHeap are the\
    \ max k elements in arr\n    for _ in 0..<k {\n        sortedArray.append(heap.pop())\n\
    \    }\n    return sortedArray", "    var start = 0\n    var end = arr.count -\
    \ 1\n    while start <= end {\n        let partition = partition(arr: &arr, start:\
    \ start, end: end)\n        if partition == k - 1 {\n            break\n     \
    \   } else if partition < k - 1 {\n            start = partition + 1\n       \
    \ } else {\n            end = partition - 1\n        }\n    }\n    var result\
    \ = [Int]()\n    for index in 0..<k {\n        result.append(arr[index])\n   \
    \ }\n    return result", "    // This is a max heap of size k.\n    // It stores\
    \ the maximum k numbers we've seen so far.\n    var heap = BinaryHeap<Int>(sort:\
    \ >)\n    for element in arr {\n        if heap.count < k {\n            heap.insert(element)\n\
    \        } else if element > heap.peek()! {\n            heap.insert(element)\n\
    \            heap.remove()\n        }\n    }\n    return heap.sorted()", "   \
    \ var numbers = arr.map { IntNumber(number: $0) }\n    numbers.sort()\n    return\
    \ numbers.map { $0.number }.suffix(k)", '    return Array(arr.sorted().suffix(k))',
  "    var result = [Int]()\n    var sorted = arr.sorted()\n    while k > 0 {\n  \
    \      result.append(sorted.removeLast())\n        k -= 1\n    }\n    return result",
  "    var result = [Int]()\n    guard arr.count >= k else { return result }\n   \
    \ var count = 0\n    var index = 0\n    while count < k {\n        let maximum\
    \ = arr.max()!\n        while arr[index] != maximum {\n            index += 1\n\
    \        }\n        result.append(maximum)\n        arr.remove(at: index)\n  \
    \      count += 1\n    }\n    return result", '    return []', "    var result\
    \ = [Int]()\n    for index in 0..<k {\n        var max = Int.min\n        var\
    \ maxIndex = -1\n        for i in 0..<arr.count {\n            if arr[i] > max\
    \ && !result.contains(arr[i]) {\n                max = arr[i]\n              \
    \  maxIndex = i\n            }\n        }\n        result.append(max)\n    }\n\
    \    return result", "    var arr = arr\n    arr.sort()\n    return Array(arr.suffix(k))",
  "    var result = Array(repeating: Int.min, count: k)\n    for (i, a) in arr.enumerated()\
    \ {\n        var j = k - 1\n        while j >= 0 {\n            if result[j] >\
    \ a {\n                if j < k - 1 {\n                    result[j + 1] = result[j]\n\
    \                }\n            } else {\n                if j < k - 1 {\n   \
    \                 result[j + 1] = a\n                }\n                break\n\
    \            }\n            j -= 1\n        }\n        if j == -1 {\n        \
    \    result[0] = a\n        }\n    }\n    return result", "    guard k < arr.count\
    \ else { return arr }\n    var heap = Heap<Int>(arr: arr, sort: <)\n    heap.remove(count:\
    \ arr.count - k)\n    return heap.elements", "    guard arr.count > k else { return\
    \ arr }\n    return Array(arr.sorted(by: >).prefix(k))", "    var result = [Int]()\n\
    \    var k = k\n    for i in 0..<arr.count {\n        let num = arr[i]\n     \
    \   if k == 0 {\n            if num > result[0] {\n                result.remove(at:\
    \ 0)\n                result.append(num)\n            }\n        } else {\n  \
    \          var inserted = false\n            for j in 0..<result.count {\n   \
    \             if num > result[j] {\n                    result.insert(num, at:\
    \ j)\n                    inserted = true\n                    break\n       \
    \         }\n            }\n            if !inserted {\n                result.append(num)\n\
    \            }\n            k -= 1\n        }\n    }\n    return result", "  \
    \  var buffer = [Int]()\n    var maxBuffer = [Int]()\n    buffer.reserveCapacity(k)\n\
    \    maxBuffer.reserveCapacity(k)\n    for value in arr {\n        if buffer.count\
    \ < k {\n            insertValue(value, into: &buffer)\n        } else if value\
    \ > buffer[0] {\n            buffer.removeFirst()\n            insertValue(value,\
    \ into: &buffer)\n        }\n    }\n    for value in buffer {\n        insertValue(value,\
    \ into: &maxBuffer)\n    }\n    return maxBuffer", "    //    var answer = [Int]()\n\
    \    //    guard k > 0 else { return answer }\n    //    var array = arr\n   \
    \ //    while answer.count < k {\n    //        let max = array.max()!\n    //\
    \        answer.append(max)\n    //        array.removeAll(where: { $0 == max\
    \ })\n    //    }\n    //    return answer\n    //===============================================================\n\
    \    var answer = [Int]()\n    guard k > 0 else { return answer }\n    var array\
    \ = arr\n    for _ in 0..<k {\n        let max = array.max()!\n        answer.append(max)\n\
    \        array.removeAll(where: { $0 == max })\n    }\n    return answer", " \
    \   var maximums = [Int]()\n    for value in arr {\n        insert(value: value,\
    \ into: &maximums, maximumCount: k)\n    }\n    return maximums", "    var res\
    \ = [Int]()\n    var i = 0\n    while i < k {\n        var max = Int.min\n   \
    \     var argmax = 0\n        for j in 0..<arr.count {\n            if res.contains(arr[j])\
    \ == false {\n                if arr[j] > max {\n                    max = arr[j]\n\
    \                    argmax = j\n                }\n            }\n        }\n\
    \        res.append(arr[argmax])\n        i += 1\n    }\n    return res", "  \
    \  if arr.count == 0 { return [] }\n    if arr.count == 1 { return arr }\n   \
    \ if k == 0 { return [] }\n    if k == arr.count { return arr }\n    var result\
    \ = [Int]()\n    var max = arr[0]\n    var index = 0\n    var _arr = arr\n   \
    \ while result.count < k {\n        for i in 0..<_arr.count {\n            if\
    \ _arr[i] > max {\n                max = _arr[i]\n                index = i\n\
    \            }\n        }\n        result.append(max)\n        _arr.remove(at:\
    \ index)\n        max = _arr[0]\n        index = 0\n    }\n    return result",
  "    var minHeap = Heap<Int>(sort: { $0 < $1 })\n    for num in arr {\n        minHeap.insert(num)\n\
    \        if minHeap.count > k {\n            minHeap.remove()\n        }\n   \
    \ }\n    return minHeap.sorted()", "    var arr = arr\n    var k = k\n    if k\
    \ == arr.count {\n        return arr.sorted()\n    }\n    var index = 0\n    while\
    \ k > 0 {\n        var maxIndex = index\n        for i in index..<arr.count -\
    \ k + 1 {\n            if arr[i] > arr[maxIndex] {\n                maxIndex =\
    \ i\n            }\n        }\n        arr.swapAt(index, maxIndex)\n        index\
    \ += 1\n        k -= 1\n    }\n    return Array(arr[arr.count - k...])", "   \
    \ let maximumHeap = Heap<Int>(type: .max)\n    for num in arr {\n        maximumHeap.add(num)\n\
    \    }\n    return maximumHeap.sorted()", "    var index = 0\n    var result =\
    \ [Int]()\n    while index < k {\n        var max = -1000\n        var maxIndex\
    \ = -1\n        for i in index..<arr.count {\n            if arr[i] > max {\n\
    \                max = arr[i]\n                maxIndex = i\n            }\n \
    \       }\n        result.append(max)\n        index = maxIndex + 1\n    }\n \
    \   return result", "    var max: [Int] = []\n    var maxs = MaxHeap<Int>()\n\
    \    for i in 0..<k {\n        maxs.insert(arr[i])\n    }\n    for i in k..<arr.count\
    \ {\n        if arr[i] > maxs.peek()! {\n            maxs.replace(element: arr[i])\n\
    \        }\n    }\n    while maxs.heapSize != 0 {\n        max.append(maxs.remove()!)\n\
    \    }\n    return max", "    var nums = arr.filter { $0 >= 0 }\n    var result\
    \ = [Int]()\n    var i = 0\n    var j = nums.count - 1\n    for _ in 0..<k {\n\
    \        if i > j {\n            break\n        }\n        if j - i <= 1 {\n \
    \           result.append(contentsOf: nums[i...j])\n            break\n      \
    \  }\n        if nums[i] * 2 <= nums[j] {\n            result.append(nums[j])\n\
    \            j -= 1\n        } else {\n            result.append(nums[i])\n  \
    \          i += 1\n        }\n    }\n    return result", "    // quick sort\n\
    \    func quickSort(arr: inout [Int], start: Int, end: Int) {\n        if start\
    \ < end {\n            let pivot = arr[start]\n            var i = start\n   \
    \         var j = end\n            while i < j {\n                while i < j\
    \ && arr[j] <= pivot {\n                    j -= 1\n                }\n      \
    \          arr[i] = arr[j]\n                while i < j && arr[i] >= pivot {\n\
    \                    i += 1\n                }\n                arr[j] = arr[i]\n\
    \            }\n            arr[i] = pivot\n            if k - 1 <= i {\n    \
    \            quickSort(arr: &arr, start: start, end: i)\n            } else {\n\
    \                quickSort(arr: &arr, start: i + 1, end: end)\n            }\n\
    \        }\n    }\n    guard arr.count > k else {\n        return arr\n    }\n\
    \    var result = arr\n    quickSort(arr: &result, start: 0, end: arr.count -\
    \ 1)\n    return Array(result[(arr.count - k)..<arr.count])", "    if arr.count\
    \ == 0 { return [] }\n    var result = [Int]()\n    for element in arr {\n   \
    \     let insertionIndex = searchInsertionIndex(result, element)\n        result.insert(element,\
    \ at: insertionIndex)\n        if result.count > k {\n            result.removeFirst()\n\
    \        }\n    }\n    return result", "    guard k > 0 else { return [] }\n \
    \   guard k < arr.count else { return arr }\n    var minHeap = Heap<Int>(priorityFunction:\
    \ >)\n    for i in 0..<k {\n        minHeap.insert(arr[i])\n    }\n    for i in\
    \ k..<arr.count {\n        if arr[i] > minHeap.peek()! {\n            minHeap.pop()\n\
    \            minHeap.insert(arr[i])\n        }\n    }\n    return minHeap.sorted()",
  "    var arr = arr\n    arr.sort()\n    return Array(arr.suffix(k))", "    var result\
    \ = [Int]()\n    var queue = [Int]()\n    var index = 0\n    while index < arr.count\
    \ {\n        let item = arr[index]\n        while queue.count > 0, item > queue.last!\
    \ {\n            queue.removeLast()\n        }\n        queue.append(item)\n \
    \       if queue.count > k {\n            queue.removeFirst()\n        }\n   \
    \     index += 1\n    }\n    return queue", "    let n = arr.count\n    var nums\
    \ = arr\n    for i in 0..<k {\n        var maxIndex = i\n        for j in i+1..<n\
    \ {\n            if nums[j] > nums[maxIndex] {\n                maxIndex = j\n\
    \            }\n        }\n        if maxIndex != i {\n            nums.swapAt(i,\
    \ maxIndex)\n        }\n    }\n    return Array(nums[0..<k])", "    guard arr.count\
    \ > 0 else { return [] }\n    guard arr.count > k else { return arr }\n    let\
    \ size = k - 1\n    var stack = arr[0..<k]\n    var j = 0\n    for i in k..<arr.count\
    \ {\n        while j >= 0 && stack[j] < arr[i] {\n            j -= 1\n       \
    \ }\n        j += 1\n        if j < size {\n            stack[j] = arr[i]\n  \
    \      }\n    }\n    return Array(stack)"]
stop_tokens:
- "\n}"
