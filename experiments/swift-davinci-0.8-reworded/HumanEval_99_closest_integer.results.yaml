language: swift
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // TODO: Check value is a valid double\n    var number = Double(value)\n  \
    \  // If number is negative, we round it down and add 1\n    if number < 0 {\n\
    \        number = floor(number!) + 1\n    } else {\n        number = ceil(number!)\
    \ - 1\n    }\n    return Int(number!)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpd_7nun7s.swift:19:8: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    if number < 0 {\n       ^\n/tmp/tmpd_7nun7s.swift:19:8:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    if number < 0 {\n       ^\n              ?? <#default value#>\n/tmp/tmpd_7nun7s.swift:19:8:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    if number < 0 {\n       ^\n             !\n/tmp/tmpd_7nun7s.swift:20:18:\
    \ error: cannot find 'floor' in scope\n        number = floor(number!) + 1\n \
    \                ^~~~~\n/tmp/tmpd_7nun7s.swift:22:18: error: cannot find 'ceil'\
    \ in scope\n        number = ceil(number!) - 1\n                 ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let decimal = Decimal(string: value)\n    let temp = decimal?.rounded(.toNearestOrAwayFromZero)\n\
    \    return NSDecimalNumber(decimal: temp!).intValue\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpivmfj9xr.swift:16:19: error: cannot find 'Decimal' in scope\n \
    \   let decimal = Decimal(string: value)\n                  ^~~~~~~\n/tmp/tmpivmfj9xr.swift:17:34:\
    \ error: cannot infer contextual base in reference to member 'toNearestOrAwayFromZero'\n\
    \    let temp = decimal?.rounded(.toNearestOrAwayFromZero)\n                 \
    \               ~^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpivmfj9xr.swift:18:12: error:\
    \ cannot find 'NSDecimalNumber' in scope\n    return NSDecimalNumber(decimal:\
    \ temp!).intValue\n           ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let double = Double(value)!\n    if double - Double(Int(double)) > 0.5 {\n\
    \        return Int(double + 1)\n    } else {\n        return Int(double)\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp9b07m9mc/tmp9b07m9mc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a4d369c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a4d060b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a4d060988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a4d05f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9b07m9mc                        0x000055a71505846b <unavailable> + 5227

    5    libc.so.6                          0x00002b2a4d555460 __libc_start_main +
    245

    6    tmp9b07m9mc                        0x000055a715058049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let flooredNumber = floor(number)\n    let\
    \ dif = number - flooredNumber\n    if dif >= 0.5 {\n        return Int(ceil(number))\n\
    \    } else {\n        return Int(flooredNumber)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0m2lwn38.swift:17:25: error: cannot find 'floor' in scope\n   \
    \ let flooredNumber = floor(number)\n                        ^~~~~\n/tmp/tmp0m2lwn38.swift:20:20:\
    \ error: cannot find 'ceil' in scope\n        return Int(ceil(number))\n     \
    \              ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueFloat = Float(value)\n    return Int(round(valueFloat!))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp4ksva31j.swift:17:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(valueFloat!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var r : Int?\n    let n = value.components(separatedBy: \".\")\n    if n.count\
    \ == 1 {\n        r = Int(n[0])!\n    } else {\n        let f = Int(n[1])!\n \
    \       if f < 5 {\n            r = Int(n[0])!\n        } else {\n           \
    \ r = Int(n[0])! + 1\n        }\n    }\n    return r!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpz8l14z2q.swift:17:19: error: value of type 'String' has no member\
    \ 'components'\n    let n = value.components(separatedBy: \".\")\n           \
    \ ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = NSString(string: value).doubleValue\n    let roundedNumber = floor(number)\n\
    \    if number - roundedNumber < 0.5 {\n        return Int(roundedNumber)\n  \
    \  } else {\n        return Int(roundedNumber + 1)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7ys3w_ui.swift:16:18: error: cannot find 'NSString' in scope\n\
    \    let number = NSString(string: value).doubleValue\n                 ^~~~~~~~\n\
    /tmp/tmp7ys3w_ui.swift:17:25: error: cannot find 'floor' in scope\n    let roundedNumber\
    \ = floor(number)\n                        ^~~~~\n/tmp/tmp7ys3w_ui.swift:18:33:\
    \ error: cannot convert value of type 'Double' to expected argument type 'Duration'\n\
    \    if number - roundedNumber < 0.5 {\n                                ^\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var integer = Int(value) ?? Int(value.rounded(.down))\n    let decimal = value.trimmingCharacters(in:\
    \ [\"-\", \"0\"]).components(separatedBy: \".\").last ?? \"0\"\n    if decimal\
    \ == \"5\" {\n        integer += 1\n    }\n    return integer\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppq5fix5e.swift:16:43: error: value of type 'String' has no member\
    \ 'rounded'\n    var integer = Int(value) ?? Int(value.rounded(.down))\n     \
    \                               ~~~~~ ^~~~~~~\n/tmp/tmppq5fix5e.swift:16:52: error:\
    \ cannot infer contextual base in reference to member 'down'\n    var integer\
    \ = Int(value) ?? Int(value.rounded(.down))\n                                \
    \                  ~^~~~\n/tmp/tmppq5fix5e.swift:17:25: error: value of type 'String'\
    \ has no member 'trimmingCharacters'\n    let decimal = value.trimmingCharacters(in:\
    \ [\"-\", \"0\"]).components(separatedBy: \".\").last ?? \"0\"\n             \
    \     ~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let closeNum = Float(value)\n    return Int(closeNum!.rounded(.up))\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TuZ6g3/tmp3hn3nbvy-1.o:tmp3hn3nbvy-1.o:function $s11tmp3hn3nbvy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''roundf''

    /tmp/TemporaryDirectory.TuZ6g3/tmp3hn3nbvy-1.o:tmp3hn3nbvy-1.o:function $s11tmp3hn3nbvy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rintf''

    /tmp/TemporaryDirectory.TuZ6g3/tmp3hn3nbvy-1.o:tmp3hn3nbvy-1.o:function $s11tmp3hn3nbvy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''truncf''

    /tmp/TemporaryDirectory.TuZ6g3/tmp3hn3nbvy-1.o:tmp3hn3nbvy-1.o:function $s11tmp3hn3nbvy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceilf''

    /tmp/TemporaryDirectory.TuZ6g3/tmp3hn3nbvy-1.o:tmp3hn3nbvy-1.o:function $s11tmp3hn3nbvy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floorf''

    /tmp/TemporaryDirectory.TuZ6g3/tmp3hn3nbvy-1.o:tmp3hn3nbvy-1.o:function $s11tmp3hn3nbvy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floorf''

    /tmp/TemporaryDirectory.TuZ6g3/tmp3hn3nbvy-1.o:tmp3hn3nbvy-1.o:function $s11tmp3hn3nbvy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceilf''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  /// Create a function that takes a value (string) representing a number\n \
    \   /// and returns the closest integer to it. If the number is equidistant\n\
    \    /// from two integers, round it away from zero.\n    let stringValue = value\n\
    \    let number = Double(stringValue)\n    let decimal = number! - Double(Int(number!))\n\
    \    if decimal < 0.5 {\n        return Int(number!)\n    } else {\n        return\
    \ Int(number!) + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpp7u3ed3x/tmpp7u3ed3x.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b627a765c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b627a45cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b627a45c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b627a45b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp7u3ed3x                        0x000055f944718512 <unavailable> + 5394

    5    libc.so.6                          0x00002b627a951460 __libc_start_main +
    245

    6    tmpp7u3ed3x                        0x000055f944718049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // using the Double.init(_:) failable initializer to check if \n    // the\
    \ string value can be converted to a double\n    if let doubleValue = Double(value)\
    \ {\n        // since doubleValue holds the Double value of the given string,\n\
    \        // we can use the ceil() and floor() methods to get the next\n      \
    \  // integer above and below doubleValue\n        let nextInt = Int(doubleValue.rounded(.up))\n\
    \        let prevInt = Int(doubleValue.rounded(.down))\n        // Now all we\
    \ have to do is check which one is closer to the\n        // doubleValue, and\
    \ return that value\n        let nextDiff = doubleValue - Double(nextInt)\n  \
    \      let prevDiff = Double(prevInt) - doubleValue\n        return nextDiff >\
    \ prevDiff ? prevInt : nextInt\n    }\n    // if value is not convertible to Double,\
    \ return 0\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.t3eBS3/tmp3cypmi_s-1.o:tmp3cypmi_s-1.o:function $s11tmp3cypmi_s15closest_i'
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let val = Double(value)!\n    let floor = Int(val.rounded(.towardZero))\n \
    \   let ceil = Int(val.rounded(.up))\n    return val - Double(floor) > Double(ceil)\
    \ - val ? ceil : floor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.MT6a12/tmp4z_e3596-1.o:tmp4z_e3596-1.o:function $s11tmp4z_e359615closest_i'
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value) ?? Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = Int(value)!\n    let str = value.components(separatedBy: \".\"\
    )\n    if str.count == 2 {\n        let num = Double(value)!\n        if num -\
    \ Double(result) >= 0.5 {\n            result += 1\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmprdxzgjjl.swift:17:21: error: value of type 'String' has no member\
    \ 'components'\n    let str = value.components(separatedBy: \".\")\n         \
    \     ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let abs_value = abs(value)\n    let floored\
    \ = floor(abs_value)\n    let ceiled = ceil(abs_value)\n    let diff_floor = abs_value\
    \ - floored\n    let diff_ceil = ceiled - abs_value\n    if diff_floor == diff_ceil\
    \ {\n        return value > 0 ? Int(ceiled) : Int(-ceiled)\n    }\n    return\
    \ diff_floor < diff_ceil ? Int(floored) : Int(ceiled)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpofg1oydo.swift:18:19: error: cannot find 'floor' in scope\n   \
    \ let floored = floor(abs_value)\n                  ^~~~~\n/tmp/tmpofg1oydo.swift:19:18:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = ceil(abs_value)\n     \
    \            ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    return Int(number.rounded(.awayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.TZ1nQa/tmp41jdwzwd-1.o:tmp41jdwzwd-1.o:function $s11tmp41jdwzwd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let integerValue = Int(doubleValue)\n\
    \    let decimalPlaces = decimalPlacesForDouble(value: doubleValue)\n    let diff\
    \ = doubleValue - Double(integerValue)\n    if diff < 0.5 {\n        return integerValue\n\
    \    } else if diff > 0.5 {\n        if integerValue >= 0 {\n            return\
    \ integerValue + 1\n        } else {\n            return integerValue - 1\n  \
    \      }\n    } else {\n        if integerValue >= 0 {\n            return integerValue\
    \ + 1\n        } else {\n            return integerValue - 1\n        }\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpkp56tyan.swift:18:25: error: cannot find 'decimalPlacesForDouble'\
    \ in scope\n    let decimalPlaces = decimalPlacesForDouble(value: doubleValue)\n\
    \                        ^~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // Ensure we have a Float value\n    guard let floatValue = Float(value) else\
    \ {\n        print(\"\\(value) is not a valid floating point number.\")\n    \
    \    return 0\n    }\n    // Apply the rounding away from zero rules\n    if floatValue\
    \ < 0 {\n        return Int(floatValue - 0.5)\n    } else {\n        return Int(floatValue\
    \ + 0.5)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return value.hasSuffix(\".0\") ? Int(value)! : Int(value.split(separator: \"\
    .\")[0])! + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpogxep585/tmpogxep585.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad53c2a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad53bf9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad53bf9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad53bf997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpogxep585                        0x000056032e99d734 <unavailable> + 5940

    5    libc.so.6                          0x00002ad53c48f460 __libc_start_main +
    245

    6    tmpogxep585                        0x000056032e99d3b9 <unavailable> + 5049

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let val = Double(value)!\n    if val.truncatingRemainder(dividingBy: 1) >=\
    \ 0.5 {\n        return Int(val.rounded(.up))\n    } else {\n        return Int(val.rounded(.down))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.s6eKK6/tmpqwpqcaof-1.o:tmpqwpqcaof-1.o:function $s11tmpqwpqcaof15closest_i'
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    if number - floor(number) < 0.5 {\n      \
    \  return Int(floor(number))\n    } else {\n        return Int(ceil(number))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdhmb85x8.swift:17:17: error: cannot find 'floor' in scope\n   \
    \ if number - floor(number) < 0.5 {\n                ^~~~~\n/tmp/tmpdhmb85x8.swift:18:20:\
    \ error: cannot find 'floor' in scope\n        return Int(floor(number))\n   \
    \                ^~~~~\n/tmp/tmpdhmb85x8.swift:20:20: error: cannot find 'ceil'\
    \ in scope\n        return Int(ceil(number))\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let int = Int(number)\n    let decimal = number\
    \ - Double(int)\n    return decimal < 0.5 ? int : int + 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpxs_cj6lu/tmpxs_cj6lu.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b95dc278c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b95dbf6fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b95dbf6f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b95dbf6e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxs_cj6lu                        0x0000563ae1acf512 <unavailable> + 5394

    5    libc.so.6                          0x00002b95dc464460 __libc_start_main +
    245

    6    tmpxs_cj6lu                        0x0000563ae1acf049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var digits = [Character]()\n    for digit in value {\n        digits.append(digit)\n\
    \    }\n    let input_decimal_index = digits.firstIndex(of: \".\") ?? digits.count\n\
    \    if digits.count > 1 {\n        if digits[input_decimal_index - 1] == \".\"\
    \ {\n            return 0\n        }\n    }\n    digits.remove(at: input_decimal_index)\n\
    \    var output = 0\n    var sign = 1\n    if digits[0] == \"-\" {\n        sign\
    \ = -1\n        digits.remove(at: 0)\n    }\n    var length = digits.count\n \
    \   for (index, digit) in digits.enumerated() {\n        let decimal_power = length\
    \ - index - 1\n        output += Int(String(digit))! * Int(pow(10, Double(decimal_power)))\n\
    \    }\n    return output * sign\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5ra2ib_7.swift:36:45: error: cannot find 'pow' in scope\n     \
    \   output += Int(String(digit))! * Int(pow(10, Double(decimal_power)))\n    \
    \                                        ^~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  return\
    \ Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp8_iobiyq/tmp8_iobiyq.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ade4a62cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade4a323561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ade4a323286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ade4a32313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ade4a322bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp8_iobiyq                        0x0000560860fba75a <unavailable> + 5978

    6    tmp8_iobiyq                        0x0000560860fba3dd <unavailable> + 5085

    7    libc.so.6                          0x00002ade4a818460 __libc_start_main +
    245

    8    tmp8_iobiyq                        0x0000560860fba039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var closestInt = Int(value)!\n    var valueFloat = Float(value)!\n    if valueFloat\
    \ - Float(closestInt) >= 0.5 {\n        closestInt += 1\n    }\n    return closestInt\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp5umz7hvo/tmp5umz7hvo.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b955bc72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b955b969561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b955b969286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b955b96913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b955b968bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp5umz7hvo                        0x000056380746283d <unavailable> + 6205

    6    tmp5umz7hvo                        0x000056380746249d <unavailable> + 5277

    7    libc.so.6                          0x00002b955be5e460 __libc_start_main +
    245

    8    tmp5umz7hvo                        0x00005638074620f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return value.toDouble()!.round()\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpb80oi0vn.swift:16:18: error: value of type 'String' has no member\
    \ 'toDouble'\n    return value.toDouble()!.round()\n           ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var dbl = Double(value) ?? 0.0\n    let rounded = round(dbl)\n    return rounded\
    \ < dbl ? Int(rounded) + 1 : Int(rounded)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpc6bogply.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(dbl)\n                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!.rounded(.awayFromZero)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpcg4jyt5x.swift:16:24: error: value of type 'Int' has no member\
    \ 'rounded'\n    return Int(value)!.rounded(.awayFromZero)\n           ~~~~~~~~~~~\
    \ ^~~~~~~\n/tmp/tmpcg4jyt5x.swift:16:33: error: cannot infer contextual base in\
    \ reference to member 'awayFromZero'\n    return Int(value)!.rounded(.awayFromZero)\n\
    \                               ~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(round(Double(value)!))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppee_2vax.swift:16:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(Double(value)!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  let\
    \ d = Double(value)!\n  return d < 0.0 ? Int(d-0.5) : Int(d+0.5)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let integer = Int(value)\n    let decimal =\
    \ value - Double(integer)\n    if decimal < 0.5 {\n        return integer\n  \
    \  } else {\n        return integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpkb31z68c/tmpkb31z68c.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5365975c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b536566cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b536566c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b536566b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkb31z68c                        0x0000564bef552512 <unavailable> + 5394

    5    libc.so.6                          0x00002b5365b61460 __libc_start_main +
    245

    6    tmpkb31z68c                        0x0000564bef552049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value_to_float = Float(value)\n    let integer_value = Int(value_to_float!)\n\
    \    if value_to_float! - Float(integer_value) >= 0.5 {\n        return integer_value\
    \ + 1\n    } else {\n        return integer_value\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpi2ofnqtz/tmpi2ofnqtz.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1e5f7bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1e5c72b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1e5c72988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1e5c717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi2ofnqtz                        0x0000561d3862d512 <unavailable> + 5394

    5    libc.so.6                          0x00002ab1e6167460 __libc_start_main +
    245

    6    tmpi2ofnqtz                        0x0000561d3862d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    if num >= 0 {\n        return Int(floor(num))\n\
    \    } else {\n        return Int(ceil(num))\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmu46g7tl.swift:18:20: error: cannot find 'floor' in scope\n   \
    \     return Int(floor(num))\n                   ^~~~~\n/tmp/tmpmu46g7tl.swift:20:20:\
    \ error: cannot find 'ceil' in scope\n        return Int(ceil(num))\n        \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let d = Double(value)!\n    let floor = Int(d.rounded(.down))\n    let ceil\
    \ = Int(d.rounded(.up))\n    let halfFloor = floor + (ceil - floor) / 2\n    if\
    \ d < Double(halfFloor) {\n        return floor\n    } else {\n        return\
    \ ceil\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.IFvJKm/tmpus4w480t-1.o:tmpus4w480t-1.o:function $s11tmpus4w480t15closest_i'
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let f_num = floor(num)\n    let c_num = ceil(num)\n\
    \    let sub_f = num - f_num\n    let sub_c = c_num - num\n    let result = sub_f\
    \ > sub_c ? c_num : f_num\n    return Int(result)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpbdh240ld.swift:17:17: error: cannot find 'floor' in scope\n   \
    \ let f_num = floor(num)\n                ^~~~~\n/tmp/tmpbdh240ld.swift:18:17:\
    \ error: cannot find 'ceil' in scope\n    let c_num = ceil(num)\n            \
    \    ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let integer = Int(value)\n    let decimal =\
    \ value - Double(integer)\n    if decimal >= 0.5 {\n        return integer + 1\n\
    \    } else {\n        return integer\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpqt9tybyo/tmpqt9tybyo.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac576beec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac5768e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac5768e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac5768e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqt9tybyo                        0x000055dc6b40b512 <unavailable> + 5394

    5    libc.so.6                          0x00002ac576dda460 __libc_start_main +
    245

    6    tmpqt9tybyo                        0x000055dc6b40b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let formatted = Double(value)!\n    let floored = Int(floor(formatted))\n \
    \   let ceiled = Int(ceil(formatted))\n    if formatted - Double(floored) < 0.5\
    \ {\n        return floored\n    } else {\n        return ceiled\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpq9fbptxh.swift:17:23: error: cannot find 'floor' in scope\n   \
    \ let floored = Int(floor(formatted))\n                      ^~~~~\n/tmp/tmpq9fbptxh.swift:18:22:\
    \ error: cannot find 'ceil' in scope\n    let ceiled = Int(ceil(formatted))\n\
    \                     ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let temp = value.components(separatedBy: \".\")\n    let left = Int(temp[0])!\n\
    \    let right = Int(temp[1])!\n    if (right >= 50) {\n        return left +\
    \ 1\n    } else {\n        return left\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpgmpdst5i.swift:16:22: error: value of type 'String' has no member\
    \ 'components'\n    let temp = value.components(separatedBy: \".\")\n        \
    \       ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    return Int(round(floatValue))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpww15mq1q.swift:17:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(floatValue))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if let number = NumberFormatter().number(from: value) {\n        return Int(round(number.doubleValue))\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpa9n9ffam.swift:16:21: error: cannot find 'NumberFormatter' in scope\n\
    \    if let number = NumberFormatter().number(from: value) {\n               \
    \     ^~~~~~~~~~~~~~~\n/tmp/tmpa9n9ffam.swift:17:20: error: cannot find 'round'\
    \ in scope\n        return Int(round(number.doubleValue))\n                  \
    \ ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let up = Int(ceil(number))\n    let down =\
    \ Int(floor(number))\n    return number - Double(down) > Double(up) - number ?\
    \ up : down\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpipympgml.swift:17:18: error: cannot find 'ceil' in scope\n    let\
    \ up = Int(ceil(number))\n                 ^~~~\n/tmp/tmpipympgml.swift:18:20:\
    \ error: cannot find 'floor' in scope\n    let down = Int(floor(number))\n   \
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard let value = Double(value) else { return -1 }\n    return Int(round(value))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmps3o7tnxp.swift:17:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(value))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var closest = Int(value)!\n    if Double(value)! - Double(closest) >= 0.5 {\n\
    \        closest += 1\n    }\n    return closest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpdcqouzh1/tmpdcqouzh1.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b8624428c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b862411f561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b862411f286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b862411f13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b862411ebb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpdcqouzh1                        0x000055a71192d82d <unavailable> + 6189

    6    tmpdcqouzh1                        0x000055a71192d49d <unavailable> + 5277

    7    libc.so.6                          0x00002b8624614460 __libc_start_main +
    245

    8    tmpdcqouzh1                        0x000055a71192d0f9 <unavailable> + 4345

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var rounded = Int(round(Double(value)!))\n    if (Double(value)! > Double(rounded))\
    \ {\n        rounded += 1\n    }\n    return rounded\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpyqa3yfp_.swift:16:23: error: cannot find 'round' in scope\n   \
    \ var rounded = Int(round(Double(value)!))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let integer = Int(value)\n    let fraction\
    \ = value - Double(integer)\n    return fraction > 0.5 ? integer + 1 : integer\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphnk2r449/tmphnk2r449.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b944cd5ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b944ca55b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b944ca55988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b944ca547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphnk2r449                        0x000055ab011b146b <unavailable> + 5227

    5    libc.so.6                          0x00002b944cf4a460 __libc_start_main +
    245

    6    tmphnk2r449                        0x000055ab011b1049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let intValue = Int(value) ?? 0\n    let decimalPart = value.split(separator:\
    \ \".\").last ?? \"\"\n    if decimalPart.isEmpty {\n        return intValue\n\
    \    }\n    let decimalValue = Int(decimalPart) ?? 0\n    if decimalValue < 50\
    \ {\n        return intValue\n    }\n    if intValue >= 0 {\n        return intValue\
    \ + 1\n    }\n    return intValue - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpx0vdfwvk/tmpx0vdfwvk.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b65c05aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65c02a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65c02a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65c02a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpx0vdfwvk                        0x000056444591182b <unavailable> + 6187

    5    libc.so.6                          0x00002b65c079a460 __libc_start_main +
    245

    6    tmpx0vdfwvk                        0x0000564445911409 <unavailable> + 5129

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value) ?? 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp7fejr14e/tmp7fejr14e.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf65c9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf65995b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf65995988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf659947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7fejr14e                        0x0000560a791d93cb <unavailable> + 5067

    5    libc.so.6                          0x00002acf65e8a460 __libc_start_main +
    245

    6    tmp7fejr14e                        0x0000560a791d8fa9 <unavailable> + 4009

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    let roundedValue = roundf(floatValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo2nw0m06.swift:17:24: error: cannot find 'roundf' in scope\n  \
    \  let roundedValue = roundf(floatValue)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(String(format: \"%.0f\", Double(value)!))!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp4y9c1rd3.swift:16:22: error: incorrect argument labels in call\
    \ (have 'format:_:', expected 'repeating:count:')\n    return Int(String(format:\
    \ \"%.0f\", Double(value)!))!\n                     ^~~~~~~\n                \
    \      repeating       count: \n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if value.contains(\".\") {\n        let length = value.count\n        let lastTwoDigits\
    \ = String(value.suffix(2))\n        let digit = Int(lastTwoDigits)\n        let\
    \ stringDigit = String(digit!)\n        if stringDigit.hasPrefix(\"0\") || stringDigit.hasPrefix(\"\
    1\") || stringDigit.hasPrefix(\"2\") || stringDigit.hasPrefix(\"3\") || stringDigit.hasPrefix(\"\
    4\") {\n            var secondNumber = \"\"\n            for number in value {\n\
    \                if number != \".\" {\n                    secondNumber.append(number)\n\
    \                } else {\n                    break\n                }\n    \
    \        }\n            if Int(secondNumber)! < 0 {\n                return Int(secondNumber)!\
    \ - 1\n            } else {\n                return Int(secondNumber)!\n     \
    \       }\n        } else {\n            var secondNumber = \"\"\n           \
    \ for number in value {\n                if number != \".\" {\n              \
    \      secondNumber.append(number)\n                } else {\n               \
    \     break\n                }\n            }\n            if Int(secondNumber)!\
    \ < 0 {\n                return Int(secondNumber)!\n            } else {\n   \
    \             return Int(secondNumber)! + 1\n            }\n        }\n    } else\
    \ {\n        return Int(value)!\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp4oamsj6_/tmp4oamsj6_.swift:20: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9624fc4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9624cbb561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9624cbb286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9624cbb13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9624cbabb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp4oamsj6_                        0x000055b1a965deec <unavailable> + 7916

    6    tmp4oamsj6_                        0x000055b1a965d94d <unavailable> + 6477

    7    libc.so.6                          0x00002b96251b0460 __libc_start_main +
    245

    8    tmp4oamsj6_                        0x000055b1a965d5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard let value = Float(value) else { return 0 }\n    return Int(value.rounded(.awayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.wjg02y/tmplikrr1q8-1.o:tmplikrr1q8-1.o:function $s11tmplikrr1q815closest_integer5valueSiSS_tF:
    error: undefined reference to ''roundf''

    /tmp/TemporaryDirectory.wjg02y/tmplikrr1q8-1.o:tmplikrr1q8-1.o:function $s11tmplikrr1q815closest_integer5valueSiSS_tF:
    error: undefined reference to ''rintf''

    /tmp/TemporaryDirectory.wjg02y/tmplikrr1q8-1.o:tmplikrr1q8-1.o:function $s11tmplikrr1q815closest_integer5valueSiSS_tF:
    error: undefined reference to ''truncf''

    /tmp/TemporaryDirectory.wjg02y/tmplikrr1q8-1.o:tmplikrr1q8-1.o:function $s11tmplikrr1q815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceilf''

    /tmp/TemporaryDirectory.wjg02y/tmplikrr1q8-1.o:tmplikrr1q8-1.o:function $s11tmplikrr1q815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floorf''

    /tmp/TemporaryDirectory.wjg02y/tmplikrr1q8-1.o:tmplikrr1q8-1.o:function $s11tmplikrr1q815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floorf''

    /tmp/TemporaryDirectory.wjg02y/tmplikrr1q8-1.o:tmplikrr1q8-1.o:function $s11tmplikrr1q815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceilf''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = 0.0\n    if let decimal = Double(value) {\n        result = decimal.rounded(.awayFromZero)\n\
    \    }\n    return Int(result)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.2nIbfy/tmp0b85nldu-1.o:tmp0b85nldu-1.o:function $s11tmp0b85nldu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.2nIbfy/tmp0b85nldu-1.o:tmp0b85nldu-1.o:function $s11tmp0b85nldu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.2nIbfy/tmp0b85nldu-1.o:tmp0b85nldu-1.o:function $s11tmp0b85nldu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.2nIbfy/tmp0b85nldu-1.o:tmp0b85nldu-1.o:function $s11tmp0b85nldu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.2nIbfy/tmp0b85nldu-1.o:tmp0b85nldu-1.o:function $s11tmp0b85nldu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2nIbfy/tmp0b85nldu-1.o:tmp0b85nldu-1.o:function $s11tmp0b85nldu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.2nIbfy/tmp0b85nldu-1.o:tmp0b85nldu-1.o:function $s11tmp0b85nldu15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if let num = Float(value) {\n        return Int(round(num))\n    }\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmplu5cbx4m.swift:17:20: error: cannot find 'round' in scope\n   \
    \     return Int(round(num))\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard value.count > 0 else { return 0 }\n    guard let doubleVal = Double(value)\
    \ else { return 0 }\n    return Int(round(doubleVal))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpm8wqihzy.swift:18:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(doubleVal))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let integer = Int(value) ?? 0\n    let decimal = Double(value)!.truncatingRemainder(dividingBy:\
    \ 1)\n    if decimal < 0.5 {\n        return integer\n    } else {\n        return\
    \ integer + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmphej3wci1/tmphej3wci1.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6161929c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6161620b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6161620988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b616161f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphej3wci1                        0x00005556dcc6e60b <unavailable> + 5643

    5    libc.so.6                          0x00002b6161b15460 __libc_start_main +
    245

    6    tmphej3wci1                        0x00005556dcc6e1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if let valueDouble = Double(value) {\n        return Int(round(valueDouble))\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdu9glyfp.swift:17:20: error: cannot find 'round' in scope\n   \
    \     return Int(round(valueDouble))\n                   ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var closest = 0\n    let str = value.split(separator: \".\")\n    if str.count\
    \ == 1 {\n        closest = Int(str[0])!\n    } else {\n        let num = Double(value)!\n\
    \        closest = Int(round(num))\n    }\n    return closest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp36j2265h.swift:22:23: error: cannot find 'round' in scope\n   \
    \     closest = Int(round(num))\n                      ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value_double = Double(value)\n    let value_int = Int(value_double!)\n\
    \    let value_double_mod = value_double! - Double(value_int)\n    return (value_double_mod\
    \ > 0.5) ? value_int + 1 : value_int\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp41choyew/tmp41choyew.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b310e611c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b310e308b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b310e308988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b310e3077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp41choyew                        0x000055678d37746b <unavailable> + 5227

    5    libc.so.6                          0x00002b310e7fd460 __libc_start_main +
    245

    6    tmp41choyew                        0x000055678d377049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatNumber = Double(value)!\n    let floatNumberArray = floatNumber.description.components(separatedBy:\
    \ \".\")\n    if floatNumberArray.count == 1 {\n        return Int(floatNumber)\n\
    \    } else {\n        if Float(floatNumberArray[1])! > 0.5 {\n            return\
    \ Int(floatNumber) + 1\n        } else {\n            return Int(floatNumber)\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpu15_71m1.swift:17:52: error: value of type 'String' has no member\
    \ 'components'\n    let floatNumberArray = floatNumber.description.components(separatedBy:\
    \ \".\")\n                           ~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let a = Int(num.rounded(.awayFromZero))\n   \
    \ return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.geizhJ/tmpqgh_j65m-1.o:tmpqgh_j65m-1.o:function $s11tmpqgh_j65m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.geizhJ/tmpqgh_j65m-1.o:tmpqgh_j65m-1.o:function $s11tmpqgh_j65m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.geizhJ/tmpqgh_j65m-1.o:tmpqgh_j65m-1.o:function $s11tmpqgh_j65m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.geizhJ/tmpqgh_j65m-1.o:tmpqgh_j65m-1.o:function $s11tmpqgh_j65m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.geizhJ/tmpqgh_j65m-1.o:tmpqgh_j65m-1.o:function $s11tmpqgh_j65m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.geizhJ/tmpqgh_j65m-1.o:tmpqgh_j65m-1.o:function $s11tmpqgh_j65m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.geizhJ/tmpqgh_j65m-1.o:tmpqgh_j65m-1.o:function $s11tmpqgh_j65m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // Your code here\n    let s = value.split(separator: \".\")\n    if let idx\
    \ = s.last?.index(where: { c in c != \"0\" }) {\n        if s.last![idx] >= \"\
    5\" {\n            return Int(s.first!)! + 1\n        }\n    }\n    return Int(s.first!)!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp4g4hnqoc/tmp4g4hnqoc.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b96f7383c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b96f707ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b96f707a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b96f70797b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4g4hnqoc                        0x0000558d17f69ad2 <unavailable> + 6866

    5    libc.so.6                          0x00002b96f756f460 __libc_start_main +
    245

    6    tmp4g4hnqoc                        0x0000558d17f69609 <unavailable> + 5641

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  return\
    \ round(string_to_double(value))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdr4qkcyj.swift:16:10: error: cannot find 'round' in scope\n  return\
    \ round(string_to_double(value))\n         ^~~~~\n/tmp/tmpdr4qkcyj.swift:16:16:\
    \ error: cannot find 'string_to_double' in scope\n  return round(string_to_double(value))\n\
    \               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let decimalPart = num - floor(num)\n    if decimalPart\
    \ == 0.5 {\n        return Int(floor(num + 0.5))\n    } else if decimalPart >\
    \ 0.5 {\n        return Int(ceil(num))\n    } else {\n        return Int(floor(num))\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpa3vjhcba.swift:17:29: error: cannot find 'floor' in scope\n   \
    \ let decimalPart = num - floor(num)\n                            ^~~~~\n/tmp/tmpa3vjhcba.swift:19:20:\
    \ error: cannot find 'floor' in scope\n        return Int(floor(num + 0.5))\n\
    \                   ^~~~~\n/tmp/tmpa3vjhcba.swift:21:20: error: cannot find 'ceil'\
    \ in scope\n        return Int(ceil(num))\n                   ^~~~\n/tmp/tmpa3vjhcba.swift:23:20:\
    \ error: cannot find 'floor' in scope\n        return Int(floor(num))\n      \
    \             ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value) ?? Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.4f88JM/tmpy8q9rexm-1.o:tmpy8q9rexm-1.o:function $s11tmpy8q9rexm15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let trimmed = value.trimmingCharacters(in: .whitespacesAndNewlines)\n    let\
    \ doubleVal = Double(trimmed) ?? 0.0\n    return Int(doubleVal.rounded(.awayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpybr9m2vk.swift:16:25: error: value of type 'String' has no member\
    \ 'trimmingCharacters'\n    let trimmed = value.trimmingCharacters(in: .whitespacesAndNewlines)\n\
    \                  ~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpybr9m2vk.swift:16:49: error:\
    \ cannot infer contextual base in reference to member 'whitespacesAndNewlines'\n\
    \    let trimmed = value.trimmingCharacters(in: .whitespacesAndNewlines)\n   \
    \                                            ~^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpybr9m2vk.swift:18:35:\
    \ error: cannot infer contextual base in reference to member 'awayFromZero'\n\
    \    return Int(doubleVal.rounded(.awayFromZero))\n                          \
    \       ~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpbvou3005/tmpbvou3005.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5c61f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5c5eeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5c5eea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5c5ee97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbvou3005                        0x00005619c229d264 <unavailable> + 4708

    5    libc.so.6                          0x00002ab5c63df460 __libc_start_main +
    245

    6    tmpbvou3005                        0x00005619c229cee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    if value >= 0 {\n        return Int(value.rounded(.up))\n\
    \    } else {\n        return Int(value.rounded(.down))\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZWUcIN/tmpwqwbvxie-1.o:tmpwqwbvxie-1.o:function $s11tmpwqwbvxie15closest_i'
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let n = Double(value)!\n    let b = Int(n)\n    if n > Double(b) + 0.5 {\n\
    \        return b + 1\n    } else {\n        return b\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpggqeoiin/tmpggqeoiin.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba176332c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba176029b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba176029988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba1760287b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpggqeoiin                        0x000055637d61946b <unavailable> + 5227

    5    libc.so.6                          0x00002ba17651e460 __libc_start_main +
    245

    6    tmpggqeoiin                        0x000055637d619049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.toNearestOrAwayFromZero))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleVal = Double(value)\n    let doubleValInt = Int(doubleVal!)\n   \
    \ if doubleVal! > Double(doubleValInt) {\n        return doubleValInt + 1\n  \
    \  } else {\n        return doubleValInt\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpk97fbjgq/tmpk97fbjgq.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b03ac9ccc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03ac6c3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03ac6c3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03ac6c27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpk97fbjgq                        0x00005569d7dfc512 <unavailable> + 5394

    5    libc.so.6                          0x00002b03acbb8460 __libc_start_main +
    245

    6    tmpk97fbjgq                        0x00005569d7dfc049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueDecimal = Decimal(string: value)\n    let result = NSDecimalNumber(decimal:\
    \ valueDecimal ?? 0.0).rounding(accordingToBehavior: NSDecimalNumberHandler(roundingMode:\
    \ .plain, scale: 0, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow:\
    \ false, raiseOnDivideByZero: false))\n    return result.intValue\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpe3i1sofw.swift:16:24: error: cannot find 'Decimal' in scope\n \
    \   let valueDecimal = Decimal(string: value)\n                       ^~~~~~~\n\
    /tmp/tmpe3i1sofw.swift:17:18: error: cannot find 'NSDecimalNumber' in scope\n\
    \    let result = NSDecimalNumber(decimal: valueDecimal ?? 0.0).rounding(accordingToBehavior:\
    \ NSDecimalNumberHandler(roundingMode: .plain, scale: 0, raiseOnExactness: false,\
    \ raiseOnOverflow: false, raiseOnUnderflow: false, raiseOnDivideByZero: false))\n\
    \                 ^~~~~~~~~~~~~~~\n/tmp/tmpe3i1sofw.swift:17:94: error: cannot\
    \ find 'NSDecimalNumberHandler' in scope\n    let result = NSDecimalNumber(decimal:\
    \ valueDecimal ?? 0.0).rounding(accordingToBehavior: NSDecimalNumberHandler(roundingMode:\
    \ .plain, scale: 0, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow:\
    \ false, raiseOnDivideByZero: false))\n                                      \
    \                                                       ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpe3i1sofw.swift:17:132: error: cannot infer contextual base in reference\
    \ to member 'plain'\n    let result = NSDecimalNumber(decimal: valueDecimal ??\
    \ 0.0).rounding(accordingToBehavior: NSDecimalNumberHandler(roundingMode: .plain,\
    \ scale: 0, raiseOnExactness: false, raiseOnOverflow: false, raiseOnUnderflow:\
    \ false, raiseOnDivideByZero: false))\n                                      \
    \                                                                            \
    \                ~^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard let number = Double(value) else { return 0 }\n    let floor = Int(number.rounded(.down))\n\
    \    let ceil = Int(number.rounded(.up))\n    let downDiff = abs(number - Double(floor))\n\
    \    let upDiff = abs(Double(ceil) - number)\n    return downDiff < upDiff ? floor\
    \ : ceil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.ZqVcuP/tmpkh09kx5d-1.o:tmpkh09kx5d-1.o:function $s11tmpkh09kx5d15closest_i'
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  \n    let value_float = Float(value)\n    let value_rounded = roundf(value_float!)\n\
    \    let value_cast = Int(value_rounded)\n    \n    return value_cast\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2siz2_2w.swift:18:25: error: cannot find 'roundf' in scope\n  \
    \  let value_rounded = roundf(value_float!)\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    if abs(doubleValue - Double(Int(doubleValue)))\
    \ >= 0.5 {\n        return Int(doubleValue) + (intValueSign(doubleValue) * 1)\n\
    \    }\n    return Int(doubleValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpx34c1qjb.swift:18:36: error: cannot find 'intValueSign' in scope\n\
    \        return Int(doubleValue) + (intValueSign(doubleValue) * 1)\n         \
    \                          ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Int(value)! + String(value).last!.sorted()[1] == \".\" ? 0 : String(value).last!.sorted()[1]\
    \ == \".\" ? 1 : -1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmprtmpwwf1.swift:16:50: error: value of type 'String.Element' (aka\
    \ 'Character') has no member 'sorted'\n    return Int(Int(value)! + String(value).last!.sorted()[1]\
    \ == \".\" ? 0 : String(value).last!.sorted()[1] == \".\" ? 1 : -1)\n        \
    \                     ~~~~~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmprtmpwwf1.swift:16:95:\
    \ error: value of type 'String.Element' (aka 'Character') has no member 'sorted'\n\
    \    return Int(Int(value)! + String(value).last!.sorted()[1] == \".\" ? 0 : String(value).last!.sorted()[1]\
    \ == \".\" ? 1 : -1)\n                                                       \
    \                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014223
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!.advanced(by: Int(value.hasSuffix(\"0\") ? 0 : (value.hasSuffix(\"\
    5\") ? 1 : 0)))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd0gafa62/tmpd0gafa62.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ab779f69c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab779c60561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab779c60286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab779c6013c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab779c5fbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd0gafa62                        0x000055e5d21868a1 <unavailable> + 6305

    6    tmpd0gafa62                        0x000055e5d218651d <unavailable> + 5405

    7    libc.so.6                          0x00002ab77a155460 __libc_start_main +
    245

    8    tmpd0gafa62                        0x000055e5d2186179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let givenValue = Double(value)!\n    let floorValue = floor(givenValue)\n \
    \   let ceilValue = ceil(givenValue)\n    let givenValueComparingFloor = givenValue\
    \ - floorValue\n    let givenValueComparingCeil = ceilValue - givenValue\n   \
    \ if givenValueComparingFloor == givenValueComparingCeil {\n        if abs(givenValue)\
    \ == floorValue {\n            return Int(givenValue.rounded(.down))\n       \
    \ } else {\n            return Int(givenValue.rounded(.up))\n        }\n    }\
    \ else if givenValueComparingFloor < givenValueComparingCeil {\n        return\
    \ Int(floorValue)\n    } else {\n        return Int(ceilValue)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpc4u660ur.swift:17:22: error: cannot find 'floor' in scope\n   \
    \ let floorValue = floor(givenValue)\n                     ^~~~~\n/tmp/tmpc4u660ur.swift:18:21:\
    \ error: cannot find 'ceil' in scope\n    let ceilValue = ceil(givenValue)\n \
    \                   ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let result = value.toDouble()\n    if (result > 0) {\n        return value.toInt()\
    \ + 1\n    } else {\n        return value.toInt() - 1\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpn_4cz_i5.swift:16:24: error: value of type 'String' has no member\
    \ 'toDouble'\n    let result = value.toDouble()\n                 ~~~~~ ^~~~~~~~\n\
    /tmp/tmpn_4cz_i5.swift:18:22: error: value of type 'String' has no member 'toInt'\n\
    \        return value.toInt() + 1\n               ~~~~~ ^~~~~\n/tmp/tmpn_4cz_i5.swift:20:22:\
    \ error: value of type 'String' has no member 'toInt'\n        return value.toInt()\
    \ - 1\n               ~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard let num = Double(value) else { return -1 }\n    return Int(num)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphyuvipdb/tmphyuvipdb.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af0b6126c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af0b5e1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af0b5e1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af0b5e1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphyuvipdb                        0x0000559b953b646b <unavailable> + 5227

    5    libc.so.6                          0x00002af0b6312460 __libc_start_main +
    245

    6    tmphyuvipdb                        0x0000559b953b6049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(round(Double(value)!))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppee_2vax.swift:16:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(Double(value)!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let decimal = num.truncatingRemainder(dividingBy:\
    \ 1)\n    if decimal < 0.5 {\n        return Int(floor(num))\n    } else {\n \
    \       return Int(ceil(num))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpa78jyj8l.swift:19:20: error: cannot find 'floor' in scope\n   \
    \     return Int(floor(num))\n                   ^~~~~\n/tmp/tmpa78jyj8l.swift:21:20:\
    \ error: cannot find 'ceil' in scope\n        return Int(ceil(num))\n        \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if value.contains(\".\") {\n        let parts = value.split(separator: \".\"\
    )\n        let left = parts[0]\n        let right = parts[1]\n        let left_i\
    \ = Int(left)!\n        let right_i = Int(right)!\n        let int_part = String(left_i)\n\
    \        var closest_i = Int(int_part)!\n        var left_diff = Double(left_i)\n\
    \        var right_diff = Double(left_i + 1)\n        if Double(right_i) > 500\
    \ {\n            closest_i = closest_i + 1\n        }\n        return closest_i\n\
    \    } else {\n        return Int(value)!\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpy1p8ql6p/tmpy1p8ql6p.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac6f4fa0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac6f4c97b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac6f4c97988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac6f4c967b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy1p8ql6p                        0x0000560e8c0128eb <unavailable> + 6379

    5    libc.so.6                          0x00002ac6f518c460 __libc_start_main +
    245

    6    tmpy1p8ql6p                        0x0000560e8c0124c9 <unavailable> + 5321

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpbvou3005/tmpbvou3005.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5c61f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5c5eeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5c5eea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5c5ee97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbvou3005                        0x00005619c229d264 <unavailable> + 4708

    5    libc.so.6                          0x00002ab5c63df460 __libc_start_main +
    245

    6    tmpbvou3005                        0x00005619c229cee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = 0\n    var isNegative = false\n    if value.hasPrefix(\"-\") {\n\
    \        isNegative = true\n    }\n    let array = value.components(separatedBy:\
    \ \".\")\n    let integer = Int(array[0])!\n    if array.count > 1 {\n       \
    \ if let fractional = Int(array[1]) {\n            if fractional > 50 {\n    \
    \            result = integer + 1\n            } else {\n                result\
    \ = integer\n            }\n        }\n    } else {\n        result = integer\n\
    \    }\n    if isNegative {\n        result = -1 * result\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpeo8l1woc.swift:21:23: error: value of type 'String' has no member\
    \ 'components'\n    let array = value.components(separatedBy: \".\")\n       \
    \         ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    return Int(round(doubleValue))\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpu4npbtbf.swift:17:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(doubleValue))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let floor = value.rounded(.down)\n    let ceiling\
    \ = value.rounded(.up)\n    let floordiff = floor - value\n    let ceildiff =\
    \ ceiling - value\n    if floordiff < 0 && ceildiff > 0 {\n        return floor.rounded()\n\
    \    } else if floordiff > 0 && ceildiff < 0 {\n        return ceiling.rounded()\n\
    \    } else if abs(floordiff) > abs(ceildiff) {\n        return ceiling.rounded()\n\
    \    } else {\n        return floor.rounded()\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpnlkp_b7b.swift:22:22: error: cannot convert return expression of\
    \ type 'Double' to return type 'Int'\n        return floor.rounded()\n       \
    \        ~~~~~~^~~~~~~~~\n               Int(           )\n/tmp/tmpnlkp_b7b.swift:24:24:\
    \ error: cannot convert return expression of type 'Double' to return type 'Int'\n\
    \        return ceiling.rounded()\n               ~~~~~~~~^~~~~~~~~\n        \
    \       Int(             )\n/tmp/tmpnlkp_b7b.swift:26:24: error: cannot convert\
    \ return expression of type 'Double' to return type 'Int'\n        return ceiling.rounded()\n\
    \               ~~~~~~~~^~~~~~~~~\n               Int(             )\n/tmp/tmpnlkp_b7b.swift:28:22:\
    \ error: cannot convert return expression of type 'Double' to return type 'Int'\n\
    \        return floor.rounded()\n               ~~~~~~^~~~~~~~~\n            \
    \   Int(           )\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueF: Double = Double(value)!\n    let num = Int(valueF)\n    let diff\
    \ = valueF - Double(num)\n    let closest: Int\n    if diff > 0.5 {\n        closest\
    \ = num + 1\n    } else if diff < -0.5 {\n        closest = num - 1\n    } else\
    \ {\n        closest = num\n    }\n    return closest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp38a3eykp/tmp38a3eykp.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae15276dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae152464b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae152464988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae1524637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp38a3eykp                        0x000055d3e787746b <unavailable> + 5227

    5    libc.so.6                          0x00002ae152959460 __libc_start_main +
    245

    6    tmp38a3eykp                        0x000055d3e7877049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let int = Int(num)\n    if (num - Double(int))\
    \ == 0.5 {\n        return num > 0 ? int + 1 : int - 1\n    }\n    return Int(num\
    \ + 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpw1b0ediu/tmpw1b0ediu.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1595bcfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b15958c6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b15958c6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b15958c57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1b0ediu                        0x0000557e46162512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1595dbb460 __libc_start_main +
    245

    6    tmpw1b0ediu                        0x0000557e46162049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueDouble = Double(value)\n    if let valueDouble = valueDouble {\n \
    \       if valueDouble >= 0 {\n            return Int(valueDouble.rounded(.up))\n\
    \        } else {\n            return Int(valueDouble.rounded(.down))\n      \
    \  }\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.FWqIV3/tmpowh4m7e8-1.o:tmpowh4m7e8-1.o:function $s11tmpowh4m7e815closest_i'
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // TODO: Implement closest_integer\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmphkq3fwrp/tmphkq3fwrp.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e148fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e145f4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e145f4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e145f37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmphkq3fwrp                        0x0000555f5675e264 <unavailable> + 4708

    5    libc.so.6                          0x00002b6e14ae9460 __libc_start_main +
    245

    6    tmphkq3fwrp                        0x0000555f5675dee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var final = 0\n    let double = Double(value)\n    let floor = floor(double!)\n\
    \    let ceil = ceil(double!)\n    if ceil - double! == 0.5 {\n        final =\
    \ Int(ceil)\n    } else if ceil - double! < 0.5 {\n        final = Int(ceil)\n\
    \    } else if ceil - double! > 0.5 {\n        final = Int(floor)\n    }\n   \
    \ return final\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp7z5nbzz5.swift:18:17: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = floor(double!)\n                ^\n/tmp/tmp7z5nbzz5.swift:18:9:\
    \ note: 'floor' declared here\n    let floor = floor(double!)\n        ^\n/tmp/tmp7z5nbzz5.swift:19:16:\
    \ error: use of local variable 'ceil' before its declaration\n    let ceil = ceil(double!)\n\
    \               ^\n/tmp/tmp7z5nbzz5.swift:19:9: note: 'ceil' declared here\n \
    \   let ceil = ceil(double!)\n        ^\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value) ?? 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp7fejr14e/tmp7fejr14e.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf65c9ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf65995b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf65995988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf659947b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7fejr14e                        0x0000560a791d93cb <unavailable> + 5067

    5    libc.so.6                          0x00002acf65e8a460 __libc_start_main +
    245

    6    tmp7fejr14e                        0x0000560a791d8fa9 <unavailable> + 4009

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let d = Double(value)!\n    let d1 = d.rounded(.toNearestOrAwayFromZero)\n\
    \    return Int(d1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.gwCK63/tmp5ivfun2q-1.o:tmp5ivfun2q-1.o:function $s11tmp5ivfun2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.gwCK63/tmp5ivfun2q-1.o:tmp5ivfun2q-1.o:function $s11tmp5ivfun2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.gwCK63/tmp5ivfun2q-1.o:tmp5ivfun2q-1.o:function $s11tmp5ivfun2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.gwCK63/tmp5ivfun2q-1.o:tmp5ivfun2q-1.o:function $s11tmp5ivfun2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.gwCK63/tmp5ivfun2q-1.o:tmp5ivfun2q-1.o:function $s11tmp5ivfun2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gwCK63/tmp5ivfun2q-1.o:tmp5ivfun2q-1.o:function $s11tmp5ivfun2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.gwCK63/tmp5ivfun2q-1.o:tmp5ivfun2q-1.o:function $s11tmp5ivfun2q15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let float = Float(value) ?? 0\n    let floor = Int(floorf(float))\n    let\
    \ ceil = Int(ceilf(float))\n    if float > 0 {\n        if float - Float(floor)\
    \ < Float(ceil) - float {\n            return floor\n        } else {\n      \
    \      return ceil\n        }\n    } else {\n        if float - Float(floor) <\
    \ Float(ceil) - float {\n            return ceil\n        } else {\n         \
    \   return floor\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpq1ukfeih.swift:17:21: error: cannot find 'floorf' in scope\n  \
    \  let floor = Int(floorf(float))\n                    ^~~~~~\n/tmp/tmpq1ukfeih.swift:18:20:\
    \ error: cannot find 'ceilf' in scope\n    let ceil = Int(ceilf(float))\n    \
    \               ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var closest: Int = Int(Double(value)!.rounded(.toNearestOrAwayFromZero))\n\
    \    if Double(value)!.rounded(.up) == Double(value)!.rounded(.down) {\n     \
    \   if closest >= 0 {\n            closest += 1\n        } else {\n          \
    \  closest -= 1\n        }\n    }\n    return closest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.LGSa68/tmp83x4ffz4-1.o:tmp83x4ffz4-1.o:function $s11tmp83x4ffz415closest_i'
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var rounded = Int(round(NumberFormatter().number(from: value)!.doubleValue))\n\
    \    let x = Double(value)! - Double(rounded)\n    if x > 0.5 {\n        rounded\
    \ += 1\n    } else if x < -0.5 {\n        rounded -= 1\n    }\n    return rounded\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpwxn27t53.swift:16:23: error: cannot find 'round' in scope\n   \
    \ var rounded = Int(round(NumberFormatter().number(from: value)!.doubleValue))\n\
    \                      ^~~~~\n/tmp/tmpwxn27t53.swift:16:29: error: cannot find\
    \ 'NumberFormatter' in scope\n    var rounded = Int(round(NumberFormatter().number(from:\
    \ value)!.doubleValue))\n                            ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let rounded = round(number)\n    let closest\
    \ = number - rounded > 0.5 ? Int(ceil(number)) : Int(floor(number))\n    return\
    \ closest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptisgeoel.swift:17:19: error: cannot find 'round' in scope\n   \
    \ let rounded = round(number)\n                  ^~~~~\n/tmp/tmptisgeoel.swift:18:48:\
    \ error: cannot find 'ceil' in scope\n    let closest = number - rounded > 0.5\
    \ ? Int(ceil(number)) : Int(floor(number))\n                                 \
    \              ^~~~\n/tmp/tmptisgeoel.swift:18:68: error: cannot find 'floor'\
    \ in scope\n    let closest = number - rounded > 0.5 ? Int(ceil(number)) : Int(floor(number))\n\
    \                                                                   ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let result = Double(value)!.rounded()\n    return Int(result)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.tuT4Zb/tmprcvzxvzp-1.o:tmprcvzxvzp-1.o:function $s11tmprcvzxvzp15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.tuT4Zb/tmprcvzxvzp-1.o:tmprcvzxvzp-1.o:function $s11tmprcvzxvzp15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.tuT4Zb/tmprcvzxvzp-1.o:tmprcvzxvzp-1.o:function $s11tmprcvzxvzp15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.tuT4Zb/tmprcvzxvzp-1.o:tmprcvzxvzp-1.o:function $s11tmprcvzxvzp15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.tuT4Zb/tmprcvzxvzp-1.o:tmprcvzxvzp-1.o:function $s11tmprcvzxvzp15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.tuT4Zb/tmprcvzxvzp-1.o:tmprcvzxvzp-1.o:function $s11tmprcvzxvzp15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.tuT4Zb/tmprcvzxvzp-1.o:tmprcvzxvzp-1.o:function $s11tmprcvzxvzp15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let integer = Int(num)\n    if num - Double(integer)\
    \ < 0.5 {\n        return integer\n    } else {\n        return integer + 1\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6h3bd1cq/tmp6h3bd1cq.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3e5ce4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3e59dbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3e59db988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3e59da7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6h3bd1cq                        0x00005567fe3e4512 <unavailable> + 5394

    5    libc.so.6                          0x00002ac3e5ed0460 __libc_start_main +
    245

    6    tmp6h3bd1cq                        0x00005567fe3e4049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let decimal = number.truncatingRemainder(dividingBy:\
    \ 1)\n    let int = Int(number)\n    if decimal >= 0.5 {\n        return int +\
    \ 1\n    } else {\n        return int\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpb3h7gu7y/tmpb3h7gu7y.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b21f3802c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b21f34f9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b21f34f9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b21f34f87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpb3h7gu7y                        0x000055689b26a5f2 <unavailable> + 5618

    5    libc.so.6                          0x00002b21f39ee460 __libc_start_main +
    245

    6    tmpb3h7gu7y                        0x000055689b26a129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let temp = Double(value)!\n    let new = temp.rounded()\n    let result = Int(new)\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.hxN3U5/tmpjwi_xwct-1.o:tmpjwi_xwct-1.o:function $s11tmpjwi_xwct15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.hxN3U5/tmpjwi_xwct-1.o:tmpjwi_xwct-1.o:function $s11tmpjwi_xwct15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.hxN3U5/tmpjwi_xwct-1.o:tmpjwi_xwct-1.o:function $s11tmpjwi_xwct15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.hxN3U5/tmpjwi_xwct-1.o:tmpjwi_xwct-1.o:function $s11tmpjwi_xwct15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hxN3U5/tmpjwi_xwct-1.o:tmpjwi_xwct-1.o:function $s11tmpjwi_xwct15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hxN3U5/tmpjwi_xwct-1.o:tmpjwi_xwct-1.o:function $s11tmpjwi_xwct15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hxN3U5/tmpjwi_xwct-1.o:tmpjwi_xwct-1.o:function $s11tmpjwi_xwct15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let v = Double(value)!\n    return v.rounded(.toNearestOrAwayFromZero)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmphxu0n7zh.swift:17:14: error: cannot convert return expression of\
    \ type 'Double' to return type 'Int'\n    return v.rounded(.toNearestOrAwayFromZero)\n\
    \           ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n           Int(             \
    \                  )\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let double = Double(value)!\n    let int = Int(double)\n    if double - Double(int)\
    \ < 0.5 {\n        return int\n    } else {\n        return int + 1\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpid7a252v/tmpid7a252v.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0472625c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b047231cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b047231c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b047231b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpid7a252v                        0x00005594868ea512 <unavailable> + 5394

    5    libc.so.6                          0x00002b0472811460 __libc_start_main +
    245

    6    tmpid7a252v                        0x00005594868ea049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let float = Double(value)!\n    return Int(float.rounded(.up))\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.PdaPFe/tmp1ckhlbc2-1.o:tmp1ckhlbc2-1.o:function $s11tmp1ckhlbc215closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.PdaPFe/tmp1ckhlbc2-1.o:tmp1ckhlbc2-1.o:function $s11tmp1ckhlbc215closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.PdaPFe/tmp1ckhlbc2-1.o:tmp1ckhlbc2-1.o:function $s11tmp1ckhlbc215closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.PdaPFe/tmp1ckhlbc2-1.o:tmp1ckhlbc2-1.o:function $s11tmp1ckhlbc215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.PdaPFe/tmp1ckhlbc2-1.o:tmp1ckhlbc2-1.o:function $s11tmp1ckhlbc215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.PdaPFe/tmp1ckhlbc2-1.o:tmp1ckhlbc2-1.o:function $s11tmp1ckhlbc215closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.PdaPFe/tmp1ckhlbc2-1.o:tmp1ckhlbc2-1.o:function $s11tmp1ckhlbc215closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num: Double = Double(value)!\n    let ans: Int = Int(round(num))\n    return\
    \ ans\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpxks1rell.swift:17:24: error: cannot find 'round' in scope\n   \
    \ let ans: Int = Int(round(num))\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    let roundedValue = roundf(floatValue)\n\
    \    return Int(roundedValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo2nw0m06.swift:17:24: error: cannot find 'roundf' in scope\n  \
    \  let roundedValue = roundf(floatValue)\n                       ^~~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let n = Double(value)!\n    return n > Double(Int(n)) ? Int(n) + 1 : Int(n)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpv0ja0w0s/tmpv0ja0w0s.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b182e9c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b182e6bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b182e6bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b182e6bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv0ja0w0s                        0x00005580289d7512 <unavailable> + 5394

    5    libc.so.6                          0x00002b182ebb2460 __libc_start_main +
    245

    6    tmpv0ja0w0s                        0x00005580289d7049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let stringAsDouble = Double(value)\n    return Int(round(stringAsDouble!))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5er02wf1.swift:17:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(stringAsDouble!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    return (value < 0) ? Int(value - 0.5) : Int(value\
    \ + 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let floor = Int(floor(doubleValue))\n\
    \    let ceiling = Int(ceil(doubleValue))\n    let decimal = doubleValue - Double(floor)\n\
    \    let absDecimal = abs(decimal)\n    switch absDecimal {\n    case 0:\n   \
    \     return floor\n    case 0.5:\n        if ceiling % 2 == 0 {\n           \
    \ return ceiling\n        } else {\n            return floor\n        }\n    default:\n\
    \        if absDecimal > 0.5 {\n            return ceiling\n        } else {\n\
    \            return floor\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp8ezuc0hz.swift:17:21: error: use of local variable 'floor' before\
    \ its declaration\n    let floor = Int(floor(doubleValue))\n                 \
    \   ^\n/tmp/tmp8ezuc0hz.swift:17:9: note: 'floor' declared here\n    let floor\
    \ = Int(floor(doubleValue))\n        ^\n/tmp/tmp8ezuc0hz.swift:18:23: error: cannot\
    \ find 'ceil' in scope\n    let ceiling = Int(ceil(doubleValue))\n           \
    \           ^~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  let\
    \ rounded = Int(value.double!)\n  if value.double == Double(rounded) {\n    return\
    \ rounded\n  }\n  return rounded > 0 ? rounded + 1 : rounded - 1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo0nk9pyz.swift:16:27: error: value of type 'String' has no member\
    \ 'double'\n  let rounded = Int(value.double!)\n                    ~~~~~ ^~~~~~\n\
    /tmp/tmpo0nk9pyz.swift:17:12: error: value of type 'String' has no member 'double'\n\
    \  if value.double == Double(rounded) {\n     ~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let decimal = Decimal(string: value)\n    let rounded = decimal.rounded(.toNearestOrAwayFromZero)\n\
    \    let roundedInt = rounded.intValue\n    return roundedInt\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpkj4qtgk9.swift:16:19: error: cannot find 'Decimal' in scope\n \
    \   let decimal = Decimal(string: value)\n                  ^~~~~~~\n/tmp/tmpkj4qtgk9.swift:17:36:\
    \ error: cannot infer contextual base in reference to member 'toNearestOrAwayFromZero'\n\
    \    let rounded = decimal.rounded(.toNearestOrAwayFromZero)\n               \
    \                   ~^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ let decimal = abs(doubleValue - Double(intValue))\n    return decimal < 0.5\
    \ ? intValue : intValue + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpmc3lgq39/tmpmc3lgq39.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adfb9166c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adfb8e5db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adfb8e5d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adfb8e5c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmc3lgq39                        0x000055e8ed79d632 <unavailable> + 5682

    5    libc.so.6                          0x00002adfb9352460 __libc_start_main +
    245

    6    tmpmc3lgq39                        0x000055e8ed79d169 <unavailable> + 4457

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueDouble = Double(value)\n    let valueInt = Int(valueDouble!)\n   \
    \ var closestInt = 0\n    if valueDouble!.truncatingRemainder(dividingBy: 1) >\
    \ 0.5 {\n        closestInt = valueInt + 1\n    } else {\n        closestInt =\
    \ valueInt\n    }\n    return closestInt\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp5qve3217/tmp5qve3217.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b78d7ffcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b78d7cf3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b78d7cf3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b78d7cf27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5qve3217                        0x00005567017c054b <unavailable> + 5451

    5    libc.so.6                          0x00002b78d81e8460 __libc_start_main +
    245

    6    tmp5qve3217                        0x00005567017c0129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  let\
    \ doubleValue = Double(value)!\n  if doubleValue - Double(Int(doubleValue)) >\
    \ 0.5 {\n    return Int(doubleValue) + 1\n  } else {\n    return Int(doubleValue)\n\
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmplou9t3pm/tmplou9t3pm.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4ecfe2ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4ecfb21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4ecfb21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4ecfb207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplou9t3pm                        0x000055bdcd00d46b <unavailable> + 5227

    5    libc.so.6                          0x00002b4ed0016460 __libc_start_main +
    245

    6    tmplou9t3pm                        0x000055bdcd00d049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let n = Double(value)!\n    let i = Int(n)\n    return n - Double(i) < 0.5\
    \ ? i : i + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp2h4n3ugt/tmp2h4n3ugt.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e1fd33c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e1fa2ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e1fa2a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e1fa297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2h4n3ugt                        0x000055bbfebaf512 <unavailable> + 5394

    5    libc.so.6                          0x00002b2e1ff1f460 __libc_start_main +
    245

    6    tmp2h4n3ugt                        0x000055bbfebaf049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  \n    let num = Double(value)!\n    let up = ceil(num)\n    let down = floor(num)\n\
    \    \n    let diffUp = up - num\n    let diffDown = num - down\n    \n    if\
    \ diffUp > diffDown {\n        return Int(down)\n    } else {\n        return\
    \ Int(up)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpdfe1ma2z.swift:18:14: error: cannot find 'ceil' in scope\n    let\
    \ up = ceil(num)\n             ^~~~\n/tmp/tmpdfe1ma2z.swift:19:16: error: cannot\
    \ find 'floor' in scope\n    let down = floor(num)\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let d = Double(value)!\n    let t = Int(d)\n    if d - Double(t) > 0.5 {\n\
    \        return t + 1\n    } else {\n        return t\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp9s6wumk8/tmp9s6wumk8.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9e8c6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9e8961b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9e8961988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9e89607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9s6wumk8                        0x000055febe5ef46b <unavailable> + 5227

    5    libc.so.6                          0x00002ab9e8e56460 __libc_start_main +
    245

    6    tmp9s6wumk8                        0x000055febe5ef049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var result = Int(round(Double(value)!))\n    if result < 0 {\n        result\
    \ = result-1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmrkqfgyw.swift:16:22: error: cannot find 'round' in scope\n   \
    \ var result = Int(round(Double(value)!))\n                     ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let double_value = Double(value)!\n    let floor_double_value = floor(double_value)\n\
    \    let decimal_value = double_value - floor_double_value\n    let ceiling_double_value\
    \ = floor_double_value + 1.0\n    if (decimal_value < 0.5) {\n        return Int(floor_double_value)\n\
    \    } else {\n        return Int(ceiling_double_value)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp2gcn46zj.swift:17:30: error: cannot find 'floor' in scope\n   \
    \ let floor_double_value = floor(double_value)\n                             ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    return num.rounded(.awayFromZero)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5nj043it.swift:17:16: error: cannot convert return expression of\
    \ type 'Double' to return type 'Int'\n    return num.rounded(.awayFromZero)\n\
    \           ~~~~^~~~~~~~~~~~~~~~~~~~~~\n           Int(                      )\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let formatter = NumberFormatter()\n    if let num = formatter.number(from:\
    \ value) {\n        let doubleValue = num.doubleValue\n        return Int(doubleValue.rounded(.toNearestOrAwayFromZero))\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpvyns9bq9.swift:16:21: error: cannot find 'NumberFormatter' in scope\n\
    \    let formatter = NumberFormatter()\n                    ^~~~~~~~~~~~~~~\n\
    /tmp/tmpvyns9bq9.swift:19:41: error: cannot infer contextual base in reference\
    \ to member 'toNearestOrAwayFromZero'\n        return Int(doubleValue.rounded(.toNearestOrAwayFromZero))\n\
    \                                       ~^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let x = Float(value)!\n    let integral = Int(x)\n    let fractional = x -\
    \ Float(integral)\n    if fractional >= 0.5 {\n        return integral + 1\n \
    \   } else {\n        return integral\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpollktdgy/tmpollktdgy.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b58ddfecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b58ddce3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b58ddce3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b58ddce27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpollktdgy                        0x000055ff8f4a8512 <unavailable> + 5394

    5    libc.so.6                          0x00002b58de1d8460 __libc_start_main +
    245

    6    tmpollktdgy                        0x000055ff8f4a8049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // The floating point representation of the input value is\n    // the closest\
    \ floating point number to the input value.\n    // \n    // When using a string\
    \ literal (or a string value) with a floating\n    // point literal, the result\
    \ is a float.\n    // https://github.com/apple/swift-evolution/blob/master/proposals/0077-remove-float-literal-conversion-rule.md\n\
    \    let num = Double(value)!\n    let decimalPart = num - Double(Int(num))\n\
    \    if decimalPart < 0.5 {\n        return Int(num)\n    } else {\n        return\
    \ Int(num) + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpuieo598r/tmpuieo598r.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f92391c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f92088b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f92088988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f920877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuieo598r                        0x000055e20fd27512 <unavailable> + 5394

    5    libc.so.6                          0x00002b6f9257d460 __libc_start_main +
    245

    6    tmpuieo598r                        0x000055e20fd27049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Float(value)!\n    return Int(number) + Int(number.sign())\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmptlt2van4.swift:17:37: error: cannot call value of non-function\
    \ type 'FloatingPointSign'\n    return Int(number) + Int(number.sign())\n    \
    \                                ^   ~~\n                                    \
    \    \n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let n = Double(value)!\n    let truncated = Int(n)\n    let f = n - Double(truncated)\n\
    \    if f < 0.5 {\n        return truncated\n    } else {\n        return truncated\
    \ > 0 ? truncated + 1 : truncated - 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp04bono9t/tmp04bono9t.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acdfcb36c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acdfc82db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acdfc82d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acdfc82c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp04bono9t                        0x00005611ce750512 <unavailable> + 5394

    5    libc.so.6                          0x00002acdfcd22460 __libc_start_main +
    245

    6    tmp04bono9t                        0x00005611ce750049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatValue = Float(value) ?? 0\n    return round(floatValue > 0 ? floatValue\
    \ + 0.5 : floatValue - 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpfguu_0aa.swift:17:12: error: cannot find 'round' in scope\n   \
    \ return round(floatValue > 0 ? floatValue + 0.5 : floatValue - 0.5)\n       \
    \    ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    if num > 0 {\n        return Int(num + 0.5)\n\
    \    } else {\n        return Int(num - 0.5)\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let floatVal = (value as NSString).floatValue\n    let roundedVal = round(floatVal)\n\
    \    let intVal = Int(roundedVal)\n    return intVal\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp78fkoinn.swift:16:30: error: cannot find type 'NSString' in scope\n\
    \    let floatVal = (value as NSString).floatValue\n                         \
    \    ^~~~~~~~\n/tmp/tmp78fkoinn.swift:16:40: error: value of type 'String' has\
    \ no member 'floatValue'\n    let floatVal = (value as NSString).floatValue\n\
    \                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp78fkoinn.swift:17:22:\
    \ error: cannot find 'round' in scope\n    let roundedVal = round(floatVal)\n\
    \                     ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  guard let number = Double(value) else { return 0 }\n    return Int(number.rounded(.toNearestOrAwayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.cNMSHz/tmpka0tepf7-1.o:tmpka0tepf7-1.o:function $s11tmpka0tepf715closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.cNMSHz/tmpka0tepf7-1.o:tmpka0tepf7-1.o:function $s11tmpka0tepf715closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.cNMSHz/tmpka0tepf7-1.o:tmpka0tepf7-1.o:function $s11tmpka0tepf715closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.cNMSHz/tmpka0tepf7-1.o:tmpka0tepf7-1.o:function $s11tmpka0tepf715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.cNMSHz/tmpka0tepf7-1.o:tmpka0tepf7-1.o:function $s11tmpka0tepf715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.cNMSHz/tmpka0tepf7-1.o:tmpka0tepf7-1.o:function $s11tmpka0tepf715closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.cNMSHz/tmpka0tepf7-1.o:tmpka0tepf7-1.o:function $s11tmpka0tepf715closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    return Int(value) >= 0 ? Int(doubleValue.rounded(.up))\
    \ : Int(doubleValue.rounded(.down))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpa90g_tfa.swift:17:12: error: value of optional type 'Int?' must\
    \ be unwrapped to a value of type 'Int'\n    return Int(value) >= 0 ? Int(doubleValue.rounded(.up))\
    \ : Int(doubleValue.rounded(.down))\n           ^\n/tmp/tmpa90g_tfa.swift:17:12:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    return Int(value) >= 0 ? Int(doubleValue.rounded(.up)) : Int(doubleValue.rounded(.down))\n\
    \           ^\n                      ?? <#default value#>\n/tmp/tmpa90g_tfa.swift:17:12:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    return Int(value) >= 0 ? Int(doubleValue.rounded(.up)) : Int(doubleValue.rounded(.down))\n\
    \           ^\n                     !\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // Don't accept values that are not numbers.\n    guard let doubleValue = Double(value)\
    \ else {\n        return 0\n    }\n    // If the number is an integer, just return\
    \ it.\n    if floor(doubleValue) == doubleValue {\n        return Int(doubleValue)\n\
    \    }\n    // Calculate the integer that is closest to the given number.\n  \
    \  let intValue = Int(doubleValue)\n    let remainder = doubleValue - Double(intValue)\n\
    \    return remainder < 0.5 ? intValue : intValue + 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpu6gmd7d8.swift:21:8: error: cannot find 'floor' in scope\n    if\
    \ floor(doubleValue) == doubleValue {\n       ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value_double = Double(value)\n    let ceiling = Int(ceil(value_double!))\n\
    \    let floor = Int(floor(value_double!))\n    let ceiling_diff = abs(value_double!\
    \ - Double(ceiling))\n    let floor_diff = abs(value_double! - Double(floor))\n\
    \    if ceiling_diff == floor_diff {\n        if value_double! >= 0 {\n      \
    \      return ceiling\n        } else {\n            return floor\n        }\n\
    \    } else if ceiling_diff < floor_diff {\n        return ceiling\n    } else\
    \ {\n        return floor\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppghncgsz.swift:17:23: error: cannot find 'ceil' in scope\n    let\
    \ ceiling = Int(ceil(value_double!))\n                      ^~~~\n/tmp/tmppghncgsz.swift:18:21:\
    \ error: use of local variable 'floor' before its declaration\n    let floor =\
    \ Int(floor(value_double!))\n                    ^\n/tmp/tmppghncgsz.swift:18:9:\
    \ note: 'floor' declared here\n    let floor = Int(floor(value_double!))\n   \
    \     ^\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Float(value)!.rounded())\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.9wFmaz/tmpattgooo_-1.o:tmpattgooo_-1.o:function $s11tmpattgooo_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''roundf''

    /tmp/TemporaryDirectory.9wFmaz/tmpattgooo_-1.o:tmpattgooo_-1.o:function $s11tmpattgooo_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rintf''

    /tmp/TemporaryDirectory.9wFmaz/tmpattgooo_-1.o:tmpattgooo_-1.o:function $s11tmpattgooo_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''truncf''

    /tmp/TemporaryDirectory.9wFmaz/tmpattgooo_-1.o:tmpattgooo_-1.o:function $s11tmpattgooo_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceilf''

    /tmp/TemporaryDirectory.9wFmaz/tmpattgooo_-1.o:tmpattgooo_-1.o:function $s11tmpattgooo_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floorf''

    /tmp/TemporaryDirectory.9wFmaz/tmpattgooo_-1.o:tmpattgooo_-1.o:function $s11tmpattgooo_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floorf''

    /tmp/TemporaryDirectory.9wFmaz/tmpattgooo_-1.o:tmpattgooo_-1.o:function $s11tmpattgooo_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceilf''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number: Double = value.doubleValue\n    let rounded = number.rounded()\n\
    \    let ceiled = number.rounded(.up)\n    let floored = number.rounded(.down)\n\
    \    let roundedAway = (number > 0.0) ? ceiled : floored\n    return Int(roundedAway)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp689zd0sr.swift:16:32: error: value of type 'String' has no member\
    \ 'doubleValue'\n    let number: Double = value.doubleValue\n                \
    \         ~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var number = Double(value) ?? 0\n    if number > 0 {\n        number.round(.up)\n\
    \    } else {\n        number.round(.down)\n    }\n    return Int(number)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3jvQbD/tmpb4l4_vwy-1.o:tmpb4l4_vwy-1.o:function $s11tmpb4l4_vwy15closest_i'
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let val_array = value.components(separatedBy: \".\")\n    if val_array.count\
    \ == 1 {\n        return Int(value)!\n    }\n    let whole_part = Int(val_array[0])!\n\
    \    let decimal_part = val_array[1]\n    if Int(decimal_part)! < 50 {\n     \
    \   return whole_part\n    } else {\n        return whole_part + 1\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpd_2n5bsk.swift:16:27: error: value of type 'String' has no member\
    \ 'components'\n    let val_array = value.components(separatedBy: \".\")\n   \
    \                 ~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let intValue = Int(doubleValue)\n   \
    \ if Double(intValue) == doubleValue {\n        return intValue\n    }\n    return\
    \ doubleValue.rounded(.up)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpr66747_q.swift:21:24: error: cannot convert return expression of\
    \ type 'Double' to return type 'Int'\n    return doubleValue.rounded(.up)\n  \
    \         ~~~~~~~~~~~~^~~~~~~~~~~~\n           Int(                    )\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    return closest_integer(value: doubleValue)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpvw6lh0jm.swift:17:35: error: cannot convert value of type 'Double'\
    \ to expected argument type 'String'\n    return closest_integer(value: doubleValue)\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var number: Double = 0\n    if let n = Double(value) {\n        number = n\n\
    \    }\n    return Int(round(number))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp5473yqmp.swift:20:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(number))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var closest = Int(value)!\n    if let lastDigit = value.last, let lastDigitValue\
    \ = Int(String(lastDigit)) {\n        if lastDigitValue >= 5 {\n            closest\
    \ += 1\n        }\n    }\n    return closest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp65494tn3/tmp65494tn3.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002ae32546dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae325164561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae325164286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae32516413c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae325163bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmp65494tn3                        0x000055bd2807d8d8 <unavailable> + 6360

    6    tmp65494tn3                        0x000055bd2807d4fd <unavailable> + 5373

    7    libc.so.6                          0x00002ae325659460 __libc_start_main +
    245

    8    tmp65494tn3                        0x000055bd2807d159 <unavailable> + 4441

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let v = Double(value)!\n    let f = floor(v)\n    let c = ceil(v)\n    let\
    \ f_diff = abs(f - v)\n    let c_diff = abs(c - v)\n    if f_diff == c_diff {\n\
    \        return c > f ? Int(c) : Int(f)\n    }\n    return f_diff < c_diff ? Int(f)\
    \ : Int(c)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppm9aolwa.swift:17:13: error: cannot find 'floor' in scope\n   \
    \ let f = floor(v)\n            ^~~~~\n/tmp/tmppm9aolwa.swift:18:13: error: cannot\
    \ find 'ceil' in scope\n    let c = ceil(v)\n            ^~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let number_round = number.rounded()\n    if\
    \ (number - number_round) < 0 {\n        return Int(number_round)\n    } else\
    \ {\n        return Int(number_round) + 1\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.3Vz0AM/tmpaf0vqwjo-1.o:tmpaf0vqwjo-1.o:function $s11tmpaf0vqwjo15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.3Vz0AM/tmpaf0vqwjo-1.o:tmpaf0vqwjo-1.o:function $s11tmpaf0vqwjo15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.3Vz0AM/tmpaf0vqwjo-1.o:tmpaf0vqwjo-1.o:function $s11tmpaf0vqwjo15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.3Vz0AM/tmpaf0vqwjo-1.o:tmpaf0vqwjo-1.o:function $s11tmpaf0vqwjo15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.3Vz0AM/tmpaf0vqwjo-1.o:tmpaf0vqwjo-1.o:function $s11tmpaf0vqwjo15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3Vz0AM/tmpaf0vqwjo-1.o:tmpaf0vqwjo-1.o:function $s11tmpaf0vqwjo15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.3Vz0AM/tmpaf0vqwjo-1.o:tmpaf0vqwjo-1.o:function $s11tmpaf0vqwjo15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  //guard let floatValue = Float(value) else { return 0 }\n    let floatValue\
    \ = Float(value)!\n    let intValue = Int(floatValue)\n    let diff = floatValue\
    \ - Float(intValue)\n    if diff >= 0.5 {\n        return intValue + 1\n    }\
    \ else {\n        return intValue\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp_drcix4y/tmp_drcix4y.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5c7aadcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5c7a7d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5c7a7d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5c7a7d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_drcix4y                        0x0000560b8ee76512 <unavailable> + 5394

    5    libc.so.6                          0x00002b5c7acc8460 __libc_start_main +
    245

    6    tmp_drcix4y                        0x0000560b8ee76049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  if value.isEmpty {\n        return 0\n    }\n    if let number = Double(value)\
    \ {\n        let roundedNumber = number.rounded()\n        return Int(roundedNumber)\n\
    \    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.5IfD2P/tmpp_c4xp6m-1.o:tmpp_c4xp6m-1.o:function $s11tmpp_c4xp6m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.5IfD2P/tmpp_c4xp6m-1.o:tmpp_c4xp6m-1.o:function $s11tmpp_c4xp6m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.5IfD2P/tmpp_c4xp6m-1.o:tmpp_c4xp6m-1.o:function $s11tmpp_c4xp6m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.5IfD2P/tmpp_c4xp6m-1.o:tmpp_c4xp6m-1.o:function $s11tmpp_c4xp6m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.5IfD2P/tmpp_c4xp6m-1.o:tmpp_c4xp6m-1.o:function $s11tmpp_c4xp6m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.5IfD2P/tmpp_c4xp6m-1.o:tmpp_c4xp6m-1.o:function $s11tmpp_c4xp6m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.5IfD2P/tmpp_c4xp6m-1.o:tmpp_c4xp6m-1.o:function $s11tmpp_c4xp6m15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    if (doubleValue - Double(Int(doubleValue))\
    \ >= 0.5) {\n        return Int(doubleValue) + 1\n    } else {\n        return\
    \ Int(doubleValue)\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6sgnr8f0/tmp6sgnr8f0.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3e425f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3e422edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3e422ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3e422ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6sgnr8f0                        0x00005563963e7512 <unavailable> + 5394

    5    libc.so.6                          0x00002b3e427e2460 __libc_start_main +
    245

    6    tmp6sgnr8f0                        0x00005563963e7049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let num = Double(value)!\n    let intNum = Int(num)\n    let decimalNum = num\
    \ - Double(intNum)\n    return decimalNum >= 0.5 ? intNum + 1 : intNum\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpnqa0n83h/tmpnqa0n83h.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b61d26ffc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b61d23f6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b61d23f6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b61d23f57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnqa0n83h                        0x0000558c37fac512 <unavailable> + 5394

    5    libc.so.6                          0x00002b61d28eb460 __libc_start_main +
    245

    6    tmpnqa0n83h                        0x0000558c37fac049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let val = Double(value)!\n    let intVal = Int(val)\n    if (val-Double(intVal))\
    \ >= 0.5 {\n        return intVal+1\n    } else {\n        return intVal\n   \
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpv8s7vcqn/tmpv8s7vcqn.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adda3568c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adda325fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adda325f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adda325e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv8s7vcqn                        0x0000557b974cc512 <unavailable> + 5394

    5    libc.so.6                          0x00002adda3754460 __libc_start_main +
    245

    6    tmpv8s7vcqn                        0x0000557b974cc049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let integer_number = Int(number)\n    let\
    \ decimal_number = number - Double(integer_number)\n    if decimal_number > 0.5\
    \ {\n        return integer_number + 1\n    } else if decimal_number < -0.5 {\n\
    \        return integer_number - 1\n    } else {\n        return integer_number\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp95mx5ywx/tmp95mx5ywx.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af7b7247c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7b6f3eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7b6f3e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7b6f3d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp95mx5ywx                        0x000055f4142f546b <unavailable> + 5227

    5    libc.so.6                          0x00002af7b7433460 __libc_start_main +
    245

    6    tmp95mx5ywx                        0x000055f4142f5049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp6o4n022c/tmp6o4n022c.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b84da389c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b84da080b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b84da080988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b84da07f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6o4n022c                        0x000055f7a5678264 <unavailable> + 4708

    5    libc.so.6                          0x00002b84da575460 __libc_start_main +
    245

    6    tmp6o4n022c                        0x000055f7a5677ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  \n    let doubleValue = Double(value)\n    var intValue = Int(value)\n    \n\
    \    guard let firstValue = doubleValue, let secondValue = intValue else { return\
    \ 0 }\n    \n    let firstRemainder = firstValue.truncatingRemainder(dividingBy:\
    \ 1)\n    let secondRemainder = secondValue.truncatingRemainder(dividingBy: 1)\n\
    \    \n    if firstRemainder > 0.5 {\n        intValue = intValue + 1\n    } else\
    \ if firstRemainder < -0.5 {\n        intValue = intValue - 1\n    } else if firstRemainder\
    \ == 0.5 || firstRemainder == -0.5 {\n        if secondRemainder > 0 {\n     \
    \       intValue = intValue + 1\n        } else if secondRemainder < 0 {\n   \
    \         intValue = intValue - 1\n        }\n    }\n    \n    return intValue\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp0zi7r_fp.swift:23:39: error: value of type 'Int' has no member\
    \ 'truncatingRemainder'\n    let secondRemainder = secondValue.truncatingRemainder(dividingBy:\
    \ 1)\n                          ~~~~~~~~~~~ ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp0zi7r_fp.swift:26:20:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        intValue = intValue + 1\n                   ^\n/tmp/tmp0zi7r_fp.swift:26:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        intValue = intValue + 1\n                   ^\n             \
    \      (        ?? <#default value#>)\n/tmp/tmp0zi7r_fp.swift:26:20: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        intValue\
    \ = intValue + 1\n                   ^\n                           !\n/tmp/tmp0zi7r_fp.swift:28:20:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \        intValue = intValue - 1\n                   ^\n/tmp/tmp0zi7r_fp.swift:28:20:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        intValue = intValue - 1\n                   ^\n             \
    \      (        ?? <#default value#>)\n/tmp/tmp0zi7r_fp.swift:28:20: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        intValue\
    \ = intValue - 1\n                   ^\n                           !\n/tmp/tmp0zi7r_fp.swift:31:24:\
    \ error: value of optional type 'Int?' must be unwrapped to a value of type 'Int'\n\
    \            intValue = intValue + 1\n                       ^\n/tmp/tmp0zi7r_fp.swift:31:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n            intValue = intValue + 1\n                       ^\n     \
    \                  (        ?? <#default value#>)\n/tmp/tmp0zi7r_fp.swift:31:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n            intValue = intValue + 1\n                       ^\n     \
    \                          !\n/tmp/tmp0zi7r_fp.swift:33:24: error: value of optional "
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleVal = Double(value)\n    return doubleVal != nil ? Int(floor(doubleVal!))\
    \ : 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpze9_haul.swift:17:35: error: cannot find 'floor' in scope\n   \
    \ return doubleVal != nil ? Int(floor(doubleVal!)) : 0\n                     \
    \             ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    return Int(number + 0.5)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpiaqyrj8h/tmpiaqyrj8h.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7deb911c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7deb608b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7deb608988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7deb6077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiaqyrj8h                        0x000055f087cf3512 <unavailable> + 5394

    5    libc.so.6                          0x00002b7debafd460 __libc_start_main +
    245

    6    tmpiaqyrj8h                        0x000055f087cf3049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    if number.isInteger {\n        return Int(number)\n\
    \    }\n    return Int(number < 0 ? number - 0.5 : number + 0.5)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3qo9ic0w.swift:17:15: error: value of type 'Double' has no member\
    \ 'isInteger'\n    if number.isInteger {\n       ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let d = Double(value)!\n    if d.truncatingRemainder(dividingBy: 1) == 0 {\n\
    \        return Int(d)\n    }\n    return Int(d > 0 ? floor(d) : ceil(d))\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp_9qsu13r.swift:20:24: error: cannot find 'floor' in scope\n   \
    \ return Int(d > 0 ? floor(d) : ceil(d))\n                       ^~~~~\n/tmp/tmp_9qsu13r.swift:20:35:\
    \ error: cannot find 'ceil' in scope\n    return Int(d > 0 ? floor(d) : ceil(d))\n\
    \                                  ^~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundDoubleValue = Double(round(doubleValue))\n\
    \    return Int(roundDoubleValue)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpb7kgrefy.swift:17:35: error: cannot find 'round' in scope\n   \
    \ let roundDoubleValue = Double(round(doubleValue))\n                        \
    \          ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var number = Int(Double(value)!)\n    let decimal = Double(value)!.truncatingRemainder(dividingBy:\
    \ 1)\n    if decimal > 0.5 {\n        number += 1\n    } else if decimal < -0.5\
    \ {\n        number -= 1\n    }\n    return number\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp_wbsoyo7/tmp_wbsoyo7.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e768adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e765a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e765a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e765a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_wbsoyo7                        0x00005609d7a4054b <unavailable> + 5451

    5    libc.so.6                          0x00002b6e76a99460 __libc_start_main +
    245

    6    tmp_wbsoyo7                        0x00005609d7a40129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let ceilValue = ceil(value)\n    let floorValue\
    \ = floor(value)\n    if ceilValue - value > value - floorValue {\n        return\
    \ Int(floorValue)\n    } else {\n        return Int(ceilValue)\n    }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmps2vcyq0y.swift:17:21: error: cannot find 'ceil' in scope\n    let\
    \ ceilValue = ceil(value)\n                    ^~~~\n/tmp/tmps2vcyq0y.swift:18:22:\
    \ error: cannot find 'floor' in scope\n    let floorValue = floor(value)\n   \
    \                  ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var num = Double(value) ?? 0\n    num = num < 0 ? num - 0.5 : num + 0.5\n \
    \   return Int(num)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.up))\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.RuNyDW/tmpcbl022sa-1.o:tmpcbl022sa-1.o:function $s11tmpcbl022sa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.RuNyDW/tmpcbl022sa-1.o:tmpcbl022sa-1.o:function $s11tmpcbl022sa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.RuNyDW/tmpcbl022sa-1.o:tmpcbl022sa-1.o:function $s11tmpcbl022sa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.RuNyDW/tmpcbl022sa-1.o:tmpcbl022sa-1.o:function $s11tmpcbl022sa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.RuNyDW/tmpcbl022sa-1.o:tmpcbl022sa-1.o:function $s11tmpcbl022sa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.RuNyDW/tmpcbl022sa-1.o:tmpcbl022sa-1.o:function $s11tmpcbl022sa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.RuNyDW/tmpcbl022sa-1.o:tmpcbl022sa-1.o:function $s11tmpcbl022sa15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueNum = (value as NSString).doubleValue\n    return Int(floor(valueNum\
    \ + 0.5))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpqbvk2z5x.swift:16:30: error: cannot find type 'NSString' in scope\n\
    \    let valueNum = (value as NSString).doubleValue\n                        \
    \     ^~~~~~~~\n/tmp/tmpqbvk2z5x.swift:16:40: error: value of type 'String' has\
    \ no member 'doubleValue'\n    let valueNum = (value as NSString).doubleValue\n\
    \                   ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmpqbvk2z5x.swift:17:16:\
    \ error: cannot find 'floor' in scope\n    return Int(floor(valueNum + 0.5))\n\
    \               ^~~~~\n"
  stdout: ''
  timestamp: 1660014221
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // your code here\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpbvou3005/tmpbvou3005.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab5c61f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab5c5eeab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab5c5eea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab5c5ee97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbvou3005                        0x00005619c229d264 <unavailable> + 4708

    5    libc.so.6                          0x00002ab5c63df460 __libc_start_main +
    245

    6    tmpbvou3005                        0x00005619c229cee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014220
- exit_code: 0
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    if number >= 0 {\n        return Int(number\
    \ + 0.5)\n    } else {\n        return Int(number - 0.5)\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let doubleValue = Double(value)!\n    let roundValue = round(doubleValue)\n\
    \    let floorValue = floor(doubleValue)\n    let ceilValue = ceil(doubleValue)\n\
    \    if abs(doubleValue - floorValue) == abs(doubleValue - ceilValue) {\n    \
    \    return (doubleValue > 0) ? Int(ceilValue) : Int(floorValue)\n    }\n    return\
    \ (doubleValue - roundValue >= 0) ? Int(ceilValue) : Int(floorValue)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpvmyc02qm.swift:17:22: error: cannot find 'round' in scope\n   \
    \ let roundValue = round(doubleValue)\n                     ^~~~~\n/tmp/tmpvmyc02qm.swift:18:22:\
    \ error: cannot find 'floor' in scope\n    let floorValue = floor(doubleValue)\n\
    \                     ^~~~~\n/tmp/tmpvmyc02qm.swift:19:21: error: cannot find\
    \ 'ceil' in scope\n    let ceilValue = ceil(doubleValue)\n                   \
    \ ^~~~\n"
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  let\
    \ dotIndex = value.firstIndex(of: \".\")\n  let result = value.replacingOccurrences(of:\
    \ \".\", with: \"\")\n  let number = Double(result)!\n  if value.contains(\".\"\
    ) {\n    if number % 1 < 0.5 {\n      let roundedNumber = String(Int(number))\n\
    \      return Int(roundedNumber)!\n    } else {\n      if dotIndex! == value.startIndex\
    \ {\n        return Int(value.replacingOccurrences(of: \"-\", with: \"\"))! +\
    \ 1\n      } else {\n        return Int(result)! + 1\n      }\n    }\n  } else\
    \ {\n    return Int(value)!\n  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpmo8z790f.swift:17:22: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n  let result = value.replacingOccurrences(of: \".\"\
    , with: \"\")\n               ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmo8z790f.swift:25:26:\
    \ error: value of type 'String' has no member 'replacingOccurrences'\n       \
    \ return Int(value.replacingOccurrences(of: \"-\", with: \"\"))! + 1\n       \
    \            ~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.awayFromZero))\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.QxQyLu/tmppkcsb9oh-1.o:tmppkcsb9oh-1.o:function $s11tmppkcsb9oh15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(round(Double(value)!))\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmppee_2vax.swift:16:16: error: cannot find 'round' in scope\n   \
    \ return Int(round(Double(value)!))\n               ^~~~~\n"
  stdout: ''
  timestamp: 1660014220
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = (value as NSString).doubleValue\n    return number > 0 ? Int(number\
    \ + 0.5) : Int(number - 0.5)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmp3w6vwi_2.swift:16:28: error: cannot find type 'NSString' in scope\n\
    \    let number = (value as NSString).doubleValue\n                          \
    \ ^~~~~~~~\n/tmp/tmp3w6vwi_2.swift:16:38: error: value of type 'String' has no\
    \ member 'doubleValue'\n    let number = (value as NSString).doubleValue\n   \
    \              ~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  if\
    \ let result = Double(value).flatMap(Int.init) {\n    return result\n  } else\
    \ {\n    return Int(Double(value)!.rounded(.awayFromZero))\n  }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tFSiSgSdcfu_:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tFSiSgSdcfu_:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tFSiSgSdcfu_:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tFSiSgSdcfu_:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:tmpc21kdicd-1.o:function $s11tmpc21kdicd15closest_integer5valueSiSS_tFSiSgSdcfu_:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.hnese9/tmpc21kdicd-1.o:t'
  stdout: ''
  timestamp: 1660014222
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    let new_value = Int(value)\n    return new_value\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmp7rxwybld/tmp7rxwybld.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef2f9c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef2f6bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef2f6bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef2f6bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7rxwybld                        0x0000555b4e31b46b <unavailable> + 5227

    5    libc.so.6                          0x00002aef2fbb2460 __libc_start_main +
    245

    6    tmp7rxwybld                        0x0000555b4e31b049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014222
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let number = Double(value)!\n    let numberToInt = Int(number)\n    if number\
    \ == Double(numberToInt) {\n        return numberToInt\n    } else if number -\
    \ Double(numberToInt) < 0.5 {\n        return numberToInt\n    } else {\n    \
    \    return numberToInt + 1\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: Exception
  stderr: 'tmpa_7l20l6/tmpa_7l20l6.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca41c4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca3ebbb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca3ebb988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca3eba7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa_7l20l6                        0x000055a2bcefd512 <unavailable> + 5394

    5    libc.so.6                          0x00002b8ca43b0460 __libc_start_main +
    245

    6    tmpa_7l20l6                        0x000055a2bcefd049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let value = Double(value)!\n    return Int(value.rounded(.awayFromZero))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.kiEBTc/tmpwwz2z7y_-1.o:tmpwwz2z7y_-1.o:function $s11tmpwwz2z7y_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.kiEBTc/tmpwwz2z7y_-1.o:tmpwwz2z7y_-1.o:function $s11tmpwwz2z7y_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.kiEBTc/tmpwwz2z7y_-1.o:tmpwwz2z7y_-1.o:function $s11tmpwwz2z7y_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.kiEBTc/tmpwwz2z7y_-1.o:tmpwwz2z7y_-1.o:function $s11tmpwwz2z7y_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.kiEBTc/tmpwwz2z7y_-1.o:tmpwwz2z7y_-1.o:function $s11tmpwwz2z7y_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.kiEBTc/tmpwwz2z7y_-1.o:tmpwwz2z7y_-1.o:function $s11tmpwwz2z7y_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.kiEBTc/tmpwwz2z7y_-1.o:tmpwwz2z7y_-1.o:function $s11tmpwwz2z7y_15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014222
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp4lfv5097/tmp4lfv5097.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7d9360c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7d9057b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7d9057988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7d90567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4lfv5097                        0x000055675bb79264 <unavailable> + 4708

    5    libc.so.6                          0x00002ad7d954c460 __libc_start_main +
    245

    6    tmp4lfv5097                        0x000055675bb78ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660014222
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var rounded_value = Int(Double(value)!)\n    let rv = Double(value)!\n    let\
    \ ci = Double(rounded_value)\n    if ci < rv {\n        rounded_value += 1\n \
    \   }\n    return rounded_value\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmp8425oh_d/tmp8425oh_d.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b198594dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1985644b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1985644988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b19856437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8425oh_d                        0x0000555a9c72a512 <unavailable> + 5394

    5    libc.so.6                          0x00002b1985b39460 __libc_start_main +
    245

    6    tmp8425oh_d                        0x0000555a9c72a049 <unavailable> + 4169

    '
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  let\
    \ value = Double(value)!\n  let convert_floor_to_int = Int(floor(value))\n  let\
    \ convert_ceil_to_int = Int(ceil(value))\n  let convert_abs_floor_to_int = abs(convert_floor_to_int)\n\
    \  let convert_abs_ceil_to_int = abs(convert_ceil_to_int)\n  let convert_diff_floor_ceil_to_double\
    \ = Double(convert_abs_floor_to_int - convert_abs_ceil_to_int)\n  let convert_diff_floor_ceil_to_int\
    \ = Int(convert_diff_floor_ceil_to_double)\n  let abs_convert_diff_floor_ceil_to_int\
    \ = abs(convert_diff_floor_ceil_to_int)\n  let diff_floor_value = abs(convert_floor_to_int\
    \ - value)\n  let diff_ceil_value = abs(convert_ceil_to_int - value)\n  if abs_convert_diff_floor_ceil_to_int\
    \ == 0 {\n    return convert_ceil_to_int\n  } else if diff_floor_value == diff_ceil_value\
    \ {\n    return convert_ceil_to_int\n  } else if diff_floor_value < diff_ceil_value\
    \ {\n    return convert_floor_to_int\n  } else {\n    return convert_ceil_to_int\n\
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(closest_integer(value: \"10\"\
    ) == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpg1tiw_pv.swift:17:34: error: cannot find 'floor' in scope\n  let\
    \ convert_floor_to_int = Int(floor(value))\n                                 ^~~~~\n\
    /tmp/tmpg1tiw_pv.swift:18:33: error: cannot find 'ceil' in scope\n  let convert_ceil_to_int\
    \ = Int(ceil(value))\n                                ^~~~\n/tmp/tmpg1tiw_pv.swift:21:43:\
    \ error: no exact matches in call to initializer \n  let convert_diff_floor_ceil_to_double\
    \ = Double(convert_abs_floor_to_int - convert_abs_ceil_to_int)\n             \
    \                             ^\n/tmp/tmpg1tiw_pv.swift:21:43: note: found candidate\
    \ with type '(Builtin.FPIEEE64) -> Double'\n  let convert_diff_floor_ceil_to_double\
    \ = Double(convert_abs_floor_to_int - convert_abs_ceil_to_int)\n             \
    \                             ^\n/tmp/tmpg1tiw_pv.swift:21:43: note: found candidate\
    \ with type '(Substring) -> Double?'\n  let convert_diff_floor_ceil_to_double\
    \ = Double(convert_abs_floor_to_int - convert_abs_ceil_to_int)\n             \
    \                             ^\n/tmp/tmpg1tiw_pv.swift:21:43: note: found candidate\
    \ with type '(Int) -> Double'\n  let convert_diff_floor_ceil_to_double = Double(convert_abs_floor_to_int\
    \ - convert_abs_ceil_to_int)\n                                          ^\n/tmp/tmpg1tiw_pv.swift:21:43:\
    \ note: found candidate with type '(Float16) -> Double'\n  let convert_diff_floor_ceil_to_double\
    \ = Double(convert_abs_floor_to_int - convert_abs_ceil_to_int)\n             \
    \                             ^\n/tmp/tmpg1tiw_pv.swift:21:43: note: found candidate\
    \ with type '(Float) -> Double'\n  let convert_diff_floor_ceil_to_double = Double(convert_abs_floor_to_int\
    \ - convert_abs_ceil_to_int)\n                                          ^\n/tmp/tmpg1tiw_pv.swift:21:43:\
    \ note: found candidate with type '(Double) -> Double'\n  let convert_diff_floor_ceil_to_double\
    \ = Double(convert_abs_floor_to_int - convert_abs_ceil_to_int)\n             \
    \                             ^\n/tmp/tmpg1tiw_pv.swift:21:43: note: found candidate\
    \ with type '(Float80) -> Double'\n  let convert_diff_floor_ceil_to_double = Double(convert_abs_fl"
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(Double(value)!.rounded(.toNearestOrAwayFromZero))\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: 'error: link command failed with exit code 1 (use -v to see invocation)

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''round''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''rint''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''trunc''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''floor''

    /tmp/TemporaryDirectory.YzL6cj/tmphocgforj-1.o:tmphocgforj-1.o:function $s11tmphocgforj15closest_integer5valueSiSS_tF:
    error: undefined reference to ''ceil''

    clang-13: error: linker command failed with exit code 1 (use -v to see invocation)

    '
  stdout: ''
  timestamp: 1660014131
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  var number = Double(value) ?? 0\n    if number < 0 {\n        number = -number\n\
    \    }\n    if number.truncatingRemainder(dividingBy: 1) >= 0.5 {\n        number\
    \ = ceil(number)\n    } else {\n        number = floor(number)\n    }\n    if\
    \ value.first == \"-\" {\n        number = -number\n    }\n    return Int(number)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpl4a94lue.swift:21:18: error: cannot find 'ceil' in scope\n    \
    \    number = ceil(number)\n                 ^~~~\n/tmp/tmpl4a94lue.swift:23:18:\
    \ error: cannot find 'floor' in scope\n        number = floor(number)\n      \
    \           ^~~~~\n"
  stdout: ''
  timestamp: 1660014222
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  let valueDouble = Double(value)\n    let nearestDouble = rint(valueDouble!)\n\
    \    let nearestInt = Int(nearestDouble)\n    return nearestInt\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value:\
    \ \"14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpo69dmaum.swift:17:25: error: cannot find 'rint' in scope\n    let\
    \ nearestDouble = rint(valueDouble!)\n                        ^~~~\n"
  stdout: ''
  timestamp: 1660014222
- exit_code: -4
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  return Int(value)!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(closest_integer(value:\
    \ \"10\") == 10)\nassert(closest_integer(value: \"14.5\") == 15)\nassert(closest_integer(value:\
    \ \"-15.5\") == -16)\nassert(closest_integer(value: \"15.3\") == 15)\nassert(closest_integer(value:\
    \ \"0\") == 0)"
  status: Exception
  stderr: 'tmpd8a3g9ft/tmpd8a3g9ft.swift:16: Fatal error: Unexpectedly found nil while
    unwrapping an Optional value

    Current stack trace:

    0    libswiftCore.so                    0x00002b9ae3a62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9ae3759561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9ae3759286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9ae375913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9ae3758bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpd8a3g9ft                        0x0000559d5b19c75a <unavailable> + 5978

    6    tmpd8a3g9ft                        0x0000559d5b19c3dd <unavailable> + 5085

    7    libc.so.6                          0x00002b9ae3c4e460 __libc_start_main +
    245

    8    tmpd8a3g9ft                        0x0000559d5b19c039 <unavailable> + 4153

    '
  stdout: ''
  timestamp: 1660014042
- exit_code: 1
  program: "\n/// Create a function that takes a value (string) representing a number\n\
    /// and returns the closest integer to it. If the number is equidistant\n/// from\
    \ two integers, round it away from zero.\n/// Examples\n/// >>> closest_integer(value:\
    \ \"10\")\n/// 10\n/// >>> closest_integer(value: \"15.3\")\n/// 15\n/// Note:\n\
    /// Rounding away from zero means that if the given number is equidistant\n///\
    \ from two integers, the one you should return is the one that is the\n/// farthest\
    \ from zero. For example closest_integer(\"14.5\") should\n/// return 15 and closest_integer(\"\
    -14.5\") should return -15.\nfunc closest_integer(value: String) -> Int {\n  \
    \  // your code goes here...\n    var strDouble = Double(value)\n    if let strDouble\
    \ = strDouble {\n        if strDouble >= 0 {\n            if strDouble.truncatingRemainder(dividingBy:\
    \ 1) >= 0.5 {\n                strDouble = ceil(strDouble)\n            } else\
    \ {\n                strDouble = floor(strDouble)\n            }\n        } else\
    \ {\n            if strDouble.truncatingRemainder(dividingBy: 1) <= -0.5 {\n \
    \               strDouble = ceil(strDouble)\n            } else {\n          \
    \      strDouble = floor(strDouble)\n            }\n        }\n        return\
    \ Int(strDouble)\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(closest_integer(value: \"10\") == 10)\nassert(closest_integer(value: \"\
    14.5\") == 15)\nassert(closest_integer(value: \"-15.5\") == -16)\nassert(closest_integer(value:\
    \ \"15.3\") == 15)\nassert(closest_integer(value: \"0\") == 0)"
  status: SyntaxError
  stderr: "/tmp/tmpx_rhuobo.swift:21:29: error: cannot find 'ceil' in scope\n    \
    \            strDouble = ceil(strDouble)\n                            ^~~~\n/tmp/tmpx_rhuobo.swift:21:17:\
    \ error: cannot assign to value: 'strDouble' is a 'let' constant\n           \
    \     strDouble = ceil(strDouble)\n                ^~~~~~~~~\n/tmp/tmpx_rhuobo.swift:23:29:\
    \ error: cannot find 'floor' in scope\n                strDouble = floor(strDouble)\n\
    \                            ^~~~~\n/tmp/tmpx_rhuobo.swift:23:17: error: cannot\
    \ assign to value: 'strDouble' is a 'let' constant\n                strDouble\
    \ = floor(strDouble)\n                ^~~~~~~~~\n/tmp/tmpx_rhuobo.swift:27:29:\
    \ error: cannot find 'ceil' in scope\n                strDouble = ceil(strDouble)\n\
    \                            ^~~~\n/tmp/tmpx_rhuobo.swift:27:17: error: cannot\
    \ assign to value: 'strDouble' is a 'let' constant\n                strDouble\
    \ = ceil(strDouble)\n                ^~~~~~~~~\n/tmp/tmpx_rhuobo.swift:29:29:\
    \ error: cannot find 'floor' in scope\n                strDouble = floor(strDouble)\n\
    \                            ^~~~~\n/tmp/tmpx_rhuobo.swift:29:17: error: cannot\
    \ assign to value: 'strDouble' is a 'let' constant\n                strDouble\
    \ = floor(strDouble)\n                ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014222
