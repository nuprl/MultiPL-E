language: swift
name: HumanEval_59_largest_prime_factor
results:
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var lastFactor\
    \ = 1\n    var target = n\n    if target % 2 == 0 {\n        lastFactor = 2\n\
    \        while target % 2 == 0 {\n            target /= 2\n        }\n    }\n\
    \    var factor = 3\n    var maxFactor = Int(sqrt(Double(target)))\n    while\
    \ target > 1 && factor <= maxFactor {\n        if target % factor == 0 {\n   \
    \         target /= factor\n            lastFactor = factor\n            while\
    \ target % factor == 0 {\n                target /= factor\n            }\n  \
    \          maxFactor = Int(sqrt(Double(target)))\n        }\n        factor +=\
    \ 2\n    }\n    if target == 1 {\n        return lastFactor\n    } else {\n  \
    \      return target\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpffbsag2e.swift:17:25: error: cannot find 'sqrt' in scope\n    var\
    \ maxFactor = Int(sqrt(Double(target)))\n                        ^~~~\n/tmp/tmpffbsag2e.swift:25:29:\
    \ error: cannot find 'sqrt' in scope\n            maxFactor = Int(sqrt(Double(target)))\n\
    \                            ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 2\n    var cn = n\n    while cn % 2 == 0 {\n        cn /= 2\n    }\n    for\
    \ i in stride(from: 3, through: n/2, by: 2) {\n        while cn % i == 0 {\n \
    \           largest_prime = i\n            cn /= i\n        }\n    }\n    return\
    \ largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return prime_factors(n:\
    \ n).max()!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpf2v6kcsb.swift:8:12: error: cannot find 'prime_factors' in scope\n\
    \    return prime_factors(n: n).max()!\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if is_prime(n:\
    \ n) {\n        return n\n    }\n    var max = 0\n    var p = primes()\n    while\
    \ n > 1 {\n        if n % p.next()! == 0 {\n            max = p.next()!\n    \
    \        n /= p.next()!\n        }\n    }\n    return max\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp00dgbjfn.swift:8:8: error: cannot find 'is_prime' in scope\n  \
    \  if is_prime(n: n) {\n       ^~~~~~~~\n/tmp/tmp00dgbjfn.swift:12:13: error:\
    \ cannot find 'primes' in scope\n    var p = primes()\n            ^~~~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return largest_prime_factor(n:\
    \ n, from: 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpcxgabyz9.swift:8:45: error: extra argument 'from' in call\n   \
    \ return largest_prime_factor(n: n, from: 2)\n                               ~~~~~~~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i <= n {\n        if is_prime(n: i) && n % i == 0 {\n\
    \            n /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    return i\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpxcvnau8p.swift:11:12: error: cannot find 'is_prime' in scope\n\
    \        if is_prime(n: i) && n % i == 0 {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // TODO\n    return\
    \ 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) ==\
    \ 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmp7xy27n3f/tmp7xy27n3f.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47b9097c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47b8d8eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47b8d8e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47b8d8d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7xy27n3f                        0x0000556d5ae681b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b47b9283460 __libc_start_main +
    245

    6    tmp7xy27n3f                        0x0000556d5ae67e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014151
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var m = n\n  for\
    \ i in 2..<Int(sqrt(Double(n))) {\n    while m % i == 0 {\n      m /= i\n    }\n\
    \  }\n  return m\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpw2js2bge.swift:9:20: error: cannot find 'sqrt' in scope\n  for\
    \ i in 2..<Int(sqrt(Double(n))) {\n                   ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n % 2 == 0\
    \ {\n        return largest_prime_factor(n: n / 2)\n    }\n    for i in stride(from:\
    \ 3, through: Int(sqrt(Double(n))), by: 2) {\n        if n % i == 0 {\n      \
    \      return largest_prime_factor(n: n / i)\n        }\n    }\n    return n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp_kdoe_jk.swift:11:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var f = 2\n    while n > 1 {\n        if n % f == 0 {\n            while n\
    \ % f == 0 {\n                n /= f\n            }\n        }\n        f += 1\n\
    \    }\n    return f - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  let n = n.abs()\n\
    \  let sqrt_n = Int(sqrt(Double(n)))\n  var max_factor = 1\n  var primes = [2]\n\
    \  var i = 3\n  while i <= sqrt_n {\n    let is_prime = !primes.contains { i %\
    \ $0 == 0 }\n    if is_prime {\n      primes.append(i)\n      if n % i == 0 {\n\
    \        max_factor = i\n      }\n    }\n    i += 2\n  }\n  return max_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp883ivmsq.swift:8:13: error: value of type 'Int' has no member 'abs'\n\
    \  let n = n.abs()\n          ~ ^~~\n/tmp/tmp883ivmsq.swift:9:20: error: cannot\
    \ find 'sqrt' in scope\n  let sqrt_n = Int(sqrt(Double(n)))\n                \
    \   ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return -1\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpz5t4bnd1/tmpz5t4bnd1.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8c62730c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8c62427b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8c62427988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8c624267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz5t4bnd1                        0x000055a925a1c1b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b8c6291c460 __libc_start_main +
    245

    6    tmpz5t4bnd1                        0x000055a925a1be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014151
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factors =\
    \ [Int]()\n    var current = n\n    for i in 2...n {\n        if current % i ==\
    \ 0 {\n            factors.append(i)\n            current /= i\n        }\n  \
    \  }\n    return factors.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpgebyhdid/tmpgebyhdid.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba05c7aec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba05c4a5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba05c4a5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba05c4a47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgebyhdid                        0x0000560867a8d550 <unavailable> + 5456

    5    libc.so.6                          0x00002ba05c99a460 __libc_start_main +
    245

    6    tmpgebyhdid                        0x0000560867a8d189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014151
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var p = 2\n  \
    \  var r = n\n    while r > 1 {\n        while r % p == 0 {\n            r /=\
    \ p\n        }\n        p += 1\n    }\n    return p - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    assert(n > 1)\n\
    \    var largest = 2\n    for i in (2...n).reversed() {\n        if n % i == 0\
    \ && is_prime(n: i) {\n            largest = i\n            break\n        }\n\
    \    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpejn9ol28.swift:11:26: error: cannot find 'is_prime' in scope\n\
    \        if n % i == 0 && is_prime(n: i) {\n                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if is_prime(n:\
    \ n) {\n        return n\n    }\n    var p = largest_prime_factor(n: n - 1)\n\
    \    while (n % p != 0) {\n        p = largest_prime_factor(n: p - 1)\n    }\n\
    \    return p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpekj58jd4.swift:8:8: error: cannot find 'is_prime' in scope\n  \
    \  if is_prime(n: n) {\n       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var n = n\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n\tvar nn = n\n\tvar\
    \ d = 2\n\tvar factors = [Int]()\n\twhile nn > 1 {\n\t\tif nn % d == 0 {\n\t\t\
    \tfactors.append(d)\n\t\t\tnn /= d\n\t\t} else {\n\t\t\td += 1\n\t\t}\n\t}\n\t\
    return factors.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n % 2 == 0\
    \ {\n        return largest_prime_factor(n: n / 2)\n    }\n    for i in stride(from:\
    \ 3, through: Int(sqrt(Double(n))), by: 2) {\n        if n % i == 0 {\n      \
    \      return largest_prime_factor(n: n / i)\n        }\n    }\n    return n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp_kdoe_jk.swift:11:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var n = n\n  var\
    \ i = 2\n  while i <= n / i {\n    while n % i == 0 {\n      n /= i\n    }\n \
    \   i += 1\n  }\n  return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpfvee8w8p/tmpfvee8w8p.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6eff5a1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6eff298b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6eff298988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6eff2977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfvee8w8p                        0x00005634ee6312c0 <unavailable> + 4800

    5    libc.so.6                          0x00002b6eff78d460 __libc_start_main +
    245

    6    tmpfvee8w8p                        0x00005634ee630ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factors =\
    \ [Int]()\n    var last_factor = 0\n    var quotient = n\n    while true {\n \
    \       if is_prime(n: quotient) {\n            last_factor = quotient\n     \
    \       break\n        }\n        for factor in 2...Int(sqrt(Double(quotient)))\
    \ {\n            if quotient % factor == 0 {\n                factors.append(factor)\n\
    \                quotient /= factor\n                break\n            }\n  \
    \      }\n    }\n    print(factors)\n    return last_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpu2qr119_.swift:12:12: error: cannot find 'is_prime' in scope\n\
    \        if is_prime(n: quotient) {\n           ^~~~~~~~\n/tmp/tmpu2qr119_.swift:16:31:\
    \ error: cannot find 'sqrt' in scope\n        for factor in 2...Int(sqrt(Double(quotient)))\
    \ {\n                              ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n\tif n % 2 == 0 {\n\
    \t\treturn largest_prime_factor(n: n / 2)\n\t}\n\tfor factor in stride(from: 3,\
    \ through: Int(sqrt(Double(n))), by: 2) {\n\t\tif n % factor == 0 {\n\t\t\treturn\
    \ largest_prime_factor(n: n / factor)\n\t\t}\n\t}\n\treturn n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpg7fcgsjk.swift:11:45: error: cannot find 'sqrt' in scope\n    \
    \    for factor in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n \
    \                                                  ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    for prime in prime_generator() {\n        if n % prime\
    \ == 0 {\n            largest = prime\n            while n % prime == 0 {\n  \
    \              n /= prime\n            }\n        }\n        if n == 1 {\n   \
    \         break\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3m9nvr9q.swift:10:18: error: cannot find 'prime_generator' in scope\n\
    \    for prime in prime_generator() {\n                 ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 2\n\
    \    var factors = [Int]()\n    var dividend = n\n    while true {\n        while\
    \ dividend % factor == 0 {\n            factors.append(factor)\n            dividend\
    \ /= factor\n        }\n        factor += 1\n        if factor > dividend {\n\
    \            break\n        }\n    }\n    return factors.max()!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor\
    \ = 1\n    var current_prime = 2\n    var upper_bound = Int(sqrt(Double(n)))\n\
    \    var temp = n\n    while temp > 1 {\n        while temp % current_prime ==\
    \ 0 {\n            temp /= current_prime\n            largest_factor = current_prime\n\
    \        }\n        current_prime += 1\n        if current_prime > upper_bound\
    \ {\n            break\n        }\n    }\n    return largest_factor\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp4j4n0xes.swift:10:27: error: cannot find 'sqrt' in scope\n    var\
    \ upper_bound = Int(sqrt(Double(n)))\n                          ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // is_prime method\
    \ failed for n = 5915587277, where n = 4 * 15 * 5 * 17 * 23 * 29 * 31 * 37 * 41\n\
    \    // so we need to check if n is divisible by each of these prime numbers\n\
    \    // 104743\n    let primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113,\
    \ 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\
    \ 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,\
    \ 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,\
    \ 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\
    \ 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601,\
    \ 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\
    \ 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821,\
    \ 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,\
    \ 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031,\
    \ 1033, 1039, 1049, 1051, 1061\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp_j3k7zu8.swift:11:889: error: expected ']' in container literal\
    \ expression\n    let primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,\
    \ 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\
    \ 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\
    \ 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\
    \ 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,\
    \ 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,\
    \ 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709,\
    \ 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,\
    \ 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,\
    \ 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033,\
    \ 1039, 1049, 1051, 1061\n                                                   \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \ ^\n/tmp/tmp_j3k7zu8.swift:11:18: note: to match this opening '['\n    let primes\
    \ = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97, 101, 103,"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var n = n\n  if\
    \ n % 2 == 0 {\n    n /= 2\n  }\n  for var i = 3; i < Int(sqrt(Double(n))); i\
    \ += 2 {\n    if n % i == 0 {\n      n /= i\n    }\n  }\n  return n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpg155zw_r.swift:12:3: error: C-style for statement has been removed\
    \ in Swift 3\n  for var i = 3; i < Int(sqrt(Double(n))); i += 2 {\n  ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    for i in stride(from:\
    \ Int(sqrt(Double(n))), through: 2, by: -1) {\n        if n % i == 0 && is_prime(n:\
    \ i) {\n            return i\n        }\n    }\n    return 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpy4wwgrrh.swift:8:31: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: Int(sqrt(Double(n))), through: 2, by: -1) {\n            \
    \                  ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n\
    \            largest = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var divisor = 2\n    while n > 1 {\n        while n % divisor == 0 {\n    \
    \        n /= divisor\n        }\n        divisor += 1\n    }\n    return divisor\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    for i in 2..<n\
    \ {\n        if n % i == 0 {\n            return largest_prime_factor(n: n / i)\n\
    \        }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let half = Int(ceil(sqrt(Double(n))))\n\
    \    for p in 2...half {\n        if n % p == 0 {\n            return largest_prime_factor(n:\
    \ n / p)\n        }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpnhje9qvs.swift:8:20: error: cannot find 'ceil' in scope\n    let\
    \ half = Int(ceil(sqrt(Double(n))))\n                   ^~~~\n/tmp/tmpnhje9qvs.swift:8:25:\
    \ error: cannot find 'sqrt' in scope\n    let half = Int(ceil(sqrt(Double(n))))\n\
    \                        ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var primes = [Int]()\n\
    \    var p = 2\n    var m = n\n    while m > 1 {\n        while m % p == 0 {\n\
    \            primes.append(p)\n            m /= p\n        }\n        p += 1\n\
    \    }\n    return primes.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i <= n / i {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    for var i = 2;\
    \ i <= n; ++i {\n        if n % i == 0 {\n            var p = n / i\n        \
    \    if is_prime(p) {\n                return p\n            }\n        }\n  \
    \  }\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp1_gokqak.swift:8:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i <= n; ++i {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var x = 2\n  \
    \  var largest = 0\n    while x <= n {\n        if (n % x == 0) {\n          \
    \  largest = x\n            n /= x\n        } else {\n            x += 1\n   \
    \     }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp5kooldun.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= x\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var primes = [Int]()\n\
    \    var remaining = n\n    var next_prime = 2\n    while remaining > 1 {\n  \
    \      if remaining % next_prime == 0 {\n            primes.append(next_prime)\n\
    \            remaining /= next_prime\n        } else {\n            next_prime\
    \ += 1\n        }\n    }\n    return primes.last!\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var p = 2\n    while n > 1 {\n        if n % p == 0 {\n           \
    \ largest_prime_factor = p\n            n /= p\n        } else {\n           \
    \ p += 1\n        }\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpmh0upcao.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= p\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // TODO: implement\
    \ the function\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpme0cr069/tmpme0cr069.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b221c771c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b221c468b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b221c468988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b221c4677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpme0cr069                        0x000055badf0f21b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b221c95d460 __libc_start_main +
    245

    6    tmpme0cr069                        0x000055badf0f1e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var divisor =\
    \ 2\n    var result = 0\n    while (n > 1) {\n        if (n % divisor == 0) {\n\
    \            n /= divisor\n            result = divisor\n        } else {\n  \
    \          divisor += 1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp0r4oly3a.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= divisor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var prime = 2\n    while n % prime != 0 {\n        prime += 1\n    }\n    while\
    \ n % prime == 0 {\n        n /= prime\n    }\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmptbkygd8l/tmptbkygd8l.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab9b601ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab9b5d11b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab9b5d11988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab9b5d107b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptbkygd8l                        0x000055d0d702b2c0 <unavailable> + 4800

    5    libc.so.6                          0x00002ab9b6206460 __libc_start_main +
    245

    6    tmptbkygd8l                        0x000055d0d702aef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let factors =\
    \ prime_factors(n: n)\n    return factors[factors.count - 1]\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpgscjkw82.swift:8:19: error: cannot find 'prime_factors' in scope\n\
    \    let factors = prime_factors(n: n)\n                  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var k = n / 2\n\
    \    for i in (2...k).reversed() {\n        if n % i == 0 && is_prime(n: i) {\n\
    \            return i\n        }\n    }\n    return 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmptt19usp1.swift:10:26: error: cannot find 'is_prime' in scope\n\
    \        if n % i == 0 && is_prime(n: i) {\n                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 0\n    let n = n\n    if n == 2 {\n        return n\n    }\n    for i in 2...n\
    \ {\n        if n % i == 0 {\n            if is_prime(n: i) {\n              \
    \  largest_prime = i\n            }\n        }\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpv33z0euo.swift:15:16: error: cannot find 'is_prime' in scope\n\
    \            if is_prime(n: i) {\n               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest =\
    \ 0\n    for i in stride(from: 2, through: n/2, by: 1) {\n        if n % i ==\
    \ 0 {\n            if is_prime(n: i) {\n                largest = i\n        \
    \    }\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmprpj358_b.swift:11:16: error: cannot find 'is_prime' in scope\n\
    \            if is_prime(n: i) {\n               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let max = Int(ceil(sqrt(Double(n))))\n\
    \    var largest = 0\n    for i in 2...max {\n        if n % i == 0 {\n      \
    \      largest = i\n            break\n        }\n    }\n    if largest > 0 {\n\
    \        return largest_prime_factor(n: n / largest)\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpmqzf8n8l.swift:8:19: error: cannot find 'ceil' in scope\n    let\
    \ max = Int(ceil(sqrt(Double(n))))\n                  ^~~~\n/tmp/tmpmqzf8n8l.swift:8:24:\
    \ error: cannot find 'sqrt' in scope\n    let max = Int(ceil(sqrt(Double(n))))\n\
    \                       ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // TODO: Implement.\n\
    \    var r = n\n    var i = 2\n    while r > 1 {\n        if r % i == 0 {\n  \
    \          r /= i\n        } else {\n            i += 1\n        }\n    }\n  \
    \  return i\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let sqrtn = Int(sqrt(Double(n)))\n\
    \    for i in stride(from: sqrtn, through: 2, by: -1) {\n        if n % i == 0\
    \ && is_prime(i) {\n            return i\n        }\n    }\n    return 1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpmt6bwgfi.swift:8:21: error: cannot find 'sqrt' in scope\n    let\
    \ sqrtn = Int(sqrt(Double(n)))\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 0\n    while n % 2 == 0 {\n        largest = 2\n        n /=\
    \ 2\n    }\n    for i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2)\
    \ {\n        while n % i == 0 {\n            largest = i\n            n /= i\n\
    \        }\n    }\n    if n > 2 {\n        largest = n\n    }\n    return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpjhwpkiu_.swift:14:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    for var i = 2;\
    \ i < n; i++ {\n        if n % i == 0 {\n            return largest_prime_factor(n/i)\n\
    \        }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmplrw2zege.swift:8:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = 2; i < n; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var factors = prime_factors(n:\
    \ n)\n  return factors[factors.count - 1]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpry3he7p1.swift:8:17: error: cannot find 'prime_factors' in scope\n\
    \  var factors = prime_factors(n: n)\n                ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var primes = [2]\n\
    \    var factors = [Int]()\n    var n = n\n    while n > 1 {\n        var new_prime\
    \ = true\n        for p in primes {\n            if n % p == 0 {\n           \
    \     factors.append(p)\n                n /= p\n                new_prime = false\n\
    \                break\n            }\n        }\n        if new_prime {\n   \
    \         let p = primes.last! + 1\n            while !is_prime(n: p) {\n    \
    \            primes.append(p)\n            }\n        }\n    }\n    return factors.max()!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmps_zxc4zn.swift:23:20: error: cannot find 'is_prime' in scope\n\
    \            while !is_prime(n: p) {\n                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var max_factor\
    \ = 2\n    var num = n\n    while num % 2 == 0 {\n        num /= 2\n    }\n  \
    \  var factor = 3\n    while Double(factor) * Double(factor) <= Double(num) {\n\
    \        if num % factor == 0 {\n            num /= factor\n            max_factor\
    \ = factor\n        } else {\n            factor += 2\n        }\n    }\n    if\
    \ num > 2 {\n        max_factor = num\n    }\n    return max_factor\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while n != 1 {\n        if n % i == 0 {\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    return i\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n % 2 == 0\
    \ {\n        return largest_prime_factor(n: n / 2)\n    }\n    var i = 3\n   \
    \ while i <= sqrt(n) {\n        if n % i == 0 {\n            return largest_prime_factor(n:\
    \ n / i)\n        }\n        i += 2\n    }\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpwahgcbbn.swift:12:16: error: cannot find 'sqrt' in scope\n    while\
    \ i <= sqrt(n) {\n               ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return factors(n:\
    \ n).filter(is_prime).last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpzydu9fad.swift:8:12: error: cannot find 'factors' in scope\n  \
    \  return factors(n: n).filter(is_prime).last!\n           ^~~~~~~\n/tmp/tmpzydu9fad.swift:8:33:\
    \ error: cannot find 'is_prime' in scope\n    return factors(n: n).filter(is_prime).last!\n\
    \                                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    assert(n > 1)\n\
    \    var prime_factors = [Int]()\n    var n = n\n    for x in 2..<n {\n      \
    \  if n % x == 0 {\n            n /= x\n            prime_factors.append(x)\n\
    \        }\n    }\n    assert(prime_factors.count > 0)\n    return prime_factors.last!\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpf1y9pt8m/tmpf1y9pt8m.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf31aabc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf317a2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf317a2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf317a17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf1y9pt8m                        0x000055bb61a405a0 <unavailable> + 5536

    5    libc.so.6                          0x00002acf31c97460 __libc_start_main +
    245

    6    tmpf1y9pt8m                        0x000055bb61a401d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 1\n\
    \    var dividend = n\n    while dividend % 2 == 0 {\n        factor = 2\n   \
    \     dividend /= 2\n    }\n    let limit = Int(sqrt(Double(dividend)))\n    var\
    \ i = 3\n    while i <= limit {\n        if dividend % i == 0 {\n            factor\
    \ = i\n            dividend /= i\n        } else {\n            i += 2\n     \
    \   }\n    }\n    if dividend > 2 {\n        factor = dividend\n    }\n    return\
    \ factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp9limgzcv.swift:14:21: error: cannot find 'sqrt' in scope\n    let\
    \ limit = Int(sqrt(Double(dividend)))\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var product = 1\n    while i <= n {\n        // special case for 2\n      \
    \  if n % i == 0 {\n            product *= i\n            if product == n {\n\
    \                return i\n            }\n        }\n        // special case for\
    \ odd numbers\n        if i == 2 {\n            i += 1\n        } else {\n   \
    \         i += 2\n        }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmph_t30py8/tmph_t30py8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4636c54c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b463694bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b463694b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b463694a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph_t30py8                        0x000055863ddfe2c0 <unavailable> + 4800

    5    libc.so.6                          0x00002b4636e40460 __libc_start_main +
    245

    6    tmph_t30py8                        0x000055863ddfdef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    assert(n > 1)\n\
    \    var r = n\n    var i = 2\n    while r > 1 {\n        while r % i == 0 {\n\
    \            r /= i\n        }\n        i += 1\n    }\n    return i - 1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var prime_factors\
    \ = [Int]()\n    var num = n\n    var factor = 2\n    while factor <= num {\n\
    \        if num % factor == 0 {\n            prime_factors.append(factor)\n  \
    \          num /= factor\n        } else {\n            factor += 1\n        }\n\
    \    }\n    return prime_factors.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let n = n\n  \
    \  var factor = 2\n    while n > 1 {\n        if n % factor == 0 {\n         \
    \   n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp8r7mi1lb.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmp8r7mi1lb.swift:8:5: note: change 'let' to 'var' to make it mutable\n \
    \   let n = n\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var prime_factors = [Int]()\n    let primes = primes_up_to(n: n)\n    while\
    \ primes.last! < n {\n        let largest_prime = primes.last!\n        if n %\
    \ largest_prime == 0 {\n            prime_factors.append(largest_prime)\n    \
    \        n /= largest_prime\n        }\n    }\n    return n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpdvbza4sm.swift:10:18: error: cannot find 'primes_up_to' in scope\n\
    \    let primes = primes_up_to(n: n)\n                 ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let p = smallest_prime_factor(n:\
    \ n)\n    if n == p {\n        return n\n    }\n    return largest_prime_factor(n:\
    \ n / p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp9msmbefd.swift:8:13: error: cannot find 'smallest_prime_factor'\
    \ in scope\n    let p = smallest_prime_factor(n: n)\n            ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    for p in 2...n\
    \ {\n        if n % p == 0 {\n            return largest_prime_factor(n: n / p)\n\
    \        }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'Swift/ClosedRange.swift:347: Fatal error: Range requires lowerBound <=
    upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002af6f1223c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af6f0f1a561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002af6f0f1a286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002af6f0f1a13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002af6f0f19bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpgfu6h8fz                        0x000055fd54768619 <unavailable> + 5657

    6    tmpgfu6h8fz                        0x000055fd5476881a <unavailable> + 6170

    7    tmpgfu6h8fz                        0x000055fd5476881a <unavailable> + 6170

    8    tmpgfu6h8fz                        0x000055fd547682c8 <unavailable> + 4808

    9    libc.so.6                          0x00002af6f140f460 __libc_start_main +
    245

    10   tmpgfu6h8fz                        0x000055fd54767fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let sqrtN = Int(sqrt(Double(n)))\n\
    \    for i in stride(from: sqrtN, through: 2, by: -1) {\n        if n % i == 0\
    \ && is_prime(i) {\n            return i\n        }\n    }\n    return n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpbe4v1omg.swift:8:21: error: cannot find 'sqrt' in scope\n    let\
    \ sqrtN = Int(sqrt(Double(n)))\n                    ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var number = n\n\
    \    var divisor = 2\n    while number > 1 {\n        while number % divisor ==\
    \ 0 {\n            number /= divisor\n        }\n        divisor += 1\n    }\n\
    \    return divisor - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var prime = 2\n\
    \    var divisor = 2\n    var quotient = n\n    while (divisor * divisor <= quotient)\
    \ {\n        if (quotient % divisor == 0) {\n            prime = divisor\n   \
    \         quotient /= divisor\n        } else {\n            divisor += 1\n  \
    \      }\n    }\n    if (quotient > prime) {\n        prime = quotient\n    }\n\
    \    return prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return prime_factors(n:\
    \ n).last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3pf_rmog.swift:8:12: error: cannot find 'prime_factors' in scope\n\
    \    return prime_factors(n: n).last!\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n <= 1 {\n\
    \        fatalError(\"n must be greater than 1\")\n    }\n    if is_prime(n: n)\
    \ {\n        fatalError(\"n must not be a prime\")\n    }\n    var res = 0\n \
    \   for i in 1 ... Int(sqrt(Double(n))) {\n        if n % i == 0 {\n         \
    \   if is_prime(n: i) {\n                res = i\n            }\n        }\n \
    \   }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpueemp4d7.swift:11:8: error: cannot find 'is_prime' in scope\n \
    \   if is_prime(n: n) {\n       ^~~~~~~~\n/tmp/tmpueemp4d7.swift:15:24: error:\
    \ cannot find 'sqrt' in scope\n    for i in 1 ... Int(sqrt(Double(n))) {\n   \
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var number = n\n\
    \  var factor = 2\n  while number != 1 {\n    if number % factor == 0 {\n    \
    \  number /= factor\n    } else {\n      factor += 1\n    }\n  }\n  return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var f = 2\n    while n > 1 {\n        while n % f == 0 {\n            n /=\
    \ f\n        }\n        f += 1\n    }\n    return f - 1\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    for i in 2..<n\
    \ {\n        if n % i == 0 {\n            return max(i, largest_prime_factor(n:\
    \ n / i))\n        }\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var number = n\n\
    \    var i = 2\n    while i < number {\n        if number % i == 0 {\n       \
    \     number /= i\n        } else {\n            i += 1\n        }\n    }\n  \
    \  return number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let sqrt_n = Int(sqrt(Double(n)))\n\
    \    var primes = sieve_of_eratosthenes(n: sqrt_n)\n    primes.removeLast()\n\
    \    var factors = Set<Int>()\n    var temp = n\n    while temp > 1 {\n      \
    \  for p in primes {\n            if temp % p == 0 {\n                factors.insert(p)\n\
    \                temp /= p\n                break\n            }\n        }\n\
    \    }\n    return factors.max()!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpqo94ygez.swift:8:22: error: cannot find 'sqrt' in scope\n    let\
    \ sqrt_n = Int(sqrt(Double(n)))\n                     ^~~~\n/tmp/tmpqo94ygez.swift:9:18:\
    \ error: cannot find 'sieve_of_eratosthenes' in scope\n    var primes = sieve_of_eratosthenes(n:\
    \ sqrt_n)\n                 ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factors =\
    \ [Int]()\n    var prime_factors = [Int]()\n    var factor = 2\n    while n >\
    \ 1 {\n        while n % factor == 0 {\n            factors.append(factor)\n \
    \           n /= factor\n        }\n        factor += 1\n    }\n    for n in factors\
    \ {\n        if is_prime(n: n) {\n            prime_factors.append(n)\n      \
    \  }\n    }\n    return prime_factors.max()!\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmplj_zv8p_.swift:14:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n\
    /tmp/tmplj_zv8p_.swift:19:12: error: cannot find 'is_prime' in scope\n       \
    \ if is_prime(n: n) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if (n % 2 == 0)\
    \ {\n        return largest_prime_factor(n: n / 2)\n    }\n    for i in stride(from:\
    \ 3, through: sqrt(Double(n)), by: 2) {\n        if (n % Int(i) == 0) {\n    \
    \        return largest_prime_factor(n: n / Int(i))\n        }\n    }\n    return\
    \ n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) ==\
    \ 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpqcelqvur.swift:11:39: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: sqrt(Double(n)), by: 2) {\n                  \
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n\treturn 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpa2k0bmxn/tmpa2k0bmxn.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1082de2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1082ad9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1082ad9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1082ad87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa2k0bmxn                        0x000055b7dd74e1b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b1082fce460 __libc_start_main +
    245

    6    tmpa2k0bmxn                        0x000055b7dd74de69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return factor(n:\
    \ n).last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp8t3jpf9u.swift:8:12: error: cannot find 'factor' in scope\n   \
    \ return factor(n: n).last!\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var x = 2\n  \
    \  var f = n\n    while f % x == 0 {\n        f /= x\n    }\n    x += 1\n    while\
    \ x < f {\n        while f % x == 0 {\n            f /= x\n        }\n       \
    \ x += 2\n    }\n    return f\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpr8zgnkr7/tmpr8zgnkr7.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3ced74dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3ced444b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3ced444988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3ced4437b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr8zgnkr7                        0x0000564b5e5722c0 <unavailable> + 4800

    5    libc.so.6                          0x00002b3ced939460 __libc_start_main +
    245

    6    tmpr8zgnkr7                        0x0000564b5e571ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 0\n\
    \    var m = n\n    var d = 2\n    while d * d <= m {\n        if m % d == 0 {\n\
    \            factor = d\n            m /= d\n        } else {\n            d +=\
    \ 1\n        }\n    }\n    return m > 1 ? m : factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // TODO\n    var\
    \ largest = 1\n    for i in 2...n {\n        if n % i == 0 {\n            largest\
    \ = i\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpnyi95cf3/tmpnyi95cf3.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b80fa13ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b80f9e31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b80f9e31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b80f9e307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnyi95cf3                        0x000055aa61a3d335 <unavailable> + 4917

    5    libc.so.6                          0x00002b80fa326460 __libc_start_main +
    245

    6    tmpnyi95cf3                        0x000055aa61a3cfe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return prime_factors(n:\
    \ n).last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3pf_rmog.swift:8:12: error: cannot find 'prime_factors' in scope\n\
    \    return prime_factors(n: n).last!\n           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var (m, d) = (n,\
    \ 2)\n    while m > 1 {\n        while m % d == 0 {\n            m /= d\n    \
    \    }\n        d += 1\n    }\n    return d - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var max: Int = 1\n\
    \  var n = n\n  for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97] {\n    while n % p == 0 {\n    \
    \  n /= p\n      max = p\n    }\n  }\n  return max\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factors =\
    \ [Int]()\n    var n = n\n    for factor in 2...n {\n        if n%factor == 0\
    \ {\n            factors.append(factor)\n            n /= factor\n        }\n\
    \    }\n    return factors.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmp8ylyhveb/tmp8ylyhveb.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7cac5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7ca952b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7ca952988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7ca9517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ylyhveb                        0x00005643dfb7e550 <unavailable> + 5456

    5    libc.so.6                          0x00002ae7cae47460 __libc_start_main +
    245

    6    tmp8ylyhveb                        0x00005643dfb7e189 <unavailable> + 4489

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // TODO: Write\
    \ this function\n    return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpcf_yipnu/tmpcf_yipnu.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afc1183fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afc11536b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afc11536988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afc115357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcf_yipnu                        0x00005612f23671b5 <unavailable> + 4533

    5    libc.so.6                          0x00002afc11a2b460 __libc_start_main +
    245

    6    tmpcf_yipnu                        0x00005612f2366e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 2\n\
    \    var largest_factor = 0\n    while factor <= n {\n        if n % factor ==\
    \ 0 {\n            var is_prime = true\n            for var i = 2; i < factor;\
    \ i++ {\n                if factor % i == 0 {\n                    is_prime =\
    \ false\n                    break\n                }\n            }\n       \
    \     if is_prime {\n                largest_factor = factor\n            }\n\
    \        }\n        factor++\n    }\n    return largest_factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpsuls0c3s.swift:13:13: error: C-style for statement has been removed\
    \ in Swift 3\n            for var i = 2; i < factor; i++ {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpsuls0c3s.swift:23:15: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        factor++\n              ^~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var nn = n\n \
    \   var factor = 2\n    while nn > 1 {\n        while nn % factor == 0 {\n   \
    \         nn /= factor\n        }\n        factor += 1\n    }\n    return factor\
    \ - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var lpf = 1\n\
    \    var i = 2\n    while i <= n {\n        if n % i == 0 {\n            lpf =\
    \ i\n            n /= i\n        } else {\n            i += 1\n        }\n   \
    \ }\n    return lpf\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpohtw_lbn.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i <= n {\n        if n % i == 0 {\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    return i\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  return 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpwgv1v2xv/tmpwgv1v2xv.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acf75e52c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acf75b49b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acf75b49988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acf75b487b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwgv1v2xv                        0x0000562d356571b5 <unavailable> + 4533

    5    libc.so.6                          0x00002acf7603e460 __libc_start_main +
    245

    6    tmpwgv1v2xv                        0x0000562d35656e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var num = n\n  var\
    \ prime = 2\n  while num > 1 {\n    while num % prime == 0 {\n      num /= prime\n\
    \    }\n    prime += 1\n  }\n  return prime - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var factor = 2,\
    \ end = Int(sqrt(Double(n)))\n  while factor <= end {\n    if n % factor == 0\
    \ {\n      n /= factor\n      end = Int(sqrt(Double(n)))\n    } else {\n     \
    \ factor += 1\n    }\n  }\n  return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpyxamo4lv.swift:8:29: error: cannot find 'sqrt' in scope\n  var\
    \ factor = 2, end = Int(sqrt(Double(n)))\n                            ^~~~\n/tmp/tmpyxamo4lv.swift:11:9:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \      n /= factor\n      ~ ^\n/tmp/tmpyxamo4lv.swift:12:17: error: cannot find\
    \ 'sqrt' in scope\n      end = Int(sqrt(Double(n)))\n                ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var result = 1\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   n /= i\n            result = i\n        } else {\n            i += 1\n   \
    \     }\n    }\n    if n > 1 {\n        result = n\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpyubxtybg.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var divisor =\
    \ 2\n    var factor = n\n    while (factor > 1) {\n        if (factor % divisor\
    \ == 0) {\n            factor /= divisor\n        } else {\n            divisor\
    \ += 1\n        }\n    }\n    return divisor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var (n, largest)\
    \ = (n, 1)\n    while n % 2 == 0 { n /= 2 }\n    for p in stride(from: 3, through:\
    \ Int(sqrt(Double(n))), by: 2) {\n        while n % p == 0 {\n            n /=\
    \ p\n            largest = p\n        }\n    }\n    return largest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpr4m2gzlx.swift:10:43: error: cannot find 'sqrt' in scope\n    for\
    \ p in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let end = Int(sqrt(Double(n)))\n\
    \    var i = 2\n    while i <= end {\n        if n % i == 0 {\n            return\
    \ largest_prime_factor(n: n / i)\n        }\n        i += 1\n    }\n    return\
    \ n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) ==\
    \ 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpuldh2h6g.swift:8:19: error: cannot find 'sqrt' in scope\n    let\
    \ end = Int(sqrt(Double(n)))\n                  ^~~~\n"
  stdout: ''
  timestamp: 1660014152
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var current_factor = 2\n    var number = n\n    while number > 1 {\n\
    \        while number % current_factor == 0 {\n            largest_prime_factor\
    \ = current_factor\n            number /= current_factor\n        }\n        current_factor\
    \ += 1\n    }\n    return largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var num = 2\n    while n > 1 {\n        if n % num == 0 {\n            n /=\
    \ num\n        } else {\n            num += 1\n        }\n    }\n    return num\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var x = 2\n    while x * x <= n {\n        if n % x == 0 {\n            n /=\
    \ x\n        } else {\n            x += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var p = 1, q =\
    \ n\n    while q % 2 == 0 {\n        p = 2\n        q /= 2\n    }\n    var f =\
    \ 3\n    while q != 1 {\n        while q % f == 0 {\n            p = f\n     \
    \       q /= f\n        }\n        f += 2\n    }\n    return p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 2\n\
    \    var largest = 2\n    while n > 1 {\n        if n % factor == 0 {\n      \
    \      largest = factor\n            n /= factor\n        } else {\n         \
    \   factor += 1\n        }\n    }\n    return largest\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpeos5bc4r.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var p = 2\n  \
    \  var n = n\n    while n != 1 {\n        if n % p == 0 {\n            n /= p\n\
    \        } else {\n            p += 1\n        }\n    }\n    return p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var prime = 2\n\
    \    while (prime * prime <= n) {\n        if (n % prime == 0) {\n           \
    \ return largest_prime_factor(n: n / prime)\n        }\n        prime += 1\n \
    \   }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var number = n\n\
    \    var i = 2\n    while i * i <= number {\n        if number % i == 0 {\n  \
    \          number /= i\n        } else {\n            i += 1\n        }\n    }\n\
    \    return number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest =\
    \ 0\n    var target = n\n    var dividend = 2\n    while target > 1 {\n      \
    \  if target % dividend == 0 {\n            largest = dividend\n            target\
    \ /= dividend\n        } else {\n            dividend += 1\n        }\n    }\n\
    \    return largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n\tvar factor = 1\n\
    \tvar num = n\n\tvar i = 2\n\t\n\twhile i * i <= num {\n\t\tif num % i == 0 {\n\
    \t\t\tfactor = i\n\t\t\tnum /= i\n\t\t} else {\n\t\t\ti += 1\n\t\t}\n\t}\n\t\n\
    \tif num > 1 {\n\t\tfactor = num\n\t}\n\t\n\treturn factor\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let prime_numbers\
    \ = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97]\n    var max_prime = 1\n    var np = n\n    while np > 1\
    \ {\n        for p in prime_numbers {\n            if np % p == 0 {\n        \
    \        np /= p\n                max_prime = p\n                break\n     \
    \       }\n        }\n    }\n    return max_prime\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var p = 2\n    while n > 1 {\n        while n % p == 0 {\n            n /=\
    \ p\n        }\n        p += 1\n    }\n    return p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmp6ppyki66/tmp6ppyki66.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b431d918c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b431d60fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b431d60f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b431d60e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6ppyki66                        0x0000557fbb525245 <unavailable> + 4677

    5    libc.so.6                          0x00002b431db04460 __libc_start_main +
    245

    6    tmp6ppyki66                        0x0000557fbb524ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 0\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      n /= i\n            largest_prime = i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > largest_prime {\n        largest_prime =\
    \ n\n    }\n    return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpjrd31fkn.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var f = 2\n    while n > 1 {\n        if n % f == 0 {\n            n /= f\n\
    \        } else {\n            f += 1\n        }\n    }\n    return f\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // Check factors\
    \ up to n\n    var current = n\n    var i = 2\n    while i < current {\n     \
    \   // If factor, update n and exit loop\n        if current % i == 0 {\n    \
    \        current = current / i\n            break\n        }\n        i += 1\n\
    \    }\n    // If n is still equal to original n, n is a prime, so return n\n\
    \    if current == n {\n        return n\n    }\n    // Otherwise, continue recursively\n\
    \    return largest_prime_factor(n: current)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var n = n\n  var\
    \ i = 2\n  while i * i <= n {\n    while n % i == 0 {\n      n /= i\n    }\n \
    \   i += 1\n  }\n  return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpexwawnz6/tmpexwawnz6.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae836f14c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae836c0bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae836c0b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae836c0a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpexwawnz6                        0x00005628806e82c0 <unavailable> + 4800

    5    libc.so.6                          0x00002ae837100460 __libc_start_main +
    245

    6    tmpexwawnz6                        0x00005628806e7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var x = n\n  \
    \  var factors = [Int]()\n    while x % 2 == 0 {\n        factors.append(2)\n\
    \        x /= 2\n    }\n    var i = 3\n    while i <= x {\n        if x % i ==\
    \ 0 {\n            factors.append(i)\n            x /= i\n        } else {\n \
    \           i += 2\n        }\n    }\n    return factors.last!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var prime_factor\
    \ = 2\n  while n > prime_factor {\n    if n % prime_factor == 0 {\n      n /=\
    \ prime_factor\n    } else {\n      prime_factor += 1\n    }\n  }\n  return prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp7lba9j7n.swift:11:9: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n      n /= prime_factor\n      ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var m = n\n  \
    \  var p = 2\n    while p * p <= m {\n        if m % p == 0 {\n            m /=\
    \ p\n        } else {\n            p += 1\n        }\n    }\n    return m\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return primes(n:\
    \ n).max()!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp6ptblbts.swift:8:12: error: cannot find 'primes' in scope\n   \
    \ return primes(n: n).max()!\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest = 2\n    if n % 2 == 0 {\n        largest = 2\n        while n\
    \ % 2 == 0 {\n            n /= 2\n        }\n    }\n    for i in 3.stride(through:\
    \ n, by: 2) {\n        if n % i == 0 {\n            largest = i\n            while\
    \ n % i == 0 {\n                n /= i\n            }\n        }\n    }\n    return\
    \ largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp9ht3a33_.swift:16:16: error: value of type 'Int' has no member\
    \ 'stride'\n    for i in 3.stride(through: n, by: 2) {\n             ~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i < n {\n        if n % i == 0 {\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // initialize\
    \ primes to an array of all primes less than n.\n    var primes = [Int]()\n  \
    \  for i in stride(from: 2, to: n, by: 1) {\n        if is_prime(n: i) {\n   \
    \         primes.append(i)\n        }\n    }\n    // if n < largest_prime then\
    \ it must be prime\n    var largest_prime = primes.last!\n    if n > largest_prime\
    \ {\n        // iterate over primes in reverse order.\n        for prime in primes.reversed()\
    \ {\n            if n % prime == 0 {\n                largest_prime = prime\n\
    \                break\n            }\n        }\n    }\n    return largest_prime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpmsa5cg9p.swift:11:12: error: cannot find 'is_prime' in scope\n\
    \        if is_prime(n: i) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    guard n > 1 else\
    \ {\n        return 0\n    }\n    var n = n\n    var lpf = 0\n    for i in 2...n\
    \ {\n        guard is_prime(i) else {\n            continue\n        }\n     \
    \   while n % i == 0 {\n            n /= i\n            lpf = i\n        }\n \
    \   }\n    return lpf\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpjw2h_hxo.swift:14:15: error: cannot find 'is_prime' in scope\n\
    \        guard is_prime(i) else {\n              ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_factor = 1\n    for i in 2...n {\n        if n % i == 0 {\n   \
    \         largest_factor = i\n            n /= i\n        }\n    }\n    return\
    \ largest_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpiqpw5t79/tmpiqpw5t79.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b299d503c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b299d1fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b299d1fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b299d1f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiqpw5t79                        0x000055de3f8a73b0 <unavailable> + 5040

    5    libc.so.6                          0x00002b299d6ef460 __libc_start_main +
    245

    6    tmpiqpw5t79                        0x000055de3f8a6fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factors =\
    \ [Int]()\n    var remainder = n\n    var factor = 2\n    while remainder % factor\
    \ == 0 {\n        factors.append(factor)\n        remainder /= factor\n    }\n\
    \    factor += 1\n    while remainder > 1 {\n        while remainder % factor\
    \ == 0 {\n            factors.append(factor)\n            remainder /= factor\n\
    \        }\n        factor += 2\n    }\n    return factors.last!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n <= 3 {\n\
    \        return n\n    }\n    var n = n\n    var largestPrime = 2\n    while n\
    \ % 2 == 0 {\n        n /= 2\n    }\n    let max = Int(sqrt(Double(n)))\n    var\
    \ i = 3\n    while i <= max {\n        while n % i == 0 {\n            n /= i\n\
    \            largestPrime = i\n        }\n        i += 2\n    }\n    if n > 2\
    \ {\n        largestPrime = n\n    }\n    return largestPrime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmplume_psr.swift:16:19: error: cannot find 'sqrt' in scope\n    let\
    \ max = Int(sqrt(Double(n)))\n                  ^~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var p = n\n  \
    \  var d = 2\n    while p % d == 0 {\n        p /= d\n    }\n    d += 1\n    while\
    \ p % d != 0 {\n        d += 2\n    }\n    return p / d\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpjavu659l/tmpjavu659l.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad87278ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad872481b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad872481988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8724807b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjavu659l                        0x000055998590f2c0 <unavailable> + 4800

    5    libc.so.6                          0x00002ad872976460 __libc_start_main +
    245

    6    tmpjavu659l                        0x000055998590eef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 2\n\
    \    var n = n\n    while n > 1 {\n        if n % factor == 0 {\n            n\
    \ /= factor\n        } else {\n            factor += 1\n        }\n    }\n   \
    \ return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var factor = 2\n    while n != 1 {\n        if n % factor == 0 {\n        \
    \    n /= factor\n        } else {\n            factor += 1\n        }\n    }\n\
    \    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var max: Int =\
    \ -1\n\n    for i in 2..<n {\n        if n % i == 0 {\n            max = i\n \
    \           break\n        }\n    }\n\n    if max == -1 {\n        return max\n\
    \    }\n\n    if max == n {\n        return max\n    }\n\n    return largest_prime_factor(n:\
    \ n / max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpzyk3j29y/tmpzyk3j29y.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b76e2cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b76b23b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b76b23988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b76b227b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzyk3j29y                        0x000055992a242335 <unavailable> + 4917

    5    libc.so.6                          0x00002b2b77018460 __libc_start_main +
    245

    6    tmpzyk3j29y                        0x000055992a241fe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmprhp5nhwf/tmprhp5nhwf.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad52eafbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad52e7f2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad52e7f2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad52e7f17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprhp5nhwf                        0x000055ba7e4251b5 <unavailable> + 4533

    5    libc.so.6                          0x00002ad52ece7460 __libc_start_main +
    245

    6    tmprhp5nhwf                        0x000055ba7e424e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var prime = 2\n    while n > 1 {\n        if n % prime == 0 {\n           \
    \ n /= prime\n        } else {\n            prime += 1\n        }\n    }\n   \
    \ return prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    guard n > 1 else\
    \ {\n        print(\"Input must be greater than 1\")\n        return -1\n    }\n\
    \    var n = n\n    var largest = -1\n    while n % 2 == 0 {\n        largest\
    \ = 2\n        n /= 2\n    }\n    for i in stride(from: 3, through: Int(sqrt(Double(n))),\
    \ by: 2) {\n        while n % i == 0 {\n            largest = i\n            n\
    \ /= i\n        }\n    }\n    if n > 2 {\n        largest = n\n    }\n    return\
    \ largest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp631qx3hn.swift:18:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var largestPrime = 1\n    while n > 1 {\n        if n % i == 0 {\n        \
    \    largestPrime = i\n            n /= i\n            continue\n        }\n \
    \       i += 1\n    }\n    return largestPrime\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpfgynouki.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime\
    \ = 1\n    var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n      \
    \      largest_prime = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        largest_prime = n\n    }\n \
    \   return largest_prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3pmijin4.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var largest_prime = 0\n    var p = 2\n    while n > 1 {\n        if n % p ==\
    \ 0 {\n            n /= p\n            largest_prime = p\n        } else {\n \
    \           p += 1\n        }\n    }\n    return largest_prime\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var num = n\n\
    \    var factor = 2\n    while num > 1 {\n        if num % factor == 0 {\n   \
    \         num /= factor\n        } else {\n            factor += 1\n        }\n\
    \    }\n    return factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor\
    \ = 2\n    var factor = 2\n    while n > 1 {\n        while n % factor == 0 {\n\
    \            n /= factor\n            largest_factor = factor\n        }\n   \
    \     factor += 1\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpgtf5jvw5.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= factor\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var factor = 2\n\
    \  var max_factor = 1\n  while factor <= n {\n    if n % factor == 0 {\n     \
    \ n /= factor\n      max_factor = factor\n    } else {\n      factor += 1\n  \
    \  }\n  }\n  return max_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpglnjk68s.swift:12:9: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n      n /= factor\n      ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_factor\
    \ = 1\n    var i = 2\n    while i <= n {\n        if n % i == 0 {\n          \
    \  largest_factor = i\n            n /= i\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return largest_factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp20ghtvi4.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var primeFactor = 1\n    while i * i <= n {\n        if n % i == 0 {\n    \
    \        primeFactor = i\n            n /= i\n        } else {\n            i\
    \ += 1\n        }\n    }\n    if n > 1 {\n        primeFactor = n\n    }\n   \
    \ return primeFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpgzs0vfhn.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var n = n\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n <= 1 {\n\
    \        return 0\n    }\n\n    var largestPrimeFactor = 1\n    var n = n\n  \
    \  for factor in primes_up_to(n: n) {\n        while n % factor == 0 {\n     \
    \       largestPrimeFactor = factor\n            n /= factor\n        }\n    }\n\
    \    return largestPrimeFactor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpku0hl2gk.swift:14:19: error: cannot find 'primes_up_to' in scope\n\
    \    for factor in primes_up_to(n: n) {\n                  ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return largest_prime_factor_helper(n:\
    \ n, f: 2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp9pzzfq9b.swift:8:12: error: cannot find 'largest_prime_factor_helper'\
    \ in scope\n    return largest_prime_factor_helper(n: n, f: 2)\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    assert(n > 1)\n\
    \    for i in (2..<n).reversed() {\n        if n % i == 0 && is_prime(n: i) {\n\
    \            return i\n        }\n    }\n    assert(false)\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpglq2ctge.swift:10:26: error: cannot find 'is_prime' in scope\n\
    \        if n % i == 0 && is_prime(n: i) {\n                         ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 0\n\
    \    var number = n\n    for i in (2...number) {\n        if is_prime(i) {\n \
    \           while number % i == 0 {\n                factor = i\n            \
    \    number /= i\n            }\n        }\n    }\n    return factor\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmph40vi1r1.swift:11:12: error: cannot find 'is_prime' in scope\n\
    \        if is_prime(i) {\n           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var r = n\n    while i < r {\n        while r % i == 0 {\n            r /=\
    \ i\n        }\n        i += 1\n    }\n    return r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpr3zdu4z3/tmpr3zdu4z3.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b889b0e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b889addfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b889addf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b889adde7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr3zdu4z3                        0x00005616912762c0 <unavailable> + 4800

    5    libc.so.6                          0x00002b889b2d4460 __libc_start_main +
    245

    6    tmpr3zdu4z3                        0x0000561691275ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if is_prime(n:\
    \ n) {\n        return n\n    }\n\n    for p in primes_gen(max: n) {\n       \
    \ if n % p == 0 {\n            return p\n        }\n    }\n\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp3cedw0o8.swift:8:8: error: cannot find 'is_prime' in scope\n  \
    \  if is_prime(n: n) {\n       ^~~~~~~~\n/tmp/tmp3cedw0o8.swift:12:14: error:\
    \ cannot find 'primes_gen' in scope\n    for p in primes_gen(max: n) {\n     \
    \        ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var d = 2\n  \
    \  var p = n\n    while p > 1 {\n        if p % d == 0 {\n            p /= d\n\
    \        } else {\n            d += 1\n        }\n    }\n    return d\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var x = n\n  var\
    \ d = 2\n  while x > 1 {\n    while x % d == 0 {\n      x /= d\n    }\n    d +=\
    \ 1\n  }\n  return d - 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  // Find the largest\
    \ prime factor of n.\n  return 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpv72q0hxy/tmpv72q0hxy.swift:25: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b220f433c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b220f12ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b220f12a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b220f1297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv72q0hxy                        0x000055e2cc7a81b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b220f61f460 __libc_start_main +
    245

    6    tmpv72q0hxy                        0x000055e2cc7a7e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest =\
    \ 0, n = n\n    for i in 2 ..< n {\n        if n % i == 0 {\n            largest\
    \ = i\n            while n % i == 0 {\n                n /= i\n            }\n\
    \        }\n    }\n    return n == 1 ? largest : n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n % 2 == 0\
    \ {\n        return largest_prime_factor(n: n / 2)\n    }\n    for i in stride(from:\
    \ 3, through: Int(sqrt(Double(n))), by: 2) {\n        if n % i == 0 {\n      \
    \      return largest_prime_factor(n: n / i)\n        }\n    }\n    return n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp_kdoe_jk.swift:11:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: Int(sqrt(Double(n))), by: 2) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014151
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 0\n\
    \    var i = 2\n    while (i * i <= n) {\n        if (n % i == 0) {\n        \
    \    factor = i\n            n /= i\n        } else {\n            i += 1\n  \
    \      }\n    }\n    if (n > 1) {\n        factor = n\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmppw2ubh_b.swift:13:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= i\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n\tfor num in 1...n\
    \ {\n\t\tif n % num == 0 {\n\t\t\tif is_prime(n: num) {\n\t\t\t\treturn num\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmppcjfzkzj.swift:10:7: error: cannot find 'is_prime' in scope\n \
    \                       if is_prime(n: num) {\n                           ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    guard n > 1 &&\
    \ !is_prime(n: n) else { return n }\n    return (2..<Int(sqrt(Double(n)))).filter({\
    \ n % $0 == 0 }).map({ n / $0 }).filter({ is_prime(n: $0) }).max()!\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpqjla4b5k.swift:8:21: error: cannot find 'is_prime' in scope\n \
    \   guard n > 1 && !is_prime(n: n) else { return n }\n                    ^~~~~~~~\n\
    /tmp/tmpqjla4b5k.swift:9:21: error: cannot find 'sqrt' in scope\n    return (2..<Int(sqrt(Double(n)))).filter({\
    \ n % $0 == 0 }).map({ n / $0 }).filter({ is_prime(n: $0) }).max()!\n        \
    \            ^~~~\n/tmp/tmpqjla4b5k.swift:9:88: error: cannot find 'is_prime'\
    \ in scope\n    return (2..<Int(sqrt(Double(n)))).filter({ n % $0 == 0 }).map({\
    \ n / $0 }).filter({ is_prime(n: $0) }).max()!\n                             \
    \                                                          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    for i in stride(from:\
    \ 2, through: Int(sqrt(Double(n))), by: 1) {\n        if n % i == 0 {\n      \
    \      return largest_prime_factor(n: n / i)\n        }\n    }\n    return n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpu3tqhbr_.swift:8:43: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 2, through: Int(sqrt(Double(n))), by: 1) {\n             \
    \                             ^~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    assert(n > 1)\n\
    \    var primes = [2]\n    var factor: Int\n    var num = n\n    repeat {\n  \
    \      for p in primes {\n            factor = n / p\n            if n % p ==\
    \ 0 {\n                num = n / p\n                break\n            }\n   \
    \     }\n        primes.append(factor)\n    } while factor != num\n    return\
    \ num\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpw6vem5a2.swift:20:23: error: variable 'factor' used before being\
    \ initialized\n        primes.append(factor)\n                      ^\n/tmp/tmpw6vem5a2.swift:10:9:\
    \ note: variable defined here\n    var factor: Int\n        ^\n/tmp/tmpw6vem5a2.swift:21:13:\
    \ error: variable 'factor' used before being initialized\n    } while factor !=\
    \ num\n            ^\n/tmp/tmpw6vem5a2.swift:10:9: note: variable defined here\n\
    \    var factor: Int\n        ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 1\n    var x = n\n    for i in 2..<x {\n        if x % i == 0 {\n        \
    \    largest_prime_factor = i\n            x /= i\n        }\n    }\n    return\
    \ largest_prime_factor\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Exception
  stderr: 'tmpnz21e__2/tmpnz21e__2.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abcbe1fec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abcbdef5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abcbdef5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abcbdef47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnz21e__2                        0x000055d9fea103b0 <unavailable> + 5040

    5    libc.so.6                          0x00002abcbe3ea460 __libc_start_main +
    245

    6    tmpnz21e__2                        0x000055d9fea0ffe9 <unavailable> + 4073

    '
  stdout: ''
  timestamp: 1660014154
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // Fill me in!\n\
    \    if n == 2 {\n        return 2\n    }\n    var primeFactors = [Int]()\n  \
    \  var remainingNumber = n\n    var prime = 2\n    while remainingNumber > 1 {\n\
    \        while remainingNumber % prime == 0 {\n            primeFactors.append(prime)\n\
    \            remainingNumber /= prime\n        }\n        prime += 1\n    }\n\
    \    return primeFactors.last!\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let sqrt_n = Int(Double(n).squareRoot())\n\
    \    return (2...sqrt_n).filter { n % $0 == 0 }.reduce(1) {\n        max($0, largest_prime_factor(n:\
    \ n / $0))\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp619_kx8b.swift:9:58: error: contextual closure type '(Int, Int)\
    \ throws -> Int' expects 2 arguments, but 1 was used in closure body\n    return\
    \ (2...sqrt_n).filter { n % $0 == 0 }.reduce(1) {\n                          \
    \                               ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while i * i <= n {\n        if n % i == 0 {\n            n /=\
    \ i\n        } else {\n            i += 1\n        }\n    }\n    return n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014060
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    assert(n > 1,\
    \ \"n must be > 1\")\n    var factor = 2\n    var value = n\n    while factor\
    \ < value {\n        if value % factor == 0 {\n            value /= factor\n \
    \       } else {\n            factor += 1\n        }\n    }\n    return factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var i = 2\n  \
    \  var largest_factor = 1\n    var number = n\n    while i * i <= number {\n \
    \       if number % i == 0 {\n            largest_factor = i\n            number\
    \ /= i\n        } else {\n            i += 1\n        }\n    }\n    if number\
    \ > 1 {\n        largest_factor = number\n    }\n    return largest_factor\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor = 2\n\
    \    var largest_factor = 1\n    while factor * factor <= n {\n        if n %\
    \ factor == 0 {\n            while n % factor == 0 {\n                n /= factor\n\
    \            }\n            largest_factor = factor\n        }\n        factor\
    \ += 1\n    }\n    if n > 1 {\n        largest_factor = n\n    }\n    return largest_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp2gnkzsl4.swift:13:19: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n                n /= factor\n            \
    \    ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var factor: Int\
    \ = 2\n    var prime: Int = 1\n    var half: Int = n / 2\n\n    for var i = factor;\
    \ i <= half; i++ {\n        if n % i == 0 {\n            prime = i\n         \
    \   while n % i == 0 {\n                n /= i\n            }\n            half\
    \ = n / 2\n        }\n    }\n\n    if n > 1 {\n        prime = n\n    }\n\n  \
    \  return prime\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpnv1w_n5o.swift:12:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for var i = factor; i <= half; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var i = 2\n    while n > 1 {\n        if n % i == 0 {\n            n /= i\n\
    \        } else {\n            i += 1\n        }\n    }\n    return i\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if is_prime(n:\
    \ n) {\n        return n\n    }\n    for p in primes(from: 2, to: Int(sqrt(Double(n)))\
    \ + 1) {\n        if n % p == 0 {\n            return largest_prime_factor(n:\
    \ n / p)\n        }\n    }\n    return 1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp6fgyrgg_.swift:8:8: error: cannot find 'is_prime' in scope\n  \
    \  if is_prime(n: n) {\n       ^~~~~~~~\n/tmp/tmp6fgyrgg_.swift:11:14: error:\
    \ cannot find 'primes' in scope\n    for p in primes(from: 2, to: Int(sqrt(Double(n)))\
    \ + 1) {\n             ^~~~~~\n/tmp/tmp6fgyrgg_.swift:11:38: error: cannot find\
    \ 'sqrt' in scope\n    for p in primes(from: 2, to: Int(sqrt(Double(n))) + 1)\
    \ {\n                                     ^~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n < 1 {\n \
    \       fatalError(\"Unsupported input: \\(n)\")\n    }\n    if n == 1 {\n   \
    \     return 1\n    }\n    if is_prime(n: n) {\n        return n\n    }\n    let\
    \ s = Int(sqrt(Double(n)))\n    let q = Int(pow(Double(s), Double(s)))\n    var\
    \ i = s\n    while i > 1 {\n        if n % i == 0 {\n            if is_prime(n:\
    \ i) {\n                return i\n            }\n        }\n        i -= 1\n \
    \   }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpvbo_krvk.swift:14:8: error: cannot find 'is_prime' in scope\n \
    \   if is_prime(n: n) {\n       ^~~~~~~~\n/tmp/tmpvbo_krvk.swift:17:17: error:\
    \ cannot find 'sqrt' in scope\n    let s = Int(sqrt(Double(n)))\n            \
    \    ^~~~\n/tmp/tmpvbo_krvk.swift:18:17: error: cannot find 'pow' in scope\n \
    \   let q = Int(pow(Double(s), Double(s)))\n                ^~~\n/tmp/tmpvbo_krvk.swift:22:16:\
    \ error: cannot find 'is_prime' in scope\n            if is_prime(n: i) {\n  \
    \             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014154
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    return 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpopjsynk8/tmpopjsynk8.swift:24: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9331c6ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9331965b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9331965988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93319647b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpopjsynk8                        0x000055b5379d71b5 <unavailable> + 4533

    5    libc.so.6                          0x00002b9331e5a460 __libc_start_main +
    245

    6    tmpopjsynk8                        0x000055b5379d6e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014060
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n == 2 {\n\
    \        return 2\n    }\n    if n == 3 {\n        return 3\n    }\n    if n ==\
    \ 5 {\n        return 5\n    }\n    let factors = prime_factors(n: n)\n    let\
    \ max_factor = factors.max()!\n    return max_factor\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpvt1i7ioq.swift:17:19: error: cannot find 'prime_factors' in scope\n\
    \    let factors = prime_factors(n: n)\n                  ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var k = 2\n  \
    \  var m = n\n    while k * k <= m {\n        if m % k == 0 {\n            m /=\
    \ k\n        } else {\n            k += 1\n        }\n    }\n    return m\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let sqrtN = Int(Double(n).squareRoot())\n\
    \    var i = sqrtN\n    while (i > 1) {\n        if (n % i == 0) {\n         \
    \   if (is_prime(n: i)) {\n                return i\n            }\n        }\n\
    \        i -= 1\n    }\n    return -1\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpg_16i4cs.swift:12:17: error: cannot find 'is_prime' in scope\n\
    \            if (is_prime(n: i)) {\n                ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n % 2 == 0\
    \ {\n        return largest_prime_factor(n: n / 2)\n    }\n    for i in stride(from:\
    \ 3, through: sqrt(Double(n)), by: 2) {\n        if n % Int(i) == 0 {\n      \
    \      return largest_prime_factor(n: n / Int(i))\n        }\n    }\n    return\
    \ n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(largest_prime_factor(n: 15) ==\
    \ 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpton1881b.swift:11:39: error: cannot find 'sqrt' in scope\n    for\
    \ i in stride(from: 3, through: sqrt(Double(n)), by: 2) {\n                  \
    \                    ^~~~\n"
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n  var largest: Int\
    \ = 0\n  var i: Int = 2\n  while i <= n {\n    if n % i == 0 {\n      n /= i\n\
    \      largest = i\n    } else {\n      i += 1\n    }\n  }\n  return largest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmp2rvj56xb.swift:12:9: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n      n /= i\n      ~ ^\n"
  stdout: ''
  timestamp: 1660014153
- exit_code: -1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    // if n is even,\
    \ the largest prime factor is 2\n    if n % 2 == 0 {\n        return largest_prime_factor(n:\
    \ n / 2)\n    }\n    // if n is odd, first we check if the largest factor is 3\n\
    \    if n % 3 == 0 {\n        return largest_prime_factor(n: n / 3)\n    }\n \
    \   // now we skip even numbers and check only odd numbers\n    var i = 5\n  \
    \  while true {\n        // if i is a factor\n        if n % i == 0 {\n      \
    \      // largest prime factor of n is i\n            return largest_prime_factor(n:\
    \ n / i)\n        }\n        // if i is not a factor, check next number\n    \
    \    i += 2\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660014159
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n < 2 {\n \
    \       return 0\n    }\n    return n.prime_factors().max()!\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmplmbiow62.swift:11:14: error: value of type 'Int' has no member\
    \ 'prime_factors'\n    return n.prime_factors().max()!\n           ~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014154
- exit_code: -4
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var n = n\n  \
    \  var f = 2\n    while n % f == 0 {\n        n /= f\n    }\n    f += 1\n    while\
    \ f * f <= n {\n        while n % f == 0 {\n            n /= f\n        }\n  \
    \      f += 2\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n: 27) ==\
    \ 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: Exception
  stderr: 'tmpz7xg0klk/tmpz7xg0klk.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b32f66ebc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b32f63e2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b32f63e2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b32f63e17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz7xg0klk                        0x000056214d8482c0 <unavailable> + 4800

    5    libc.so.6                          0x00002b32f68d7460 __libc_start_main +
    245

    6    tmpz7xg0klk                        0x000056214d847ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var (largestPrime,\
    \ p) = (1, 2)\n    while n > 1 {\n        while n % p == 0 {\n            largestPrime\
    \ = p\n            n /= p\n        }\n        p += 1\n    }\n    return largestPrime\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmpuzvoxq4g.swift:12:15: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n            n /= p\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014154
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var divisor =\
    \ 2\n    var factor = n\n    while factor > 1 {\n        if factor % divisor ==\
    \ 0 {\n            factor /= divisor\n        } else {\n            divisor +=\
    \ 1\n        }\n    }\n    return divisor\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var largest_prime_factor\
    \ = 0\n    var smallest_factor = 2\n    var current_number = n\n    while current_number\
    \ > 1 {\n        if current_number % smallest_factor == 0 {\n            largest_prime_factor\
    \ = smallest_factor\n            current_number /= smallest_factor\n        }\
    \ else {\n            smallest_factor += 1\n        }\n    }\n    return largest_prime_factor\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var k = 2\n  \
    \  var p = n\n    while k * k <= p {\n        if p % k == 0 {\n            p /=\
    \ k\n        } else {\n            k += 1\n        }\n    }\n    return p\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    if n <= 1 {\n\
    \        return -1\n    }\n\n    if is_prime(n: n) {\n        return n\n    }\n\
    \n    var i = 2\n    while n % i != 0 {\n        i += 1\n    }\n\n    return max(i,\
    \ largest_prime_factor(n: n / i))\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmps59sd8ty.swift:12:8: error: cannot find 'is_prime' in scope\n \
    \   if is_prime(n: n) {\n       ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014154
- exit_code: 1
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    let factors =\
    \ factor(n: n)\n    return factors[factors.count - 1]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(largest_prime_factor(n: 15) == 5)\nassert(largest_prime_factor(n:\
    \ 27) == 3)\nassert(largest_prime_factor(n: 63) == 7)\nassert(largest_prime_factor(n:\
    \ 330) == 11)\nassert(largest_prime_factor(n: 13195) == 29)"
  status: SyntaxError
  stderr: "/tmp/tmptr82a3cp.swift:8:19: error: cannot find 'factor' in scope\n   \
    \ let factors = factor(n: n)\n                  ^~~~~~\n"
  stdout: ''
  timestamp: 1660014154
- exit_code: 0
  program: "\n/// Return the largest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n/// >>> largest_prime_factor(n: 13195)\n/// 29\n/// >>> largest_prime_factor(n:\
    \ 2048)\n/// 2\nfunc largest_prime_factor(n: Int) -> Int {\n    var div = 2\n\
    \    var factor = n\n    while factor > 1 {\n        if factor % div == 0 {\n\
    \            factor /= div\n        } else {\n            div += 1\n        }\n\
    \    }\n    return div\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(largest_prime_factor(n:\
    \ 15) == 5)\nassert(largest_prime_factor(n: 27) == 3)\nassert(largest_prime_factor(n:\
    \ 63) == 7)\nassert(largest_prime_factor(n: 330) == 11)\nassert(largest_prime_factor(n:\
    \ 13195) == 29)"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014154
