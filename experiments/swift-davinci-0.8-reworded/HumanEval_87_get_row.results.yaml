language: swift
name: HumanEval_87_get_row
results:
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for (n, row) in lst.enumerated() {\n      \
    \  for (m, el) in row.enumerated() {\n            if el == x {\n             \
    \   res.append((n, m))\n            }\n        }\n    }\n    return res.sorted(by:\
    \ { (lhs, rhs) -> Bool in\n        if lhs.0 == rhs.0 {\n            return lhs.1\
    \ > rhs.1\n        }\n        return lhs.0 < rhs.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var row = 0\n    for sublist in lst {\n\
    \        var col = 0\n        for num in sublist {\n            if num == x {\n\
    \                result.append((row, col))\n            }\n            col +=\
    \ 1\n        }\n        row += 1\n    }\n    return result.sorted(by: {\n    \
    \    if $0.0 == $1.0 {\n            return $0.1 > $1.1\n        }\n        return\
    \ $0.0 < $1.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                res.append((i,\
    \ j))\n            }\n        }\n    }\n    res.sort(by: { $0.0 < $1.0 })\n  \
    \  res.sort(by: { $0.1 > $1.1 })\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpzwi_af7u/tmpzwi_af7u.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6c6dcfac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6c6d9f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6c6d9f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6c6d9f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzwi_af7u                        0x00005623387d185f <unavailable> + 6239

    5    libc.so.6                          0x00002b6c6dee6460 __libc_start_main +
    245

    6    tmpzwi_af7u                        0x00005623387d1329 <unavailable> + 4905

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var i = 0\n    for row in lst {\n    \
    \    for (j, el) in row.enumerated() {\n            if el == x {\n           \
    \     result.append((i, j))\n            }\n        }\n        i += 1\n    }\n\
    \    return result.sorted(by: {\n        if $0.0 != $1.0 {\n            return\
    \ $0.0 < $1.0\n        } else {\n            return $0.1 > $1.1\n        }\n \
    \   })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap { (i, arr) in\n        arr.enumerated().filter\
    \ { $0.element == x }.map { (i, $0.offset) }\n    }.sorted(by: { $0.0 < $1.0 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph8pw86xn/tmph8pw86xn.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bb149bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bb1192b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bb1192988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bb11917b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph8pw86xn                        0x000055c3903b07af <unavailable> + 6063

    5    libc.so.6                          0x00002b4bb1687460 __libc_start_main +
    245

    6    tmph8pw86xn                        0x000055c3903b0279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let sorted: [[Int]] = lst.map({ row in\n        var row = row\n        row.sort(by:\
    \ { $0 > $1 })\n        return row\n    })\n    let rows = lst.map({ row in\n\
    \        let rowIndex = lst.index(of: row)!\n        let indexes = row.enumerated().filter({\
    \ $0.element == x }).map({ $0.offset })\n        return indexes.map({ (rowIndex,\
    \ $0) })\n    })\n    return rows.flatMap({ $0 }).sorted(by: { $0.0 < $1.0 ||\
    \ ($0.0 == $1.0 && $0.1 > $1.1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9uvur3wa/tmp9uvur3wa.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5651a58c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b565174fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b565174f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b565174e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9uvur3wa                        0x000055d883240cf5 <unavailable> + 7413

    5    libc.so.6                          0x00002b5651c44460 __libc_start_main +
    245

    6    tmp9uvur3wa                        0x000055d883240439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var tuples: [(Int, Int)] = []\n  for (i, n) in lst.enumerated() {\n    for\
    \ (j, k) in n.enumerated() {\n      if k == x {\n        tuples.append((i, j))\n\
    \      }\n    }\n  }\n  tuples.sort { $0.0 < $1.0 }\n  tuples.sort { $0.1 > $1.1\
    \ }\n  return tuples\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmprex9dxi6/tmprex9dxi6.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af06f281c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af06ef78b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af06ef78988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af06ef777b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprex9dxi6                        0x000055fa6f7057ff <unavailable> + 6143

    5    libc.so.6                          0x00002af06f46d460 __libc_start_main +
    245

    6    tmprex9dxi6                        0x000055fa6f7052c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (index1, value1) in lst.enumerated()\
    \ {\n        for (index2, value2) in value1.enumerated() {\n            if value2\
    \ == x {\n                result.append((index1, index2))\n            }\n   \
    \     }\n    }\n    let sortedResult = result.sorted(by: { $0.0 == $1.0 ? $0.1\
    \ > $1.1 : $0.0 < $1.0 })\n    return sortedResult\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, arr) in lst.enumerated() {\n\
    \        for (col, val) in arr.enumerated() {\n            if val == x {\n   \
    \             result.append((row, col))\n            }\n        }\n    }\n   \
    \ return result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n    \
    \        return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let row_with_cols = lst.enumerated().map({ ($0.0, $0.1.enumerated().filter({\
    \ $0.1 == x })) })\n    let filtered_rows = row_with_cols.filter({ $0.1.count\
    \ > 0 })\n    return filtered_rows.map({ row in\n        (row.0, row.1.map({ $0.0\
    \ }).max()!)\n    }).sorted(by: { $0.0 < $1.0 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpwjnr13vd/tmpwjnr13vd.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6df2b01c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6df27f8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6df27f8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6df27f77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwjnr13vd                        0x0000559b0ede599f <unavailable> + 6559

    5    libc.so.6                          0x00002b6df2ced460 __libc_start_main +
    245

    6    tmpwjnr13vd                        0x0000559b0ede5469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([]) {\n        if let index = $1.firstIndex(of:\
    \ x) {\n            return $0 + [(index, $0.count)]\n        }\n        return\
    \ $0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpkt1p9zf5.swift:19:27: error: value of tuple type 'EnumeratedSequence<[[Int]]>.Iterator.Element'\
    \ (aka '(offset: Int, element: Array<Int>)') has no member 'firstIndex'\n    \
    \    if let index = $1.firstIndex(of: x) {\n                       ~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // insert code here\n    var tuples: [(Int, Int)] = []\n    var index: Int\
    \ = 0\n    for row in lst {\n        var i: Int = 0\n        while i < row.count\
    \ {\n            if x == row[i] {\n                tuples.append((index, i))\n\
    \            }\n            i += 1\n        }\n        index += 1\n    }\n   \
    \ tuples.sort {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n \
    \       }\n        return $0.0 < $1.0\n    }\n    return tuples\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\t\
    var tuples: [(Int, Int)] = []\n\tvar n = 0\n\tfor array in lst {\n\t\tfor i in\
    \ 0..<array.count {\n\t\t\tif array[i] == x {\n\t\t\t\ttuples.append((n, i))\n\
    \t\t\t}\n\t\t}\n\t\tn = n + 1\n\t}\n\ttuples.sort{ $0.0 < $1.0 }\n\tfor i in 0..<tuples.count\
    \ {\n\t\tfor j in 0..<tuples.count - 1 {\n\t\t\tif tuples[j].0 == tuples[j + 1].0\
    \ {\n\t\t\t\tif tuples[j].1 < tuples[j + 1].1 {\n\t\t\t\t\tlet temp = tuples[j]\n\
    \t\t\t\t\ttuples[j] = tuples[j + 1]\n\t\t\t\t\ttuples[j + 1] = temp\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\treturn tuples\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var tupleArray: [(Int, Int)] = []\n    for (index, value) in lst.enumerated()\
    \ {\n        for (innerIndex, innerValue) in value.enumerated() {\n          \
    \  if innerValue == x {\n                tupleArray.append((index, innerIndex))\n\
    \            }\n        }\n    }\n    return tupleArray.sorted { ($0.0 < $1.0)\
    \ || ($0.0 == $1.0 && $0.1 > $1.1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // return (0..<lst.count).flatMap {\n    //     (0..<lst[$0].count).compactMap\
    \ {\n    //         lst[$0][$1] == x ? ($0, $1) : nil\n    //     }\n    // }\n\
    \    var result: [(Int, Int)] = []\n    for (row, arr) in lst.enumerated() {\n\
    \        for (column, element) in arr.enumerated() {\n            if element ==\
    \ x {\n                result.append((row, column))\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpcy2k6qfu/tmpcy2k6qfu.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b40bfa5bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b40bf752b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b40bf752988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b40bf7517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcy2k6qfu                        0x0000561ddd5d070f <unavailable> + 5903

    5    libc.so.6                          0x00002b40bfc47460 __libc_start_main +
    245

    6    tmpcy2k6qfu                        0x0000561ddd5d01d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var index = [(Int, Int)]()\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                index.append((i,\
    \ j))\n            }\n        }\n    }\n    index.sort { (e1, e2) -> Bool in\n\
    \        if e1.0 < e2.0 {\n            return true\n        } else if e1.0 ==\
    \ e2.0 {\n            return e1.1 > e2.1\n        } else {\n            return\
    \ false\n        }\n    }\n    return index\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    var i = 0\n    while i < lst.count {\n \
    \       let row = lst[i]\n        var j = 0\n        while j < row.count {\n \
    \           if row[j] == x {\n                result.append((i, j))\n        \
    \    }\n            j += 1\n        }\n        i += 1\n    }\n    return result.sorted(by:\
    \ { (p1, p2) -> Bool in\n        if p1.0 == p2.0 {\n            return p1.1 >\
    \ p2.1\n        }\n        return p1.0 < p2.0\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  let tuplesArray = lst.enumerated().flatMap { (outerIndex, array) -> [(Int,\
    \ Int)] in\n    let tuples = array.enumerated().filter { (index, val) -> Bool\
    \ in\n      return val == x\n    }.map { (index, _) -> (Int, Int) in\n      return\
    \ (outerIndex, index)\n    }\n    return tuples\n  }\n  let sortedTuples = tuplesArray.sorted\
    \ { (t1, t2) -> Bool in\n    if t1.0 == t2.0 {\n      return t1.1 > t2.1\n   \
    \ }\n    return t1.0 < t2.0\n  }\n  return sortedTuples\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([(Int, Int)]()) { (res, pair) in\n       \
    \ let (index, list) = pair\n        let row = list.enumerated().filter({ (subpair)\
    \ -> Bool in\n            let (subindex, elem) = subpair\n            return elem\
    \ == x\n        }).map({ (subpair) -> (Int, Int) in\n            let (subindex,\
    \ _) = subpair\n            return (index, subindex)\n        })\n        return\
    \ res + row\n    }.sorted(by: { (a, b) -> Bool in\n        if a.0 != b.0 {\n \
    \           return a.0 < b.0\n        } else {\n            return a.1 > b.1\n\
    \        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([(Int, Int)]()) { (res, item) in\n       \
    \ let (index, array) = item\n        let ret = array.enumerated().filter { (tuple)\
    \ -> Bool in\n            return tuple.element == x\n        }.map { (tuple) ->\
    \ (Int, Int) in\n            let (index, _) = tuple\n            return (index,\
    \ index)\n        }\n        return res + ret\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpzmdxizbr/tmpzmdxizbr.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab237f8cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab237c83b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab237c83988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab237c827b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzmdxizbr                        0x0000558f6a3d87df <unavailable> + 6111

    5    libc.so.6                          0x00002ab238178460 __libc_start_main +
    245

    6    tmpzmdxizbr                        0x0000558f6a3d82a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var i = 0, j = 0\n    for elem in lst\
    \ {\n        j = 0\n        for innerElem in elem {\n            if innerElem\
    \ == x {\n                result.append((i, j))\n            }\n            j\
    \ += 1\n        }\n        i += 1\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpkgtse_bd/tmpkgtse_bd.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b681ff3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b681fc31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b681fc31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b681fc307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkgtse_bd                        0x000055a1ebe9865f <unavailable> + 5727

    5    libc.so.6                          0x00002b6820126460 __libc_start_main +
    245

    6    tmpkgtse_bd                        0x000055a1ebe98129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap { row in\n        return row.element.enumerated().filter({\
    \ $0.element == x })\n            .map { x, y in (row.offset, y) }\n    }.sorted(by:\
    \ { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph4a78n9w/tmph4a78n9w.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3671a8fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3671786b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3671786988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b36717857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph4a78n9w                        0x000055d3af77f7af <unavailable> + 6063

    5    libc.so.6                          0x00002b3671c7b460 __libc_start_main +
    245

    6    tmph4a78n9w                        0x000055d3af77f279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (row, colList) in lst.enumerated() {\n\
    \        for (col, item) in colList.enumerated() {\n            if item == x {\n\
    \                result.append((row, col))\n            }\n        }\n    }\n\
    \    return result.sorted(by: { (tuple1, tuple2) -> Bool in\n        if tuple1.0\
    \ < tuple2.0 {\n            return true\n        } else if tuple1.0 == tuple2.0\
    \ {\n            return tuple1.1 > tuple2.1\n        } else {\n            return\
    \ false\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    lst.enumerated().forEach { index, innerArr\
    \ in\n        innerArr.enumerated().forEach { innerIndex, innerValue in\n    \
    \        if x == innerValue {\n                result.append((index, innerIndex))\n\
    \            }\n        }\n    }\n    return result.sorted{$0.0 == $1.0 ? $0.1\
    \ > $1.1 : $0.0 < $1.0}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, element) in row.enumerated() {\n            if element == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted{$0.0 < $1.0}.sorted{$0.1 > $1.1}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpqqxno3_x/tmpqqxno3_x.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b52c8c25c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52c891cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52c891c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52c891b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqqxno3_x                        0x000056230bfe177f <unavailable> + 6015

    5    libc.so.6                          0x00002b52c8e11460 __libc_start_main +
    245

    6    tmpqqxno3_x                        0x000056230bfe1249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014106
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014106
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let sorted = lst.enumerated().filter({ $0.element.contains(x) }).sorted(by:\
    \ { $0.offset < $1.offset })\n    return sorted.map({ ($0.offset, $0.element.index(of:\
    \ x)!) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp68cj48ml/tmp68cj48ml.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae279d0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae279a05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae279a05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae279a047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp68cj48ml                        0x000055cc27a5089f <unavailable> + 6303

    5    libc.so.6                          0x00002ae279efa460 __libc_start_main +
    245

    6    tmp68cj48ml                        0x000055cc27a50369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    var rowCounter = 0\n    var columnCounter\
    \ = 0\n    for row in lst {\n        columnCounter = 0\n        for element in\
    \ row {\n            if element == x {\n                result.append((rowCounter,\
    \ columnCounter))\n            }\n            columnCounter += 1\n        }\n\
    \        rowCounter += 1\n    }\n    return result.sorted { (a, b) -> Bool in\n\
    \        if a.0 < b.0 {\n            return true\n        } else if a.0 == b.0\
    \ {\n            return a.1 > b.1\n        } else {\n            return false\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap { (row_index, row) -> [(Int, Int)] in\n \
    \       row.enumerated().filter { (column_index, element) -> Bool in\n       \
    \     element == x\n        }.map { (column_index, element) -> (Int, Int) in\n\
    \            (row_index, column_index)\n        }\n    }.sorted { (lhs, rhs) ->\
    \ Bool in\n        if lhs.0 == rhs.0 {\n            return lhs.1 > rhs.1\n   \
    \     }\n        return lhs.0 < rhs.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var tuples = [(Int, Int)]()\n  for (index, values) in lst.enumerated() {\n\
    \    for (i, value) in values.enumerated() {\n      if value == x {\n        tuples.append((index,\
    \ i))\n      }\n    }\n  }\n  return tuples.sorted(by: {\n    if $0.0 != $1.0\
    \ {\n      return $0.0 < $1.0\n    } else {\n      return $0.1 > $1.1\n    }\n\
    \  })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var arr : [(Int, Int)] = []\n    var rowCount = 0\n    for row in lst {\n\
    \        for value in row {\n            if (value == x) {\n                arr.append((rowCount,\
    \ row.index(of: value)!))\n            }\n        }\n        rowCount += 1\n \
    \   }\n    return arr.sorted(by: {\n        return ($0.0 < $1.0) ? true : (($0.0\
    \ == $1.0) ? ($0.1 > $1.1) : false)\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbyasosn_/tmpbyasosn_.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b970ea74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b970e76bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b970e76b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b970e76a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbyasosn_                        0x000055eeac8ae7df <unavailable> + 6111

    5    libc.so.6                          0x00002b970ec60460 __libc_start_main +
    245

    6    tmpbyasosn_                        0x000055eeac8ae2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var arr = [(Int, Int)]()\n    for (row, rowArr) in lst.enumerated() {\n \
    \       for (col, num) in rowArr.enumerated() {\n            if num == x {\n \
    \               arr.append((row, col))\n            }\n        }\n    }\n    return\
    \ arr.sorted { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 > $1.1) }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (indexRow, row) in lst.enumerated()\
    \ {\n        for (indexCol, value) in row.enumerated() {\n            if value\
    \ == x {\n                result.append((indexRow, indexCol))\n            }\n\
    \        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: {\
    \ $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbv73w0lu/tmpbv73w0lu.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abaa4adfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abaa47d6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abaa47d6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abaa47d57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbv73w0lu                        0x000056407121c77f <unavailable> + 6015

    5    libc.so.6                          0x00002abaa4ccb460 __libc_start_main +
    245

    6    tmpbv73w0lu                        0x000056407121c249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var coordinates = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n\
    \        for (j, x1) in row.enumerated() {\n            if x1 == x {\n       \
    \         coordinates.append((i, j))\n            }\n        }\n    }\n    return\
    \ coordinates.sorted { $0.0 < $1.0 || $0.0 == $1.0 && $0.1 > $1.1 }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var a: [(Int, Int)] = []\n    var r: [Int] = []\n    var temp: [Int] = []\n\
    \    for x in 0..<lst.count {\n        r.append(x)\n    }\n    for x in lst {\n\
    \        temp.append(x.count)\n    }\n    for x in 0..<lst.count {\n        if\
    \ temp[x] == 0 {\n            r.remove(at: x)\n        }\n    }\n    for x in\
    \ 0..<lst.count {\n        for y in 0..<lst[x].count {\n            if lst[x][y]\
    \ == x {\n                a.append((x, y))\n            }\n        }\n    }\n\
    \    return a\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp_uthlbhm/tmp_uthlbhm.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abeb0fd0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abeb0cc7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abeb0cc7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abeb0cc67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_uthlbhm                        0x0000562a9e8f898f <unavailable> + 6543

    5    libc.so.6                          0x00002abeb11bc460 __libc_start_main +
    245

    6    tmp_uthlbhm                        0x0000562a9e8f8459 <unavailable> + 5209

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let flatten = lst.enumerated().flatMap { (offset, element) -> [(Int, Int)]\
    \ in\n        return element.enumerated().compactMap { (offset2, element2) ->\
    \ (Int, Int)? in\n            return element2 == x ? (offset, offset2) : nil\n\
    \        }\n    }.sorted { (left, right) -> Bool in\n        if left.0 == right.0\
    \ {\n            return left.1 > right.1\n        }\n        return left.0 < right.0\n\
    \    }\n    return flatten\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var coordinates = [(Int, Int)]()\n    var rows = 0\n    var columns = 0\n\
    \    for row in lst {\n        columns = 0\n        for column in row {\n    \
    \        if column == x {\n                coordinates.append((rows, columns))\n\
    \            }\n            columns += 1\n        }\n        rows += 1\n    }\n\
    \    coordinates.sort { (first, second) -> Bool in\n        if first.0 < second.0\
    \ {\n            return true\n        } else if first.0 == second.0 {\n      \
    \      return first.1 > second.1\n        } else {\n            return false\n\
    \        }\n    }\n    return coordinates\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var list : [(Int, Int)] = []\n    for (i, array) in lst.enumerated() {\n\
    \        for (j, number) in array.enumerated() {\n            if number == x {\n\
    \                list.append((i, j))\n            }\n        }\n    }\n    list.sort{($0.0,\
    \ -$0.1) < ($1.0, -$1.1)}\n    return list\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var row: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                row.append((i,\
    \ j))\n            }\n        }\n    }\n    return row.sorted(by: {$0.0 < $1.0}).sorted(by:\
    \ {$0.1 > $1.1})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpwd9tzipc/tmpwd9tzipc.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82934bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82931b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82931b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82931b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwd9tzipc                        0x000055b7adf267ef <unavailable> + 6127

    5    libc.so.6                          0x00002b82936a9460 __libc_start_main +
    245

    6    tmpwd9tzipc                        0x000055b7adf262b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let lst = lst.enumerated().map { (i, a) in\n        a.enumerated().map {\
    \ (j, a) in\n            (i, j, a)\n        }\n    }.flatMap { $0 }.filter { $0.2\
    \ == x }.sorted { $0.0 < $1.0 }.map { (i, j, _) in\n        (i, j)\n    }\n  \
    \  return lst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpt2evrqo1/tmpt2evrqo1.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad79d5afc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad79d2a6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad79d2a6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad79d2a57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpt2evrqo1                        0x000055a17c22986f <unavailable> + 6255

    5    libc.so.6                          0x00002ad79d79b460 __libc_start_main +
    245

    6    tmpt2evrqo1                        0x000055a17c229339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for i in 0..<lst.count {\n        var j\
    \ = 0\n        while j < lst[i].count {\n            if lst[i][j] == x {\n   \
    \             result.append((i, j))\n            }\n            j += 1\n     \
    \   }\n    }\n    return result.sorted(by: {$0.0 < $1.0}).sorted(by: {$0.1 > $1.1})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpnpah4al0/tmpnpah4al0.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acde16bdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acde13b4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acde13b4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acde13b37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnpah4al0                        0x000055c53f94983f <unavailable> + 6207

    5    libc.so.6                          0x00002acde18a9460 __libc_start_main +
    245

    6    tmpnpah4al0                        0x000055c53f949309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: { $0.0 <\
    \ $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp2u0dqtn8/tmp2u0dqtn8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1020257c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b101ff4eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b101ff4e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b101ff4d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2u0dqtn8                        0x00005636c511c7ef <unavailable> + 6127

    5    libc.so.6                          0x00002b1020443460 __libc_start_main +
    245

    6    tmp2u0dqtn8                        0x00005636c511c2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013889
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return [] as [(Int, Int)]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp2np9vvcf/tmp2np9vvcf.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d5ba22c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d5b719b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d5b719988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d5b7187b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2np9vvcf                        0x000055c7ac63249f <unavailable> + 5279

    5    libc.so.6                          0x00002b2d5bc0e460 __libc_start_main +
    245

    6    tmp2np9vvcf                        0x000055c7ac631f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap{ (index, array) in\n        return array.enumerated().filter{\
    \ $0.element == x }.map{ ($0.offset, index) }\n    }.sorted(by: <).sorted(by:\
    \ >)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp9rbwyu6i/tmp9rbwyu6i.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57a1e88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57a1b7fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57a1b7f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57a1b7e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9rbwyu6i                        0x0000560861ce18bf <unavailable> + 6335

    5    libc.so.6                          0x00002b57a2074460 __libc_start_main +
    245

    6    tmp9rbwyu6i                        0x0000560861ce1389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // your code here\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpi1eg11o7/tmpi1eg11o7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bcd2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bccfacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bccfac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bccfab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi1eg11o7                        0x0000564afd81f49f <unavailable> + 5279

    5    libc.so.6                          0x00002b4bcd4a1460 __libc_start_main +
    245

    6    tmpi1eg11o7                        0x0000564afd81ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (row, rows) in lst.enumerated() {\n\
    \        for (column, value) in rows.enumerated() {\n            if value == x\
    \ {\n                result.append((row, column))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { (left, right) -> Bool in\n        if left.0\
    \ < right.0 {\n            return true\n        } else if left.0 == right.0 {\n\
    \            return left.1 > right.1\n        } else {\n            return false\n\
    \        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, value) in lst.enumerated()\
    \ {\n        if let indexOf = value.index(of: x) {\n            result.append((index,\
    \ indexOf))\n        }\n    }\n    return result.sorted(by: {\n        if $0.0\
    \ == $1.0 {\n            return $0.1 > $1.1\n        }\n        return $0.0 <\
    \ $1.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpodsdwazz/tmpodsdwazz.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b75908adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b75905a4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b75905a4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b75905a37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpodsdwazz                        0x00005625701cd82f <unavailable> + 6191

    5    libc.so.6                          0x00002b7590a99460 __libc_start_main +
    245

    6    tmpodsdwazz                        0x00005625701cd2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: {$0.0 < $1.0\
    \ || ($0.0 == $1.0 && $0.1 > $1.1)})\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var coord = [(Int, Int)]()\n    for(row, array) in lst.enumerated() {\n \
    \       for(col, element) in array.enumerated() {\n            if element == x\
    \ {\n                coord.append((row, col))\n            }\n        }\n    }\n\
    \    coord.sort {$0.0 < $1.0}\n    coord.sort {$0.1 > $1.1}\n    return coord\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpybbub6z7/tmpybbub6z7.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0322bf2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b03228e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b03228e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b03228e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpybbub6z7                        0x000055aa7422584f <unavailable> + 6223

    5    libc.so.6                          0x00002b0322dde460 __libc_start_main +
    245

    6    tmpybbub6z7                        0x000055aa74225319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var newLst = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n   \
    \     for (j, value) in row.enumerated() {\n            if x == value {\n    \
    \            newLst.append((i, j))\n            }\n        }\n    }\n    newLst.sort\
    \ { $0.0 < $1.0 }\n    for i in 0..<newLst.count - 1 {\n        if newLst[i].0\
    \ == newLst[i + 1].0 {\n            if newLst[i].1 < newLst[i + 1].1 {\n     \
    \           let temp = newLst[i]\n                newLst[i] = newLst[i + 1]\n\
    \                newLst[i + 1] = temp\n            }\n        }\n    }\n    return\
    \ newLst\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c96970c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c96667561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b9c96667286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b9c9666713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b9c96666bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpxj87r50i                        0x000055d8a081ec07 <unavailable> + 11271

    6    tmpxj87r50i                        0x000055d8a081e28a <unavailable> + 8842

    7    libc.so.6                          0x00002b9c96b5c460 __libc_start_main +
    245

    8    tmpxj87r50i                        0x000055d8a081d539 <unavailable> + 5433

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, e) in lst.enumerated() {\n   \
    \     for (j, ee) in e.enumerated() {\n            if ee == x {\n            \
    \    result.append((i, j))\n            }\n        }\n    }\n    let result1 =\
    \ result.sorted { (e1, e2) -> Bool in\n        if e1.0 == e2.0 {\n           \
    \ return e1.1 > e2.1\n        }\n        return e1.0 < e2.0\n    }\n    return\
    \ result1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                res.append((i,\
    \ j))\n            }\n        }\n    }\n    return res.sorted(by: {a, b in\n \
    \       if a.0 == b.0 {\n            return a.1 > b.1\n        }\n        return\
    \ a.0 < b.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpux68fkdz/tmpux68fkdz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba686718c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba68640fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba68640f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba68640e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpux68fkdz                        0x000055ebddab949f <unavailable> + 5279

    5    libc.so.6                          0x00002ba686904460 __libc_start_main +
    245

    6    tmpux68fkdz                        0x000055ebddab8f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var tuple_lst = [(Int, Int)]()\n    for (row, row_lst) in lst.enumerated()\
    \ {\n        for (col, x_val) in row_lst.enumerated() {\n            if x_val\
    \ == x {\n                tuple_lst.append((row, col))\n            }\n      \
    \  }\n    }\n    return tuple_lst.sorted {\n        if $0.0 == $1.0 {\n      \
    \      return $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([]) {\n        var m = $0\n        $1.0.enumerated().forEach\
    \ {\n            if $1.1 == x {\n                m.append(($1.0, $0))\n      \
    \      }\n        }\n        return m\n    }.sorted(by: {\n        if $0.0 ==\
    \ $1.0 {\n            return $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmplmubebwi.swift:20:14: error: value of type 'Int' has no member\
    \ 'enumerated'\n        $1.0.enumerated().forEach {\n        ~~~~ ^~~~~~~~~~\n\
    /tmp/tmplmubebwi.swift:22:26: error: tuple type '(Int, _)' is not convertible\
    \ to tuple type '(Int, Int)'\n                m.append(($1.0, $0))\n         \
    \                ^\n"
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var to_return: [(Int, Int)] = []\n    var i = 0\n    for row in lst {\n \
    \       var j = 0\n        for col in row {\n            if (col == x) {\n   \
    \             to_return.append((i, j))\n            }\n            j += 1\n  \
    \      }\n        i += 1\n    }\n    return to_return\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmporati9yn/tmporati9yn.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c09a74c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c0976bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c0976b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c0976a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmporati9yn                        0x0000558d8386b65f <unavailable> + 5727

    5    libc.so.6                          0x00002b2c09c60460 __libc_start_main +
    245

    6    tmporati9yn                        0x0000558d8386b129 <unavailable> + 4393

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (indexI, i) in lst.enumerated() {\n\
    \        for (indexJ, j) in i.enumerated() {\n            if j == x {\n      \
    \          result.append((indexI, indexJ))\n            }\n        }\n    }\n\
    \    return result.sorted { (a, b) -> Bool in\n        if a.0 != b.0 {\n     \
    \       return a.0 < b.0\n        } else {\n            return a.1 > b.1\n   \
    \     }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, v) in row.enumerated() {\n            if v == x {\n          \
    \      result.append((i, j))\n            }\n        }\n    }\n    return result.sorted\
    \ { (t1, t2) -> Bool in\n        if t1.0 == t2.0 {\n            return t1.1 >\
    \ t2.1\n        }\n        return t1.0 < t2.0\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var result: [(Int, Int)] = []\n  for (row, rowData) in lst.enumerated() {\n\
    \    for (column, columnData) in rowData.enumerated() {\n      if columnData ==\
    \ x {\n        result.append((row, column))\n      }\n    }\n  }\n  return result.sorted\
    \ { (t1, t2) -> Bool in\n    if t1.0 != t2.0 {\n      return t1.0 < t2.0\n   \
    \ } else {\n      return t1.1 > t2.1\n    }\n  }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\t\
    var positionList = [(Int, Int)]()\n\tfor (row, col) in lst.enumerated() {\n\t\t\
    for (index, value) in col.enumerated() {\n\t\t\tif value == x {\n\t\t\t\tpositionList.append((row,\
    \ index))\n\t\t\t}\n\t\t}\n\t}\n\treturn positionList.sorted(by: {$0.0 < $1.0\
    \ || ($0.0 == $1.0 && $0.1 > $1.1)})\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    var rows = [Int]()\n    var cols = [Int]()\n\
    \    for (index1, row) in lst.enumerated() {\n        for (index2, col) in row.enumerated()\
    \ {\n            if col == x {\n                rows.append(index1)\n        \
    \        cols.append(index2)\n            }\n        }\n    }\n    for i in 0..<rows.count\
    \ {\n        res.append((rows[i], cols[i]))\n    }\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpqmj9zq1j/tmpqmj9zq1j.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8d1a830c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8d1a527b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8d1a527988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8d1a5267b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqmj9zq1j                        0x000055cd1110fa3f <unavailable> + 6719

    5    libc.so.6                          0x00002b8d1aa1c460 __libc_start_main +
    245

    6    tmpqmj9zq1j                        0x000055cd1110f509 <unavailable> + 5385

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n   \
    \     for (j, value) in row.enumerated() {\n            if value == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { (a, b) -> Bool in\n        if a.0 != b.0 {\n           \
    \ return a.0 < b.0\n        } else {\n            return a.1 > b.1\n        }\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([]) { (result, enumeration) in\n        result\
    \ + enumeration.element.enumerated().filter { $0.element == x }.map { (enumeration.offset,\
    \ $0.offset) }\n    }.sorted { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 > $1.1) }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let indices = lst.enumerated().map { (row, columns) -> [Int] in\n       \
    \ columns.enumerated().filter { $0.element == x }.map { (row, $0.offset) }\n \
    \   }.flatMap { $0 }\n    return indices.sorted { $0.0 < $1.0 || ($0.0 == $1.0\
    \ && $0.1 > $1.1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpw6x0yuoe.swift:19:63: error: cannot convert value of type '(Int,\
    \ Int)' to closure result type 'Int'\n        columns.enumerated().filter { $0.element\
    \ == x }.map { (row, $0.offset) }\n                                          \
    \                    ^~~~~~~~~~~~~~~~\n/tmp/tmpw6x0yuoe.swift:21:12: error: the\
    \ compiler is unable to type-check this expression in reasonable time; try breaking\
    \ up the expression into distinct sub-expressions\n    return indices.sorted {\
    \ $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 > $1.1) }\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014278
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var array = [(Int, Int)]()\n    for (i, element) in lst.enumerated() {\n\
    \        let filtered = element.enumerated().filter { (index, value) -> Bool in\n\
    \            return value == x\n        }\n        for (j, _) in filtered {\n\
    \            array.append((i, j))\n        }\n    }\n    return array.sorted(by:\
    \ { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return a.1 > b.1\n\
    \        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var indexes: [(Int, Int)] = []\n    lst.enumerated().forEach { (idx, subarray)\
    \ in\n        subarray.enumerated().forEach {\n            if $1 == x {\n    \
    \            indexes.append((idx, $0))\n            }\n        }\n    }\n    indexes.sort\
    \ {\n        $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 > $1.1)\n    }\n    return indexes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let result = lst.enumerated().flatMap { (index, arr) -> [(Int, Int)] in\n\
    \        arr.enumerated().compactMap { (xIndex, value) -> (Int, Int)? in\n   \
    \         if value == x {\n                return (index, xIndex)\n          \
    \  }\n            return nil\n        }\n    }\n    return result.sorted(by: {\
    \ (t1, t2) -> Bool in\n        if t1.0 == t2.0 {\n            return t1.1 > t2.1\n\
    \        }\n        return t1.0 < t2.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, array) in lst.enumerated() {\n\
    \        for (j, item) in array.enumerated() {\n            if item == x {\n \
    \               result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: { $0.0 < $1.0 })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpoe78rxc_/tmpoe78rxc_.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2c55ea1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2c55b98b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2c55b98988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2c55b977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoe78rxc_                        0x000055af21cf977f <unavailable> + 6015

    5    libc.so.6                          0x00002b2c5608d460 __libc_start_main +
    245

    6    tmpoe78rxc_                        0x000055af21cf9249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // your code here\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpi1eg11o7/tmpi1eg11o7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bcd2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bccfacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bccfac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bccfab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi1eg11o7                        0x0000564afd81f49f <unavailable> + 5279

    5    libc.so.6                          0x00002b4bcd4a1460 __libc_start_main +
    245

    6    tmpi1eg11o7                        0x0000564afd81ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var arr: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                arr.append((i,\
    \ j))\n            }\n        }\n    }\n    arr.sort(by: <)\n    return arr\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpnfku96bu/tmpnfku96bu.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87a2af2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87a27e9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87a27e9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87a27e87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnfku96bu                        0x0000562238acb90f <unavailable> + 6415

    5    libc.so.6                          0x00002b87a2cde460 __libc_start_main +
    245

    6    tmpnfku96bu                        0x0000562238acb3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var result = [(Int, Int)]()\n  for (row_index, row) in lst.enumerated() {\n\
    \    for (column_index, column) in row.enumerated() {\n      if column == x {\n\
    \        result.append((row_index, column_index))\n      }\n    }\n  }\n  return\
    \ result.sorted(by: {\n    if $0.0 != $1.0 {\n      return $0.0 < $1.0\n    }\
    \ else {\n      return $0.1 > $1.1\n    }\n  })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, _) in row.enumerated() {\n            if row[index2] ==\
    \ x {\n                result.append((index, index2))\n            }\n       \
    \ }\n    }\n    return result.sorted{ $0.0 < $1.0 }.sorted{ $0.1 > $1.1 }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpew2htr42/tmpew2htr42.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b813f338c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b813f02fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b813f02f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b813f02e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpew2htr42                        0x000055cbf441681f <unavailable> + 6175

    5    libc.so.6                          0x00002b813f524460 __libc_start_main +
    245

    6    tmpew2htr42                        0x000055cbf44162e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for (i, e) in lst.enumerated() {\n      \
    \  for (j, e1) in e.enumerated() {\n            if e1 == x {\n               \
    \ res.append((i, j))\n            }\n        }\n    }\n    res.sort {\n      \
    \  $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 > $1.1)\n    }\n    return res\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                res.append((i,\
    \ j))\n            }\n        }\n    }\n    return res.sorted(by: {$0.0 < $1.0}).sorted(by:\
    \ {$0.1 > $1.1})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp6g94umyr/tmp6g94umyr.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9d77eb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9d77ba8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9d77ba8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9d77ba77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6g94umyr                        0x000055636c0da83f <unavailable> + 6207

    5    libc.so.6                          0x00002b9d7809d460 __libc_start_main +
    245

    6    tmp6g94umyr                        0x000055636c0da309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\t\
    return lst.enumerated().flatMap { (row, rowValues) -> [(Int, Int)] in\n\t\treturn\
    \ rowValues.enumerated().compactMap { (column, value) -> (Int, Int)? in\n\t\t\t\
    return value == x ? (row, column) : nil\n\t\t}.sorted { $0.1 > $1.1 }\n\t}.sorted(by:\
    \ { $0.0 < $1.0 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var array: [(Int, Int)] = []\n    var rows: [Int] = []\n    var columns:\
    \ [Int] = []\n    var counter: Int = 0\n    for i in lst{\n        for x in i{\n\
    \            if x == x{\n                array.append((counter, i.firstIndex(of:\
    \ x)!))\n            }\n        }\n        counter += 1\n    }\n    for x in array{\n\
    \        rows.append(x.0)\n    }\n    rows.sort()\n    for x in rows{\n      \
    \  var counter: Int = 0\n        while counter < array.count{\n            if\
    \ array[counter].0 == x{\n                columns.append(array[counter].1)\n \
    \               array.remove(at: counter)\n            }\n            counter\
    \ += 1\n        }\n        columns.sort()\n        for z in columns{\n       \
    \     for y in array{\n                if z == y.1{\n                    array.remove(at:\
    \ array.firstIndex(of: y)!)\n                }\n            }\n        }\n   \
    \     for x in columns{\n            array.append((x, rows[rows.firstIndex(of:\
    \ x)!]))\n        }\n        columns.removeAll()\n    }\n    return array\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmp_jfq17yw.swift:47:38: error: type '(Int, Int)' cannot conform to\
    \ 'Equatable'\n                    array.remove(at: array.firstIndex(of: y)!)\n\
    \                                     ^\n/tmp/tmp_jfq17yw.swift:47:38: note: only\
    \ concrete types such as structs, enums and classes can conform to protocols\n\
    \                    array.remove(at: array.firstIndex(of: y)!)\n            \
    \                         ^\n/tmp/tmp_jfq17yw.swift:47:38: note: required by referencing\
    \ instance method 'firstIndex(of:)' on 'Collection' where 'Self.Element' = '(Int,\
    \ Int)'\n                    array.remove(at: array.firstIndex(of: y)!)\n    \
    \                                 ^\n"
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (idx, arr) in lst.enumerated() {\n\
    \        for (idx2, element) in arr.enumerated() {\n            if element ==\
    \ x {\n                result.append((idx, idx2))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpevhvp2n7/tmpevhvp2n7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb51879c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb51570b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb51570988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb5156f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpevhvp2n7                        0x00005626c5aed77f <unavailable> + 6015

    5    libc.so.6                          0x00002abb51a65460 __libc_start_main +
    245

    6    tmpevhvp2n7                        0x00005626c5aed249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // your code here\n    if lst.isEmpty {\n        return []\n    }\n    var\
    \ temp = [[Int]]()\n    var toReturn = [(Int, Int)]()\n    for i in 0..<lst.count\
    \ {\n        temp.append([])\n        for j in 0..<lst[i].count {\n          \
    \  if lst[i][j] == x {\n                temp[i].append(j)\n            }\n   \
    \     }\n    }\n    for i in 0..<temp.count {\n        temp[i].sort(by: >)\n \
    \   }\n    for i in 0..<temp.count {\n        for j in 0..<temp[i].count {\n \
    \           toReturn.append((i, temp[i][j]))\n        }\n    }\n    return toReturn\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var ret = [(Int, Int)]()\n    for (i, r) in lst.enumerated() {\n        for\
    \ (j, v) in r.enumerated() {\n            if v == x {\n                ret.append((i,\
    \ j))\n            }\n        }\n    }\n    return ret.sorted { (lhs, rhs) ->\
    \ Bool in\n        if lhs.0 != rhs.0 {\n            return lhs.0 < rhs.0\n   \
    \     } else {\n            return lhs.1 > rhs.1\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for i in 0..<lst.count {\n        for j\
    \ in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    result.sort {\n        if $0.0 ==\
    \ $1.0 {\n            return $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var lst = lst\n    var res = [(Int, Int)]()\n    var row = 0\n    for i in\
    \ lst {\n        var col = 0\n        for j in i {\n            if x == j {\n\
    \                res.append((row, col))\n            }\n            col += 1\n\
    \        }\n        row += 1\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpkutmcdx2/tmpkutmcdx2.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad8f5d17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad8f5a0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad8f5a0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad8f5a0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkutmcdx2                        0x00005624ad22c6af <unavailable> + 5807

    5    libc.so.6                          0x00002ad8f5f03460 __libc_start_main +
    245

    6    tmpkutmcdx2                        0x00005624ad22c179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var output = [(Int, Int)]()\n    for y in 0..<lst.count {\n        for z\
    \ in 0..<lst[y].count {\n            if lst[y][z] == x {\n                output.append((y,\
    \ z))\n            }\n        }\n    }\n    output.sort{$0.0 < $1.0}\n    for\
    \ i in 0..<output.count {\n        for j in 0..<output.count {\n            if\
    \ output[i].0 == output[j].0 && output[i].1 < output[j].1 {\n                output.swapAt(i,\
    \ j)\n            }\n        }\n    }\n    return output\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpyle38f3j/tmpyle38f3j.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5bbde17c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5bbdb0eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5bbdb0e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5bbdb0d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyle38f3j                        0x000055fd6b04391f <unavailable> + 6431

    5    libc.so.6                          0x00002b5bbe003460 __libc_start_main +
    245

    6    tmpyle38f3j                        0x000055fd6b0433e9 <unavailable> + 5097

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (row, value) in lst.enumerated() {\n\
    \        for (column, value) in value.enumerated() {\n            if value ==\
    \ x {\n                result.append((row, column))\n            }\n        }\n\
    \    }\n    return result.sorted { (first: (Int, Int), second: (Int, Int)) ->\
    \ Bool in\n        if first.0 == second.0 {\n            return first.1 > second.1\n\
    \        }\n        return first.0 < second.0\n    }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // get indexes of inner arrays\n    var indexes = [(0, 0)]\n    for (index,\
    \ element) in lst.enumerated() {\n        for (index_inner, element_inner) in\
    \ element.enumerated() {\n            if element_inner == x {\n              \
    \  indexes.append((index, index_inner))\n            }\n        }\n    }\n   \
    \ // sort indexes by row and inner\n    indexes.sort { (row1, row2) -> Bool in\n\
    \        if row1.0 == row2.0 {\n            return row1.1 > row2.1\n        }\n\
    \        return row1.0 < row2.0\n    }\n    // return result\n    return indexes\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpi8oi5v7t/tmpi8oi5v7t.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac058d2ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac058a25b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac058a25988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac058a247b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi8oi5v7t                        0x00005569f5fc17ff <unavailable> + 6143

    5    libc.so.6                          0x00002ac058f1a460 __libc_start_main +
    245

    6    tmpi8oi5v7t                        0x00005569f5fc12c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var tmp = [(Int, Int)]()\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                tmp.append((i,\
    \ j))\n            }\n        }\n    }\n    return tmp.sorted(by: {$0.0 < $1.0}).sorted(by:\
    \ {$0.1 > $1.1})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmprno31046/tmprno31046.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b504fba2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b504f899b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b504f899988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b504f8987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprno31046                        0x000055cb3f24a83f <unavailable> + 6207

    5    libc.so.6                          0x00002b504fd8e460 __libc_start_main +
    245

    6    tmprno31046                        0x000055cb3f24a309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for i in 0..<lst.count {\n        var j = 0\n\
    \        while j < lst[i].count {\n            if lst[i][j] == x {\n         \
    \       res.append((i, j))\n            }\n            j += 1\n        }\n   \
    \ }\n    res.sort {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var coordinate: (Int, Int) = (0, 0)\n\
    \    for row in lst {\n        coordinate.0 = lst.index(of: row)!\n        for\
    \ item in row {\n            coordinate.1 = row.index(of: item)!\n           \
    \ if item == x {\n                result.append(coordinate)\n            }\n \
    \       }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1\
    \ > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmptnjt6d0j/tmptnjt6d0j.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac454dac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac451d1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac451d1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac451d07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptnjt6d0j                        0x000055d8c7f3781f <unavailable> + 6175

    5    libc.so.6                          0x00002aac456c6460 __libc_start_main +
    245

    6    tmptnjt6d0j                        0x000055d8c7f372e9 <unavailable> + 4841

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (rowIndex, row) in lst.enumerated()\
    \ {\n        for (colIndex, col) in row.enumerated() {\n            if col ==\
    \ x {\n                result.append((rowIndex, colIndex))\n            }\n  \
    \      }\n    }\n    return result.sorted{\n        if $0.0 != $1.0 {\n      \
    \      return $0.0 < $1.0\n        } else {\n            return $0.1 > $1.1\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014107
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // your code here\n    var result: [(Int, Int)] = []\n    for i in 0...lst.count-1\
    \ {\n        for j in 0...lst[i].count-1 {\n            if lst[i][j] == x {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp3ul9p5c7/tmp3ul9p5c7.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c1ec60c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c1e957b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c1e957988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c1e9567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3ul9p5c7                        0x0000556ac928977f <unavailable> + 6015

    5    libc.so.6                          0x00002b9c1ee4c460 __libc_start_main +
    245

    6    tmp3ul9p5c7                        0x0000556ac9289249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let maxIndex = lst.reduce(0) { (result, array) -> Int in\n        max(result,\
    \ array.count)\n    }\n    var result = [(Int, Int)]()\n    var y = 0\n    while\
    \ y < lst.count {\n        var x = 0\n        while x < maxIndex {\n         \
    \   if x < lst[y].count && lst[y][x] == x {\n                result.append((y,\
    \ x))\n            }\n            x += 1\n        }\n        y += 1\n    }\n \
    \   return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp21ttzfmq/tmp21ttzfmq.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada8e30ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada8e001b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada8e001988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada8e0007b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp21ttzfmq                        0x000055860bdac74f <unavailable> + 5967

    5    libc.so.6                          0x00002ada8e4f6460 __libc_start_main +
    245

    6    tmp21ttzfmq                        0x000055860bdac219 <unavailable> + 4633

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for (i, sublst) in lst.enumerated() {\n   \
    \     for (j, y) in sublst.enumerated() {\n            if y == x {\n         \
    \       res.append((i, j))\n            }\n        }\n    }\n    return res.sorted\
    \ { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbhgkk1va/tmpbhgkk1va.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef79ac5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef797bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef797bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef797bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbhgkk1va                        0x0000564a958867cf <unavailable> + 6095

    5    libc.so.6                          0x00002aef79cb1460 __libc_start_main +
    245

    6    tmpbhgkk1va                        0x0000564a95886299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    /// Write your code here!\n    return [(0, 0)]\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpzedi957p/tmpzedi957p.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8242533c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b824222ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b824222a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82422297b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzedi957p                        0x000056387c44f49f <unavailable> + 5279

    5    libc.so.6                          0x00002b824271f460 __libc_start_main +
    245

    6    tmpzedi957p                        0x000056387c44ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for (r, row) in lst.enumerated() {\n      \
    \  for (c, e) in row.enumerated() {\n            if e == x {\n               \
    \ res.append((r, c))\n            }\n        }\n    }\n    res.sort { (t1, t2)\
    \ -> Bool in\n        if t1.0 == t2.0 {\n            return t1.1 > t2.1\n    \
    \    }\n        return t1.0 < t2.0\n    }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var rowArray: [(Int, Int)] = []\n  for i in 0..<lst.count {\n    for j in 0..<lst[i].count\
    \ {\n      if lst[i][j] == x {\n        rowArray.append((i, j))\n      }\n   \
    \ }\n  }\n  return rowArray.sorted { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpca92hsfp/tmpca92hsfp.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0d6f4e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0d6f1e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0d6f1e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0d6f1df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpca92hsfp                        0x000055c0913ca7ef <unavailable> + 6127

    5    libc.so.6                          0x00002b0d6f6d5460 __libc_start_main +
    245

    6    tmpca92hsfp                        0x000055c0913ca2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    /// TODO: check if proper input\n    var row = [(Int, Int)]()\n    for (i,\
    \ val) in lst.enumerated() {\n        for (j, value) in val.enumerated() {\n \
    \           if value == x {\n                row.append((i, j))\n            }\n\
    \        }\n    }\n    row.sort {\n        if $0.0 == $1.0 {\n            return\
    \ $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n    return row\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: { (lhs, rhs)\
    \ -> Bool in\n        if lhs.0 == rhs.0 {\n            return lhs.1 > rhs.1\n\
    \        }\n        return lhs.0 < rhs.0\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n      \
    \  for (j, elem) in row.enumerated() {\n            if elem == x {\n         \
    \       res.append((i, j))\n            }\n        }\n    }\n    res.sort { (a,\
    \ b) -> Bool in\n        if a.0 == b.0 {\n            return a.1 > b.1\n     \
    \   }\n        return a.0 < b.0\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpux68fkdz/tmpux68fkdz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba686718c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba68640fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba68640f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba68640e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpux68fkdz                        0x000055ebddab949f <unavailable> + 5279

    5    libc.so.6                          0x00002ba686904460 __libc_start_main +
    245

    6    tmpux68fkdz                        0x000055ebddab8f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, sub) in lst.enumerated() {\n\
    \        for (col, elem) in sub.enumerated() {\n            if elem == x {\n \
    \               result.append((row, col))\n            }\n        }\n    }\n \
    \   return result.sorted(by: { (a, b) -> Bool in\n        if a.0 == b.0 {\n  \
    \          return a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().map { (i, r) in r.enumerated().compactMap { (j, e)\
    \ in e == x ? (i, j) : nil } }.flatMap { $0 }.sorted(by: { ($0.0, -$0.1) < ($1.0,\
    \ -$1.1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap { (i, xs) in\n        xs.enumerated().compactMap\
    \ { (j, x) in\n            x == x ? (i, j) : nil\n        }\n    }.sorted { (a,\
    \ b) in\n        a.0 == b.0 ? a.1 > b.1 : a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpb5v2smu7.swift:18:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return lst.enumerated().flatMap { (i, xs) in\n        \
    \   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014214
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var coordinates: [(Int, Int)] = []\n    for (index, row) in lst.enumerated()\
    \ {\n        for (index_, item) in row.enumerated() {\n            if item ==\
    \ x {\n                coordinates.append((index, index_))\n            }\n  \
    \      }\n    }\n    return coordinates.sorted(by: { $0.0 < $1.0 }).sorted(by:\
    \ { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpcdgt5us4/tmpcdgt5us4.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09c46f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09c43e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09c43e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09c43e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcdgt5us4                        0x000055e4e047677f <unavailable> + 6015

    5    libc.so.6                          0x00002b09c48dd460 __libc_start_main +
    245

    6    tmpcdgt5us4                        0x000055e4e0476249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var ans: [(Int, Int)] = []\n    for index in 0..<lst.count {\n        for\
    \ j in 0..<lst[index].count {\n            if lst[index][j] == x {\n         \
    \       ans.append((index, j))\n            }\n        }\n    }\n    return ans.sorted(by:\
    \ <)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp3nn8t_5l/tmp3nn8t_5l.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6134e6ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6134b61b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6134b61988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6134b607b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3nn8t_5l                        0x0000563cf06a588f <unavailable> + 6287

    5    libc.so.6                          0x00002b6135056460 __libc_start_main +
    245

    6    tmp3nn8t_5l                        0x0000563cf06a5359 <unavailable> + 4953

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var result = [(Int, Int)]()\n  for (i, row) in lst.enumerated() {\n    if let\
    \ j = row.index(of: x) {\n      result.append((i, j))\n    }\n  }\n  return result.sorted(by:\
    \ { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpiv53ibdi/tmpiv53ibdi.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba339b2fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba339826b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba339826988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba3398257b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpiv53ibdi                        0x000055bc77b9987f <unavailable> + 6271

    5    libc.so.6                          0x00002ba339d1b460 __libc_start_main +
    245

    6    tmpiv53ibdi                        0x000055bc77b99349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, array) in lst.enumerated() {\n\
    \        for (column, element) in array.enumerated() {\n            if element\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: {(a, b) in\n        if a.0 < b.0 {\n\
    \            return true\n        } else if a.0 == b.0 {\n            return a.1\
    \ > b.1\n        } else {\n            return false\n        }\n    })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (index, row) in lst.enumerated() {\n\
    \        for (c_index, item) in row.enumerated() {\n            if item == x {\n\
    \                result.append((index, c_index))\n            }\n        }\n \
    \   }\n    return result.sorted(by: { (a, b) -> Bool in\n        if a.0 != b.0\
    \ {\n            return a.0 < b.0\n        } else {\n            return a.1 >\
    \ b.1\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var newList = [(Int, Int)]()\n    for (index, element) in lst.enumerated()\
    \ {\n        for (index2, element2) in element.enumerated() {\n            if\
    \ (element2 == x) {\n                newList.append((index, index2))\n       \
    \     }\n        }\n    }\n    newList.sort { (element1, element2) -> Bool in\n\
    \        if (element1.0 < element2.0) {\n            return true\n        } else\
    \ if (element1.0 == element2.0) {\n            return element1.1 > element2.1\n\
    \        } else {\n            return false\n        }\n    }\n    return newList\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (row, rowLst) in lst.enumerated()\
    \ {\n        for (column, elem) in rowLst.enumerated() {\n            if elem\
    \ == x {\n                result.append((row, column))\n            }\n      \
    \  }\n    }\n    return result.sorted(by: {$0.0 < $1.0}).sorted(by: {$0.1 > $1.1})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpaxugb3zd/tmpaxugb3zd.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aac1ae4ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aac1ab45b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aac1ab45988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aac1ab447b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaxugb3zd                        0x00005578c25d677f <unavailable> + 6015

    5    libc.so.6                          0x00002aac1b03a460 __libc_start_main +
    245

    6    tmpaxugb3zd                        0x00005578c25d6249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, value) in lst.enumerated()\
    \ {\n        for (indexOf, valueOf) in value.enumerated() {\n            if valueOf\
    \ == x {\n                result.append((index, indexOf))\n            }\n   \
    \     }\n    }\n    return result.sorted(by: {$0.0 < $1.0})\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpdb9a4afj/tmpdb9a4afj.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b77671a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7766e99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7766e99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7766e987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdb9a4afj                        0x0000561153e7877f <unavailable> + 6015

    5    libc.so.6                          0x00002b776738e460 __libc_start_main +
    245

    6    tmpdb9a4afj                        0x0000561153e78249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([(Int, Int)]()) {\n        let r = $0.filter\
    \ { $0.0 == $1.0 }.sorted { $0.1 > $1.1 }\n        return ($1.1.enumerated().filter\
    \ { $0.1 == x }.map { ($1.0, $0.0) } + r).sorted { $0.0 < $1.0 }\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmprwbac_3_.swift:18:29: error: cannot convert return expression of\
    \ type '(_, _) -> _' to return type '[(Int, Int)]'\n    return lst.enumerated().reduce([(Int,\
    \ Int)]()) {\n           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprwbac_3_.swift:18:35:\
    \ error: missing argument label 'into:' in call\n    return lst.enumerated().reduce([(Int,\
    \ Int)]()) {\n                                  ^\n                          \
    \         into: \n/tmp/tmprwbac_3_.swift:18:36: error: cannot convert value of\
    \ type '[(Int, Int)]' to expected argument type '(inout @escaping (_, _) -> _,\
    \ (offset: Int, element: Array<Int>)) throws -> ()'\n    return lst.enumerated().reduce([(Int,\
    \ Int)]()) {\n                                   ^\n"
  stdout: ''
  timestamp: 1660014115
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap { (index: Int, element: [Int]) -> [(Int,\
    \ Int)] in\n        return element.enumerated().filter { $0.element == x }.map\
    \ { (index, $0.offset) }\n    }.sorted(by: { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1\
    \ > $1.1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (row, col) in zip(lst.indices, lst.map({\
    \ $0.indices })) {\n        result += col.map { y in\n            return (row,\
    \ y)\n        }.filter { y in\n            return lst[row][y] == x\n        }\n\
    \    }\n    return result.sorted { (first, second) in\n        if first.0 == second.0\
    \ {\n            return first.1 > second.1\n        }\n        return first.0\
    \ < second.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpxxtp_q1c.swift:23:29: error: cannot convert value of type '(Int,\
    \ Int)' to expected argument type 'Int'\n            return lst[row][y] == x\n\
    \                            ^\n"
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for (index, val) in lst.enumerated() {\n  \
    \      for (ind, va) in val.enumerated() {\n            if va == x {\n       \
    \         res.append((index, ind))\n            }\n        }\n    }\n    res.sort(by:\
    \ {$0.0 > $1.0})\n    res.sort(by: {$0.1 < $1.1})\n    return res\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp688ae010/tmp688ae010.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad18a689c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad18a380b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad18a380988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad18a37f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp688ae010                        0x0000560741b2184f <unavailable> + 6223

    5    libc.so.6                          0x00002ad18a875460 __libc_start_main +
    245

    6    tmp688ae010                        0x0000560741b21319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var result = [(Int, Int)]()\n  for (i, array) in lst.enumerated() {\n    for\
    \ (j, num) in array.enumerated() {\n      if num == x {\n        result.append((i,\
    \ j))\n      }\n    }\n  }\n  return result.sorted(by: { $0.0 < $1.0 })\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpc4s6fdk8/tmpc4s6fdk8.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b971777cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9717473b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9717473988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97174727b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc4s6fdk8                        0x0000563f4bed37cf <unavailable> + 6095

    5    libc.so.6                          0x00002b9717968460 __libc_start_main +
    245

    6    tmpc4s6fdk8                        0x0000563f4bed3299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var array = [(Int, Int)]()\n    for row in 0..<lst.count {\n        for column\
    \ in 0..<lst[row].count {\n            if lst[row][column] == x {\n          \
    \      array.append((row, column))\n            }\n        }\n    }\n    return\
    \ array.sorted { (first, second) -> Bool in\n        if first.0 == second.0 {\n\
    \            return first.1 > second.1\n        }\n        return first.0 < second.0\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for row in 0..<lst.count {\n        for\
    \ column in 0..<lst[row].count {\n            if lst[row][column] == x {\n   \
    \             result.append((row, column))\n            }\n        }\n    }\n\
    \    //sort(by: >) - descending order\n    //sort(by: <) - ascending order\n \
    \   result.sort { (tuple1, tuple2) -> Bool in\n        if tuple1.0 == tuple2.0\
    \ {\n            return tuple1.1 > tuple2.1\n        } else {\n            return\
    \ tuple1.0 < tuple2.0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var tuples = [(Int, Int)]()\n    var rows = [(row: Int, col: Int)]()\n  \
    \  var cols = [(row: Int, col: Int)]()\n    for (row, lst) in lst.enumerated()\
    \ {\n        for (col, x) in lst.enumerated() {\n            if x == x {\n   \
    \             rows.append((row: row, col: col))\n            }\n        }\n  \
    \  }\n    rows.sort{$0.row < $1.row}\n    for (row, lst) in rows.enumerated()\
    \ {\n        cols.append((row: lst.row, col: lst.col))\n    }\n    cols.sort{$0.col\
    \ > $1.col}\n    for (row, lst) in cols.enumerated() {\n        tuples.append((lst.row,\
    \ lst.col))\n    }\n    return tuples\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmprkkeky2z/tmprkkeky2z.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b76301e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b762fed7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b762fed7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b762fed67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprkkeky2z                        0x0000557b6b1b884f <unavailable> + 6223

    5    libc.so.6                          0x00002b76303cc460 __libc_start_main +
    245

    6    tmprkkeky2z                        0x0000557b6b1b8319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var res: [(Int, Int)] = []\n  for i in 0..<lst.count {\n    for j in 0..<lst[i].count\
    \ {\n      if lst[i][j] == x {\n        res.append((i, j))\n      }\n    }\n \
    \ }\n  return res.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpu8_f0cyr/tmpu8_f0cyr.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae89a782c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae89a479b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae89a479988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae89a4787b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu8_f0cyr                        0x0000559bf26917ef <unavailable> + 6127

    5    libc.so.6                          0x00002ae89a96e460 __libc_start_main +
    245

    6    tmpu8_f0cyr                        0x0000559bf26912b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, elem) in row.enumerated() {\n            if elem == x {\n    \
    \            result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var ans: [(Int, Int)] = []\n    for (rowIndex, row) in lst.enumerated() {\n\
    \        for (colIndex, col) in row.enumerated() {\n            if col == x {\n\
    \                ans.append((rowIndex, colIndex))\n            }\n        }\n\
    \    }\n    return ans.sorted(by: { (first, second) -> Bool in\n        if first.0\
    \ < second.0 {\n            return true\n        } else if first.0 == second.0\
    \ {\n            return first.1 > second.1\n        } else {\n            return\
    \ false\n        }\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var lst = lst.map { $0.enumerated().filter { $0.element == x }.map { ($0.offset,\
    \ $1) } }\n    lst.removeAll { $0.isEmpty }\n    lst.sort { $0[0].0 < $1[0].0\
    \ }\n    return lst.map { $0.sorted { $0.0 > $1.0 } }.flatMap { $0 }\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpjn8rdw04.swift:18:78: error: value of type 'Int' has no member\
    \ 'offset'\n    var lst = lst.map { $0.enumerated().filter { $0.element == x }.map\
    \ { ($0.offset, $1) } }\n                                                    \
    \                      ~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014108
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.reduce([(Int, Int)]()) { (result, row, index) -> [(Int, Int)]\
    \ in\n        var rowResult = row.enumerated().reduce([(Int, Int)]()) { (result,\
    \ item) -> [(Int, Int)] in\n            if item.element == x {\n             \
    \   return result + [(index, item.offset)]\n            }\n            return\
    \ result\n        }\n        return result + rowResult\n    }.sorted(by: { (f,\
    \ s) -> Bool in\n        return f.0 < s.0\n    }).sorted(by: { (f, s) -> Bool\
    \ in\n        return f.1 > s.1\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpzihtaysq.swift:18:41: error: contextual closure type '([(Int, Int)],\
    \ [Int]) throws -> [(Int, Int)]' expects 2 arguments, but 3 were used in closure\
    \ body\n    return lst.reduce([(Int, Int)]()) { (result, row, index) -> [(Int,\
    \ Int)] in\n                                        ^\n/tmp/tmpzihtaysq.swift:21:35:\
    \ error: cannot convert value of type '_' to expected element type 'Int'\n   \
    \             return result + [(index, item.offset)]\n                       \
    \           ^\n"
  stdout: ''
  timestamp: 1660014112
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index1, arr) in lst.enumerated()\
    \ {\n        for (index2, item) in arr.enumerated() {\n            if item ==\
    \ x {\n                result.append((index1, index2))\n            }\n      \
    \  }\n    }\n    return result.sorted { (t1, t2) -> Bool in\n        if t1.0 ==\
    \ t2.0 {\n            return t1.1 > t2.1\n        }\n        return t1.0 < t2.0\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap { (r, row) in\n        row.enumerated().compactMap\
    \ { (c, col) in\n            col == x ? (r, c) : nil\n        }\n    }.sorted\
    \ { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpfi3zzgxq/tmpfi3zzgxq.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9defd1dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9defa14b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9defa14988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9defa137b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfi3zzgxq                        0x000055b991ed670f <unavailable> + 5903

    5    libc.so.6                          0x00002b9deff09460 __libc_start_main +
    245

    6    tmpfi3zzgxq                        0x000055b991ed61d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014110
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpux68fkdz/tmpux68fkdz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba686718c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba68640fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba68640f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba68640e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpux68fkdz                        0x000055ebddab949f <unavailable> + 5279

    5    libc.so.6                          0x00002ba686904460 __libc_start_main +
    245

    6    tmpux68fkdz                        0x000055ebddab8f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for i in 0..<lst.count {\n        for j\
    \ in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    result.sort {\n        if $0.0 !=\
    \ $1.0 {\n            return $0.0 < $1.0\n        } else {\n            return\
    \ $0.1 > $1.1\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([]) {\n        acc, elem in\n        let (index,\
    \ row) = elem\n        return acc + row.enumerated().filter { $0.element == x\
    \ }.map { (index, $0.offset) }\n    }.sorted {\n        if $0.0 == $1.0 {\n  \
    \          return $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var rowCount = 0\n    var colCount = 0\n\
    \    lst.forEach { (row) in\n        colCount = 0\n        row.forEach({ (value)\
    \ in\n            if value == x {\n                result.append((rowCount, colCount))\n\
    \            }\n            colCount += 1\n        })\n        rowCount += 1\n\
    \    }\n    return result.sorted(by: {$0.0 < $1.0 || ($0.0 == $1.0 && $0.1 > $1.1)})\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let results = lst.enumerated().reduce([], { partial, next in\n        let\
    \ (index, value) = next\n        return partial + value.enumerated().reduce([],\
    \ { result, next in\n            let (index, value) = next\n            return\
    \ value == x ? result + [(index, index)] : result\n        })\n    })\n    return\
    \ results.sorted(by: { first, second in\n        return first.0 < second.0 ||\
    \ (first.0 == second.0 && first.1 > second.1)\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpb5bpita5.swift:25:20: error: cannot convert return expression of\
    \ type '[Any]' to return type '[(Int, Int)]'\n    return results.sorted(by: {\
    \ first, second in\n                   ^\n/tmp/tmpb5bpita5.swift:25:20: note:\
    \ arguments to generic parameter 'Element' ('Any' and '(Int, Int)') are expected\
    \ to be equal\n    return results.sorted(by: { first, second in\n            \
    \       ^\n/tmp/tmpb5bpita5.swift:26:22: error: value of type 'Any' has no member\
    \ '0'\n        return first.0 < second.0 || (first.0 == second.0 && first.1 >\
    \ second.1)\n               ~~~~~ ^\n/tmp/tmpb5bpita5.swift:26:22: note: cast\
    \ 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific type\
    \ to access members\n        return first.0 < second.0 || (first.0 == second.0\
    \ && first.1 > second.1)\n                     ^\n               (     as AnyObject)\n\
    /tmp/tmpb5bpita5.swift:26:33: error: value of type 'Any' has no member '0'\n \
    \       return first.0 < second.0 || (first.0 == second.0 && first.1 > second.1)\n\
    \                         ~~~~~~ ^\n/tmp/tmpb5bpita5.swift:26:33: note: cast 'Any'\
    \ to 'AnyObject' or use 'as!' to force downcast to a more specific type to access\
    \ members\n        return first.0 < second.0 || (first.0 == second.0 && first.1\
    \ > second.1)\n                                ^\n                         ( \
    \     as AnyObject)\n/tmp/tmpb5bpita5.swift:26:45: error: value of type 'Any'\
    \ has no member '0'\n        return first.0 < second.0 || (first.0 == second.0\
    \ && first.1 > second.1)\n                                      ~~~~~ ^\n/tmp/tmpb5bpita5.swift:26:45:\
    \ note: cast 'Any' to 'AnyObject' or use 'as!' to force downcast to a more specific\
    \ type to access members\n        return first.0 < second.0 || (first.0 == second.0\
    \ && first.1 > second.1)\n                                            ^\n    \
    \                                  (     as AnyObject)\n/tmp/tmpb5bpita5.swift:26:57:\
    \ error: value of type 'Any' has no member '0'\n        return first.0 < second.0\
    \ || (first.0 == second.0 && first.1 > second.1)\n                           \
    \                     "
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\t\
    var result = [(Int, Int)]()\n\tfor (indexRow, row) in lst.enumerated() {\n\t\t\
    for (indexColumn, value) in row.enumerated() {\n\t\t\tif value == x {\n\t\t\t\t\
    result.append((indexRow, indexColumn))\n\t\t\t}\n\t\t}\n\t}\n\tresult.sort{ (tuple1,\
    \ tuple2) -> Bool in\n\t\tlet order: Bool\n\t\tif tuple1.0 == tuple2.0 {\n\t\t\
    \torder = tuple1.1 > tuple2.1\n\t\t} else {\n\t\t\torder = tuple1.0 < tuple2.0\n\
    \t\t}\n\t\treturn order\n\t}\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n   \
    \     for (j, item) in row.enumerated() {\n            if item == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: <)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpazv9p9ta/tmpazv9p9ta.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade695c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade692b9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade692b9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade692b87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpazv9p9ta                        0x000055cb9a0fc86f <unavailable> + 6255

    5    libc.so.6                          0x00002ade697ae460 __libc_start_main +
    245

    6    tmpazv9p9ta                        0x000055cb9a0fc339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                res.append((i,\
    \ j))\n            }\n        }\n    }\n    res.sort{ if $0.0 == $1.0 { return\
    \ $0.1 > $1.1 }\n        return $0.0 < $1.0 }\n    return res\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var index: [(Int, Int)] = []\n    for a in 0..<lst.count {\n        for b\
    \ in 0..<lst[a].count {\n            if lst[a][b] == x {\n                index.append((a,\
    \ b))\n            }\n        }\n    }\n    return index.sorted { ($0.0, -$0.1)\
    \ < ($1.0, -$1.1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, col) in row.enumerated() {\n            if col == x {\n      \
    \          result.append((i, j))\n            }\n        }\n    }\n    result.sort(by:\
    \ { (e1, e2) -> Bool in\n        if e1.0 < e2.0 {\n            return true\n \
    \       } else if e1.0 == e2.0 {\n            return e1.1 > e2.1\n        } else\
    \ {\n            return false\n        }\n    })\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return [(Int, Int)]()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp49v80q4a/tmp49v80q4a.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b17072fbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1706ff2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1706ff2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1706ff17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp49v80q4a                        0x000055b7c80914ef <unavailable> + 5359

    5    libc.so.6                          0x00002b17074e7460 __libc_start_main +
    245

    6    tmp49v80q4a                        0x000055b7c8090fb9 <unavailable> + 4025

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var indexes: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n\
    \        indexes += row.enumerated().filter { $0.element == x }.map { (i, $0.offset)\
    \ }\n    }\n    return indexes.sorted { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 >\
    \ $1.1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res = [(Int, Int)]()\n    for (i, row) in lst.enumerated() {\n      \
    \  for (j, v) in row.enumerated() {\n            if v == x {\n               \
    \ res.append((i, j))\n            }\n        }\n    }\n    return res.sorted {\
    \ (v1, v2) -> Bool in\n        if v1.0 == v2.0 {\n            return v1.1 > v2.1\n\
    \        }\n        return v1.0 < v2.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap { (offset: Int, element: [Int]) -> [(Int,\
    \ Int)] in\n        return element.enumerated().filter { (offset2: Int, element2:\
    \ Int) -> Bool in\n            return element2 == x\n        }.map { (offset2:\
    \ Int, element2: Int) -> (Int, Int) in\n            return (offset, offset2)\n\
    \        }\n    }.sorted(by: { (arg0: (Int, Int), arg1: (Int, Int)) -> Bool in\n\
    \        return arg0.0 < arg1.0\n    }).sorted(by: { (arg0: (Int, Int), arg1:\
    \ (Int, Int)) -> Bool in\n        return arg0.1 > arg1.1\n    })\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp364var2z/tmp364var2z.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b33557d3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b33554cab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b33554ca988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b33554c97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp364var2z                        0x0000561d3db1a7af <unavailable> + 6063

    5    libc.so.6                          0x00002b33559bf460 __libc_start_main +
    245

    6    tmp364var2z                        0x0000561d3db1a279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let result = lst.enumerated().reduce([], { (result, cur) -> [(Int, Int)]\
    \ in\n        let (index, row) = cur\n        var new_result = result\n      \
    \  new_result.append(contentsOf: row.enumerated().reduce([], { (result, cur) ->\
    \ [(Int, Int)] in\n            let (index, item) = cur\n            var new_result\
    \ = result\n            if item == x {\n                new_result.append((index,\
    \ index))\n            }\n            return new_result\n        }).map({ (index,\
    \ item) -> (Int, Int) in\n            return (index, item)\n        }))\n    \
    \    return new_result\n    })\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpd05cca_p/tmpd05cca_p.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002acbd224bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002acbd1f42b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002acbd1f42988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002acbd1f417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd05cca_p                        0x0000560565df679f <unavailable> + 6047

    5    libc.so.6                          0x00002acbd2437460 __libc_start_main +
    245

    6    tmpd05cca_p                        0x0000560565df6269 <unavailable> + 4713

    '
  stdout: ''
  timestamp: 1660014108
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var tupArray = [(Int, Int)]()\n    var tup = (0, 0)\n    var row = 0\n  \
    \  var col = 0\n    for i in lst {\n        for n in i {\n            if n ==\
    \ x {\n                tup = (row, col)\n                tupArray.append(tup)\n\
    \            }\n            col += 1\n        }\n        row += 1\n        col\
    \ = 0\n    }\n    return tupArray.sorted(by: <)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpdxyi6pk2/tmpdxyi6pk2.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b47c9b4bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b47c9842b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b47c9842988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b47c98417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdxyi6pk2                        0x000055cb3c5627bf <unavailable> + 6079

    5    libc.so.6                          0x00002b47c9d37460 __libc_start_main +
    245

    6    tmpdxyi6pk2                        0x000055cb3c562289 <unavailable> + 4745

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (index, array) in lst.enumerated()\
    \ {\n        for (i, element) in array.enumerated() {\n            if element\
    \ == x {\n                result.append((index, i))\n            }\n        }\n\
    \    }\n    return result.sorted(by: { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 >\
    \ $1.1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // Write your solution here\n    let p = lst.enumerated().flatMap { (i, row)\
    \ -> [(Int, Int)] in\n        return row.enumerated().filter { (j, v) -> Bool\
    \ in\n            return v == x\n        }.map { (j, v) -> (Int, Int) in\n   \
    \         return (i, j)\n        }\n    }\n    return p.sorted { (lhs, rhs) ->\
    \ Bool in\n        return lhs.0 < rhs.0 || (lhs.0 == rhs.0 && lhs.1 > rhs.1)\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var results = [(Int, Int)]()\n    for (y, row) in lst.enumerated() {\n  \
    \      for (x, col) in row.enumerated() {\n            if col == x {\n       \
    \         results.append((y, x))\n            }\n        }\n    }\n    return\
    \ results.sorted{ $0.0 < $1.0 || $0.0 == $1.0 && $0.1 > $1.1 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpsfv4nydh/tmpsfv4nydh.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add16f64c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add16c5bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add16c5b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add16c5a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpsfv4nydh                        0x000055b164c157cf <unavailable> + 6095

    5    libc.so.6                          0x00002add17150460 __libc_start_main +
    245

    6    tmpsfv4nydh                        0x000055b164c15299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let len = lst.count;\n    var points = [(Int, Int)]();\n    for i in 0 ..<\
    \ len {\n        let s = lst[i];\n        let slen = s.count;\n        for j in\
    \ 0 ..< slen {\n            if s[j] == x {\n                points.append((i,\
    \ j));\n            }\n        }\n    }\n    points.sort { (p1, p2) -> Bool in\n\
    \        if p1.0 != p2.0 {\n            return p1.0 < p2.0;\n        } else {\n\
    \            return p1.1 > p2.1;\n        }\n    }\n    return points;\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().reduce([]) { (acc, pair) in\n        let row = pair.offset\n\
    \        let columns = pair.element.enumerated().filter { $0.element == x }.map\
    \ { $0.offset }\n        return acc + columns.map { (row, $0) }\n    }.sorted\
    \ { (t1, t2) in\n        if t1.0 != t2.0 {\n            return t1.0 < t2.0\n \
    \       } else {\n            return t1.1 > t2.1\n        }\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var lst = lst\n  for (i, v) in lst.enumerated() {\n    lst[i] = v.enumerated().filter({\
    \ $0.element == x }).map({ (i, $0.offset) })\n  }\n  lst = lst.filter({ !$0.isEmpty\
    \ })\n  lst.sort(by: { $0[0].0 < $1[0].0 })\n  for (i, v) in lst.enumerated()\
    \ {\n    lst[i] = v.sorted(by: { $0.1 > $1.1 })\n  }\n  return lst.flatMap({ $0\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmp_mx8i22p.swift:20:63: error: cannot convert value of type '(Int,\
    \ Int)' to closure result type 'Int'\n    lst[i] = v.enumerated().filter({ $0.element\
    \ == x }).map({ (i, $0.offset) })\n                                          \
    \                    ^~~~~~~~~~~~~~\n/tmp/tmp_mx8i22p.swift:23:24: error: value\
    \ of type 'Int' has no member '0'\n  lst.sort(by: { $0[0].0 < $1[0].0 })\n   \
    \              ~~~~~ ^\n/tmp/tmp_mx8i22p.swift:23:34: error: value of type 'Int'\
    \ has no member '0'\n  lst.sort(by: { $0[0].0 < $1[0].0 })\n                 \
    \          ~~~~~ ^\n/tmp/tmp_mx8i22p.swift:25:32: error: value of type 'Int' has\
    \ no member '1'\n    lst[i] = v.sorted(by: { $0.1 > $1.1 })\n                \
    \            ~~ ^\n/tmp/tmp_mx8i22p.swift:25:39: error: value of type 'Int' has\
    \ no member '1'\n    lst[i] = v.sorted(by: { $0.1 > $1.1 })\n                \
    \                   ~~ ^\n/tmp/tmp_mx8i22p.swift:27:24: error: cannot convert\
    \ value of type '[Int]' to closure result type '(Int, Int)?'\n  return lst.flatMap({\
    \ $0 })\n                       ^~\n"
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    if lst.isEmpty {\n        return []\n    }\n    var res: [(Int, Int)] = []\n\
    \    for (i, sub) in lst.enumerated() {\n        for (j, val) in sub.enumerated()\
    \ {\n            if val == x {\n                res.append((i, j))\n         \
    \   }\n        }\n    }\n    return res.sorted {\n        if $0.0 == $1.0 {\n\
    \            return $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: { (tuple1,\
    \ tuple2) -> Bool in\n        tuple1.0 < tuple2.0\n    }).sorted(by: { (tuple1,\
    \ tuple2) -> Bool in\n        tuple1.1 > tuple2.1\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpoo3yrrlw/tmpoo3yrrlw.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0b994f7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0b991eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0b991ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0b991ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoo3yrrlw                        0x0000560029f547ef <unavailable> + 6127

    5    libc.so.6                          0x00002b0b996e3460 __libc_start_main +
    245

    6    tmpoo3yrrlw                        0x0000560029f542b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (index, row) in lst.enumerated() {\n\
    \        for (index2, col) in row.enumerated() {\n            if col == x {\n\
    \                result.append((index, index2))\n            }\n        }\n  \
    \  }\n    return result.sorted(by: <)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbgo49cm9/tmpbgo49cm9.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b99d3a49c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b99d3740b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b99d3740988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b99d373f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbgo49cm9                        0x000055cba5e8786f <unavailable> + 6255

    5    libc.so.6                          0x00002b99d3c35460 __libc_start_main +
    245

    6    tmpbgo49cm9                        0x000055cba5e87339 <unavailable> + 4921

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var array: [(Int, Int)] = []\n    for (index, value) in lst.enumerated()\
    \ {\n        if let index2 = value.firstIndex(of: x) {\n            array.append((index,\
    \ index2))\n        }\n    }\n    return array.sorted(by: { $0.0 < $1.0 }).sorted(by:\
    \ { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpuzhu2t18/tmpuzhu2t18.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b783a541c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b783a238b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b783a238988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b783a2377b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuzhu2t18                        0x000055f70bdff82f <unavailable> + 6191

    5    libc.so.6                          0x00002b783a72d460 __libc_start_main +
    245

    6    tmpuzhu2t18                        0x000055f70bdff2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap {\n        return $0.element.enumerated().filter\
    \ {\n            return $0.element == x\n        }.map {\n            return ($0.offset,\
    \ $1.offset)\n        }\n    }.sorted {\n        return $0.0 == $1.0 ? $0.1 >\
    \ $1.1 : $0.0 < $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpkzkd4wen.swift:18:12: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    return lst.enumerated().flatMap {\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014402
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let answer = lst.enumerated().flatMap { element -> [(Int, Int)] in\n    \
    \    let row = element.offset\n        return element.element.enumerated().compactMap\
    \ {\n            $0.element == x ? (row, $0.offset) : nil\n        }\n    }\n\
    \    return answer.sorted(by: { $0.0 == $1.0 ? $0.1 > $1.1 : $0.0 < $1.0 })\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: {\n        if $0.0 == $1.0 {\n            return $0.1 > $1.1\n\
    \        }\n        return $0.0 < $1.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013890
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var elements = [(Int, Int)]()\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                elements.append((i,\
    \ j))\n            }\n        }\n    }\n    elements.sort {\n        $0.0 < $1.0\n\
    \    }\n    for i in 0..<elements.count {\n        for j in 0..<elements.count\
    \ {\n            if elements[i].0 == elements[j].0 && elements[i].1 < elements[j].1\
    \ {\n                let temp = elements[i]\n                elements[i] = elements[j]\n\
    \                elements[j] = temp\n            }\n        }\n    }\n    return\
    \ elements\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp4sryi2f7/tmp4sryi2f7.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57d9760c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57d9457b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57d9457988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57d94567b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4sryi2f7                        0x0000560c654af8ff <unavailable> + 6399

    5    libc.so.6                          0x00002b57d994c460 __libc_start_main +
    245

    6    tmp4sryi2f7                        0x0000560c654af3c9 <unavailable> + 5065

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    var row = 0\n    var col = 0\n    for subArr\
    \ in lst {\n        col = 0\n        for num in subArr {\n            if num ==\
    \ x {\n                result.append((row, col))\n            }\n            col\
    \ += 1\n        }\n        row += 1\n    }\n    return result.sorted(by: { (row1,\
    \ row2) -> Bool in\n        if row1.0 != row2.0 {\n            return row1.0 <\
    \ row2.0\n        } else {\n            return row1.1 > row2.1\n        }\n  \
    \  })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // your code here\n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpi1eg11o7/tmpi1eg11o7.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4bcd2b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4bccfacb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4bccfac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4bccfab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi1eg11o7                        0x0000564afd81f49f <unavailable> + 5279

    5    libc.so.6                          0x00002b4bcd4a1460 __libc_start_main +
    245

    6    tmpi1eg11o7                        0x0000564afd81ef69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n    \
    \    for (j, val) in row.enumerated() {\n            if val == x {\n         \
    \       res.append((i, j))\n            }\n        }\n    }\n    return res.sorted(by:\
    \ { (p1, p2) -> Bool in\n        if p1.0 == p2.0 {\n            return p1.1 >\
    \ p2.1\n        }\n        return p1.0 < p2.0\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    if lst.isEmpty {\n        return []\n    }\n\n    var ret: [(Int, Int)] =\
    \ []\n    for (i, arr) in lst.enumerated() {\n        for (j, n) in arr.enumerated()\
    \ {\n            if n == x {\n                ret.append((i, j))\n           \
    \ }\n        }\n    }\n\n    return ret.sorted(by: {\n        if $0.0 == $1.0\
    \ {\n            return $0.1 > $1.1\n        }\n        return $0.0 < $1.0\n \
    \   })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  /// Your code goes here\n  let ys = lst.enumerated().flatMap { (i, v) -> [(Int,\
    \ Int)] in\n    return v.enumerated().compactMap { (j, k) -> (Int, Int)? in\n\
    \      if k == x {\n        return (i, j)\n      }\n      return nil\n    }\n\
    \  }\n  return ys.sorted { $0.0 < $1.0 }.sorted { $0.1 > $1.1 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpyqeilvho/tmpyqeilvho.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad25365bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad253352b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad253352988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad2533517b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpyqeilvho                        0x0000560733f1870f <unavailable> + 5903

    5    libc.so.6                          0x00002ad253847460 __libc_start_main +
    245

    6    tmpyqeilvho                        0x0000560733f181d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var arry = [(Int, Int)]()\n    for (y, item) in lst.enumerated() {\n    \
    \    for (x, num) in item.enumerated() {\n            if num == x {\n        \
    \        arry.append((y, x))\n            }\n        }\n    }\n    return arry.sorted\
    \ { (first, second) -> Bool in\n        if first.0 == second.0 {\n           \
    \ return first.1 > second.1\n        }\n        return first.0 < second.0\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpa6kei8r5/tmpa6kei8r5.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0c81903c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0c815fab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0c815fa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0c815f97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa6kei8r5                        0x000055ff643897cf <unavailable> + 6095

    5    libc.so.6                          0x00002b0c81aef460 __libc_start_main +
    245

    6    tmpa6kei8r5                        0x000055ff64389299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for (i, arr) in lst.enumerated() {\n    \
    \    for (j, val) in arr.enumerated() {\n            if val == x {\n         \
    \       res.append((i, j))\n            }\n        }\n    }\n    return res.sorted(by:\
    \ { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpw3eptvoq/tmpw3eptvoq.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b269ff45c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b269fc3cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b269fc3c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b269fc3b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw3eptvoq                        0x00005602c491877f <unavailable> + 6015

    5    libc.so.6                          0x00002b26a0131460 __libc_start_main +
    245

    6    tmpw3eptvoq                        0x00005602c4918249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    lst.enumerated().forEach { (row, item)\
    \ in\n        item.enumerated().forEach { (column, number) in\n            if\
    \ number == x {\n                result.append((row, column))\n            }\n\
    \        }\n    }\n    return result.sorted(by: { (arg0, arg1) -> Bool in\n  \
    \      if arg0.0 == arg1.0 {\n            return arg0.1 > arg1.1\n        }\n\
    \        return arg0.0 < arg1.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var lst = lst\n    let res = lst.enumerated().reduce([], { (acc, data) ->\
    \ [(Int, Int)] in\n        let (index, array) = data\n        var array = array\n\
    \        let res = array.enumerated().reduce([], { (acc, data) -> [(Int, Int)]\
    \ in\n            let (index, element) = data\n            if element == x {\n\
    \                return acc + [(index, index)]\n            }\n            return\
    \ acc\n        })\n        if res.count > 0 {\n            return acc + res\n\
    \        }\n        return acc\n    })\n    return res\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpxm3_f_it.swift:21:13: error: invalid redeclaration of 'array'\n\
    \        var array = array\n            ^\n/tmp/tmpxm3_f_it.swift:20:21: note:\
    \ 'array' previously declared here\n        let (index, array) = data\n      \
    \              ^\n"
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var arr: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n    \
    \    for (j, elem) in row.enumerated() {\n            if elem == x {\n       \
    \         arr.append((i, j))\n            }\n        }\n    }\n    return arr.sorted(by:\
    \ { (a, b) -> Bool in\n        if a.0 == b.0 {\n            return a.1 > b.1\n\
    \        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for row in 0..<lst.count {\n        for col\
    \ in 0..<lst[row].count {\n            if lst[row][col] == x {\n             \
    \   res.append((row, col))\n            }\n        }\n    }\n    return res.sorted(by:\
    \ { (arg0, arg1) -> Bool in\n        if arg0.0 == arg1.0 {\n            return\
    \ arg0.1 > arg1.1\n        }\n        return arg0.0 < arg1.0\n    })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    var index1 = 0\n    var index2 = 0\n   \
    \ var sorted_row = [(Int, Int)]()\n    for array in lst {\n        for element\
    \ in array {\n            if element == x {\n                result.append((index1,\
    \ index2))\n            }\n            index2 += 1\n        }\n        index2\
    \ = 0\n        index1 += 1\n    }\n    sorted_row = result.sorted(by: { $0.0 <\
    \ $1.0})\n    for i in 0..<sorted_row.count {\n        for j in i+1..<sorted_row.count\
    \ {\n            if sorted_row[i].0 == sorted_row[j].0 {\n                if sorted_row[i].1\
    \ < sorted_row[j].1 {\n                    sorted_row.swapAt(i, j)\n         \
    \       }\n            }\n        }\n    }\n    return sorted_row\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().map { $0.1.enumerated().filter { $0.1 == x }.map\
    \ { ($0.0, $1.0) } }.reduce([], +).sorted { $0.0 < $1.0 }.sorted { $0.1 > $1.1\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpym0izbj9.swift:18:84: error: value of type 'Int' has no member\
    \ '0'\n    return lst.enumerated().map { $0.1.enumerated().filter { $0.1 == x\
    \ }.map { ($0.0, $1.0) } }.reduce([], +).sorted { $0.0 < $1.0 }.sorted { $0.1\
    \ > $1.1 }\n                                                                 \
    \               ~~ ^\n/tmp/tmpym0izbj9.swift:18:90: error: value of type 'Int'\
    \ has no member '0'\n    return lst.enumerated().map { $0.1.enumerated().filter\
    \ { $0.1 == x }.map { ($0.0, $1.0) } }.reduce([], +).sorted { $0.0 < $1.0 }.sorted\
    \ { $0.1 > $1.1 }\n                                                          \
    \                            ~~ ^\n"
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return lst.enumerated().flatMap {\n        (offset, array) -> [(Int, Int)]\
    \ in\n        return array.enumerated().filter({\n            (index, value) ->\
    \ Bool in\n            return value == x\n        }).map {\n            (index,\
    \ value) -> (Int, Int) in\n            return (offset, index)\n        }\n   \
    \ }.sorted {\n        (left, right) -> Bool in\n        if left.0 == right.0 {\n\
    \            return left.1 > right.1\n        }\n        return left.0 < right.0\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    if lst.isEmpty {\n        return []\n    }\n    var result: [(Int, Int)]\
    \ = []\n    for (row, col) in lst.enumerated() {\n        for (column, element)\
    \ in col.enumerated() {\n            if element == x {\n                result.append((row,\
    \ column))\n            }\n        }\n    }\n    return result.sorted(by: {\n\
    \        if $0.0 != $1.0 {\n            return $0.0 < $1.0\n        } else {\n\
    \            return $0.1 > $1.1\n        }\n    })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, row) in lst.enumerated() {\n \
    \       for (j, value) in row.enumerated() {\n            if value == x {\n  \
    \              result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted { (p1, p2) -> Bool in\n        if p1.0 == p2.0 {\n           \
    \ return p1.1 > p2.1\n        }\n        return p1.0 < p2.0\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var coordinates: [(Int, Int)] = []\n  for i in 0..<lst.count {\n    for j in\
    \ 0..<lst[i].count {\n      if lst[i][j] == x {\n        coordinates.append((i,\
    \ j))\n      }\n    }\n  }\n  coordinates.sort(by: {\n    if $0.0 == $1.0 {\n\
    \      return $0.1 > $1.1\n    }\n    return $0.0 < $1.0\n  })\n  return coordinates\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    let arr = lst.map {\n        (subArr) -> [(Int, Int)] in\n        subArr.enumerated().map({\n\
    \            (index, elem) -> (Int, Int) in\n            if elem == x {\n    \
    \            return (subArr.count, index)\n            }\n            return (0,\
    \ 0)\n        }).filter({$0 != (0, 0)})\n    }.filter({$0.count > 0})\n    \n\
    \    var newArr = arr.reduce([], +)\n    newArr.sort { (a, b) -> Bool in\n   \
    \     if a.0 == b.0 {\n            return a.1 > b.1\n        }\n        return\
    \ a.0 < b.0\n    }\n    return newArr\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmptla6vboa/tmptla6vboa.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5cc56c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5cc53bdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5cc53bd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5cc53bc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptla6vboa                        0x000056158f6e299f <unavailable> + 6559

    5    libc.so.6                          0x00002b5cc58b2460 __libc_start_main +
    245

    6    tmptla6vboa                        0x000056158f6e2469 <unavailable> + 5225

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var t = [(Int, Int)]()\n    for i in 0..<lst.count {\n        for j in 0..<lst[i].count\
    \ {\n            if lst[i][j] == x {\n                t.append((i, j))\n     \
    \       }\n        }\n    }\n    return t.sorted(by: { ($0.0, -$0.1) < ($1.0,\
    \ -$1.1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var coordinates: [(Int, Int)] = []\n    for (index, element) in lst.enumerated()\
    \ {\n        for (i, e) in element.enumerated() {\n            if e == x {\n \
    \               coordinates.append((index, i))\n            }\n        }\n   \
    \ }\n    coordinates.sort { $0.0 < $1.0 }\n    return coordinates\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpcn7bhnab/tmpcn7bhnab.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af1b378ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af1b3485b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af1b3485988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af1b34847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcn7bhnab                        0x000055a0d73907ff <unavailable> + 6143

    5    libc.so.6                          0x00002af1b397a460 __libc_start_main +
    245

    6    tmpcn7bhnab                        0x000055a0d73902c9 <unavailable> + 4809

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var index = 0\n    for subLst in lst {\n\
    \        var subIndex = 0\n        for item in subLst {\n            if item ==\
    \ x {\n                result.append((index, subIndex))\n            }\n     \
    \       subIndex += 1\n        }\n        index += 1\n    }\n    return result.sorted\
    \ {\n        if $0.0 < $1.0 {\n            return true\n        } else if $0.0\
    \ == $1.0 {\n            return $0.1 > $1.1\n        } else {\n            return\
    \ false\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var ret = [(Int, Int)]()\n    var i = 0\n    for row in lst {\n        var\
    \ j = 0\n        for c in row {\n            if c == x {\n                ret.append((i,\
    \ j))\n            }\n            j += 1\n        }\n        i += 1\n    }\n \
    \   return ret.sorted{ $0.0 < $1.0 }.sorted{ $0.1 > $1.1 }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpfmj59quz/tmpfmj59quz.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06e10a2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06e0d99b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06e0d99988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06e0d987b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfmj59quz                        0x00005576ec65f71f <unavailable> + 5919

    5    libc.so.6                          0x00002b06e128e460 __libc_start_main +
    245

    6    tmpfmj59quz                        0x00005576ec65f1e9 <unavailable> + 4585

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted(by: { ($0.0,\
    \ -$0.1) < ($1.0, -$1.1) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5,\
    \ 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
    \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4,\
    \ 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]],\
    \ x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int,\
    \ Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var re: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                re.append((i,\
    \ j))\n            }\n        }\n    }\n    for i in 0..<re.count - 1 {\n    \
    \    for j in 0..<re.count - i - 1 {\n            if re[j].0 > re[j + 1].0 {\n\
    \                let temp = re[j]\n                re[j] = re[j + 1]\n       \
    \         re[j + 1] = temp\n            }\n        }\n    }\n    for i in 0..<re.count\
    \ - 1 {\n        for j in 0..<re.count - i - 1 {\n            if re[j].0 == re[j\
    \ + 1].0 {\n                if re[j].1 < re[j + 1].1 {\n                    let\
    \ temp = re[j]\n                    re[j] = re[j + 1]\n                    re[j\
    \ + 1] = temp\n                }\n            }\n        }\n    }\n    return\
    \ re\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'Swift/Range.swift:743: Fatal error: Range requires lowerBound <= upperBound

    Current stack trace:

    0    libswiftCore.so                    0x00002b4c8cee7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4c8cbde561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b4c8cbde286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b4c8cbde13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b4c8cbddbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    tmpajhthtuc                        0x0000559bc6697965 <unavailable> + 10597

    6    tmpajhthtuc                        0x0000559bc6696fea <unavailable> + 8170

    7    libc.so.6                          0x00002b4c8d0d3460 __libc_start_main +
    245

    8    tmpajhthtuc                        0x0000559bc6696299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (i, array) in lst.enumerated() {\n\
    \        for (j, value) in array.enumerated() {\n            if x == value {\n\
    \                result.append((i, j))\n            }\n        }\n    }\n    return\
    \ result.sorted(by: {\n        if $0.0 != $1.0 {\n            return $0.0 < $1.0\n\
    \        } else {\n            return $0.1 > $1.1\n        }\n    })\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1),\
    \ (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0),\
    \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6,\
    \ 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst:\
    \ [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1],\
    \ [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for row in 0..<lst.count {\n        for\
    \ col in 0..<lst[row].count {\n            if lst[row][col] == x {\n         \
    \       result.append((row, col))\n            }\n        }\n    }\n    return\
    \ result.sorted { (left, right) -> Bool in\n        if left.0 < right.0 {\n  \
    \          return true\n        } else if left.0 == right.0 {\n            return\
    \ left.1 > right.1\n        } else {\n            return false\n        }\n  \
    \  }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for j in\
    \ 0..<lst[i].count {\n            if lst[i][j] == x {\n                res.append((i,\
    \ j))\n            }\n        }\n    }\n    return res.sorted(by: { (a: (Int,\
    \ Int), b: (Int, Int)) -> Bool in\n        if a.0 == b.0 {\n            return\
    \ a.1 > b.1\n        }\n        return a.0 < b.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  var res: [(Int, Int)] = []\n  for (i, j) in lst.enumerated() {\n    for (k,\
    \ v) in j.enumerated() {\n      if v == x {\n        res.append((i, k))\n    \
    \  }\n    }\n  }\n  return res.sorted {\n    if $0.0 != $1.0 {\n      return $0.0\
    \ < $1.0\n    } else {\n      return $0.1 > $1.1\n    }\n  }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014109
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var res: [(Int, Int)] = []\n    for (row, e) in lst.enumerated() {\n    \
    \    if let c = e.firstIndex(of: x) {\n            res.append((row, c))\n    \
    \    }\n    }\n    return res.sorted(by: { (a, b) -> Bool in\n        if a.0 ==\
    \ b.0 {\n            return a.1 > b.1\n        }\n        return a.0 < b.0\n \
    \   })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4),\
    \ (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp3yy5eqie/tmp3yy5eqie.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9d4575c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9d426cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae9d426c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae9d426b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3yy5eqie                        0x00005638607e982f <unavailable> + 6191

    5    libc.so.6                          0x00002ae9d4761460 __libc_start_main +
    245

    6    tmp3yy5eqie                        0x00005638607e92f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014109
- exit_code: 1
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\t\
    if (lst.count == 0) {\n\t\treturn []\n\t}\n\tvar coords = [(Int, Int)]()\n\tfor\
    \ (index, row) in lst.enumerated() {\n\t\tfor (index2, val) in row.enumerated()\
    \ {\n\t\t\tif (val == x) {\n\t\t\t\tcoords.append((index, index2))\n\t\t\t}\n\t\
    \t}\n\t}\n\tcoords.sort()\n\treturn coords\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: SyntaxError
  stderr: "/tmp/tmpro98zf9b.swift:29:2: error: type '(Int, Int)' cannot conform to\
    \ 'Comparable'\n        coords.sort()\n        ^\n/tmp/tmpro98zf9b.swift:29:2:\
    \ note: only concrete types such as structs, enums and classes can conform to\
    \ protocols\n        coords.sort()\n        ^\n/tmp/tmpro98zf9b.swift:29:2: note:\
    \ required by referencing instance method 'sort()' on 'MutableCollection' where\
    \ 'Self.Element' = '(Int, Int)'\n        coords.sort()\n        ^\n"
  stdout: ''
  timestamp: 1660014109
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    var i = 0\n    for arr in lst {\n      \
    \  var j = 0\n        for number in arr {\n            if number == x {\n    \
    \            result.append((i, j))\n            }\n            j = j + 1\n   \
    \     }\n        i = i + 1\n    }\n    return result.sorted {\n        if $0.0\
    \ == $1.0 {\n            return $0.1 > $1.1\n        }\n        return $0.0 <\
    \ $1.0\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var tuple: [(Int, Int)] = []\n    var rows = lst.count\n    var columns =\
    \ lst[0].count\n    var c = 0\n    for i in 0..<rows {\n        for j in 0..<columns\
    \ {\n            if lst[i][j] == x {\n                tuple.append((i, j))\n \
    \           }\n        }\n    }\n    return tuple\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmputs71lp1/tmputs71lp1.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0717427c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b071711eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b071711e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b071711d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmputs71lp1                        0x000056304c4bc77f <unavailable> + 6015

    5    libc.so.6                          0x00002b0717613460 __libc_start_main +
    245

    6    tmputs71lp1                        0x000056304c4bc249 <unavailable> + 4681

    '
  stdout: ''
  timestamp: 1660014110
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \  return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp2sjnd_mu/tmp2sjnd_mu.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b97accf7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b97ac9eeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b97ac9ee988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b97ac9ed7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2sjnd_mu                        0x0000559e6987d49f <unavailable> + 5279

    5    libc.so.6                          0x00002b97acee3460 __libc_start_main +
    245

    6    tmp2sjnd_mu                        0x0000559e6987cf69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var row = [(Int, Int)]()\n    for (r, array) in lst.enumerated() {\n    \
    \    for (c, item) in array.enumerated() {\n            if item == x {\n     \
    \           row.append((r, c))\n            }\n        }\n    }\n    return row.sorted(by:\
    \ { $0.0 < $1.0 || $0.0 == $1.0 && $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1,\
    \ 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for i in 0..<lst.count {\n        for\
    \ j in 0..<lst[i].count {\n            if lst[i][j] == x {\n                result.append((i,\
    \ j))\n            }\n        }\n    }\n    return result.sorted {$0.0 < $1.0}.sorted\
    \ {$0.1 > $1.1}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpbl9m7mf7/tmpbl9m7mf7.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adc01919c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adc01610b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adc01610988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adc0160f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbl9m7mf7                        0x0000562d50db77ef <unavailable> + 6127

    5    libc.so.6                          0x00002adc01b05460 __libc_start_main +
    245

    6    tmpbl9m7mf7                        0x0000562d50db72b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660014110
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmpux68fkdz/tmpux68fkdz.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba686718c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba68640fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba68640f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba68640e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpux68fkdz                        0x000055ebddab949f <unavailable> + 5279

    5    libc.so.6                          0x00002ba686904460 __libc_start_main +
    245

    6    tmpux68fkdz                        0x000055ebddab8f69 <unavailable> + 3945

    '
  stdout: ''
  timestamp: 1660014107
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    if lst.isEmpty {\n        return []\n    }\n    var res = [(Int, Int)]()\n\
    \    for i in 0..<lst.count {\n        if lst[i].contains(x) {\n            let\
    \ indexes = lst[i].indices.filter({ lst[i][$0] == x })\n            let tuples\
    \ = indexes.map({ (i, $0) })\n            res.append(contentsOf: tuples)\n   \
    \     }\n    }\n    res.sort { (first, second) -> Bool in\n        if first.0\
    \ == second.0 {\n            return first.1 > second.1\n        }\n        return\
    \ first.0 < second.0\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var i = 0\n    for row in lst {\n    \
    \    var j = 0\n        for col in row {\n            if col == x {\n        \
    \        result.append((i, j))\n            }\n            j += 1\n        }\n\
    \        i += 1\n    }\n    return result.sorted { $0.0 < $1.0 || ($0.0 == $1.0\
    \ && $0.1 > $1.1) }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var arrayOfTuples = [(Int, Int)]()\n    for (rowNumber, row) in lst.enumerated()\
    \ {\n        for (columnNumber, number) in row.enumerated() {\n            if\
    \ number == x {\n                arrayOfTuples.append((rowNumber, columnNumber))\n\
    \            }\n        }\n    }\n    return arrayOfTuples.sorted {\n        if\
    \ $0.0 != $1.0 {\n            return $0.0 < $1.0\n        } else {\n         \
    \   return $0.1 > $1.1\n        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var locations: [(Int, Int)] = []\n    var i = 0\n    var j = 0\n    for row\
    \ in lst {\n        for item in row {\n            if item == x {\n          \
    \      locations.append((i, j))\n            }\n            j += 1\n        }\n\
    \        j = 0\n        i += 1\n    }\n    return locations.sorted(by: {a, b in\n\
    \        if a.0 == b.0 {\n            return a.1 > b.1\n        }\n        return\
    \ a.0 < b.0\n    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var new_lst: [(Int, Int)] = []\n    var y: Int = 0\n    for i in lst {\n\
    \        var y_x: Int = 0\n        for j in i {\n            if j == x {\n   \
    \             new_lst.append((y, y_x))\n            }\n            y_x += 1\n\
    \        }\n        y += 1\n    }\n    new_lst.sort { (a, b) -> Bool in\n    \
    \    if a.0 == b.0 {\n            return a.1 > b.1\n        }\n        return\
    \ a.0 < b.0\n    }\n    return new_lst\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3,\
    \ 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3,\
    \ 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3,\
    \ 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    var row: Int = 0\n    for row_items in\
    \ lst {\n        for (index, item) in row_items.enumerated() {\n            if\
    \ (item == x) {\n                result.append((row, index))\n            }\n\
    \        }\n        row += 1\n    }\n    // result.sort(by: { lhs, rhs in\n  \
    \  //     if (lhs.0 < rhs.0) {\n    //         return true\n    //     } else\
    \ if (lhs.0 == rhs.0) {\n    //         return lhs.1 > rhs.1\n    //     } else\
    \ {\n    //         return false\n    //     }\n    // })\n    result.sort { lhs,\
    \ rhs in\n        if (lhs.0 < rhs.0) {\n            return true\n        } else\
    \ if (lhs.0 == rhs.0) {\n            return lhs.1 > rhs.1\n        } else {\n\
    \            return false\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result: [(Int, Int)] = []\n    for (idx, row) in lst.enumerated() {\n\
    \        if let xIdx = row.firstIndex(of: x) {\n            result.append((idx,\
    \ xIdx))\n        }\n    }\n    return result.sorted(by: { $0.0 < $1.0 }).sorted(by:\
    \ { $0.1 > $1.1 })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmp63qz9zf5/tmp63qz9zf5.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad9754dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad9751d5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad9751d5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad9751d47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp63qz9zf5                        0x0000562bc341982f <unavailable> + 6191

    5    libc.so.6                          0x00002ad9756ca460 __libc_start_main +
    245

    6    tmp63qz9zf5                        0x0000562bc34192f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var result = [(Int, Int)]()\n    for (index, value) in lst.enumerated() {\n\
    \        for (innerIndex, innerValue) in value.enumerated() {\n            if\
    \ innerValue == x {\n                result.append((index, innerIndex))\n    \
    \        }\n        }\n    }\n    return result.sorted(by: { (first, second) ->\
    \ Bool in\n        if first.0 < second.0 {\n            return true\n        }\
    \ else if first.0 == second.0 {\n            return first.1 > second.1\n     \
    \   } else {\n            return false\n        }\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6],\
    \ [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1),\
    \ (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0),\
    \ (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst:\
    \ [] as [[Int]], x: 1) == [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2)\
    \ == [] as [(Int, Int)])\nassert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x:\
    \ 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
- exit_code: -4
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    var out = [(Int, Int)]()\n    for (r, row) in lst.enumerated() {\n      \
    \  if let i = row.firstIndex(of: x) {\n            out.append((r, i))\n      \
    \  }\n    }\n    return out.sorted(by: { $0.0 < $1.0 }).sorted(by: { $0.1 > $1.1\
    \ })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(get_row(lst: [[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1, 4), (1, 0),\
    \ (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\nassert(get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5,\
    \ 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0,\
    \ 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0),\
    \ (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\nassert(get_row(lst: [[]\
    \ as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: Exception
  stderr: 'tmph5e8uj56/tmph5e8uj56.swift:40: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b290c95cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b290c653b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b290c653988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b290c6527b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph5e8uj56                        0x0000563dae6ba87f <unavailable> + 6271

    5    libc.so.6                          0x00002b290cb48460 __libc_start_main +
    245

    6    tmph5e8uj56                        0x0000563dae6ba349 <unavailable> + 4937

    '
  stdout: ''
  timestamp: 1660014110
- exit_code: 0
  program: "\n/// You are given a 2 dimensional data, as a nested arrays,\n/// which\
    \ is similar to matrix, however, unlike matrices,\n/// each row may contain a\
    \ different number of columns.\n/// Given lst, and integer x, find integers x\
    \ in the array,\n/// and return array of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n/// each tuple is a coordinate - (row, columns), starting with 0.\n///\
    \ Sort coordinates initially by rows in ascending order.\n/// Also, sort coordinates\
    \ of the row by columns in descending order.\n/// Examples:\n/// >>> get_row(lst:\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1)\n/// [(0,\
    \ 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n/// >>> get_row(lst: [] as [[Int]], x:\
    \ 1)\n/// [] as [(Int, Int)]\n/// >>> get_row(lst: [[] as [Int], [1], [1, 2, 3]],\
    \ x: 3)\n/// [(2, 2)]\nfunc get_row(lst: [[Int]], x: Int) -> [(Int, Int)] {\n\
    \    // It is another solution.\n    //    func get_row(lst: [[Int]], x: Int)\
    \ -> [(Int, Int)] {\n    //        let indices = lst.indices.flatMap { i in\n\
    \    //            return lst[i].indices.map { j in\n    //                (i,\
    \ j)\n    //            }\n    //        }\n    //        let result = indices.filter\
    \ { lst[$0.0][$0.1] == x }\n    //        return result.sorted {\n    //     \
    \       if $0.0 != $1.0 {\n    //                return $0.0 < $1.0\n    //  \
    \          } else {\n    //                return $0.1 > $1.1\n    //        \
    \    }\n    //        }\n    //    }\n    let result = lst.enumerated().flatMap\
    \ { (i, arr) in\n        arr.enumerated().filter { $0.element == x }.map { (i,\
    \ $0.offset) }\n    }\n    return result.sorted {\n        if $0.0 != $1.0 {\n\
    \            return $0.0 < $1.0\n        } else {\n            return $0.1 > $1.1\n\
    \        }\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(get_row(lst: [[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], x: 1) == [(0, 0), (1,\
    \ 4), (1, 0), (2, 5), (2, 0)])\nassert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6]], x: 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\
    assert(get_row(lst: [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6],\
    \ [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5,\
    \ 1]], x: 1) == [(0, 0), (1, 0), (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0),\
    \ (5, 4), (5, 0), (6, 5), (6, 0)])\nassert(get_row(lst: [] as [[Int]], x: 1) ==\
    \ [] as [(Int, Int)])\nassert(get_row(lst: [[1]], x: 2) == [] as [(Int, Int)])\n\
    assert(get_row(lst: [[] as [Int], [1], [1, 2, 3]], x: 3) == [(2, 2)])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660014110
