name: HumanEval_116_sort_array
language: swift
prompt: "\n/// In this Kata, you have to sort an array of non-negative integers according\
  \ to\n/// number of ones in their binary representation in ascending order.\n///\
  \ For similar number of ones, sort based on decimal value.\n/// It must be implemented\
  \ like this:\n/// >>> sort_array(arr: [1, 5, 2, 3, 4])\n/// [1, 2, 3, 4, 5]\n///\
  \ >>> sort_array(arr: [-2, -3, -4, -5, -6])\n/// [-6, -5, -4, -3, -2]\n/// >>> sort_array(arr:\
  \ [1, 0, 2, 3, 4])\n/// [0, 1, 2, 3, 4]\nfunc sort_array(arr: [Int]) -> [Int] {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(sort_array(arr: [1, 5, 2, 3, 4]) == [1,\
  \ 2, 4, 3, 5])\nassert(sort_array(arr: [-2, -3, -4, -5, -6]) == [-4, -2, -6, -5,\
  \ -3])\nassert(sort_array(arr: [1, 0, 2, 3, 4]) == [0, 1, 2, 4, 3])\nassert(sort_array(arr:\
  \ [] as [Int]) == [] as [Int])\nassert(sort_array(arr: [2, 5, 77, 4, 5, 3, 5, 7,\
  \ 2, 3, 4]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77])\nassert(sort_array(arr: [3, 6,\
  \ 44, 12, 32, 5]) == [32, 3, 5, 6, 12, 44])\nassert(sort_array(arr: [2, 4, 8, 16,\
  \ 32]) == [2, 4, 8, 16, 32])\nassert(sort_array(arr: [2, 4, 8, 16, 32]) == [2, 4,\
  \ 8, 16, 32])"
completions: ["    var dic: [Int: [Int]] = [:]\n    var maxNum = 0\n    for n in arr\
    \ {\n        let num = String(n, radix: 2).filter { $0 == \"1\" }.count\n    \
    \    dic[num] = (dic[num] ?? []) + [n]\n        maxNum = max(maxNum, num)\n  \
    \  }\n    var result: [Int] = []\n    for i in 0...maxNum {\n        result +=\
    \ dic[i]?.sorted() ?? []\n    }\n    return result", "    var sorted = arr.sorted(by:\
    \ { $0.hammingWeight > $1.hammingWeight })\n    for i in 1..<sorted.count {\n\
    \        if sorted[i].hammingWeight == sorted[i - 1].hammingWeight {\n       \
    \     if sorted[i] < sorted[i - 1] {\n                sorted.swapAt(i, i - 1)\n\
    \            }\n        }\n    }\n    return sorted", "    var result = arr\n\
    \    result.sort {\n        let n1 = $0.nonzeroBitCount\n        let n2 = $1.nonzeroBitCount\n\
    \        return n1 < n2 || (n1 == n2 && $0 < $1)\n    }\n    return result", " \
    \   return arr.sorted(by: { num1, num2 in\n        let ones1 = String(num1, radix:\
    \ 2).filter { $0 == \"1\" }.count\n        let ones2 = String(num2, radix: 2).filter\
    \ { $0 == \"1\" }.count\n        return ones1 == ones2 ? num1 < num2 : ones1 <\
    \ ones2\n    })", "  return arr.sorted(by: { a, b in\n    let comp = compare_ones(a,\
    \ b)\n    return comp != 0 ? comp < 0 : a < b\n  })", "    var answer: [Int] =\
    \ []\n    var ones: [Int] = []\n    var zeros: [Int] = []\n    var sorted: [Int]\
    \ = []\n    var bin: [Int] = []\n    for number in arr {\n        bin = decimalToBinary(number:\
    \ number)\n        if bin.contains(1) {\n            ones.append(number)\n   \
    \     } else {\n            zeros.append(number)\n        }\n    }\n    answer\
    \ = ones\n    sorted = sortedByNumberOfOnes(arr: answer)\n    answer = sorted\n\
    \    answer.append(contentsOf: zeros)\n    return answer", "    // Implement your\
    \ solution here\n    return []", "    return arr.sorted { (a, b) -> Bool in\n\
    \        var binaryA = String(a, radix: 2)\n        var binaryB = String(b, radix:\
    \ 2)\n        if binaryA.count < binaryB.count {\n            for _ in 0..<binaryB.count\
    \ - binaryA.count {\n                binaryA = \"0\" + binaryA\n            }\n\
    \        } else if binaryA.count > binaryB.count {\n            for _ in 0..<binaryA.count\
    \ - binaryB.count {\n                binaryB = \"0\" + binaryB\n            }\n\
    \        }\n        let onesA = binaryA.filter({ $0 == \"1\" }).count\n      \
    \  let onesB = binaryB.filter({ $0 == \"1\" }).count\n        if onesA == onesB\
    \ {\n            return a < b\n        }\n        return onesA < onesB\n    }",
  "    return arr.sorted {\n        let lhsValue = lhs ?? 0\n        let rhsValue\
    \ = rhs ?? 0\n        let lhsBits = lhsValue.bitCount\n        let rhsBits = rhsValue.bitCount\n\
    \        return lhsBits == rhsBits ? lhsValue < rhsValue : lhsBits < rhsBits\n\
    \    }", '    return arr.sorted(by: { Int(String($0, radix: 2).filter { $0 ==
    "1" }.count) < Int(String($1, radix: 2).filter { $0 == "1" }.count) })', "   \
    \ return arr.sorted {\n        if $0.nonzeroBitCount != $1.nonzeroBitCount {\n\
    \            return $0.nonzeroBitCount < $1.nonzeroBitCount\n        }\n     \
    \   return $0 < $1\n    }", "    return arr.sorted { (a, b) -> Bool in\n     \
    \   var aOnes = 0\n        var bOnes = 0\n        for c in a.description.characters\
    \ {\n            if c == \"1\" {\n                aOnes += 1\n            }\n\
    \        }\n        for c in b.description.characters {\n            if c == \"\
    1\" {\n                bOnes += 1\n            }\n        }\n        if aOnes\
    \ == bOnes {\n            return a < b\n        }\n        return aOnes < bOnes\n\
    \    }", "    var sortedArr = arr.sorted(by: { (lhs, rhs) -> Bool in\n       \
    \ let lhsOneCount = lhs.countBits(of: 1)\n        let rhsOneCount = rhs.countBits(of:\
    \ 1)\n        if lhsOneCount == rhsOneCount {\n            return lhs < rhs\n\
    \        }\n        return lhsOneCount < rhsOneCount\n    })\n    return sortedArr",
  "    return arr.sorted {\n        let onesCount1 = $0.onesCount\n        let onesCount2\
    \ = $1.onesCount\n        return onesCount1 < onesCount2 || (onesCount1 == onesCount2\
    \ && $0 < $1)\n    }", "    return arr.sorted(by: {a, b in\n        let aOne =\
    \ a.numberOfOnes()\n        let bOne = b.numberOfOnes()\n        if aOne == bOne\
    \ {\n            return a < b\n        }\n        return aOne < bOne\n    })",
  "    let sorted = arr.sorted { a, b in\n        let countA = a.nonzeroBitCount\n\
    \        let countB = b.nonzeroBitCount\n        return countA == countB ? a <\
    \ b : countA < countB\n    }\n    return sorted", "    var list = arr\n    list.sort\
    \ { (a, b) -> Bool in\n        let aCount = a.numOfOnes()\n        let bCount\
    \ = b.numOfOnes()\n        if aCount == bCount {\n            return a < b\n \
    \       }\n        return aCount < bCount\n    }\n    return list", "    return\
    \ arr.sorted {\n        let (num1, num2) = ($0, $1)\n        let (bit1, bit2)\
    \ = (numberOfOnes(num1), numberOfOnes(num2))\n        return bit1 == bit2 ? num1\
    \ < num2 : bit1 < bit2\n    }", "    let sorted = arr.sorted {\n        if $0.nonzeroBitCount\
    \ != $1.nonzeroBitCount {\n            return $0.nonzeroBitCount < $1.nonzeroBitCount\n\
    \        }\n        return $0 < $1\n    }\n    return sorted", "    let ones =\
    \ arr.map { $0.nonzeroBitCount }\n    return zip(arr, ones).sorted { a, b in\n\
    \        if a.1 == b.1 {\n            return a.0 < b.0\n        }\n        return\
    \ a.1 < b.1\n    }.map { $0.0 }", "    let sorted = arr.sorted { (lhs, rhs) ->\
    \ Bool in\n        let l = lhs.nonzeroBitCount\n        let r = rhs.nonzeroBitCount\n\
    \        if l == r {\n            return lhs < rhs\n        }\n        return\
    \ l < r\n    }\n    return sorted", "    var decimalNumbers = arr.map { ($0, countDecimalOnes($0))\
    \ }\n    decimalNumbers.sort { (lhs, rhs) -> Bool in\n        if lhs.1 == rhs.1\
    \ {\n            return lhs.0 < rhs.0\n        }\n        return lhs.1 < rhs.1\n\
    \    }\n    return decimalNumbers.map { $0.0 }", "    return arr.sorted {\n  \
    \      $0.onesCount < $1.onesCount\n    }", "    return arr.sorted {\n       \
    \ var a = $0\n        var b = $1\n        let aCount = countOnes(number: &a)\n\
    \        let bCount = countOnes(number: &b)\n        if aCount == bCount {\n \
    \           return $0 < $1\n        }\n        return aCount < bCount\n    }",
  "    // your code here\n    return arr", "    var dict = Dictionary<Int, [Int]>()\n\
    \    for item in arr {\n        let key = String(item, radix: 2).filter { $0 ==\
    \ \"1\" }.count\n        if let values = dict[key] {\n            dict[key] =\
    \ values + [item]\n        } else {\n            dict[key] = [item]\n        }\n\
    \    }\n    var result = [Int]()\n    for key in dict.keys.sorted() {\n      \
    \  result += dict[key]!.sorted()\n    }\n    return result", "    return arr.sorted\
    \ { (lhs, rhs) -> Bool in\n        String(lhs, radix: 2).count == String(rhs,\
    \ radix: 2).count ? lhs < rhs : String(lhs, radix: 2).count < String(rhs, radix:\
    \ 2).count\n    }", "    // nil-safety\n    guard arr.count > 0 else { return\
    \ [] }\n    \n    // As in the Kata, it must be implemented like this:\n    //\
    \ let binary: [String] = arr.map { String($0, radix: 2) }\n    let binary: [String]\
    \ = arr.map { String($0, radix: 2) }\n    let ones: [Int] = binary.map {\n   \
    \     var n = 0\n        for c in $0 {\n            if c == \"1\" { n += 1 }\n\
    \        }\n        return n\n    }\n    // zip() can be used to combine two Arrays.\n\
    \    let sortedArray = zip(arr, ones).sorted { $0.1 < $1.1 }.map { $0.0 }\n  \
    \  return sortedArray", "    let sorted = arr.sorted {\n        ($0 & 1, $0) <\
    \ ($1 & 1, $1)\n    }\n    return sorted", "    return arr.sorted { num1, num2\
    \ in\n        (num1.nonzeroBitCount, num1) < (num2.nonzeroBitCount, num2)\n  \
    \  }", "    return arr.sorted(by: {\n        let aOnes = String($0, radix: 2).components(separatedBy:\
    \ \"1\").count - 1\n        let bOnes = String($1, radix: 2).components(separatedBy:\
    \ \"1\").count - 1\n        return aOnes == bOnes ? $0 < $1 : aOnes < bOnes\n\
    \    })", '    return arr.sorted(by: { count_ones(value: $0) < count_ones(value:
    $1) })', "  //return arr.sorted(by: { abs($0) % 2 == 1 ? $0.ones(digit: 1) > $1.ones(digit:\
    \ 1) : $0 > $1})\n  return arr.sorted(by: { (lhs, rhs) -> Bool in\n    if abs(lhs)\
    \ % 2 == abs(rhs) % 2 {\n      return abs(lhs) < abs(rhs)\n    } else {\n    \
    \  return abs(lhs) % 2 == 1\n    }\n  })", "    // sort the input array\n    let\
    \ sortedArray = arr.sorted { (left: Int, right: Int) -> Bool in\n        let leftToBinary\
    \ = String(left, radix: 2, uppercase: false)\n        let rightToBinary = String(right,\
    \ radix: 2, uppercase: false)\n        let totalOfOneLeft = leftToBinary.filter\
    \ { $0 == \"1\" }.count\n        let totalOfOneRight = rightToBinary.filter {\
    \ $0 == \"1\" }.count\n        return totalOfOneLeft < totalOfOneRight\n    }\n\
    \    return sortedArray", "    var array = arr\n    array.sort { (i, j) -> Bool\
    \ in\n        let bi = String(i, radix: 2).count\n        let bj = String(j, radix:\
    \ 2).count\n        if bi == bj {\n            return i < j\n        }\n     \
    \   return bi < bj\n    }\n    return array", "    // TODO\n    return []", " \
    \   return arr.sorted { (x, y) -> Bool in\n        if x.nonzeroBitCount < y.nonzeroBitCount\
    \ {\n            return true\n        } else if x.nonzeroBitCount > y.nonzeroBitCount\
    \ {\n            return false\n        } else {\n            return x < y\n  \
    \      }\n    }", "    let arr = arr.map { (num: Int) -> (Int, String) in\n  \
    \      return (num, String(num, radix: 2))\n    }.sorted { (left: (Int, String),\
    \ right: (Int, String)) -> Bool in\n        if left.1.count == right.1.count {\n\
    \            return left.0 < right.0\n        }\n        return left.1.count <\
    \ right.1.count\n    }\n    return arr.map { (tuple: (Int, String)) -> Int in\n\
    \        return tuple.0\n    }", "    return arr.sorted {\n        if $0.nonzeroBitCount\
    \ == $1.nonzeroBitCount {\n            return $0 < $1\n        }\n        return\
    \ $0.nonzeroBitCount < $1.nonzeroBitCount\n    }", "    \n    guard arr.count\
    \ > 1 else { return arr }\n    \n    return arr.sorted { (a, b) -> Bool in\n \
    \       let aBinary = String(a, radix: 2)\n        let bBinary = String(b, radix:\
    \ 2)\n        \n        return aBinary.countOf(substring: \"1\") == bBinary.countOf(substring:\
    \ \"1\") ? a < b : aBinary.countOf(substring: \"1\") < bBinary.countOf(substring:\
    \ \"1\")\n    }", "    var answer = arr\n    for i in 0..<answer.count {\n   \
    \     for j in 0..<answer.count - 1 {\n            if (answer[j].onesCount() >\
    \ answer[j + 1].onesCount()) {\n                let tmp = answer[j]\n        \
    \        answer[j] = answer[j + 1]\n                answer[j + 1] = tmp\n    \
    \        } else if (answer[j].onesCount() == answer[j + 1].onesCount()) {\n  \
    \              if (answer[j] > answer[j + 1]) {\n                    let tmp =\
    \ answer[j]\n                    answer[j] = answer[j + 1]\n                 \
    \   answer[j + 1] = tmp\n                }\n            }\n        }\n    }\n\
    \    return answer", '    return arr.sorted(by: { binaryCount(n: $0) == binaryCount(n:
    $1) ? $0 < $1 : binaryCount(n: $0) < binaryCount(n: $1) })', "    return arr.sorted(by:\
    \ {\n        numA, numB in\n        let binA = String(numA, radix: 2)\n      \
    \  let binB = String(numB, radix: 2)\n        let onesA = binA.filter({ $0 ==\
    \ \"1\" }).count\n        let onesB = binB.filter({ $0 == \"1\" }).count\n   \
    \     return onesA == onesB ? numA < numB : onesA < onesB\n    })", "    return\
    \ arr.sorted { (a, b) -> Bool in\n        let aValue = a.nonzeroBitCount\n   \
    \     let bValue = b.nonzeroBitCount\n        if aValue != bValue {\n        \
    \    return aValue < bValue\n        }\n        return a < b\n    }", '    return
    arr.sorted(by: { $0.decimal < $1.decimal })', "    let sortedArr = arr.sorted\
    \ {\n        let numberOfBits = $0.nonzeroBitCount\n        let numberOfBits2\
    \ = $1.nonzeroBitCount\n        return numberOfBits == numberOfBits2 ? $0 < $1\
    \ : numberOfBits < numberOfBits2\n    }\n    return sortedArr", "    return arr.sorted\
    \ { (a, b) -> Bool in\n        if a.onesCount == b.onesCount {\n            return\
    \ a < b\n        }\n        return a.onesCount < b.onesCount\n    }", "    return\
    \ arr.sorted(by: { (a, b) -> Bool in\n        if a.nonzeroBitCount == b.nonzeroBitCount\
    \ {\n            return a < b\n        }\n        return a.nonzeroBitCount < b.nonzeroBitCount\n\
    \    })", "    let digits = arr.map { convert_to_binary_digits($0) }\n    return\
    \ zip(arr, digits).sorted { (i1, i2) in\n        if i1.1.count == i2.1.count {\n\
    \            return i1.0 < i2.0\n        }\n        return i1.1.count < i2.1.count\n\
    \    }.map { $0.0 }", "    var arr = arr\n    arr.sortInPlace { lhs, rhs in\n\
    \        lhs.onesCount != rhs.onesCount ? lhs.onesCount < rhs.onesCount : lhs\
    \ < rhs\n    }\n    return arr", '    return arr.sorted(by: {$0.nonzeros() < $1.nonzeros()})',
  "    \n    let sortedDict = arr.map{ ($0, String($0, radix: 2).components(separatedBy:\
    \ \"1\").count - 1) }.sorted {\n        return ($0.1 < $1.1) || (($0.1 == $1.1)\
    \ && ($0.0 < $1.0))\n    }\n    \n    return sortedDict.map{ $0.0 }", "    return\
    \ arr.sorted(by: { (a, b) -> Bool in\n        var aOnes = 0\n        var bOnes\
    \ = 0\n        for i in a...1 {\n            aOnes += i\n        }\n        for\
    \ i in b...1 {\n            bOnes += i\n        }\n        return aOnes > bOnes\n\
    \    })", "    var arr = arr\n    arr.sort {\n        let a = $0\n        let\
    \ b = $1\n        var result = false\n        if a > 0 && b > 0 {\n          \
    \  result = countOne(x: a) < countOne(x: b)\n        } else if a < 0 && b < 0\
    \ {\n            result = countOne(x: a) > countOne(x: b)\n        } else if a\
    \ > 0 && b < 0 {\n            result = true\n        } else if a < 0 && b > 0\
    \ {\n            result = false\n        } else if a == 0 && b > 0 {\n       \
    \     result = true\n        } else if a > 0 && b == 0 {\n            result =\
    \ false\n        } else if a == 0 && b < 0 {\n            result = false\n   \
    \     } else if a < 0 && b == 0 {\n            result = true\n        }\n    \
    \    return result\n    }\n    return arr", "    return arr.sorted { (a, b) ->\
    \ Bool in\n        let aBits = a.nonzeroBitCount\n        let bBits = b.nonzeroBitCount\n\
    \        if aBits != bBits {\n            return aBits < bBits\n        }\n  \
    \      return a < b\n    }", "    arr.sorted { (a, b) -> Bool in\n        let\
    \ (aOne, aZero) = countOnes(a)\n        let (bOne, bZero) = countOnes(b)\n   \
    \     if aOne == bOne {\n            return a < b\n        }\n        return aOne\
    \ < bOne\n    }", "    guard arr.count > 1 else { return arr }\n    return arr.sorted\
    \ { (a, b) -> Bool in\n        guard a > 0, b > 0 else { return a < b }\n    \
    \    return binary(a) == binary(b) ? a < b : binary(a) < binary(b)\n    }", '    return
    arr.sorted(by: { ($0.numberOfOnes(), $0) < ($1.numberOfOnes(), $1) })', "    var\
    \ ones = [[Int]]()\n    arr.forEach {\n        let binaryString = String($0, radix:\
    \ 2)\n        let binaryArray = Array(binaryString)\n        var num = 0\n   \
    \     binaryArray.forEach {\n            if $0 == \"1\" {\n                num\
    \ += 1\n            }\n        }\n        if ones.count > num {\n            ones[num].append($0)\n\
    \        } else {\n            ones.append([$0])\n        }\n    }\n    var sorted\
    \ = [Int]()\n    ones.forEach {\n        let sortedValue = $0.sorted(by: { $0\
    \ < $1 })\n        sorted.append(contentsOf: sortedValue)\n    }\n    return sorted",
  "    let sorted: [Int] = arr.sorted { (num1, num2) -> Bool in\n        let binary1\
    \ = String(num1, radix: 2)\n        let binary2 = String(num2, radix: 2)\n   \
    \     if binary1.characters.filter({ $0 == \"1\" }).count == binary2.characters.filter({\
    \ $0 == \"1\" }).count {\n            return num1 < num2\n        }\n        return\
    \ binary1.characters.filter({ $0 == \"1\" }).count < binary2.characters.filter({\
    \ $0 == \"1\" }).count\n    }\n    return sorted", "    var newArr = arr.sorted(by:\
    \ { $0 > $1 })\n    var onesArr = [Int]()\n    for num in newArr {\n        let\
    \ numberOfOnes = num.bin.filter { $0 == \"1\" }.count\n        onesArr.append(numberOfOnes)\n\
    \    }\n    for i in 0..<newArr.count {\n        for j in 0..<newArr.count - 1\
    \ {\n            if onesArr[j] == onesArr[j + 1] {\n                if newArr[j]\
    \ > newArr[j + 1] {\n                    let tmp = newArr[j]\n               \
    \     newArr[j] = newArr[j + 1]\n                    newArr[j + 1] = tmp\n   \
    \             }\n            }\n        }\n    }\n    return newArr", "    var\
    \ result = arr\n    result.sort { (a, b) -> Bool in\n        if onesInBinary(a)\
    \ == onesInBinary(b) {\n            return a < b\n        }\n        return onesInBinary(a)\
    \ < onesInBinary(b)\n    }\n    return result", "    var newArr = arr.map { (number)\
    \ -> (number: Int, binary: String) in\n        return (number, String(number,\
    \ radix: 2))\n    }\n    newArr.sort { (obj1, obj2) -> Bool in\n        if obj1.binary.filter({\
    \ $0 == \"1\" }).count == obj2.binary.filter({ $0 == \"1\" }).count {\n      \
    \      return obj1.number < obj2.number\n        }\n        return obj1.binary.filter({\
    \ $0 == \"1\" }).count < obj2.binary.filter({ $0 == \"1\" }).count\n    }\n  \
    \  return newArr.map { $0.number }", "    return arr.sorted(by: { (first: Int,\
    \ second: Int) -> Bool in\n        let firstOnes = String(first, radix: 2).filter({\
    \ $0 == \"1\" }).count\n        let secondOnes = String(second, radix: 2).filter({\
    \ $0 == \"1\" }).count\n        if firstOnes == secondOnes {\n            return\
    \ first < second\n        }\n        return firstOnes < secondOnes\n    })", " \
    \   var oneCounts = [Int: [Int]]()\n    for a in arr {\n        let aString =\
    \ String(a, radix: 2)\n        var numOnes = 0\n        for c in aString {\n \
    \           if c == \"1\" {\n                numOnes += 1\n            }\n   \
    \     }\n        if oneCounts[numOnes] == nil {\n            oneCounts[numOnes]\
    \ = [a]\n        } else {\n            oneCounts[numOnes]!.append(a)\n       \
    \ }\n    }\n    var result = [Int]()\n    for i in 0...arr.count {\n        if\
    \ let a = oneCounts[i] {\n            result.append(contentsOf: a.sorted())\n\
    \        }\n    }\n    return result", "    arr.sorted {\n        let a = $0\n\
    \        let b = $1\n        let (aBits, bBits) = (bits(n: a), bits(n: b))\n \
    \       if aBits == bBits {\n            return a < b\n        }\n        return\
    \ aBits < bBits\n    }", "    return arr.sorted { (lhs, rhs) -> Bool in\n    \
    \    let lhsOnes = lhs.ones\n        let rhsOnes = rhs.ones\n        if lhsOnes\
    \ == rhsOnes {\n            return lhs < rhs\n        }\n        return lhsOnes\
    \ < rhsOnes\n    }", "    var d = Dictionary<Int, [Int]>()\n    for i in arr {\n\
    \        let c = String(i, radix: 2).filter { $0 == \"1\" }.count\n        if\
    \ d[c] == nil {\n            d[c] = [i]\n        } else {\n            d[c]!.append(i)\n\
    \        }\n    }\n    return d.keys.sorted().flatMap {\n        d[$0]!.sorted()\n\
    \    }", '    return arr.sorted(by: { $0.binaryDescription.filter({ $0 == "1"
    }).count == $1.binaryDescription.filter({ $0 == "1" }).count ? $0 < $1 : $0.binaryDescription.filter({
    $0 == "1" }).count < $1.binaryDescription.filter({ $0 == "1" }).count })', " \
    \   return arr.sorted {\n        let a = String($0, radix: 2).replacingOccurrences(of:\
    \ \"0\", with: \"\")\n        let b = String($1, radix: 2).replacingOccurrences(of:\
    \ \"0\", with: \"\")\n        if a.count == b.count {\n            return $0 <\
    \ $1\n        }\n        return a.count < b.count\n    }", "    guard arr.count\
    \ > 1 else { return arr }\n    let sortedArr = arr.sorted { (a, b) -> Bool in\n\
    \        let aOnes = String(a, radix: 2).filter { $0 == \"1\" }.count\n      \
    \  let bOnes = String(b, radix: 2).filter { $0 == \"1\" }.count\n        if aOnes\
    \ != bOnes {\n            return aOnes < bOnes\n        }\n        return a <\
    \ b\n    }\n    return sortedArr", "    return arr.sorted {\n        numOfOnes($0)\
    \ == numOfOnes($1) ? $0 < $1 : numOfOnes($0) < numOfOnes($1)\n    }", "    var\
    \ nonNeg = arr.filter { $0 >= 0 }\n    var neg = arr.filter { $0 < 0 }\n    nonNeg.sort\
    \ { a, b in\n        let aBinary = String(a, radix: 2)\n        let bBinary =\
    \ String(b, radix: 2)\n        let a1Count = aBinary.reduce(0) { $1 == \"1\" ?\
    \ $0 + 1 : $0 }\n        let b1Count = bBinary.reduce(0) { $1 == \"1\" ? $0 +\
    \ 1 : $0 }\n        if a1Count != b1Count {\n            return a1Count < b1Count\n\
    \        }\n        return a < b\n    }\n    return neg + nonNeg", "  return arr.sorted\
    \ {\n    let onesA = $0.onesCount\n    let onesB = $1.onesCount\n    return onesA\
    \ == onesB ? $0 < $1 : onesA < onesB\n  }", "    return arr.sorted {\n       \
    \ let numberOfOnes = ($0).countOnes()\n        let numberOfOnes2 = ($1).countOnes()\n\
    \        if numberOfOnes == numberOfOnes2 {\n            return $0 < $1\n    \
    \    }\n        return numberOfOnes < numberOfOnes2\n    }", "    return arr.sorted(by:\
    \ { (a, b) -> Bool in\n        var x = a\n        var y = b\n        var ax =\
    \ 0\n        var bx = 0\n        while x > 0 {\n            if x % 2 != 0 {\n\
    \                ax += 1\n            }\n            x /= 2\n        }\n     \
    \   while y > 0 {\n            if y % 2 != 0 {\n                bx += 1\n    \
    \        }\n            y /= 2\n        }\n        if ax == bx {\n           \
    \ return a < b\n        }\n        return ax < bx\n    })", "    return arr.sorted(by:\
    \ { (first, second) -> Bool in\n        let firstCount = first.oneCount()\n  \
    \      let secondCount = second.oneCount()\n        return firstCount == secondCount\
    \ ? first < second : firstCount < secondCount\n    })", "    let sorted: [(Int,\
    \ Int)] = arr.map { return ($0, $0.nonzeroBitCount) }.sorted { $0.1 == $1.1 ?\
    \ $0.0 < $1.0 : $0.1 < $1.1 }\n    return sorted.map { $0.0 }", "  let sortedOnesBinary\
    \ = arr.sorted(by: { count_ones(a: $0) < count_ones(a: $1) })\n  return sortedOnesBinary.sorted(by:\
    \ {$0 < $1})", "  var array = arr\n  array.sort(by: { (lhs, rhs) -> Bool in\n\
    \    var lhsBinary = lhs\n    var rhsBinary = rhs\n    var lhsOnes = 0\n    var\
    \ rhsOnes = 0\n    while lhsBinary > 0 {\n      if lhsBinary % 2 == 1 {\n    \
    \    lhsOnes += 1\n      }\n      lhsBinary /= 2\n    }\n    while rhsBinary >\
    \ 0 {\n      if rhsBinary % 2 == 1 {\n        rhsOnes += 1\n      }\n      rhsBinary\
    \ /= 2\n    }\n    if lhsOnes == rhsOnes {\n      return lhs < rhs\n    }\n  \
    \  return lhsOnes < rhsOnes\n  })\n  return array", "  return arr.sorted(by: {\n\
    \    (a: Int, b: Int) -> Bool in\n    let aOnes = onesInBinaryString(a)\n    let\
    \ bOnes = onesInBinaryString(b)\n    if aOnes < bOnes {\n      return true\n \
    \   } else if aOnes > bOnes {\n      return false\n    } else {\n      return\
    \ a < b\n    }\n  })", "    return arr.sorted { (a, b) -> Bool in\n        let\
    \ aOnes = a.nonzeroBitCount\n        let bOnes = b.nonzeroBitCount\n        if\
    \ aOnes == bOnes {\n            return a < b\n        }\n        return aOnes\
    \ < bOnes\n    }", "    return arr.sorted { (a, b) -> Bool in\n        var aBin\
    \ = [Int](repeating: 0, count: 8)\n        var bBin = [Int](repeating: 0, count:\
    \ 8)\n        (aBin, _) = convertIntToBinaryArray(value: a, binaryArray: aBin)\n\
    \        (bBin, _) = convertIntToBinaryArray(value: b, binaryArray: bBin)\n  \
    \      let aSum = sumBinaryArray(array: aBin)\n        let bSum = sumBinaryArray(array:\
    \ bBin)\n        if aSum < bSum {\n            return true\n        } else if\
    \ aSum > bSum {\n            return false\n        } else {\n            return\
    \ a < b\n        }\n    }", "    return arr.sorted {\n        let (ones_a, _)\
    \ = countOne(num: $0)\n        let (ones_b, _) = countOne(num: $1)\n        if\
    \ ones_a == ones_b {\n            return $0 < $1\n        }\n        return ones_a\
    \ < ones_b\n    }", "    return arr.sorted(by: {(a: Int, b: Int) -> Bool in\n\
    \        let aStr = String(a, radix: 2)\n        let bStr = String(b, radix: 2)\n\
    \        let a1s = aStr.filter({$0 == \"1\"}).count\n        let b1s = bStr.filter({$0\
    \ == \"1\"}).count\n        if a1s != b1s {\n            return a1s < b1s\n  \
    \      }\n        return a < b\n    })", "    return arr.sorted { (a, b) -> Bool\
    \ in\n        var aa = a\n        var bb = b\n        var a1s = 0\n        var\
    \ b1s = 0\n        while aa > 0 {\n            a1s += aa % 2\n            aa /=\
    \ 2\n        }\n        while bb > 0 {\n            b1s += bb % 2\n          \
    \  bb /= 2\n        }\n        if a1s < b1s {\n            return true\n     \
    \   } else if a1s > b1s {\n            return false\n        } else {\n      \
    \      return a < b\n        }\n    }", "    if arr.isEmpty {\n        return\
    \ []\n    }\n    var ones = [Int]()\n    var zeros = [Int]()\n    for number in\
    \ arr {\n        var binary = String(number, radix: 2)\n        if binary.count\
    \ < 8 {\n            while binary.count < 8 {\n                binary = \"0\"\
    \ + binary\n            }\n        }\n        if binary.contains(\"1\") {\n  \
    \          var count = 0\n            for char in binary {\n                if\
    \ char == \"1\" {\n                    count += 1\n                }\n       \
    \     }\n            ones.append(count)\n        } else {\n            zeros.append(number)\n\
    \        }\n    }\n    var numbers = [Int]()\n    for _ in ones {\n        let\
    \ zero = zeros.removeFirst()\n        numbers.append(zero)\n    }\n    for _ in\
    \ zeros {\n        let one = ones.removeFirst()\n        numbers.append(one)\n\
    \    }\n    return numbers", "    return arr.sorted { (lhs, rhs) -> Bool in\n\
    \        let onesLhs = countOnes(lhs)\n        let onesRhs = countOnes(rhs)\n\
    \        if onesLhs == onesRhs {\n            return lhs < rhs\n        }\n  \
    \      return onesLhs < onesRhs\n    }", '    return []', "    let ones = arr.map\
    \ { $0.numberOfOnes }\n    return arr.sorted { ones[$0] == ones[$1] ? $0 < $1\
    \ : ones[$0] < ones[$1] }", "    guard arr.count > 1 else { return arr }\n   \
    \ let sorted = arr.sorted {\n        let lhsOnes = $0.numberOfOnes()\n       \
    \ let rhsOnes = $1.numberOfOnes()\n        if lhsOnes == rhsOnes {\n         \
    \   return $0 < $1\n        }\n        return lhsOnes < rhsOnes\n    }\n    return\
    \ sorted", "    // your code here\n    if arr.count == 0 {\n        return []\n\
    \    }\n    let sortedArr = arr.sorted { (a, b) -> Bool in\n        a.description.count\
    \ > b.description.count\n    }\n    return sortedArr", "    // Your code here\n\
    \    return arr", "    return arr.sorted(by: {\n        let a = String($0, radix:\
    \ 2)\n        let b = String($1, radix: 2)\n        if a.count == b.count {\n\
    \            return $0 < $1\n        }\n        return a.count < b.count\n   \
    \ })", "    return arr.sorted(by: {\n        return $0.numberOfOnes != $1.numberOfOnes\
    \ ? $0.numberOfOnes < $1.numberOfOnes : $0 < $1\n    })", "    var result = arr\n\
    \    let max = arr.max() ?? 0\n    let newMax = binary_repr(max)\n    let sorted\
    \ = arr.sorted { (a, b) -> Bool in\n        binary_repr(a) == binary_repr(b) ?\
    \ a < b : binary_repr(a) < binary_repr(b)\n    }\n    let count = Double(newMax).log2()\n\
    \    var group = [Int]()\n    for i in 0...count {\n        for j in 0..<sorted.count\
    \ {\n            if binary_repr(sorted[j]) == i {\n                group.append(sorted[j])\n\
    \            }\n        }\n        result = result.map { value in\n          \
    \  if group.contains(value) {\n                let index = group.firstIndex(of:\
    \ value) ?? 0\n                return group[index]\n            } else {\n   \
    \             return value\n            }\n        }\n        group.removeAll()\n\
    \    }\n    return result", "    // Your code here\n    return arr", "    var\
    \ newArr = arr.map { (value) -> (Int, Int) in\n        let string = String(value,\
    \ radix: 2)\n        return (Int(string.filter { $0 == \"1\" }.count), value)\n\
    \    }\n    newArr.sort { (first, second) -> Bool in\n        if first.0 != second.0\
    \ {\n            return first.0 < second.0\n        } else {\n            return\
    \ first.1 < second.1\n        }\n    }\n    return newArr.map { $0.1 }", "  return\
    \ arr.sorted {\n    let onesL = $0.nonzeroBitCount\n    let onesR = $1.nonzeroBitCount\n\
    \    return onesL == onesR ? $0 < $1 : onesL < onesR\n  }", "    return arr.sorted(by:\
    \ {\n        let bin1 = String($0, radix: 2, uppercase: false)\n        let bin2\
    \ = String($1, radix: 2, uppercase: false)\n        if bin1.components(separatedBy:\
    \ \"1\").count == bin2.components(separatedBy: \"1\").count {\n            return\
    \ $0 < $1\n        }\n        return bin1.components(separatedBy: \"1\").count\
    \ < bin2.components(separatedBy: \"1\").count\n    })", "    return arr.sorted(by:\
    \ {\n        let a = String($0, radix: 2).components(separatedBy: \"1\").count\
    \ - 1\n        let b = String($1, radix: 2).components(separatedBy: \"1\").count\
    \ - 1\n        return a > b || (a == b && $0 > $1)\n    })", "    return arr.sorted(by:\
    \ {\n        getOnes(num: $0) < getOnes(num: $1) ||\n        (getOnes(num: $0)\
    \ == getOnes(num: $1) && $0 < $1)\n    })", "    return arr.sorted(by: { first,\
    \ second in\n        var firstResult = 0\n        var secondResult = 0\n     \
    \   for char in String(first, radix: 2).characters {\n            if char == \"\
    1\" {\n                firstResult += 1\n            }\n        }\n        for\
    \ char in String(second, radix: 2).characters {\n            if char == \"1\"\
    \ {\n                secondResult += 1\n            }\n        }\n        if firstResult\
    \ == secondResult {\n            return first < second\n        }\n        return\
    \ firstResult < secondResult\n    })", "  var array: [Int] = arr.sorted(by: {\
    \ $0 < $1 })\n  var low = 0\n  var high = array.count - 1\n  while low < high\
    \ {\n    let l = array[low]\n    let h = array[high]\n    let l1 = getOnes(for:\
    \ l)\n    let h1 = getOnes(for: h)\n    if l1 < h1 {\n      low += 1\n    } else\
    \ if l1 > h1 {\n      high -= 1\n    } else {\n      if l > h {\n        low +=\
    \ 1\n        high -= 1\n      } else {\n        let tmp = array[low]\n       \
    \ array[low] = array[high]\n        array[high] = tmp\n        low += 1\n    \
    \    high -= 1\n      }\n    }\n  }\n  return array", "    return arr.sorted {\
    \ (left, right) -> Bool in\n        let leftBinary = String(left, radix: 2).map\
    \ { $0 == \"1\" }.filter { $0 }.count\n        let rightBinary = String(right,\
    \ radix: 2).map { $0 == \"1\" }.filter { $0 }.count\n        return leftBinary\
    \ < rightBinary || leftBinary == rightBinary && left < right\n    }", "    let\
    \ sortedPairs = arr.map({ Int(String($0, radix: 2, uppercase: false))! })\n  \
    \      .enumerated()\n        .sorted(by: { (pair1, pair2) -> Bool in\n      \
    \      if pair1.element != pair2.element {\n                return pair1.element\
    \ < pair2.element\n            } else {\n                return arr[pair1.offset]\
    \ < arr[pair2.offset]\n            }\n        })\n    return sortedPairs.map({\
    \ arr[$0.offset] })", "    guard arr.count > 1 else { return arr }\n    return\
    \ arr.sorted {\n        if $0.nonzeroBitCount < $1.nonzeroBitCount {\n       \
    \     return true\n        } else if $0.nonzeroBitCount > $1.nonzeroBitCount {\n\
    \            return false\n        } else {\n            return $0 < $1\n    \
    \    }\n    }", "    return arr.sorted { (a, b) -> Bool in\n        let aBinary\
    \ = String(a, radix: 2)\n        let bBinary = String(b, radix: 2)\n        return\
    \ aBinary.components(separatedBy: \"1\").count > bBinary.components(separatedBy:\
    \ \"1\").count\n    }", "    let sortedArr = arr.sorted(by: { $0.toBinaryString().filter({\
    \ $0 == \"1\" }).count < $1.toBinaryString().filter({ $0 == \"1\" }).count })\n\
    \    var items: [Int] = []\n    var lastValue = -1\n    for item in sortedArr\
    \ {\n        if item.toBinaryString().filter({ $0 == \"1\" }).count == lastValue\
    \ {\n            items.append(item)\n        } else {\n            if items.count\
    \ > 0 {\n                sortedArr.filter({ items.contains($0) }).sorted(by: {\
    \ $0 < $1 }).forEach({ _ = items.popLast() })\n                items.append(contentsOf:\
    \ sortedArr.filter({ items.contains($0) }).sorted(by: { $0 < $1 }))\n        \
    \    }\n            items.append(item)\n            lastValue = item.toBinaryString().filter({\
    \ $0 == \"1\" }).count\n        }\n    }\n    return items", "    let sorted =\
    \ arr.sorted { (lhs, rhs) -> Bool in\n        let left = (lhs >= 0) ? lhs : -lhs\n\
    \        let right = (rhs >= 0) ? rhs : -rhs\n        let leftCount = getOneCount(left)\n\
    \        let rightCount = getOneCount(right)\n        if leftCount == rightCount\
    \ {\n            return left < right\n        }\n        return leftCount < rightCount\n\
    \    }\n    return sorted", "    return arr.sorted(by: {\n        let num1Ones\
    \ = $0.binaryRepresentation.components(separatedBy: \"1\").count - 1\n       \
    \ let num2Ones = $1.binaryRepresentation.components(separatedBy: \"1\").count\
    \ - 1\n        if num1Ones == num2Ones {\n            return $0 < $1\n       \
    \ }\n        return num1Ones < num2Ones\n    })", "    return arr.sorted(by: {\
    \ (lhs, rhs) -> Bool in\n        let lhsStr = String(lhs, radix: 2)\n        let\
    \ rhsStr = String(rhs, radix: 2)\n        let lhsOnes = lhsStr.filter { $0 ==\
    \ \"1\" }.count\n        let rhsOnes = rhsStr.filter { $0 == \"1\" }.count\n \
    \       if lhsOnes == rhsOnes {\n            return lhs < rhs\n        }\n   \
    \     return lhsOnes < rhsOnes\n    })", "    return arr.sorted { (lhs, rhs) ->\
    \ Bool in\n        let lhsBinary = String(lhs, radix: 2)\n        let rhsBinary\
    \ = String(rhs, radix: 2)\n        if lhsBinary.count == rhsBinary.count {\n \
    \           return lhs < rhs\n        }\n        return lhsBinary.count < rhsBinary.count\n\
    \    }", "    return arr.sorted { (left, right) -> Bool in\n        let sumLeft\
    \ = left.binary.countOnes\n        let sumRight = right.binary.countOnes\n   \
    \     return sumLeft < sumRight || (sumLeft == sumRight && left < right)\n   \
    \ }", "    return arr.sorted {\n        if $0 < 0 && $1 < 0 {\n            return\
    \ $0 < $1\n        }\n        if $0 < 0 {\n            return false\n        }\n\
    \        if $1 < 0 {\n            return true\n        }\n        let oneCounts\
    \ = (onesCount($0), onesCount($1))\n        if oneCounts.0 == oneCounts.1 {\n\
    \            return $0 < $1\n        }\n        return oneCounts.0 < oneCounts.1\n\
    \    }", "    return arr.sorted { first, second in\n        let firstValue = String(first,\
    \ radix: 2).filter { $0 == \"1\" }.count\n        let secondValue = String(second,\
    \ radix: 2).filter { $0 == \"1\" }.count\n        if firstValue == secondValue\
    \ {\n            return first < second\n        }\n        return firstValue <\
    \ secondValue\n    }", "  var res = arr\n  res.sort(by: { (a, b) -> Bool in\n\
    \    a.countOneBits() < b.countOneBits() || (a.countOneBits() == b.countOneBits()\
    \ && a < b)\n  })\n  return res", "    var result = arr\n    result.sort { (a,\
    \ b) -> Bool in\n        (a.nonzeroBitCount, a) < (b.nonzeroBitCount, b)\n   \
    \ }\n    return result", "    return arr.sorted(by: {\n        let bin0 = String($0,\
    \ radix: 2)\n        let bin1 = String($1, radix: 2)\n        let cmp = bin0.split(separator:\
    \ \"1\").count.compare(bin1.split(separator: \"1\").count)\n        if cmp ==\
    \ .orderedSame {\n            return $0.compare($1) == .orderedAscending\n   \
    \     }\n        return cmp == .orderedAscending\n    })", "    return arr.sorted\
    \ {\n        var b1 = UInt64(bitPattern: $0), b2 = UInt64(bitPattern: $1)\n  \
    \      let ones1 = UInt64(~b1).nonzeroBitCount\n        let ones2 = UInt64(~b2).nonzeroBitCount\n\
    \        if ones1 != ones2 {\n            return ones1 < ones2\n        }\n  \
    \      if b1 == b2 {\n            return $0 < $1\n        }\n        var d1 =\
    \ 0, d2 = 0\n        while b1 > 0 {\n            b1 /= 10\n            d1 += 1\n\
    \        }\n        while b2 > 0 {\n            b2 /= 10\n            d2 += 1\n\
    \        }\n        return d1 < d2\n    }", "    var sortedArr = arr.sorted {\n\
    \        $0.onesCount < $1.onesCount\n    }\n    sortedArr.sort {\n        $0.onesCount\
    \ == $1.onesCount ? $0 < $1 : false\n    }\n    return sortedArr", "    return\
    \ arr.sorted {\n        (a, b) in\n        let aBinary = String(a, radix: 2)\n\
    \        let bBinary = String(b, radix: 2)\n        let a1Count = aBinary.filter\
    \ { $0 == \"1\" }.count\n        let b1Count = bBinary.filter { $0 == \"1\" }.count\n\
    \        if a1Count == b1Count {\n            return a < b\n        }\n      \
    \  return a1Count < b1Count\n    }", "    // Base case: empty array\n    guard\
    \ arr.count > 0 else { return [] }\n    \n    // Dictionary to map binary representation\
    \ of numbers with their indeces\n    var binaryMap = [String: [Int]]()\n    \n\
    \    // Loop over array elements\n    for (i, element) in arr.enumerated() {\n\
    \        // Base case: empty array\n        if binaryMap.isEmpty {\n         \
    \   // Initialize map with first pair\n            binaryMap[String(element, radix:\
    \ 2)] = [i]\n        } else {\n            // Check if element's binary representation\
    \ is in map\n            if let indeces = binaryMap[String(element, radix: 2)]\
    \ {\n                // Binary representation found, append index\n          \
    \      binaryMap[String(element, radix: 2)] = indeces + [i]\n            } else\
    \ {\n                // Binary representation not found, append new key\n    \
    \            binaryMap[String(element, radix: 2)] = [i]\n            }\n     \
    \   }\n    }\n    \n    // Sort keys by binary representation\n    let binaryMapKeys\
    \ = binaryMap.keys.sorted(by: { (s1, s2) -> Bool in\n        s1.count < s2.count\n\
    \    })\n    \n    // Return sorted array\n    return binaryMapKeys.flatMap {\
    \ binaryMap[$0]!.map { arr[$0] } }", "    let sorted = arr.sorted { (i1, i2) ->\
    \ Bool in\n        let ones1 = i1.numberOfOnes()\n        let ones2 = i2.numberOfOnes()\n\
    \        if ones1 == ones2 {\n            return i1 < i2\n        }\n        return\
    \ ones1 < ones2\n    }\n    return sorted", "    guard arr.count > 1 else { return\
    \ arr }\n    let decimal = arr.sorted()\n    var ones = [[Int]]()\n    for num\
    \ in decimal {\n        let bin = String(num, radix: 2).components(separatedBy:\
    \ \"\").map { Int($0) ?? 0 }\n        ones.append(bin)\n    }\n    ones.sort(by:\
    \ { a, b in\n        let count = min(a.count, b.count)\n        for i in 0..<count\
    \ {\n            if a[i] == b[i] { continue }\n            return a[i] < b[i]\n\
    \        }\n        return a.count < b.count\n    })\n    var result = [Int]()\n\
    \    for var i in 0..<ones.count {\n        for var j in 0..<ones[i].count {\n\
    \            j += 1\n            if j == ones[i].count {\n                result.append(decimal[i])\n\
    \                i += 1\n                break\n            }\n        }\n   \
    \ }\n    return result", "    return arr.sorted { (lhs, rhs) -> Bool in\n    \
    \    let lhs_ones = lhs.nonzeroBitCount\n        let rhs_ones = rhs.nonzeroBitCount\n\
    \        return lhs_ones < rhs_ones || (lhs_ones == rhs_ones && lhs < rhs)\n \
    \   }", "    return arr.sorted(by: {\n        let b1 = String($0, radix: 2).filter({\
    \ $0 == \"1\" }).count\n        let b2 = String($1, radix: 2).filter({ $0 == \"\
    1\" }).count\n        return b1 == b2 ? $0 < $1 : b1 < b2\n    })", "    var result\
    \ = arr\n    result.sort { a, b in\n        if Int(String(a, radix: 2)) == Int(String(b,\
    \ radix: 2)) {\n            return a < b\n        }\n        return countOnes(a)\
    \ < countOnes(b)\n    }\n    return result", "    return arr.sorted { (a, b) ->\
    \ Bool in\n        a.numberOfOnes() < b.numberOfOnes() || (a.numberOfOnes() ==\
    \ b.numberOfOnes() && a < b)\n    }", "    var result = arr\n    for i in 0..<result.count\
    \ {\n        for j in (i+1)..<result.count {\n            let value1 = result[i]\n\
    \            let value2 = result[j]\n            if decToBin(dec: value1) < decToBin(dec:\
    \ value2) {\n                result.swapAt(i, j)\n            }\n        }\n \
    \   }\n    return result", "    guard arr.count > 1 else { return arr }\n    var\
    \ array = arr\n    let sortedNumbers = array.sorted { (a, b) -> Bool in\n    \
    \    let aOnes = countOnes(of: a)\n        let bOnes = countOnes(of: b)\n    \
    \    return aOnes < bOnes || (aOnes == bOnes && a < b)\n    }\n    return sortedNumbers",
  "    return arr.sorted(by: { (_lhs: Int, _rhs: Int) -> Bool in\n        let lhs\
    \ = String(_lhs, radix: 2).count\n        let rhs = String(_rhs, radix: 2).count\n\
    \        if lhs < rhs {\n            return true\n        } else if lhs > rhs\
    \ {\n            return false\n        } else {\n            return _lhs < _rhs\n\
    \        }\n    })", "    return arr.sorted {\n        let val1 = $0.nonzeroBitCount\n\
    \        let val2 = $1.nonzeroBitCount\n        return val1 == val2 ? $0 < $1\
    \ : val1 < val2\n    }", "    let ones_tuples = arr.map {($0, \"\\($0)\".filter{$0\
    \ == \"1\"}.count)}.sorted {\n        if $0.1 == $1.1 {\n            return $0.0\
    \ < $1.0\n        }\n        return $0.1 < $1.1\n    }\n    return ones_tuples.map\
    \ {$0.0}", "    return arr.sorted { (i1, i2) -> Bool in\n        var c1 = 0\n\
    \        var c2 = 0\n        var i = i1\n        var j = i2\n        while i >\
    \ 0 {\n            if i & 1 == 1 {\n                c1 += 1\n            }\n \
    \           i >>= 1\n        }\n        while j > 0 {\n            if j & 1 ==\
    \ 1 {\n                c2 += 1\n            }\n            j >>= 1\n        }\n\
    \        if c1 == c2 {\n            return i1 < i2\n        }\n        return\
    \ c1 < c2\n    }", "    return arr.sorted(by: {\n        var count = 0\n     \
    \   for digit in String($0, radix: 2) {\n            if digit == \"1\" {\n   \
    \             count += 1\n            }\n        }\n        var count2 = 0\n \
    \       for digit in String($1, radix: 2) {\n            if digit == \"1\" {\n\
    \                count2 += 1\n            }\n        }\n        if count == count2\
    \ {\n            return $0 < $1\n        }\n        return count < count2\n  \
    \  })", "    if arr.isEmpty {\n        return []\n    }\n    return arr.sorted\
    \ {(n1, n2) in\n        let ones1 = n1.nonzeroBitCount\n        let ones2 = n2.nonzeroBitCount\n\
    \        if ones1 == ones2 {\n            return n1 < n2\n        }\n        return\
    \ ones1 < ones2\n    }", "    return arr.sorted(by: {\n        let bits = [String](repeating:\
    \ \"0\", count: 32 - String($0, radix: 2).count) + String($0, radix: 2).map {\
    \ String($0) }\n        let bits1 = [String](repeating: \"0\", count: 32 - String($1,\
    \ radix: 2).count) + String($1, radix: 2).map { String($0) }\n        let ones\
    \ = bits.filter { $0 == \"1\" }.count\n        let ones1 = bits1.filter { $0 ==\
    \ \"1\" }.count\n        if ones == ones1 {\n            return $0 < $1\n    \
    \    }\n        return ones < ones1\n    })", "    return arr.sorted(by: { (a,\
    \ b) -> Bool in\n        return compare(a, b)\n    })", "    return arr.sorted\
    \ { (lhs, rhs) -> Bool in\n        let lhsOnes = lhs.numberOfOnes\n        let\
    \ rhsOnes = rhs.numberOfOnes\n        if lhsOnes != rhsOnes {\n            return\
    \ lhsOnes < rhsOnes\n        }\n        return lhs < rhs\n    }", "    return\
    \ arr.sorted { (a, b) -> Bool in\n        let countA = a.nonzeroBitCount\n   \
    \     let countB = b.nonzeroBitCount\n        return countA == countB ? a < b\
    \ : countA < countB\n    }", "    return arr.sorted { s, e in\n        if (s &\
    \ 1) == (e & 1) {\n            return s < e\n        }\n        if (s & 1) ==\
    \ 1 {\n            return false\n        }\n        return true\n    }", "   \
    \ return arr.sorted { (lhs, rhs) -> Bool in\n        let countLhs = lhs.nonzeroBitCount\n\
    \        let countRhs = rhs.nonzeroBitCount\n        return countLhs < countRhs\
    \ || (countLhs == countRhs && lhs < rhs)\n    }", "    var result = arr\n    for\
    \ i in 0..<result.count {\n        for j in i+1..<result.count {\n           \
    \ let iBinary = String(result[i], radix: 2)\n            let jBinary = String(result[j],\
    \ radix: 2)\n            let iOnes = iBinary.filter({ $0 == \"1\" }).count\n \
    \           let jOnes = jBinary.filter({ $0 == \"1\" }).count\n            if\
    \ iOnes > jOnes {\n                result.swapAt(i, j)\n            } else if\
    \ iOnes == jOnes && result[i] > result[j] {\n                result.swapAt(i,\
    \ j)\n            }\n        }\n    }\n    return result", "    return arr.sorted\
    \ { a, b in\n        var aOne = 0\n        var bOne = 0\n        for a in String(a,\
    \ radix: 2) {\n            if a == \"1\" {\n                aOne += 1\n      \
    \      }\n        }\n        for b in String(b, radix: 2) {\n            if b\
    \ == \"1\" {\n                bOne += 1\n            }\n        }\n        if\
    \ aOne == bOne {\n            return a < b\n        }\n        return aOne < bOne\n\
    \    }", "    let onesCount = arr.map { onesCount(in: $0) }\n    let tuple = zip(arr,\
    \ onesCount).sorted { $0.1 < $1.1 }\n    return tuple.map { $0.0 }", "    return\
    \ arr.sorted { x, y in\n        let bitsX = Set(String(x, radix: 2).filter({ $0\
    \ == \"1\" }))\n        let bitsY = Set(String(y, radix: 2).filter({ $0 == \"\
    1\" }))\n        if bitsX.count != bitsY.count {\n            return bitsX.count\
    \ < bitsY.count\n        }\n        return x < y\n    }", "    var sorted = arr.sorted(by:\
    \ { $0.onesCount < $1.onesCount })\n    sorted.sort { (a, b) -> Bool in\n    \
    \    if a.onesCount == b.onesCount {\n            return a < b\n        }\n  \
    \      return true\n    }\n    return sorted", "    let binToIntArr = arr.map\
    \ { $0.binaryToInt }\n    let sortedArr = arr.sorted { arr, arr1 in\n        if\
    \ binToIntArr[arr] < binToIntArr[arr1] {\n            return true\n        } else\
    \ if binToIntArr[arr] > binToIntArr[arr1] {\n            return false\n      \
    \  } else {\n            return arr < arr1\n        }\n    }\n    return sortedArr",
  "    var numberOnes: [Int] = []\n    for number in arr {\n        numberOnes.append(number.ones())\n\
    \    }\n    return zipped(arr, numberOnes).sorted {\n        $0.1 < $1.1 || ($0.1\
    \ == $1.1 && $0.0 < $1.0)\n    }.map { $0.0 }", "  let sorted = arr.sorted { (a,\
    \ b) -> Bool in\n    let aBinary = String(a, radix: 2)\n    let bBinary = String(b,\
    \ radix: 2)\n    let aOnes = aBinary.filter({ $0 == \"1\" }).count\n    let bOnes\
    \ = bBinary.filter({ $0 == \"1\" }).count\n    if aOnes == bOnes {\n      return\
    \ a < b\n    }\n    return aOnes < bOnes\n  }\n  return sorted", "    return arr.sorted\
    \ {\n        let x = String($0, radix: 2).filter { $0 == \"1\" }.count\n     \
    \   let y = String($1, radix: 2).filter { $0 == \"1\" }.count\n        return\
    \ x == y ? $0 < $1 : x < y\n    }", "    return arr.sorted { (x, y) -> Bool in\n\
    \        if x == y {\n            return x < y\n        }\n        if x.nonzeroBitCount\
    \ == y.nonzeroBitCount {\n            return x < y\n        }\n        return\
    \ x.nonzeroBitCount < y.nonzeroBitCount\n    }", "    return arr.sorted { (first:\
    \ Int, second: Int) -> Bool in\n        let f = String(first, radix: 2).filter\
    \ { $0 == \"1\" }.count\n        let s = String(second, radix: 2).filter { $0\
    \ == \"1\" }.count\n        return f == s ? first < second : f < s\n    }", " \
    \   let sortedByOneCount = arr.sorted {\n        let count = countOnes($0)\n \
    \       let otherCount = countOnes($1)\n        if count == otherCount {\n   \
    \         return $0 < $1\n        }\n        return count < otherCount\n    }\n\
    \    return sortedByOneCount", "    var sorted = arr.sorted()\n    for i in (0..<sorted.count\
    \ - 1).reversed() {\n        for j in 0..<i {\n            let a = sorted[j]\n\
    \            let b = sorted[j + 1]\n            if a.trailingZeroBitCount > b.trailingZeroBitCount\
    \ {\n                sorted.swapAt(j, j + 1)\n            } else if a.trailingZeroBitCount\
    \ == b.trailingZeroBitCount && a > b {\n                sorted.swapAt(j, j + 1)\n\
    \            }\n        }\n    }\n    return sorted", "  return arr.sorted(by:\
    \ { (x, y) -> Bool in\n    var x1 = x\n    var y1 = y\n    var xOnes = 0\n   \
    \ var yOnes = 0\n    while x1 > 0 {\n      xOnes += x1 % 2\n      x1 /= 2\n  \
    \  }\n    while y1 > 0 {\n      yOnes += y1 % 2\n      y1 /= 2\n    }\n    if\
    \ xOnes == yOnes {\n      return x < y\n    }\n    return xOnes < yOnes\n  })",
  "    return arr.sorted { (first, second) -> Bool in\n        let firstBitsCount\
    \ = countOnes(in: first)\n        let secondBitsCount = countOnes(in: second)\n\
    \        if firstBitsCount == secondBitsCount {\n            return first < second\n\
    \        }\n        return firstBitsCount < secondBitsCount\n    }", "  var newArr\
    \ = arr\n  newArr.sort(by: {\n    String($0, radix: 2).filter { $0 == \"1\" }.count\
    \ < String($1, radix: 2).filter { $0 == \"1\" }.count\n  })\n  newArr.sort(by:\
    \ {\n    String($0, radix: 2).filter { $0 == \"1\" }.count == String($1, radix:\
    \ 2).filter { $0 == \"1\" }.count\n      ? $0 < $1\n      : false\n  })\n  return\
    \ newArr", "  var ones: [Int] = []\n  var zeros: [Int] = []\n  for n in arr {\n\
    \    if String(n, radix: 2).characters.filter({$0 == \"1\"}).count > 0 {\n   \
    \   ones.append(n)\n    } else {\n      zeros.append(n)\n    }\n  }\n  ones.sortInPlace({\n\
    \    if String($0, radix: 2).characters.filter({$0 == \"1\"}).count > String($1,\
    \ radix: 2).characters.filter({$0 == \"1\"}).count {\n      return true\n    }\
    \ else if String($0, radix: 2).characters.filter({$0 == \"1\"}).count == String($1,\
    \ radix: 2).characters.filter({$0 == \"1\"}).count {\n      return $0 < $1\n \
    \   } else {\n      return false\n    }\n  })\n  zeros.sortInPlace()\n  return\
    \ zeros + ones", "    return arr.sorted(by: { (lhs, rhs) -> Bool in\n        let\
    \ lhsNumberOfOnes = lhs.binaryValue.filter({ (char) -> Bool in\n            return\
    \ char == \"1\"\n        }).count\n        let rhsNumberOfOnes = rhs.binaryValue.filter({\
    \ (char) -> Bool in\n            return char == \"1\"\n        }).count\n    \
    \    if lhsNumberOfOnes == rhsNumberOfOnes {\n            return lhs < rhs\n \
    \       }\n        return lhsNumberOfOnes < rhsNumberOfOnes\n    })", "    let\
    \ oneCount = arr.map { $0.countOnes() }\n    let tupleArr = zip(arr, oneCount)\n\
    \    let sortedArr = tupleArr.sorted { $0.1 == $1.1 ? $0.0 < $1.0 : $0.1 < $1.1\
    \ }\n    return sortedArr.map { $0.0 }", "    let obj = Dictionary(grouping: arr)\
    \ { number in\n        return number.bitString.components(separatedBy: \"1\").count\n\
    \    }\n    return obj.sorted {\n        $0.key > $1.key\n    }.flatMap { $0.value\
    \ }", '    return arr.sorted(by: { $0.binary.count == $1.binary.count ? $0 < $1
    : $0.binary.count < $1.binary.count })', "    //    guard arr.count > 1 else {\
    \ return arr }\n    //    let ones = arr.reduce([Int]()) {\n    //        let\
    \ binary = String($1, radix: 2)\n    //        var result = $0\n    //       \
    \ result.append(contentsOf: binary.filter { $0 == \"1\" }.map { Int($0) })\n \
    \   //        return result\n    //    }\n    //    return zip(arr, ones).sorted\
    \ { $0.1 < $1.1 }.map { $0.0 }\n    return arr.sorted {\n        let a = String($0,\
    \ radix: 2).filter { $0 == \"1\" }.count\n        let b = String($1, radix: 2).filter\
    \ { $0 == \"1\" }.count\n        return a == b ? $0 < $1 : a < b\n    }", "  \
    \  var bucketDict = [Int: [Int]]()\n    var result = [Int]()\n    \n    for n\
    \ in arr {\n        var binaryDigits = getBinaryDigits(n)\n        if !bucketDict.keys.contains(binaryDigits)\
    \ {\n            bucketDict[binaryDigits] = [n]\n        } else {\n          \
    \  bucketDict[binaryDigits]?.append(n)\n        }\n    }\n    \n    for key in\
    \ bucketDict.keys.sorted() {\n        var bucket = bucketDict[key]!\n        result.append(contentsOf:\
    \ bucket.sorted())\n    }\n    \n    return result", "    return arr.sorted {\
    \ (num1, num2) -> Bool in\n        let ones1 = num1.decimalToBinary().reduce(0)\
    \ { $0 + ($1 == \"1\" ? 1 : 0) }\n        let ones2 = num2.decimalToBinary().reduce(0)\
    \ { $0 + ($1 == \"1\" ? 1 : 0) }\n        return ones1 == ones2 ? num1 < num2\
    \ : ones1 < ones2\n    }", "  let zeroes = arr.filter { $0.binaryOnes == 0 }\n\
    \  let sorted = arr.filter { $0.binaryOnes > 0 }.sorted { $0.binaryOnes == $1.binaryOnes\
    \ ? $0 < $1 : $0.binaryOnes < $1.binaryOnes }\n  return zeroes + sorted", "  \
    \  guard arr.count > 1 else { return arr }\n    var result = arr\n    result.sort\
    \ { (left, right) -> Bool in\n        let leftBinary = String(left, radix: 2)\n\
    \        let rightBinary = String(right, radix: 2)\n        if leftBinary.count\
    \ != rightBinary.count {\n            return leftBinary.count < rightBinary.count\n\
    \        }\n        let leftOnes = leftBinary.split(separator: \"1\").count -\
    \ 1\n        let rightOnes = rightBinary.split(separator: \"1\").count - 1\n \
    \       if leftOnes != rightOnes {\n            return leftOnes < rightOnes\n\
    \        }\n        return left < right\n    }\n    return result", "    \n  \
    \  var temp = [Int]()\n    var map = [Int: Int]()\n    var result = [Int]()\n\
    \    \n    for i in arr {\n        temp.append(i)\n        map[i] = i.nonzeroBitCount\n\
    \    }\n    \n    temp.sort()\n    \n    for i in temp {\n        let count =\
    \ map[i]!\n        var index = 0\n        while index < result.count && map[result[index]]!\
    \ <= count {\n            index += 1\n        }\n        result.insert(i, at:\
    \ index)\n    }\n    \n    return result", "    \n    return arr.sorted(by: {\n\
    \        let binaryA = String($0, radix: 2)\n        let binaryB = String($1,\
    \ radix: 2)\n        if binaryA.filter({$0 == \"1\"}).count == binaryB.filter({$0\
    \ == \"1\"}).count {\n            return $0 < $1\n        }\n        return binaryA.filter({$0\
    \ == \"1\"}).count < binaryB.filter({$0 == \"1\"}).count\n    })", "    var result\
    \ = [Int]()\n    var ones = [Int]()\n    var zeros = [Int]()\n    for i in arr\
    \ {\n        let count = String(i, radix: 2).components(separatedBy: \"1\").count\
    \ - 1\n        if count > 0 {\n            ones.append(i)\n        } else {\n\
    \            zeros.append(i)\n        }\n    }\n    ones.sort(by: {String($0,\
    \ radix: 2).components(separatedBy: \"1\").count - 1 > String($1, radix: 2).components(separatedBy:\
    \ \"1\").count - 1})\n    zeros.sort(by: {$0 > $1})\n    result.append(contentsOf:\
    \ zeros)\n    result.append(contentsOf: ones)\n    return result", "    let sortedArr\
    \ = arr.sorted { left, right in\n        var leftCount = 0\n        var rightCount\
    \ = 0\n        var leftValue = left\n        var rightValue = right\n        while\
    \ leftValue > 0 {\n            leftCount += leftValue % 2\n            leftValue\
    \ /= 2\n        }\n        while rightValue > 0 {\n            rightCount += rightValue\
    \ % 2\n            rightValue /= 2\n        }\n        if leftCount == rightCount\
    \ {\n            return left < right\n        }\n        return leftCount < rightCount\n\
    \    }\n    return sortedArr", "    var countedOnes: [(count: Int, value: Int)]\
    \ = []\n    for a in arr {\n        countedOnes.append((count: Integer.countOnes(a),\
    \ value: a))\n    }\n    countedOnes.sort { (lhs, rhs) -> Bool in\n        if\
    \ lhs.count == rhs.count {\n            return lhs.value < rhs.value\n       \
    \ }\n        return lhs.count < rhs.count\n    }\n    return countedOnes.map {\
    \ $0.value }", "    let zipped = zip(arr, arr.map { num -> (Int, Int) in\n   \
    \     (num, num.nonzeroBitCount)\n    })\n    return zipped.sorted {\n       \
    \ $0.1.1 == $1.1.1 ? $0.1.0 < $1.1.0 : $0.1.1 < $1.1.1\n    }.map { $0.0 }", '    return
    []', "    var zeroOnesArray = [(0, 0)]\n    for n in arr {\n        var n = n\n\
    \        var ones = 0\n        while n > 0 {\n            ones += n & 1\n    \
    \        n >>= 1\n        }\n        zeroOnesArray.append((n, ones))\n    }\n\
    \    zeroOnesArray.sort {\n        if $0.1 == $1.1 {\n            return $0.0\
    \ < $1.0\n        }\n        return $0.1 < $1.1\n    }\n    return zeroOnesArray.map\
    \ { $0.0 }", "    guard !arr.isEmpty else { return [] }\n    var countMap = [Int:\
    \ Int]()\n    var sortedArr = [Int]()\n    for i in arr {\n        let count =\
    \ countOnes(from: i)\n        if countMap[count] == nil {\n            countMap[count]\
    \ = 1\n        } else {\n            countMap[count]! += 1\n        }\n    }\n\
    \    for (k, v) in countMap {\n        for _ in 0..<v {\n            let val =\
    \ arr.filter { countOnes(from: $0) == k }.sorted().first!\n            sortedArr.append(val)\n\
    \        }\n    }\n    return sortedArr", "    var arr = arr\n    arr.sort(by:\
    \ {\n        let n1: UInt = UInt(bitPattern: $0)\n        let n2: UInt = UInt(bitPattern:\
    \ $1)\n        let bin1 = String(n1, radix: 2)\n        let bin2 = String(n2,\
    \ radix: 2)\n        let ones1 = bin1.filter { $0 == \"1\" }.count\n        let\
    \ ones2 = bin2.filter { $0 == \"1\" }.count\n        if ones1 == ones2 {\n   \
    \         return n1 < n2\n        }\n        return ones1 < ones2\n    })\n  \
    \  return arr", "    guard !arr.isEmpty else { return [] }\n    guard arr.count\
    \ > 1 else { return arr }\n    guard arr.contains(where: { $0 < 0 }) else { return\
    \ arr.sorted() }\n    return arr.sorted(by: {\n        let firstBinary = String($0,\
    \ radix: 2).count\n        let secondBinary = String($1, radix: 2).count\n   \
    \     return firstBinary > secondBinary ? true : firstBinary < secondBinary ?\
    \ false : $0 < $1\n    })", "    return arr.sorted(by: {\n        return $0.onesCount\
    \ < $1.onesCount || ($0.onesCount == $1.onesCount && $0 < $1)\n    })", "    var\
    \ arr = arr\n    arr.sort(by: { binary_ones(Int64($0)) != binary_ones(Int64($1))\
    \ ? binary_ones(Int64($0)) < binary_ones(Int64($1)) : $0 < $1 })\n    return arr",
  "    guard !arr.isEmpty else { return [] }\n    return arr.sorted(by: {\n      \
    \  let countOfOnesInBinary = $0.nonzeroBitCount\n        let countOfOnesInBinary2\
    \ = $1.nonzeroBitCount\n        guard countOfOnesInBinary != countOfOnesInBinary2\
    \ else {\n            return $0 < $1\n        }\n        return countOfOnesInBinary\
    \ < countOfOnesInBinary2\n    })", "    var n = arr.map { (a: Int) -> (Int, Int)\
    \ in\n        (a, String(a, radix: 2).split(separator: \"1\").count)\n    }\n\
    \    n.sort(by: { $0.1 < $1.1 })\n    return n.map { $0.0 }", "    if arr.isEmpty\
    \ {\n        return []\n    }\n    return arr.sorted {\n        let decimalValue\
    \ = $0 < $1\n        let binaryValue = String($0, radix: 2).count < String($1,\
    \ radix: 2).count\n        return binaryValue || (decimalValue && !binaryValue)\n\
    \    }", '    return arr.sorted(by: { sortHelper(a: $0, b: $1) })', "    let sorted\
    \ = arr.sorted { (a, b) -> Bool in\n        let aBinary = String(a, radix: 2)\n\
    \        let bBinary = String(b, radix: 2)\n        let countOfOnesA = aBinary.characters.reduce(0)\
    \ { $1 == \"1\" ? $0 + 1 : $0 }\n        let countOfOnesB = bBinary.characters.reduce(0)\
    \ { $1 == \"1\" ? $0 + 1 : $0 }\n        if countOfOnesA > countOfOnesB {\n  \
    \          return true\n        } else if countOfOnesA < countOfOnesB {\n    \
    \        return false\n        } else {\n            return a < b\n        }\n\
    \    }\n    return sorted", "    var sorted = arr.map { (v: Int) -> (Int, Int)\
    \ in\n        return (v, countOnes(v))\n    }\n    sorted.sort { (left, right)\
    \ -> Bool in\n        if left.1 < right.1 {\n            return true\n       \
    \ } else if left.1 > right.1 {\n            return false\n        } else {\n \
    \           return left.0 < right.0\n        }\n    }\n    return sorted.map {\
    \ $0.0 }", "    var res = arr\n    for i in (0..<res.count).reversed() {\n   \
    \     for j in 0..<i {\n            let b1 = String(res[j], radix: 2)\n      \
    \      let b2 = String(res[j + 1], radix: 2)\n            let n1 = b1.filter {\
    \ $0 == \"1\" }.count\n            let n2 = b2.filter { $0 == \"1\" }.count\n\
    \            if n1 > n2 || (n1 == n2 && res[j] > res[j + 1]) {\n             \
    \   res.swapAt(j, j + 1)\n            }\n        }\n    }\n    return res", " \
    \   var dic = [Int: [Int]]()\n    var arr = arr\n    arr.sort()\n    arr.forEach\
    \ { dic[$0, default: []].append($0) }\n    var result = [Int]()\n    arr.forEach\
    \ { result.append(contentsOf: dic[$0]!.sorted()) }\n    return result", "    return\
    \ arr.sorted { (left, right) -> Bool in\n        let l = String(left, radix: 2)\n\
    \        let r = String(right, radix: 2)\n        if l.reduce(0, { $0 + ($1 ==\
    \ \"1\" ? 1 : 0) }) == r.reduce(0, { $0 + ($1 == \"1\" ? 1 : 0) }) {\n       \
    \     return left < right\n        }\n        return l.reduce(0, { $0 + ($1 ==\
    \ \"1\" ? 1 : 0) }) < r.reduce(0, { $0 + ($1 == \"1\" ? 1 : 0) })\n    }", " \
    \ var sorted = arr.sorted { $0 < $1 }\n  sorted.sort {\n    countOnes(n: $0) <\
    \ countOnes(n: $1)\n  }\n  return sorted", "  let result = arr.sorted(by: { (lhs,\
    \ rhs) -> Bool in\n    if lhs == rhs {\n      return lhs < rhs\n    } else {\n\
    \      return lhs.onesCount() < rhs.onesCount()\n    }\n  })\n  return result",
  "    return arr.sorted { (x, y) -> Bool in\n        if (x == y) {\n            return\
    \ x < y\n        }\n        var a = x\n        var b = y\n        var aOnes =\
    \ 0\n        var bOnes = 0\n        while (a > 0) {\n            if (a % 2 ==\
    \ 1) {\n                aOnes += 1\n            }\n            a /= 2\n      \
    \  }\n        while (b > 0) {\n            if (b % 2 == 1) {\n               \
    \ bOnes += 1\n            }\n            b /= 2\n        }\n        return aOnes\
    \ < bOnes\n    }", "    var zeros = [Int]()\n    var ones = [Int]()\n    var twos\
    \ = [Int]()\n    var threes = [Int]()\n    var fours = [Int]()\n    var fives\
    \ = [Int]()\n    var sixes = [Int]()\n    var sevens = [Int]()\n    var eights\
    \ = [Int]()\n    var nines = [Int]()\n    var tens = [Int]()\n    var elevens\
    \ = [Int]()\n    var twelves = [Int]()\n    var thirteens = [Int]()\n    var fourteens\
    \ = [Int]()\n    var fifteens = [Int]()\n    var sixteen = [Int]()\n    for x\
    \ in arr {\n        if x == 0 {\n            zeros.append(x)\n        } else if\
    \ x == 1 {\n            ones.append(x)\n        } else if x == 2 {\n         \
    \   twos.append(x)\n        } else if x == 3 {\n            threes.append(x)\n\
    \        } else if x == 4 {\n            fours.append(x)\n        } else if x\
    \ == 5 {\n            fives.append(x)\n        } else if x == 6 {\n          \
    \  sixes.append(x)\n        } else if x == 7 {\n            sevens.append(x)\n\
    \        } else if x == 8 {\n            eights.append(x)\n        } else if x\
    \ == 9 {\n            nines.append(x)\n        } else if x == 10 {\n         \
    \   tens.append(x)\n        } else if x == 11 {\n            elevens.append(x)\n\
    \        } else if x == 12 {\n            twelves.append(x)\n        } else if\
    \ x == 13 {\n            thirteens.append(x)\n        } else if x == 14 {\n  \
    \          fourteens.append(x)\n        } else if x == 15 {\n            fifteens.append(x)\n\
    \        } else if x == 16 {\n            sixteen.append(x)\n        }\n    }\n\
    \    let finalArr = zeros + ones + twos + threes + fours +", "    // Your code\
    \ here\n    return arr", "    return arr.sorted(by: {\n        let a = String($0,\
    \ radix: 2)\n        let b = String($1, radix: 2)\n        let aOnes = a.filter({\
    \ $0 == \"1\" }).count\n        let bOnes = b.filter({ $0 == \"1\" }).count\n\
    \        if aOnes == bOnes {\n            return $0 < $1\n        }\n        return\
    \ aOnes < bOnes\n    })", "    let sorted = arr.sorted { (a, b) -> Bool in\n \
    \       let aOnes = a.nonzeroBitCount\n        let bOnes = b.nonzeroBitCount\n\
    \        return aOnes == bOnes ? a < b : aOnes < bOnes\n    }\n    return sorted",
  "    let arr_ = arr.map { Int(String($0, radix: 2, uppercase: false).split(separator:\
    \ \"1\").count) }\n    var temp = Array(zip(arr_, arr))\n    temp.sort { $0.0\
    \ < $1.0 }\n    return temp.map { $0.1 }", "    return arr.sorted(by: {\n    \
    \    let count1 = $0.nonzeroBitCount\n        let count2 = $1.nonzeroBitCount\n\
    \        if count1 == count2 {\n            return $0 < $1\n        }\n      \
    \  return count1 < count2\n    })"]
stop_tokens:
- "\n}"
