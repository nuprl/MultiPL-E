{
  "name": "mbpp_618_div_list",
  "language": "rs",
  "prompt": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmp6hyv84dd.rs:3:54\n  |\n3 |     nums1.iter().zip(nums2).map(|(x, y)| *x as f64 / *y as f64).collect()\n  |                                                      ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0614`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        res.push(*n1 as f64 / *n2 as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter()\n        .zip(nums2.iter())\n        .map(|(x, y)| *x as f64 / *y as f64)\n        .collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result: Vec<f64> = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(a, b)| *a as f64 / *b as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (num1, num2) in nums1.iter().zip(nums2.iter()) {\n        result.push(num1 as f64 / num2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpux_u5ou8.rs:5:21\n  |\n5 |         result.push(num1 as f64 / num2 as f64);\n  |                     ----^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*num1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpux_u5ou8.rs:5:35\n  |\n5 |         result.push(num1 as f64 / num2 as f64);\n  |                                   ----^^^^^^^\n  |                                   |\n  |                                   cannot cast `&isize` as `f64`\n  |                                   help: dereference the expression: `*num2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(n1, n2)| n1 as f64 / n2 as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpsirvl4jj.rs:3:51\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(n1, n2)| n1 as f64 / n2 as f64).collect()\n  |                                                   --^^^^^^^\n  |                                                   |\n  |                                                   cannot cast `&isize` as `f64`\n  |                                                   help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpsirvl4jj.rs:3:63\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(n1, n2)| n1 as f64 / n2 as f64).collect()\n  |                                                               --^^^^^^^\n  |                                                               |\n  |                                                               cannot cast `&isize` as `f64`\n  |                                                               help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        res.push(n1 as f64 / n2 as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:18\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                  --^^^^^^^\n  |                  |\n  |                  cannot cast `&isize` as `f64`\n  |                  help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:30\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                              --^^^^^^^\n  |                              |\n  |                              cannot cast `&isize` as `f64`\n  |                              help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, num) in nums1.iter().enumerate() {\n        result.push(*num as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2).map(|(a, b)| a as f64 / b as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:49\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                 -^^^^^^^\n  |                                                 |\n  |                                                 cannot cast `&isize` as `f64`\n  |                                                 help: dereference the expression: `*x`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:60\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                            -^^^^^^^\n  |                                                            |\n  |                                                            cannot cast `&isize` as `f64`\n  |                                                            help: dereference the expression: `*y`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = vec![];\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (a, b) in nums1.iter().zip(nums2.iter()) {\n        result.push(a as f64 / b as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp82b9jxrj.rs:5:21\n  |\n5 |         result.push(a as f64 / b as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*a`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp82b9jxrj.rs:5:32\n  |\n5 |         result.push(a as f64 / b as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*b`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        res.push(i as f64 / j as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp96xqpxrw.rs:5:18\n  |\n5 |         res.push(i as f64 / j as f64);\n  |                  -^^^^^^^\n  |                  |\n  |                  cannot cast `&isize` as `f64`\n  |                  help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp96xqpxrw.rs:5:29\n  |\n5 |         res.push(i as f64 / j as f64);\n  |                             -^^^^^^^\n  |                             |\n  |                             cannot cast `&isize` as `f64`\n  |                             help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(a, b)| *a as f64 / *b as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut ret = Vec::new();\n    for (num1, num2) in nums1.iter().zip(nums2.iter()) {\n        ret.push(num1 as f64 / num2 as f64);\n    }\n    ret\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp006h6d7r.rs:5:18\n  |\n5 |         ret.push(num1 as f64 / num2 as f64);\n  |                  ----^^^^^^^\n  |                  |\n  |                  cannot cast `&isize` as `f64`\n  |                  help: dereference the expression: `*num1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp006h6d7r.rs:5:32\n  |\n5 |         ret.push(num1 as f64 / num2 as f64);\n  |                                ----^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*num2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result: Vec<f64> = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:49\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                 -^^^^^^^\n  |                                                 |\n  |                                                 cannot cast `&isize` as `f64`\n  |                                                 help: dereference the expression: `*x`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:60\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                            -^^^^^^^\n  |                                                            |\n  |                                                            cannot cast `&isize` as `f64`\n  |                                                            help: dereference the expression: `*y`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (x, y) in nums1.iter().zip(nums2.iter()) {\n        result.push(x / y);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n --> /tmp/tmpf_os7c1r.rs:7:5\n  |\n2 | fn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n  |                                                      -------- expected `Vec<f64>` because of return type\n...\n7 |     result\n  |     ^^^^^^ expected `f64`, found `isize`\n  |\n  = note: expected struct `Vec<f64>`\n             found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = vec![];\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(*n1 as f64 / *n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result: Vec<f64> = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(a, b)| *a as f64 / *b as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        res.push(n1 as f64 / n2 as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:18\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                  --^^^^^^^\n  |                  |\n  |                  cannot cast `&isize` as `f64`\n  |                  help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:30\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                              --^^^^^^^\n  |                              |\n  |                              cannot cast `&isize` as `f64`\n  |                              help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmp6hyv84dd.rs:3:54\n  |\n3 |     nums1.iter().zip(nums2).map(|(x, y)| *x as f64 / *y as f64).collect()\n  |                                                      ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0614`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result: Vec<f64> = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (num1, num2) in nums1.iter().zip(nums2.iter()) {\n        result.push(num1 as f64 / num2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpux_u5ou8.rs:5:21\n  |\n5 |         result.push(num1 as f64 / num2 as f64);\n  |                     ----^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*num1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpux_u5ou8.rs:5:35\n  |\n5 |         result.push(num1 as f64 / num2 as f64);\n  |                                   ----^^^^^^^\n  |                                   |\n  |                                   cannot cast `&isize` as `f64`\n  |                                   help: dereference the expression: `*num2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2).map(|(a, b)| a as f64 / b as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0614]: type `isize` cannot be dereferenced\n --> /tmp/tmp6hyv84dd.rs:3:54\n  |\n3 |     nums1.iter().zip(nums2).map(|(x, y)| *x as f64 / *y as f64).collect()\n  |                                                      ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0614`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = vec![];\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(a, b)| *a as f64 / *b as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:49\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                 -^^^^^^^\n  |                                                 |\n  |                                                 cannot cast `&isize` as `f64`\n  |                                                 help: dereference the expression: `*x`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:60\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                            -^^^^^^^\n  |                                                            |\n  |                                                            cannot cast `&isize` as `f64`\n  |                                                            help: dereference the expression: `*y`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:49\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                 -^^^^^^^\n  |                                                 |\n  |                                                 cannot cast `&isize` as `f64`\n  |                                                 help: dereference the expression: `*x`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:60\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                            -^^^^^^^\n  |                                                            |\n  |                                                            cannot cast `&isize` as `f64`\n  |                                                            help: dereference the expression: `*y`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        res.push(*i as f64 / *j as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = vec![];\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpufu6f3n9.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpufu6f3n9.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        res.push(n1 as f64 / n2 as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:18\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                  --^^^^^^^\n  |                  |\n  |                  cannot cast `&isize` as `f64`\n  |                  help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:30\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                              --^^^^^^^\n  |                              |\n  |                              cannot cast `&isize` as `f64`\n  |                              help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(*n1 as f64 / *n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (x, y) in nums1.iter().zip(nums2.iter()) {\n        result.push(x as f64 / y as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpt48fznkm.rs:5:21\n  |\n5 |         result.push(x as f64 / y as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*x`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpt48fznkm.rs:5:32\n  |\n5 |         result.push(x as f64 / y as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*y`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result: Vec<f64> = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        res.push(*i as f64 / *j as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        if nums2[i] != 0 {\n            result.push(nums1[i] as f64 / nums2[i] as f64);\n        } else {\n            result.push(0.0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        res.push(n1 as f64 / n2 as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:18\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                  --^^^^^^^\n  |                  |\n  |                  cannot cast `&isize` as `f64`\n  |                  help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmp7gdktgo1.rs:5:30\n  |\n5 |         res.push(n1 as f64 / n2 as f64);\n  |                              --^^^^^^^\n  |                              |\n  |                              cannot cast `&isize` as `f64`\n  |                              help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        res.push(*i as f64 / *j as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        res.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    res\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        result.push(nums1[i] as f64 / nums2[i] as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(i as f64 / j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:21\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                     -^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*i`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdaj6un0h.rs:5:32\n  |\n5 |         result.push(i as f64 / j as f64);\n  |                                -^^^^^^^\n  |                                |\n  |                                cannot cast `&isize` as `f64`\n  |                                help: dereference the expression: `*j`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (i, j) in nums1.iter().zip(nums2.iter()) {\n        result.push(*i as f64 / *j as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.into_iter().zip(nums2.into_iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:49\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                 -^^^^^^^\n  |                                                 |\n  |                                                 cannot cast `&isize` as `f64`\n  |                                                 help: dereference the expression: `*x`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmpdbtq9tsn.rs:3:60\n  |\n3 |     nums1.iter().zip(nums2.iter()).map(|(x, y)| x as f64 / y as f64).collect()\n  |                                                            -^^^^^^^\n  |                                                            |\n  |                                                            cannot cast `&isize` as `f64`\n  |                                                            help: dereference the expression: `*y`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        let div = nums1[i] as f64 / nums2[i] as f64;\n        result.push(div);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    nums1.iter().zip(nums2.iter()).map(|(x, y)| *x as f64 / *y as f64).collect()\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1665510125,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to divide two lists element wise.\nfn div_list(nums1: Vec<isize>, nums2: Vec<isize>) -> Vec<f64> {\n    let mut result = Vec::new();\n    for (n1, n2) in nums1.iter().zip(nums2.iter()) {\n        result.push(n1 as f64 / n2 as f64);\n    }\n    result\n}\n\nfn main() {\n    let candidate = div_list;\n    assert_eq!(candidate(vec![4, 5, 6], vec![1, 2, 3]), vec![4.0, 2.5, 2.0]);\n    assert_eq!(candidate(vec![3, 2], vec![1, 4]), vec![3.0, 0.5]);\n    assert_eq!(candidate(vec![90, 120], vec![50, 70]), vec![1.8, 1.7142857142857142]);\n}\n",
      "timestamp": 1666122577,
      "stdout": "",
      "stderr": "error[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:21\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                     --^^^^^^^\n  |                     |\n  |                     cannot cast `&isize` as `f64`\n  |                     help: dereference the expression: `*n1`\n\nerror[E0606]: casting `&isize` as `f64` is invalid\n --> /tmp/tmplvb512c0.rs:5:33\n  |\n5 |         result.push(n1 as f64 / n2 as f64);\n  |                                 --^^^^^^^\n  |                                 |\n  |                                 cannot cast `&isize` as `f64`\n  |                                 help: dereference the expression: `*n2`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0606`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}