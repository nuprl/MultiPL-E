{
  "name": "mbpp_308_large_product",
  "language": "rs",
  "prompt": "/// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfn large_product(nums1: Vec<isize>, nums2: Vec<isize>, N: isize) -> Vec<isize> {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = large_product;\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6], vec![3, 6, 8, 9, 10, 6], 3), vec![60, 54, 50]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6], vec![3, 6, 8, 9, 10, 6], 4), vec![60, 54, 50, 48]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6], vec![3, 6, 8, 9, 10, 6], 5), vec![60, 54, 50, 48, 45]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    let mut nums1 = nums1.clone();\n    let mut nums2 = nums2.clone();\n    nums1.sort();\n    nums2.sort();\n    let mut res = vec![];\n    let mut i = nums1.len() as isize - 1;\n    let mut j = nums2.len() as isize - 1;\n    while N > 0 {\n        if i < 0 || j < 0 {\n            break;\n        }\n        let a = nums1[i as usize];\n        let b = nums2[j as usize];\n        if a * b > nums1[i as usize - 1] * nums2[j as usize] {\n            res.push(a * b);\n            i -= 1;\n        } else {\n            res.push(nums1[i as usize - 1] * nums2[j as usize]);\n            j -= 1;\n        }\n        N -= 1;\n    }\n    res",
    "    let mut products = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            products.push(nums1[i] * nums2[j]);\n        }\n    }\n    products.sort();\n    products.reverse();\n    products[0..N as usize].to_vec()",
    "    let mut result = Vec::new();\n    let mut nums1 = nums1;\n    let mut nums2 = nums2;\n    nums1.sort_by(|a, b| b.cmp(a));\n    nums2.sort_by(|a, b| b.cmp(a));\n    let mut i = 0;\n    let mut j = 0;\n    while i < nums1.len() && j < nums2.len() && N > 0 {\n        let product = nums1[i] * nums2[j];\n        if product > 0 {\n            result.push(product);\n            i += 1;\n            N -= 1;\n        } else if product < 0 {\n            result.push(product);\n            j += 1;\n            N -= 1;\n        } else {\n            if nums1[i] > nums2[j] {\n                result.push(product);\n                i += 1;\n                N -= 1;\n            } else if nums1[i] < nums2[j] {\n                result.push(product);\n                j += 1;\n                N -= 1;\n            } else {\n                result.push(product);\n                i += 1;\n                j += 1;\n                N -= 1;\n            }\n        }\n    }\n    while i < nums1.len() && N > 0 {\n        result.push(nums1[i] * nums2[nums2.len() - 1]);\n        i += 1;\n        N -= 1;\n    }\n    while j < nums2.len() && N > 0 {\n        result.push(nums1[nums1.len() - 1] * nums2[j]);\n        j += 1;\n        N -= 1;\n    }\n    result",
    "    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(nums1[i] * nums2[j]);\n            if heap.len() > N as usize {\n                heap.pop();\n            }\n        }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap());\n    }\n    result.reverse();\n    result",
    "    let mut nums1 = nums1;\n    let mut nums2 = nums2;\n    nums1.sort();\n    nums2.sort();\n    let mut res = Vec::new();\n    let mut i = nums1.len() as isize - 1;\n    let mut j = nums2.len() as isize - 1;\n    while N > 0 {\n        if nums1[i as usize] * nums2[j as usize] > nums1[i as usize] * nums2[(j - 1) as usize] {\n            res.push(nums1[i as usize] * nums2[j as usize]);\n            j -= 1;\n        } else {\n            res.push(nums1[i as usize] * nums2[(j - 1) as usize]);\n            i -= 1;\n        }\n        N -= 1;\n    }\n    res",
    "    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let product = nums1[i] * nums2[j];\n            if heap.len() < N as usize {\n                heap.push(product);\n            } else if product > heap.peek().unwrap() {\n                heap.pop();\n                heap.push(product);\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n    res",
    "    let mut res = Vec::new();\n    let mut nums1 = nums1.clone();\n    let mut nums2 = nums2.clone();\n    nums1.sort();\n    nums2.sort();\n    let mut i = nums1.len() - 1;\n    let mut j = nums2.len() - 1;\n    let mut count = 0;\n    while count < N {\n        let mut max = nums1[i] * nums2[j];\n        if nums1[i] * nums2[j - 1] > max {\n            max = nums1[i] * nums2[j - 1];\n            j -= 1;\n        } else if nums1[i - 1] * nums2[j] > max {\n            max = nums1[i - 1] * nums2[j];\n            i -= 1;\n        } else {\n            i -= 1;\n            j -= 1;\n        }\n        res.push(max);\n        count += 1;\n    }\n    res",
    "    let mut products = Vec::new();\n    for &n1 in &nums1 {\n        for &n2 in &nums2 {\n            products.push(n1 * n2);\n        }\n    }\n    products.sort_by(|a, b| b.cmp(a));\n    products.into_iter().take(N as usize).collect()",
    "    let mut nums1 = nums1;\n    let mut nums2 = nums2;\n    nums1.sort();\n    nums2.sort();\n    let mut res = Vec::new();\n    let mut i = nums1.len() - 1;\n    let mut j = nums2.len() - 1;\n    while N > 0 {\n        let mut max = nums1[i] * nums2[j];\n        let mut max_i = i;\n        let mut max_j = j;\n        if i > 0 && nums1[i - 1] * nums2[j] > max {\n            max = nums1[i - 1] * nums2[j];\n            max_i = i - 1;\n            max_j = j;\n        }\n        if j > 0 && nums1[i] * nums2[j - 1] > max {\n            max = nums1[i] * nums2[j - 1];\n            max_i = i;\n            max_j = j - 1;\n        }\n        if i > 0 && j > 0 && nums1[i - 1] * nums2[j - 1] > max {\n            max = nums1[i - 1] * nums2[j - 1];\n            max_i = i - 1;\n            max_j = j - 1;\n        }\n        res.push(max);\n        i = max_i;\n        j = max_j;\n        N -= 1;\n    }\n    res",
    "    let mut nums1 = nums1;\n    let mut nums2 = nums2;\n    nums1.sort();\n    nums2.sort();\n    let mut res = Vec::new();\n    let mut i = nums1.len() as isize - 1;\n    let mut j = nums2.len() as isize - 1;\n    while N > 0 {\n        if nums1[i as usize] * nums2[j as usize] > nums1[i as usize] * nums2[(j - 1) as usize] {\n            res.push(nums1[i as usize] * nums2[j as usize]);\n            j -= 1;\n        } else {\n            res.push(nums1[i as usize] * nums2[j as usize]);\n            i -= 1;\n        }\n        N -= 1;\n    }\n    res",
    "    let mut nums1 = nums1;\n    let mut nums2 = nums2;\n    nums1.sort();\n    nums2.sort();\n    let mut res = vec![];\n    let mut i = nums1.len() - 1;\n    let mut j = nums2.len() - 1;\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            res.push(nums1[i] * nums2[j]);\n            i -= 1;\n        } else {\n            res.push(nums1[i] * nums2[j]);\n            j -= 1;\n        }\n        N -= 1;\n    }\n    res",
    "    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(nums1[i] * nums2[j]);\n            if heap.len() > N as usize {\n                heap.pop();\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n    res",
    "    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    let mut visited = HashSet::new();\n    heap.push(State {\n        i: 0,\n        j: 0,\n        val: nums1[0] * nums2[0],\n    });\n    visited.insert((0, 0));\n    while res.len() < N as usize {\n        let state = heap.pop().unwrap();\n        res.push(state.val);\n        if state.i + 1 < nums1.len() && !visited.contains(&(state.i + 1, state.j)) {\n            heap.push(State {\n                i: state.i + 1,\n                j: state.j,\n                val: nums1[state.i + 1] * nums2[state.j],\n            });\n            visited.insert((state.i + 1, state.j));\n        }\n        if state.j + 1 < nums2.len() && !visited.contains(&(state.i, state.j + 1)) {\n            heap.push(State {\n                i: state.i,\n                j: state.j + 1,\n                val: nums1[state.i] * nums2[state.j + 1],\n            });\n            visited.insert((state.i, state.j + 1));\n        }\n    }\n    res",
    "    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let product = nums1[i] * nums2[j];\n            if heap.len() < N as usize {\n                heap.push(product);\n            } else {\n                if product > heap.peek().unwrap() {\n                    heap.pop();\n                    heap.push(product);\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n    res",
    "    let mut nums1 = nums1;\n    let mut nums2 = nums2;\n    nums1.sort();\n    nums2.sort();\n    let mut result = Vec::new();\n    let mut i = nums1.len() - 1;\n    let mut j = nums2.len() - 1;\n    let mut k = N - 1;\n    while k >= 0 {\n        if i < 0 || j < 0 {\n            break;\n        }\n        result.push(nums1[i] * nums2[j]);\n        if nums1[i] > nums2[j] {\n            i -= 1;\n        } else {\n            j -= 1;\n        }\n        k -= 1;\n    }\n    result",
    "    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(nums1[i] * nums2[j]);\n            if heap.len() > N as usize {\n                heap.pop();\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n    res",
    "    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(nums1[i] * nums2[j]);\n            if heap.len() > N as usize {\n                heap.pop();\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap());\n    }\n    res.reverse();\n    res",
    "    let mut nums1 = nums1;\n    nums1.sort();\n    let mut nums2 = nums2;\n    nums2.sort();\n    let mut res = Vec::new();\n    let mut i = nums1.len() as isize - 1;\n    let mut j = nums2.len() as isize - 1;\n    while N > 0 {\n        if nums1[i as usize] * nums2[j as usize] > nums1[i as usize] * nums2[(j - 1) as usize] {\n            res.push(nums1[i as usize] * nums2[j as usize]);\n            j -= 1;\n        } else {\n            res.push(nums1[i as usize] * nums2[(j - 1) as usize]);\n            i -= 1;\n        }\n        N -= 1;\n    }\n    res",
    "    let mut res = Vec::new();\n    let mut nums1 = nums1.clone();\n    let mut nums2 = nums2.clone();\n    nums1.sort();\n    nums2.sort();\n    let mut i = nums1.len() - 1;\n    let mut j = nums2.len() - 1;\n    while N > 0 {\n        if nums1[i] > nums2[j] {\n            res.push(nums1[i] * nums2[j]);\n            i -= 1;\n        } else {\n            res.push(nums1[i] * nums2[j]);\n            j -= 1;\n        }\n        N -= 1;\n    }\n    res",
    "    let mut products = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            products.push(nums1[i] * nums2[j]);\n        }\n    }\n    products.sort();\n    products.reverse();\n    products[0..N as usize].to_vec()"
  ]
}