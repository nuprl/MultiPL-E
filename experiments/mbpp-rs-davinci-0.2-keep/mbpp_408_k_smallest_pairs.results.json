{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "rs",
  "prompt": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| a[0].cmp(&b[0]));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 2], [3, 4], [3, 6], [7, 2]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmpg3cxx1v0.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, i, j)));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 > sum {\n                    heap.pop();\n                    heap.push(Reverse((sum, i, j)));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse((sum, i, j)) = heap.pop().unwrap();\n        result.push(vec![nums1[i], nums2[j]]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpc70_4ygr.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpc70_4ygr.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, i, j)));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpc70_4ygr.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, i, j)));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpc70_4ygr.rs:20:13\n   |\n20 |         let Reverse((sum, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, nums1[i], nums2[j])));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 > sum {\n                    heap.pop();\n                    heap.push(Reverse((sum, nums1[i], nums2[j])));\n                }\n            }\n        }\n    }\n    for item in heap {\n        result.push(vec![item.1, item.2]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpbydllvv5.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpbydllvv5.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, nums1[i], nums2[j])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpbydllvv5.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, nums1[i], nums2[j])));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    let mut res = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < nums1.len() && j < nums2.len() {\n        heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        if i == nums1.len() - 1 {\n            j += 1;\n        } else if j == nums2.len() - 1 {\n            i += 1;\n        } else {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i += 1;\n            } else {\n                j += 1;\n            }\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let (sum, i, j) = heap.pop().unwrap().0;\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpygjhhr2w.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpygjhhr2w.rs:8:19\n  |\n8 |         heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut count = 0;\n    while count < k && !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        count += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_b495vug.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp_b495vug.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_b495vug.rs:12:13\n   |\n12 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push((-sum, (i, j)));\n            } else {\n                if sum < -heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push((-sum, (i, j)));\n                }\n            }\n        }\n    }\n    while let Some((_, (i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpgbjmhp3y.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let Reverse((_, i, j)) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpr_8rfmh8.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpr_8rfmh8.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpr_8rfmh8.rs:11:13\n   |\n11 |         let Reverse((_, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            index1: i,\n            index2: 0,\n        });\n    }\n    while k > 0 && !heap.is_empty() {\n        let pair = heap.pop().unwrap();\n        res.push(vec![nums1[pair.index1], nums2[pair.index2]]);\n        if pair.index2 < nums2.len() - 1 {\n            heap.push(Pair {\n                sum: nums1[pair.index1] + nums2[pair.index2 + 1],\n                index1: pair.index1,\n                index2: pair.index2 + 1,\n            });\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpm7s5lu1v.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmpm7s5lu1v.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpm7s5lu1v.rs:19:23\n   |\n19 |             heap.push(Pair {\n   |                       ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], nums1[i], nums2[j]));\n        }\n    }\n    for _ in 0..k {\n        if let Some(x) = heap.pop() {\n            res.push(vec![x.1, x.2]);\n        } else {\n            break;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpe0n4nep2.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpe0n4nep2.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            let pair = vec![nums1[i], nums2[j]];\n            if heap.len() < k as usize {\n                heap.push((-sum, pair));\n            } else {\n                if sum > -heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push((-sum, pair));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap().1);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0ll9cewn.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < nums1.len() && j < nums2.len() && res.len() < k as usize {\n        let mut tmp = vec![nums1[i], nums2[j]];\n        if i + 1 < nums1.len() && j + 1 < nums2.len() {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i += 1;\n            } else {\n                j += 1;\n            }\n        } else if i + 1 < nums1.len() {\n            i += 1;\n        } else {\n            j += 1;\n        }\n        res.push(tmp);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 6], [7, 6]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmpcmrc592v.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.iter().take(k as usize).map(|v| v.to_vec()).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n        }\n    }\n    let mut count = 0;\n    while count < k && !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        count += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp1swmzb3m.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp1swmzb3m.rs:8:23\n  |\n8 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp1swmzb3m.rs:13:13\n   |\n13 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 > sum {\n                    heap.pop();\n                    heap.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        result.push(vec![nums1[i], nums2[j]]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp71odcog4.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp71odcog4.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp71odcog4.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, (i, j))));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp71odcog4.rs:20:13\n   |\n20 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else if let Some(Reverse(x)) = heap.peek() {\n                if sum < *x {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while let Some(Reverse(x)) = heap.pop() {\n        res.push(vec![x]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpjhclvkmt.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpjhclvkmt.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjhclvkmt.rs:10:32\n   |\n10 |             } else if let Some(Reverse(x)) = heap.peek() {\n   |                                ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjhclvkmt.rs:13:31\n   |\n13 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjhclvkmt.rs:18:20\n   |\n18 |     while let Some(Reverse(x)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse((sum, (i, j))));\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpeozl8xv0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpeozl8xv0.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpeozl8xv0.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, (i, j))));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpeozl8xv0.rs:16:20\n   |\n16 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                let top = heap.peek().unwrap();\n                if sum < top.0 {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair = Vec::new();\n        pair.push(sum / 10);\n        pair.push(sum % 10);\n        result.push(pair);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp5u96rgau.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp5u96rgau.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp5u96rgau.rs:14:31\n   |\n14 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp5u96rgau.rs:19:20\n   |\n19 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if pq.len() < k as usize {\n                pq.push(Reverse((sum, (i, j))));\n            } else {\n                if sum < pq.peek().unwrap().0 {\n                    pq.pop();\n                    pq.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    while !pq.is_empty() {\n        let (sum, (i, j)) = pq.pop().unwrap().0;\n        result.push(vec![nums1[i], nums2[j]]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpe52hfo_k.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpe52hfo_k.rs:9:25\n  |\n9 |                 pq.push(Reverse((sum, (i, j))));\n  |                         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpe52hfo_k.rs:13:29\n   |\n13 |                     pq.push(Reverse((sum, (i, j))));\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp8f7saq5q.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp8f7saq5q.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp8f7saq5q.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut res = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpcay8djpb.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpcay8djpb.rs:6:23\n  |\n6 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpcay8djpb.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpxi0z6mtx.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpxi0z6mtx.rs:8:23\n  |\n8 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpxi0z6mtx.rs:12:21\n   |\n12 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse(sum));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair = vec![];\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    result.push(pair);\n                    break;\n                }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpdfx0j3k2.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpdfx0j3k2.rs:8:23\n  |\n8 |             heap.push(Reverse(sum));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpdfx0j3k2.rs:14:20\n   |\n14 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp8f7saq5q.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp8f7saq5q.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp8f7saq5q.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    let mut res = Vec::new();\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpnp5rfy7t.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpnp5rfy7t.rs:7:23\n  |\n7 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpnp5rfy7t.rs:14:20\n   |\n14 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse(sum));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair = Vec::new();\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    res.push(pair);\n                    break;\n                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpiju43409.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpiju43409.rs:8:23\n  |\n8 |             heap.push(Reverse(sum));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpiju43409.rs:14:20\n   |\n14 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp2y4z6z01.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp2y4z6z01.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp2y4z6z01.rs:13:31\n   |\n13 |                     heap.push(Reverse((sum, (i, j))));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp2y4z6z01.rs:19:13\n   |\n19 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut result = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpqw9q_wns.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpqw9q_wns.rs:6:23\n  |\n6 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpqw9q_wns.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, i, j)));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse((sum, i, j)));\n            }\n        }\n    }\n    while let Some(Reverse((_, i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp1usf8k66.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp1usf8k66.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, i, j)));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp1usf8k66.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, i, j)));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp1usf8k66.rs:16:20\n   |\n16 |     while let Some(Reverse((_, i, j))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                let top = heap.peek().unwrap();\n                if sum < top.0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse((sum, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpidrcs_pm.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpidrcs_pm.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpidrcs_pm.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, (i, j))));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpidrcs_pm.rs:20:13\n   |\n20 |         let Reverse((sum, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpewt9n300.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpewt9n300.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpewt9n300.rs:11:13\n   |\n11 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut pq: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    let mut visited: HashSet<(isize, isize)> = HashSet::new();\n\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return res;\n    }\n\n    pq.push((nums1[0] + nums2[0], 0, 0));\n    visited.insert((0, 0));\n\n    while !pq.is_empty() && res.len() < k as usize {\n        let (sum, i, j) = pq.pop().unwrap();\n        res.push(vec![nums1[i as usize], nums2[j as usize]]);\n\n        if i + 1 < nums1.len() as isize && !visited.contains(&(i + 1, j)) {\n            pq.push((nums1[(i + 1) as usize] + nums2[j as usize], i + 1, j));\n            visited.insert((i + 1, j));\n        }\n\n        if j + 1 < nums2.len() as isize && !visited.contains(&(i, j + 1)) {\n            pq.push((nums1[i as usize] + nums2[(j + 1) as usize], i, j + 1));\n            visited.insert((i, j + 1));\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpud6hezxq.rs:4:17\n  |\n4 |     let mut pq: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                 ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpud6hezxq.rs:4:53\n  |\n4 |     let mut pq: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                     ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0412]: cannot find type `HashSet` in this scope\n --> /tmp/tmpud6hezxq.rs:5:22\n  |\n5 |     let mut visited: HashSet<(isize, isize)> = HashSet::new();\n  |                      ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpud6hezxq.rs:5:48\n  |\n5 |     let mut visited: HashSet<(isize, isize)> = HashSet::new();\n  |                                                ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp8f7saq5q.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp8f7saq5q.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp8f7saq5q.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                let top = heap.peek().unwrap();\n                if sum < top.0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpekx4ohfz.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpekx4ohfz.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpekx4ohfz.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, (i, j))));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpekx4ohfz.rs:19:20\n   |\n19 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((sum, i, j))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpp61acbgl.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpp61acbgl.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpp61acbgl.rs:11:21\n   |\n11 |         if let Some(Reverse((sum, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Tuple(sum, i, j));\n            } else {\n                let top = heap.peek().unwrap();\n                if sum < top.0 {\n                    heap.pop();\n                    heap.push(Tuple(sum, i, j));\n                }\n            }\n        }\n    }\n    while let Some(Tuple(_, i, j)) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpopc_a0up.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Tuple` in this scope\n --> /tmp/tmpopc_a0up.rs:9:27\n  |\n9 |                 heap.push(Tuple(sum, i, j));\n  |                           ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Tuple` in this scope\n  --> /tmp/tmpopc_a0up.rs:14:31\n   |\n14 |                     heap.push(Tuple(sum, i, j));\n   |                               ^^^^^ not found in this scope\n\nerror[E0531]: cannot find tuple struct or tuple variant `Tuple` in this scope\n  --> /tmp/tmpopc_a0up.rs:19:20\n   |\n19 |     while let Some(Tuple(_, i, j)) = heap.pop() {\n   |                    ^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            let pair = vec![nums1[i], nums2[j]];\n            if heap.len() < k as usize {\n                heap.push((-sum, pair));\n            } else {\n                if -sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push((-sum, pair));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        result.push(heap.pop().unwrap().1);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0d_k_l8b.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse((sum, (i, j))));\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpjwyrp91v.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpjwyrp91v.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjwyrp91v.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, (i, j))));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjwyrp91v.rs:16:20\n   |\n16 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse(sum));\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        let mut pair: Vec<isize> = Vec::new();\n        pair.push(sum);\n        pair.push(sum);\n        res.push(pair);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpywe8jfsz.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpywe8jfsz.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpywe8jfsz.rs:12:27\n   |\n12 |                 heap.push(Reverse(sum));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpywe8jfsz.rs:17:13\n   |\n17 |         let Reverse(sum) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut pq = BinaryHeap::new();\n    let mut visited = HashSet::new();\n    if nums1.len() == 0 || nums2.len() == 0 || k == 0 {\n        return res;\n    }\n    pq.push(Reverse((nums1[0] + nums2[0], 0, 0)));\n    visited.insert((0, 0));\n    while k > 0 && !pq.is_empty() {\n        let Reverse((sum, i, j)) = pq.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n        if i + 1 < nums1.len() && !visited.contains(&(i + 1, j)) {\n            pq.push(Reverse((nums1[i + 1] + nums2[j], i + 1, j)));\n            visited.insert((i + 1, j));\n        }\n        if j + 1 < nums2.len() && !visited.contains(&(i, j + 1)) {\n            pq.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\n            visited.insert((i, j + 1));\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_hkdoh7s.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp_hkdoh7s.rs:5:23\n  |\n5 |     let mut visited = HashSet::new();\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp_hkdoh7s.rs:9:13\n  |\n9 |     pq.push(Reverse((nums1[0] + nums2[0], 0, 0)));\n  |             ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_hkdoh7s.rs:12:13\n   |\n12 |         let Reverse((sum, i, j)) = pq.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_hkdoh7s.rs:16:21\n   |\n16 |             pq.push(Reverse((nums1[i + 1] + nums2[j], i + 1, j)));\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_hkdoh7s.rs:20:21\n   |\n20 |             pq.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            let pair = vec![nums1[i], nums2[j]];\n            if heap.len() < k as usize {\n                heap.push((sum, pair));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push((sum, pair));\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap().1);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpdjzqfz0a.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmptpt514th.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmptpt514th.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmptpt514th.rs:11:21\n   |\n11 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    let mut res = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp1x23ujap.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp1x23ujap.rs:8:23\n  |\n8 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp1x23ujap.rs:14:20\n   |\n14 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    if nums1.is_empty() || nums2.is_empty() {\n        return result;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            index1: i,\n            index2: 0,\n        });\n    }\n    for _ in 0..k {\n        if let Some(pair) = heap.pop() {\n            result.push(vec![nums1[pair.index1], nums2[pair.index2]]);\n            if pair.index2 + 1 < nums2.len() {\n                heap.push(Pair {\n                    sum: nums1[pair.index1] + nums2[pair.index2 + 1],\n                    index1: pair.index1,\n                    index2: pair.index2 + 1,\n                });\n            }\n        } else {\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpee13zgqm.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmpee13zgqm.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpee13zgqm.rs:19:27\n   |\n19 |                 heap.push(Pair {\n   |                           ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse(sum));\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        let mut pair = vec![];\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    res.push(pair);\n                    pair = vec![];\n                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpy1u6jmke.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpy1u6jmke.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpy1u6jmke.rs:12:27\n   |\n12 |                 heap.push(Reverse(sum));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpy1u6jmke.rs:17:13\n   |\n17 |         let Reverse(sum) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for num1 in nums1 {\n        for num2 in nums2.iter() {\n            pairs.push(vec![num1, *num2]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.iter().take(k as usize).map(|pair| pair.to_vec()).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, i, j)));\n            } else {\n                if let Some(Reverse((top, _, _))) = heap.peek() {\n                    if *top > sum {\n                        heap.pop();\n                        heap.push(Reverse((sum, i, j)));\n                    }\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp3b1rk60c.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp3b1rk60c.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, i, j)));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3b1rk60c.rs:11:29\n   |\n11 |                 if let Some(Reverse((top, _, _))) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3b1rk60c.rs:14:35\n   |\n14 |                         heap.push(Reverse((sum, i, j)));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3b1rk60c.rs:20:20\n   |\n20 |     while let Some(Reverse((_, i, j))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse((sum, (i, j))));\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpjwyrp91v.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpjwyrp91v.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjwyrp91v.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, (i, j))));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjwyrp91v.rs:16:20\n   |\n16 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        let mut pair = vec![];\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    result.push(pair);\n                    break;\n                }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp4rvqdnnb.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp4rvqdnnb.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4rvqdnnb.rs:13:31\n   |\n13 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4rvqdnnb.rs:19:13\n   |\n19 |         let Reverse(sum) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 > sum {\n                    heap.pop();\n                    heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap().1);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpdlwbeaa4.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpdlwbeaa4.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpdlwbeaa4.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = Vec::new();\n    let mut nums1 = nums1;\n    let mut nums2 = nums2;\n    nums1.sort();\n    nums2.sort();\n    let mut i = 0;\n    let mut j = 0;\n    while i < nums1.len() && j < nums2.len() && pairs.len() < k as usize {\n        pairs.push(vec![nums1[i], nums2[j]]);\n        if i + 1 < nums1.len() && nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 3', /tmp/tmphagvgfb7.rs:12:72\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpurcwlhix.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpurcwlhix.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpurcwlhix.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push((-sum, (i, j)));\n            } else {\n                if sum > -heap.peek().unwrap().0 {\n                    break;\n                } else {\n                    heap.pop();\n                    heap.push((-sum, (i, j)));\n                }\n            }\n        }\n    }\n    while let Some((_, (i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp38dgg2pk.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa_2wq1gg.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa_2wq1gg.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa_2wq1gg.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| a[0].cmp(&b[0]));\n    pairs.iter().take(k as usize).map(|v| v.to_vec()).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 2], [3, 4], [3, 6], [7, 2]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmp449mh0l_.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse((sum, (i, j))));\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpjwyrp91v.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpjwyrp91v.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjwyrp91v.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, (i, j))));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpjwyrp91v.rs:16:20\n   |\n16 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    let mut visited = HashSet::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return result;\n    }\n    heap.push(State {\n        i: 0,\n        j: 0,\n        sum: nums1[0] + nums2[0],\n    });\n    visited.insert((0, 0));\n    while heap.len() > 0 && result.len() < k as usize {\n        let state = heap.pop().unwrap();\n        result.push(vec![nums1[state.i as usize], nums2[state.j as usize]]);\n        if state.i + 1 < nums1.len() as isize && !visited.contains(&(state.i + 1, state.j)) {\n            heap.push(State {\n                i: state.i + 1,\n                j: state.j,\n                sum: nums1[(state.i + 1) as usize] + nums2[state.j as usize],\n            });\n            visited.insert((state.i + 1, state.j));\n        }\n        if state.j + 1 < nums2.len() as isize && !visited.contains(&(state.i, state.j + 1)) {\n            heap.push(State {\n                i: state.i,\n                j: state.j + 1,\n                sum: nums1[state.i as usize] + nums2[(state.j + 1) as usize],\n            });\n            visited.insert((state.i, state.j + 1));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpy8sownac.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmpy8sownac.rs:5:23\n  |\n5 |     let mut visited = HashSet::new();\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `State` in this scope\n --> /tmp/tmpy8sownac.rs:9:15\n  |\n9 |     heap.push(State {\n  |               ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `State` in this scope\n  --> /tmp/tmpy8sownac.rs:19:23\n   |\n19 |             heap.push(State {\n   |                       ^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `State` in this scope\n  --> /tmp/tmpy8sownac.rs:27:23\n   |\n27 |             heap.push(State {\n   |                       ^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmptpt514th.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmptpt514th.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmptpt514th.rs:11:21\n   |\n11 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    let mut res = Vec::new();\n    if nums1.len() == 0 || nums2.len() == 0 || k == 0 {\n        return res;\n    }\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            i: i,\n            j: 0,\n        });\n    }\n    while k > 0 && !heap.is_empty() {\n        let pair = heap.pop().unwrap();\n        res.push(vec![nums1[pair.i], nums2[pair.j]]);\n        if pair.j + 1 < nums2.len() {\n            heap.push(Pair {\n                sum: nums1[pair.i] + nums2[pair.j + 1],\n                i: pair.i,\n                j: pair.j + 1,\n            });\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmps1rubth7.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmps1rubth7.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmps1rubth7.rs:19:23\n   |\n19 |             heap.push(Pair {\n   |                       ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                if let Some(Reverse((s, _))) = heap.peek() {\n                    if *s > sum {\n                        heap.pop();\n                        heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                    }\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, v))) = heap.pop() {\n        res.push(v);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpitux5ov3.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpitux5ov3.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpitux5ov3.rs:11:29\n   |\n11 |                 if let Some(Reverse((s, _))) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpitux5ov3.rs:14:35\n   |\n14 |                         heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpitux5ov3.rs:20:20\n   |\n20 |     while let Some(Reverse((_, v))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return res;\n    }\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            idx1: i,\n            idx2: 0,\n        });\n    }\n    while k > 0 && !heap.is_empty() {\n        let pair = heap.pop().unwrap();\n        res.push(vec![nums1[pair.idx1], nums2[pair.idx2]]);\n        if pair.idx2 < nums2.len() - 1 {\n            heap.push(Pair {\n                sum: nums1[pair.idx1] + nums2[pair.idx2 + 1],\n                idx1: pair.idx1,\n                idx2: pair.idx2 + 1,\n            });\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpp2scrv3z.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmpp2scrv3z.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpp2scrv3z.rs:19:23\n   |\n19 |             heap.push(Pair {\n   |                       ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                let Reverse(min) = heap.peek().unwrap();\n                if sum < min {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        result.push(vec![sum, sum]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpldp86biy.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpldp86biy.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpldp86biy.rs:11:21\n   |\n11 |                 let Reverse(min) = heap.peek().unwrap();\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpldp86biy.rs:14:31\n   |\n14 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpldp86biy.rs:20:13\n   |\n20 |         let Reverse(sum) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            index1: i,\n            index2: 0,\n        });\n    }\n    while k > 0 && !heap.is_empty() {\n        let pair = heap.pop().unwrap();\n        res.push(vec![nums1[pair.index1], nums2[pair.index2]]);\n        if pair.index2 < nums2.len() - 1 {\n            heap.push(Pair {\n                sum: nums1[pair.index1] + nums2[pair.index2 + 1],\n                index1: pair.index1,\n                index2: pair.index2 + 1,\n            });\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpm7s5lu1v.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmpm7s5lu1v.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpm7s5lu1v.rs:19:23\n   |\n19 |             heap.push(Pair {\n   |                       ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut count = 0;\n    while !heap.is_empty() && count < k {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        count += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpux0cykd5.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpux0cykd5.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpux0cykd5.rs:12:13\n   |\n12 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut count = 0;\n    while count < k && !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        count += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpt9g1onln.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpt9g1onln.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpt9g1onln.rs:12:13\n   |\n12 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| a[0].cmp(&b[0]));\n    pairs.iter().take(k as usize).cloned().collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 2], [3, 4], [3, 6], [7, 2]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmp4_yia6se.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp8f7saq5q.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp8f7saq5q.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp8f7saq5q.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpijrpimfz.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpijrpimfz.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpijrpimfz.rs:11:13\n   |\n11 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if pq.len() < k as usize {\n                pq.push(Reverse((sum, nums1[i], nums2[j])));\n            } else {\n                let top = pq.peek().unwrap();\n                if sum < top.0 {\n                    pq.pop();\n                    pq.push(Reverse((sum, nums1[i], nums2[j])));\n                }\n            }\n        }\n    }\n    while !pq.is_empty() {\n        let Reverse((_, a, b)) = pq.pop().unwrap();\n        res.push(vec![a, b]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmps2sjrp_q.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmps2sjrp_q.rs:9:25\n  |\n9 |                 pq.push(Reverse((sum, nums1[i], nums2[j])));\n  |                         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmps2sjrp_q.rs:14:29\n   |\n14 |                     pq.push(Reverse((sum, nums1[i], nums2[j])));\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmps2sjrp_q.rs:20:13\n   |\n20 |         let Reverse((_, a, b)) = pq.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], i, j));\n        }\n    }\n    for _ in 0..k {\n        if let Some((_, i, j)) = heap.pop() {\n            res.push(vec![nums1[i as usize], nums2[j as usize]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmphtyhdnsh.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmphtyhdnsh.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    let mut res = Vec::new();\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpnp5rfy7t.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpnp5rfy7t.rs:7:23\n  |\n7 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpnp5rfy7t.rs:14:20\n   |\n14 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse(sum));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair = Vec::new();\n        pair.push(sum - nums2[0]);\n        pair.push(nums2[0]);\n        result.push(pair);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp2gvarwsi.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp2gvarwsi.rs:8:23\n  |\n8 |             heap.push(Reverse(sum));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp2gvarwsi.rs:14:20\n   |\n14 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            let pair = vec![nums1[i], nums2[j]];\n            if heap.len() < k as usize {\n                heap.push((-sum, pair));\n            } else if -sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push((-sum, pair));\n            }\n        }\n    }\n    for (_, pair) in heap {\n        result.push(pair);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpst915pjj.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpbd2i7xz2.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpbd2i7xz2.rs:8:23\n  |\n8 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpbd2i7xz2.rs:14:20\n   |\n14 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if pq.len() < k as usize {\n                pq.push(Tuple(sum, (i, j)));\n            } else if sum < pq.peek().unwrap().0 {\n                pq.pop();\n                pq.push(Tuple(sum, (i, j)));\n            }\n        }\n    }\n    while !pq.is_empty() {\n        let Tuple(_, (i, j)) = pq.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp7xge9oi_.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Tuple` in this scope\n --> /tmp/tmp7xge9oi_.rs:9:25\n  |\n9 |                 pq.push(Tuple(sum, (i, j)));\n  |                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Tuple` in this scope\n  --> /tmp/tmp7xge9oi_.rs:12:25\n   |\n12 |                 pq.push(Tuple(sum, (i, j)));\n   |                         ^^^^^ not found in this scope\n\nerror[E0531]: cannot find tuple struct or tuple variant `Tuple` in this scope\n  --> /tmp/tmp7xge9oi_.rs:17:13\n   |\n17 |         let Tuple(_, (i, j)) = pq.pop().unwrap();\n   |             ^^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    if nums1.is_empty() || nums2.is_empty() {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            i,\n            j: 0,\n        });\n    }\n    for _ in 0..k {\n        if let Some(Pair { sum, i, j }) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n            if j + 1 < nums2.len() {\n                heap.push(Pair {\n                    sum: nums1[i] + nums2[j + 1],\n                    i,\n                    j: j + 1,\n                });\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpq5nvnd5d.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmpq5nvnd5d.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpq5nvnd5d.rs:16:21\n   |\n16 |         if let Some(Pair { sum, i, j }) = heap.pop() {\n   |                     ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpq5nvnd5d.rs:19:27\n   |\n19 |                 heap.push(Pair {\n   |                           ^^^^ not found in this scope\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse((sum, (i, j))));\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse((sum, (i, j))) = heap.pop().unwrap();\n        result.push(vec![nums1[i], nums2[j]]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpr6ae_8t2.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpr6ae_8t2.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpr6ae_8t2.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, (i, j))));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpr6ae_8t2.rs:17:13\n   |\n17 |         let Reverse((sum, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    if nums1.is_empty() || nums2.is_empty() {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            index1: i,\n            index2: 0,\n        });\n    }\n    for _ in 0..k {\n        if let Some(pair) = heap.pop() {\n            res.push(vec![nums1[pair.index1], nums2[pair.index2]]);\n            if pair.index2 + 1 < nums2.len() {\n                heap.push(Pair {\n                    sum: nums1[pair.index1] + nums2[pair.index2 + 1],\n                    index1: pair.index1,\n                    index2: pair.index2 + 1,\n                });\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpu3rccry8.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmpu3rccry8.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpu3rccry8.rs:19:27\n   |\n19 |                 heap.push(Pair {\n   |                           ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                if let Some(Reverse((_, (i1, j1)))) = heap.peek() {\n                    if sum < nums1[*i1] + nums2[*j1] {\n                        heap.pop();\n                        heap.push(Reverse((sum, (i, j))));\n                    }\n                }\n            }\n        }\n    }\n    let mut res = vec![];\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpwkyfmj6w.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpwkyfmj6w.rs:8:27\n  |\n8 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpwkyfmj6w.rs:10:29\n   |\n10 |                 if let Some(Reverse((_, (i1, j1)))) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpwkyfmj6w.rs:13:35\n   |\n13 |                         heap.push(Reverse((sum, (i, j))));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpwkyfmj6w.rs:20:20\n   |\n20 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], i, j));\n        }\n    }\n    for _ in 0..k {\n        if let Some(t) = heap.pop() {\n            res.push(vec![nums1[t.1], nums2[t.2]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmphk94mws4.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmphk94mws4.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return result;\n    }\n\n    for i in 0..nums1.len() {\n        heap.push((nums1[i] + nums2[0], nums1[i], 0));\n    }\n\n    while k > 0 && !heap.is_empty() {\n        let (sum, num1, num2) = heap.pop().unwrap();\n        result.push(vec![num1, nums2[num2 as usize]]);\n        if num2 + 1 < nums2.len() as isize {\n            heap.push((num1 + nums2[(num2 + 1) as usize], num1, num2 + 1));\n        }\n        k -= 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpk8wf3ufl.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpk8wf3ufl.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pq.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    while k > 0 && !pq.is_empty() {\n        let Reverse((_, (i, j))) = pq.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmppn48ifik.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmppn48ifik.rs:7:21\n  |\n7 |             pq.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmppn48ifik.rs:11:13\n   |\n11 |         let Reverse((_, (i, j))) = pq.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if let Some(Reverse(x)) = heap.peek() {\n                    if sum < *x {\n                        heap.pop();\n                        heap.push(Reverse(sum));\n                    }\n                }\n            }\n        }\n    }\n    while let Some(Reverse(x)) = heap.pop() {\n        result.push(vec![x, x]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpiccf27p2.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpiccf27p2.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpiccf27p2.rs:11:29\n   |\n11 |                 if let Some(Reverse(x)) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpiccf27p2.rs:14:35\n   |\n14 |                         heap.push(Reverse(sum));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpiccf27p2.rs:20:20\n   |\n20 |     while let Some(Reverse(x)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpxlz097_r.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpxlz097_r.rs:8:23\n  |\n8 |             heap.push(Reverse((sum, i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpxlz097_r.rs:12:21\n   |\n12 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if heap.peek().unwrap().0 > sum {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair = Vec::new();\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    res.push(pair);\n                    break;\n                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmppm87mshi.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmppm87mshi.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmppm87mshi.rs:13:31\n   |\n13 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmppm87mshi.rs:18:20\n   |\n18 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    for i in heap {\n        res.push(vec![nums1[i.1.0], nums2[i.1.1]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpnb9td5ng.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpnb9td5ng.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpnb9td5ng.rs:13:31\n   |\n13 |                     heap.push(Reverse((sum, (i, j))));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 < sum {\n                    break;\n                } else {\n                    heap.pop();\n                    heap.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpa8theywi.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpa8theywi.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa8theywi.rs:16:31\n   |\n16 |                     heap.push(Reverse((sum, (i, j))));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpa8theywi.rs:21:20\n   |\n21 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], i, j));\n        }\n    }\n    for _ in 0..k {\n        if let Some((_, i, j)) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpmwpdelpf.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = vec![];\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                let top = heap.peek().unwrap().0;\n                if top.0 > sum {\n                    heap.pop();\n                    heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                }\n            }\n        }\n    }\n    for i in heap {\n        res.push(i.0.1);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpchwsg_wu.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpchwsg_wu.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpchwsg_wu.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push((sum, (i, j)));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push((sum, (i, j)));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let (_, (i, j)) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpnd34_x56.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], (i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(x) = heap.pop() {\n            res.push(vec![nums1[x.1.0], nums2[x.1.1]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmphmg65r2h.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                }\n            }\n        }\n    }\n    for i in heap {\n        res.push(i.1);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpm5jw46x6.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpm5jw46x6.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpm5jw46x6.rs:13:31\n   |\n13 |                     heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                if let Some(Reverse((s, _))) = heap.peek() {\n                    if sum < *s {\n                        heap.pop();\n                        heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                    }\n                }\n            }\n        }\n    }\n    for Reverse((_, v)) in heap {\n        res.push(v);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp6npxrlvc.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp6npxrlvc.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp6npxrlvc.rs:11:29\n   |\n11 |                 if let Some(Reverse((s, _))) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp6npxrlvc.rs:14:35\n   |\n14 |                         heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp6npxrlvc.rs:20:9\n   |\n20 |     for Reverse((_, v)) in heap {\n   |         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    let mut result = Vec::new();\n    let mut visited = HashSet::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut count = 0;\n    while count < k {\n        let sum = nums1[i] + nums2[j];\n        if !visited.contains(&(i, j)) {\n            heap.push((-sum, (i, j)));\n            visited.insert((i, j));\n        }\n        if i < nums1.len() - 1 {\n            i += 1;\n        } else {\n            j += 1;\n        }\n        count += 1;\n    }\n    while let Some((_, (i, j))) = heap.pop() {\n        result.push(vec![nums1[i], nums2[j]]);\n        if i < nums1.len() - 1 {\n            i += 1;\n        } else {\n            j += 1;\n        }\n        if !visited.contains(&(i, j)) {\n            heap.push((-nums1[i] - nums2[j], (i, j)));\n            visited.insert((i, j));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_as7l_sv.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp_as7l_sv.rs:5:23\n  |\n5 |     let mut visited = HashSet::new();\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], i as isize, j as isize));\n        }\n    }\n    for _ in 0..k {\n        if let Some((_, i, j)) = heap.pop() {\n            res.push(vec![nums1[i as usize], nums2[j as usize]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpc7tj3j__.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpc7tj3j__.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((sum, i, j))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmptan95m0d.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmptan95m0d.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmptan95m0d.rs:11:21\n   |\n11 |         if let Some(Reverse((sum, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpc_bdlmdf.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpc_bdlmdf.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpc_bdlmdf.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for n1 in &nums1 {\n        for n2 in &nums2 {\n            pairs.push(vec![*n1, *n2]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    if nums1.is_empty() || nums2.is_empty() {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        let mut pair = Vec::new();\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    res.push(pair);\n                    pair = Vec::new();\n                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpwoiv4ovc.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpwoiv4ovc.rs:12:27\n   |\n12 |                 heap.push(Reverse(sum));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpwoiv4ovc.rs:16:31\n   |\n16 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpwoiv4ovc.rs:22:13\n   |\n22 |         let Reverse(sum) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut ret = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            ret.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpv0lo962q.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpv0lo962q.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpv0lo962q.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmplh2uamkh.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmplh2uamkh.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmplh2uamkh.rs:11:21\n   |\n11 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut count = 0;\n    while count < k && !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        count += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_b495vug.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp_b495vug.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_b495vug.rs:12:13\n   |\n12 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            let pair = vec![nums1[i], nums2[j]];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, pair)));\n            } else {\n                let top = heap.peek().unwrap();\n                if sum < top.0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, pair)));\n                }\n            }\n        }\n    }\n    for i in heap {\n        res.push(i.1);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp6uyur7o2.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp6uyur7o2.rs:10:27\n   |\n10 |                 heap.push(Reverse((sum, pair)));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp6uyur7o2.rs:15:31\n   |\n15 |                     heap.push(Reverse((sum, pair)));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse(sum));\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        res.push(vec![sum, sum]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmptctybq12.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmptctybq12.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmptctybq12.rs:12:27\n   |\n12 |                 heap.push(Reverse(sum));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmptctybq12.rs:17:13\n   |\n17 |         let Reverse(sum) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut res = vec![];\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpijoviqxd.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpijoviqxd.rs:6:23\n  |\n6 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpijoviqxd.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp4qr_4s90.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp4qr_4s90.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4qr_4s90.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let (_, (i, j)) = heap.pop().unwrap().0;\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpvzmitqg1.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpvzmitqg1.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut result = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpqw9q_wns.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpqw9q_wns.rs:6:23\n  |\n6 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpqw9q_wns.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let Reverse((_, i, j)) = heap.pop().unwrap();\n        result.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_3lh3b0u.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp_3lh3b0u.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_3lh3b0u.rs:11:13\n   |\n11 |         let Reverse((_, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse(sum));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        let mut pair = Vec::new();\n        pair.push(sum);\n        pair.push(sum);\n        result.push(pair);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpyjv6qr6m.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpyjv6qr6m.rs:8:23\n  |\n8 |             heap.push(Reverse(sum));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpyjv6qr6m.rs:15:13\n   |\n15 |         let Reverse(sum) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmptpt514th.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmptpt514th.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmptpt514th.rs:11:21\n   |\n11 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpsp6a8r5b.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpsp6a8r5b.rs:8:23\n  |\n8 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpsp6a8r5b.rs:12:21\n   |\n12 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmptpt514th.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmptpt514th.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmptpt514th.rs:11:21\n   |\n11 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pq.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = pq.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpf4554c1u.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpf4554c1u.rs:7:21\n  |\n7 |             pq.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                     ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpf4554c1u.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = pq.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse(sum));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair: Vec<isize> = Vec::new();\n        pair.push(sum);\n        pair.push(sum);\n        res.push(pair);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpde9wnj97.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpde9wnj97.rs:8:23\n  |\n8 |             heap.push(Reverse(sum));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpde9wnj97.rs:14:20\n   |\n14 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    for i in 0..heap.len() {\n        let sum = heap.pop().unwrap().0;\n        let mut temp = Vec::new();\n        temp.push(sum);\n        res.push(temp);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp28va18sp.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp28va18sp.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp28va18sp.rs:13:31\n   |\n13 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpxi0z6mtx.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpxi0z6mtx.rs:8:23\n  |\n8 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpxi0z6mtx.rs:12:21\n   |\n12 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], nums1[i], nums2[j]));\n        }\n    }\n    let mut count = 0;\n    while count < k && !heap.is_empty() {\n        let (sum, num1, num2) = heap.pop().unwrap();\n        res.push(vec![num1, num2]);\n        count += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpxx3w2ufg.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpxx3w2ufg.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push((nums1[i] + nums2[0], i, 0));\n    }\n    while k > 0 && !heap.is_empty() {\n        let (sum, i, j) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        if j + 1 < nums2.len() {\n            heap.push((nums1[i] + nums2[j + 1], i, j + 1));\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpatdaunan.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpatdaunan.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 > sum {\n                    heap.pop();\n                    heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, v))) = heap.pop() {\n        res.push(v);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmphw8061uj.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmphw8061uj.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmphw8061uj.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmphw8061uj.rs:19:20\n   |\n19 |     while let Some(Reverse((_, v))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp8f7saq5q.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp8f7saq5q.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp8f7saq5q.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let Reverse((_, i, j)) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpr_8rfmh8.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpr_8rfmh8.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpr_8rfmh8.rs:11:13\n   |\n11 |         let Reverse((_, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| a[0].cmp(&b[0]).then(a[1].cmp(&b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 2], [3, 4], [3, 6], [7, 2]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmp00vz3i_d.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse(sum));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair = Vec::new();\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    res.push(pair);\n                    break;\n                }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpzh_g3vxr.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpzh_g3vxr.rs:8:23\n  |\n8 |             heap.push(Reverse(sum));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpzh_g3vxr.rs:14:20\n   |\n14 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if pq.len() < k as usize {\n                pq.push(Reverse((sum, (i, j))));\n            } else {\n                let (sum, (i, j)) = pq.peek().unwrap().0;\n                if sum > nums1[i] + nums2[j] {\n                    pq.pop();\n                    pq.push(Reverse((sum, (i, j))));\n                }\n            }\n        }\n    }\n    while let Some(Reverse((sum, (i, j)))) = pq.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpyp_k7ol0.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpyp_k7ol0.rs:9:25\n  |\n9 |                 pq.push(Reverse((sum, (i, j))));\n  |                         ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpyp_k7ol0.rs:14:29\n   |\n14 |                     pq.push(Reverse((sum, (i, j))));\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpyp_k7ol0.rs:19:20\n   |\n19 |     while let Some(Reverse((sum, (i, j)))) = pq.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut h = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            h.push(Reverse((sum, (i, j))));\n            if h.len() > k as usize {\n                h.pop();\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = h.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp3xi3cxj8.rs:4:17\n  |\n4 |     let mut h = BinaryHeap::new();\n  |                 ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp3xi3cxj8.rs:8:20\n  |\n8 |             h.push(Reverse((sum, (i, j))));\n  |                    ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3xi3cxj8.rs:14:20\n   |\n14 |     while let Some(Reverse((_, (i, j)))) = h.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                if let Some(Reverse((s, _))) = heap.peek() {\n                    if sum < *s {\n                        heap.pop();\n                        heap.push(Reverse((sum, (i, j))));\n                    }\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp3q52qh1x.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp3q52qh1x.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3q52qh1x.rs:11:29\n   |\n11 |                 if let Some(Reverse((s, _))) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3q52qh1x.rs:14:35\n   |\n14 |                         heap.push(Reverse((sum, (i, j))));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3q52qh1x.rs:20:20\n   |\n20 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp43jc5d12.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp43jc5d12.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp43jc5d12.rs:11:21\n   |\n11 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = vec![];\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if pq.len() < k as usize {\n                pq.push((-sum, (i, j)));\n            } else {\n                let (top_sum, _) = pq.peek().unwrap();\n                if *top_sum < -sum {\n                    break;\n                } else {\n                    pq.pop();\n                    pq.push((-sum, (i, j)));\n                }\n            }\n        }\n    }\n    while !pq.is_empty() {\n        let (_, (i, j)) = pq.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_t1d2bdm.rs:4:18\n  |\n4 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            index1: i,\n            index2: 0,\n        });\n    }\n    while k > 0 && !heap.is_empty() {\n        let pair = heap.pop().unwrap();\n        res.push(vec![nums1[pair.index1], nums2[pair.index2]]);\n        if pair.index2 + 1 < nums2.len() {\n            heap.push(Pair {\n                sum: nums1[pair.index1] + nums2[pair.index2 + 1],\n                index1: pair.index1,\n                index2: pair.index2 + 1,\n            });\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpkucj3dgj.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n --> /tmp/tmpkucj3dgj.rs:9:19\n  |\n9 |         heap.push(Pair {\n  |                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Pair` in this scope\n  --> /tmp/tmpkucj3dgj.rs:19:23\n   |\n19 |             heap.push(Pair {\n   |                       ^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0422, E0433.\nFor more information about an error, try `rustc --explain E0422`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                let top = heap.peek().unwrap();\n                if sum < top.0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        res.push(heap.pop().unwrap().1);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpkllhbtip.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpkllhbtip.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpkllhbtip.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0bwqm1w0.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0bwqm1w0.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0bwqm1w0.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut res = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpcay8djpb.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpcay8djpb.rs:6:23\n  |\n6 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpcay8djpb.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            let mut pair = vec![nums1[i], nums2[j]];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, pair)));\n            } else {\n                if let Some(Reverse((_, p))) = heap.peek() {\n                    if sum < *p {\n                        heap.pop();\n                        heap.push(Reverse((sum, pair)));\n                    }\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, p))) = heap.pop() {\n        res.push(p);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp4_qz2r21.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4_qz2r21.rs:10:27\n   |\n10 |                 heap.push(Reverse((sum, pair)));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4_qz2r21.rs:12:29\n   |\n12 |                 if let Some(Reverse((_, p))) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4_qz2r21.rs:15:35\n   |\n15 |                         heap.push(Reverse((sum, pair)));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4_qz2r21.rs:21:20\n   |\n21 |     while let Some(Reverse((_, p))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| a[0].cmp(&b[0]));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 2], [3, 4], [3, 6], [7, 2]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmpg3cxx1v0.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    while k > 0 && !heap.is_empty() {\n        let Reverse((_, i, j)) = heap.pop().unwrap();\n        result.push(vec![nums1[i], nums2[j]]);\n        k -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpyexj7b2j.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpyexj7b2j.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpyexj7b2j.rs:11:13\n   |\n11 |         let Reverse((_, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = vec![];\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.iter().take(k as usize).map(|x| x.to_vec()).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, i, j)));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse((sum, i, j)));\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse((sum, i, j)) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpy1gso592.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpy1gso592.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, i, j)));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpy1gso592.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, i, j)));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpy1gso592.rs:17:13\n   |\n17 |         let Reverse((sum, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse(nums1[i] + nums2[j]));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    let mut res = Vec::new();\n    while let Some(Reverse(sum)) = heap.pop() {\n        res.push(vec![sum]);\n    }\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpq6doj_m5.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpq6doj_m5.rs:6:23\n  |\n6 |             heap.push(Reverse(nums1[i] + nums2[j]));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpq6doj_m5.rs:13:20\n   |\n13 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push((-sum, (i, j)));\n            } else {\n                if sum < -heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push((-sum, (i, j)));\n                }\n            }\n        }\n    }\n    while let Some((_, (i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpgbjmhp3y.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    if nums1.is_empty() || nums2.is_empty() {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Reverse((nums1[i] + nums2[0], i, 0)));\n    }\n    while k > 0 && !heap.is_empty() {\n        let Reverse((sum, i, j)) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        if j + 1 < nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp4a15gmuh.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp4a15gmuh.rs:9:19\n  |\n9 |         heap.push(Reverse((nums1[i] + nums2[0], i, 0)));\n  |                   ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4a15gmuh.rs:12:13\n   |\n12 |         let Reverse((sum, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp4a15gmuh.rs:15:23\n   |\n15 |             heap.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\n   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = vec![];\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| a[0].cmp(&b[0]).then(a[1].cmp(&b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 2], [3, 4], [3, 6], [7, 2]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmpmw6fbkmc.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpurcwlhix.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpurcwlhix.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpurcwlhix.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n        }\n    }\n\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpvayn1o7t.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpvayn1o7t.rs:9:23\n  |\n9 |             heap.push(Reverse((sum, (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpvayn1o7t.rs:14:21\n   |\n14 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if let Some(Reverse(max)) = heap.peek() {\n                    if sum < *max {\n                        heap.pop();\n                        heap.push(Reverse(sum));\n                    }\n                }\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        result.push(vec![sum / 10, sum % 10]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp3e_s75ek.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp3e_s75ek.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3e_s75ek.rs:11:29\n   |\n11 |                 if let Some(Reverse(max)) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3e_s75ek.rs:14:35\n   |\n14 |                         heap.push(Reverse(sum));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp3e_s75ek.rs:20:20\n   |\n20 |     while let Some(Reverse(sum)) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if let Some(Reverse(x)) = heap.peek() {\n                    if sum < *x {\n                        heap.pop();\n                        heap.push(Reverse(sum));\n                    }\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        if let Some(Reverse(x)) = heap.pop() {\n            res.push(vec![x]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_53g4kox.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp_53g4kox.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_53g4kox.rs:11:29\n   |\n11 |                 if let Some(Reverse(x)) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_53g4kox.rs:14:35\n   |\n14 |                         heap.push(Reverse(sum));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_53g4kox.rs:21:21\n   |\n21 |         if let Some(Reverse(x)) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, usize, usize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push((nums1[i] + nums2[0], nums1[i], 0, i));\n    }\n    for _ in 0..k {\n        if let Some((_, num1, num2_index, num1_index)) = heap.pop() {\n            result.push(vec![num1, nums2[num2_index]]);\n            if num2_index + 1 < nums2.len() {\n                heap.push((num1 + nums2[num2_index + 1], num1, num2_index + 1, num1_index));\n            }\n        } else {\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpjwgpwd_w.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, usize, usize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpjwgpwd_w.rs:4:62\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, usize, usize)> = BinaryHeap::new();\n  |                                                              ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut visited = HashSet::new();\n    while res.len() < k as usize && !heap.is_empty() {\n        let Reverse((_, (i, j))) = heap.pop().unwrap();\n        if visited.contains(&(i, j)) {\n            continue;\n        }\n        res.push(vec![nums1[i], nums2[j]]);\n        visited.insert((i, j));\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpbndvz1ga.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpbndvz1ga.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpbndvz1ga.rs:10:23\n   |\n10 |     let mut visited = HashSet::new();\n   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpbndvz1ga.rs:12:13\n   |\n12 |         let Reverse((_, (i, j))) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else if sum < heap.peek().unwrap().0 {\n                heap.pop();\n                heap.push(Reverse(sum));\n            }\n        }\n    }\n    for i in 0..heap.len() {\n        let mut tmp = Vec::new();\n        tmp.push(heap.pop().unwrap().0);\n        tmp.push(heap.pop().unwrap().0);\n        res.push(tmp);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpcobyssfj.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpcobyssfj.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpcobyssfj.rs:12:27\n   |\n12 |                 heap.push(Reverse(sum));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut result = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpqw9q_wns.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpqw9q_wns.rs:6:23\n  |\n6 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpqw9q_wns.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    if nums1.is_empty() || nums2.is_empty() {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(nums1[i] + nums2[j]);\n        }\n    }\n    for _ in 0..k {\n        if let Some(x) = heap.pop() {\n            res.push(vec![x, x]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpmejn58g6.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], (i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some((_, (i, j))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpil62mk1u.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut res = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpcay8djpb.rs:3:20\n  |\n3 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpcay8djpb.rs:6:23\n  |\n6 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpcay8djpb.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    let mut visited = HashSet::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return res;\n    }\n    heap.push(Reverse((nums1[0] + nums2[0], 0, 0)));\n    visited.insert((0, 0));\n    while k > 0 && !heap.is_empty() {\n        let Reverse((sum, i, j)) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        if i + 1 < nums1.len() && !visited.contains(&(i + 1, j)) {\n            heap.push(Reverse((nums1[i + 1] + nums2[j], i + 1, j)));\n            visited.insert((i + 1, j));\n        }\n        if j + 1 < nums2.len() && !visited.contains(&(i, j + 1)) {\n            heap.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\n            visited.insert((i, j + 1));\n        }\n        k -= 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp_zs3eofk.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n --> /tmp/tmp_zs3eofk.rs:5:23\n  |\n5 |     let mut visited = HashSet::new();\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp_zs3eofk.rs:9:15\n  |\n9 |     heap.push(Reverse((nums1[0] + nums2[0], 0, 0)));\n  |               ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_zs3eofk.rs:12:13\n   |\n12 |         let Reverse((sum, i, j)) = heap.pop().unwrap();\n   |             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_zs3eofk.rs:15:23\n   |\n15 |             heap.push(Reverse((nums1[i + 1] + nums2[j], i + 1, j)));\n   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp_zs3eofk.rs:19:23\n   |\n19 |             heap.push(Reverse((nums1[i] + nums2[j + 1], i, j + 1)));\n   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if heap.peek().unwrap().0 > sum {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    for i in 0..heap.len() {\n        let mut tmp = Vec::new();\n        tmp.push(heap.pop().unwrap().0);\n        res.push(tmp);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp9ozar2gh.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp9ozar2gh.rs:9:27\n  |\n9 |                 heap.push(Reverse(sum));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp9ozar2gh.rs:13:31\n   |\n13 |                     heap.push(Reverse(sum));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], i, j));\n        }\n    }\n    for _ in 0..k {\n        if let Some(v) = heap.pop() {\n            result.push(vec![nums1[v.1 as usize], nums2[v.2 as usize]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0412]: cannot find type `BinaryHeap` in this scope\n --> /tmp/tmpra3iwncg.rs:4:19\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                   ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpra3iwncg.rs:4:55\n  |\n4 |     let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n  |                                                       ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor more information about an error, try `rustc --explain E0412`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 < sum {\n                    heap.pop();\n                    heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, v))) = heap.pop() {\n        result.push(v);\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp85ke3y95.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp85ke3y95.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp85ke3y95.rs:14:31\n   |\n14 |                     heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp85ke3y95.rs:19:20\n   |\n19 |     while let Some(Reverse((_, v))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs: Vec<Vec<isize>> = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    while i < nums1.len() && j < nums2.len() && pairs.len() < k as usize {\n        pairs.push(vec![nums1[i], nums2[j]]);\n        if i + 1 < nums1.len() && j + 1 < nums2.len() {\n            if nums1[i + 1] + nums2[j] < nums1[i] + nums2[j + 1] {\n                i += 1;\n            } else {\n                j += 1;\n            }\n        } else if i + 1 < nums1.len() {\n            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123084,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `[[1, 2], [1, 4], [1, 6], [3, 6], [7, 6]]`,\n right: `[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]`', /tmp/tmpwy6x3_2e.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, (i, j))));\n            } else {\n                if let Some(Reverse((top, _))) = heap.peek() {\n                    if sum < *top {\n                        heap.pop();\n                        heap.push(Reverse((sum, (i, j))));\n                    }\n                }\n            }\n        }\n    }\n    while let Some(Reverse((_, (i, j)))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp0gse7s6i.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp0gse7s6i.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, (i, j))));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0gse7s6i.rs:11:29\n   |\n11 |                 if let Some(Reverse((top, _))) = heap.peek() {\n   |                             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0gse7s6i.rs:14:35\n   |\n14 |                         heap.push(Reverse((sum, (i, j))));\n   |                                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp0gse7s6i.rs:20:20\n   |\n20 |     while let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res: Vec<Vec<isize>> = Vec::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return res;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, i, j)));\n            } else {\n                let top = heap.peek().unwrap();\n                if top.0 < sum {\n                    break;\n                } else {\n                    heap.pop();\n                    heap.push(Reverse((sum, i, j)));\n                }\n            }\n        }\n    }\n    while let Some(Reverse((sum, i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpqqghyps5.rs:7:20\n  |\n7 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpqqghyps5.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, i, j)));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpqqghyps5.rs:19:31\n   |\n19 |                     heap.push(Reverse((sum, i, j)));\n   |                               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpqqghyps5.rs:24:20\n   |\n24 |     while let Some(Reverse((sum, i, j))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.truncate(k as usize);\n    pairs\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.into_iter().take(k as usize).collect()\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1665510145,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, i, j))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp43jc5d12.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp43jc5d12.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp43jc5d12.rs:11:21\n   |\n11 |         if let Some(Reverse((_, i, j))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = vec![];\n    if nums1.is_empty() || nums2.is_empty() {\n        return res;\n    }\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pq.push((nums1[i] + nums2[j], (i, j)));\n        }\n    }\n    let mut count = 0;\n    while count < k && !pq.is_empty() {\n        let (sum, (i, j)) = pq.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n        count += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpbpminsl0.rs:7:18\n  |\n7 |     let mut pq = BinaryHeap::new();\n  |                  ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut result = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmp8f7saq5q.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmp8f7saq5q.rs:7:23\n  |\n7 |             heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n  |                       ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmp8f7saq5q.rs:11:21\n   |\n11 |         if let Some(Reverse((_, (i, j)))) = heap.pop() {\n   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, i, j)));\n            } else if sum < heap.peek().unwrap().0.0 {\n                heap.pop();\n                heap.push(Reverse((sum, i, j)));\n            }\n        }\n    }\n    while let Some(Reverse((_, i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res\n}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
      "timestamp": 1666123083,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `BinaryHeap`\n --> /tmp/tmpmdj6hhft.rs:4:20\n  |\n4 |     let mut heap = BinaryHeap::new();\n  |                    ^^^^^^^^^^ not found in this scope\n  |\nhelp: consider importing this struct\n  |\n1 | use std::collections::BinaryHeap;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n --> /tmp/tmpmdj6hhft.rs:9:27\n  |\n9 |                 heap.push(Reverse((sum, i, j)));\n  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider importing this tuple struct\n  |\n1 | use std::cmp::Reverse;\n  |\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpmdj6hhft.rs:12:27\n   |\n12 |                 heap.push(Reverse((sum, i, j)));\n   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror[E0531]: cannot find tuple struct or tuple variant `Reverse` in this scope\n  --> /tmp/tmpmdj6hhft.rs:16:20\n   |\n16 |     while let Some(Reverse((_, i, j))) = heap.pop() {\n   |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this tuple struct\n   |\n1  | use std::cmp::Reverse;\n   |\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0433, E0531.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}