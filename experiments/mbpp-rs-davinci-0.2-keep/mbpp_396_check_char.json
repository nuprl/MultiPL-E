{
  "name": "mbpp_396_check_char",
  "language": "rs",
  "prompt": "/// Write a function to check whether the given string starts and ends with the same character or not.\nfn check_char(string: String) -> String {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_396_check_char.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = check_char;\n    assert_eq!(candidate(String::from(\"abba\")), String::from(\"Valid\"));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"Valid\"));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"Invalid\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    let mut result = String::new();\n    let mut chars = string.chars();\n    let first_char = chars.next();\n    let last_char = chars.last();\n    if first_char == last_char {\n        result.push_str(\"Yes\");\n    } else {\n        result.push_str(\"No\");\n    }\n    result",
    "    let mut chars = string.chars();\n    let first_char = chars.next();\n    let last_char = chars.last();\n    if first_char == last_char {\n        return String::from(\"True\");\n    }\n    return String::from(\"False\");",
    "    let mut chars = string.chars();\n    let first = chars.next().unwrap();\n    let last = chars.rev().next().unwrap();\n    if first == last {\n        format!(\"{} starts and ends with the same character\", string)\n    } else {\n        format!(\"{} does not start and end with the same character\", string)\n    }",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return String::from(\"True\");\n    }\n    String::from(\"False\")",
    "    let mut chars = string.chars();\n    let first = chars.next().unwrap();\n    let last = chars.last().unwrap();\n    if first == last {\n        return \"True\".to_string();\n    }\n    \"False\".to_string()",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return \"True\".to_string();\n    }\n    \"False\".to_string()",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return \"True\".to_string();\n    } else {\n        return \"False\".to_string();\n    }",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.rev().next();\n    if first == last {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return String::from(\"True\");\n    }\n    String::from(\"False\")",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    match (first, last) {\n        (Some(f), Some(l)) => {\n            if f == l {\n                String::from(\"True\")\n            } else {\n                String::from(\"False\")\n            }\n        }\n        _ => String::from(\"False\"),\n    }",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return format!(\"{} starts and ends with the same character {}\", string, first.unwrap());\n    } else {\n        return format!(\"{} does not start and end with the same character\", string);\n    }",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return String::from(\"True\");\n    }\n    return String::from(\"False\");",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        format!(\"{} starts and ends with the same character\", string)\n    } else {\n        format!(\"{} does not start and end with the same character\", string)\n    }",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"No\");",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return format!(\"{} starts and ends with the same character\", string);\n    } else {\n        return format!(\"{} does not start and end with the same character\", string);\n    }",
    "    if string.chars().next() == string.chars().last() {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.last();\n    if first == last {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")",
    "    let mut chars = string.chars();\n    let first = chars.next();\n    let last = chars.rev().next();\n    if first == last {\n        return String::from(\"True\");\n    }\n    String::from(\"False\")"
  ]
}