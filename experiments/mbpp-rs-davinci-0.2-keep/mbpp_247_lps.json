{
  "name": "mbpp_247_lps",
  "language": "rs",
  "prompt": "/// Write a function to find the length of the longest palindromic subsequence in the given string.\nfn lps(str: String) -> isize {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = lps;\n    assert_eq!(candidate(String::from(\"TENS FOR TENS\")), 5);\n    assert_eq!(candidate(String::from(\"CARDIO FOR CARDS\")), 7);\n    assert_eq!(candidate(String::from(\"PART OF THE JOURNEY IS PART\")), 9);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    let s = str.as_bytes();\n    let n = s.len();\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        dp[i][i] = 1;\n    }\n    for i in (0..n - 1).rev() {\n        for j in i + 1..n {\n            if s[i] == s[j] {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][n - 1] as isize",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    let mut max = 0;\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n        max = 1;\n    }\n    for i in 0..str.len() - 1 {\n        if str.chars().nth(i).unwrap() == str.chars().nth(i + 1).unwrap() {\n            dp[i][i + 1] = 2;\n            max = 2;\n        }\n    }\n    for i in (3..str.len() + 1).rev() {\n        for j in 0..str.len() - i + 1 {\n            let k = j + i - 1;\n            if str.chars().nth(j).unwrap() == str.chars().nth(k).unwrap() {\n                dp[j][k] = dp[j + 1][k - 1] + 2;\n            } else {\n                dp[j][k] = max(dp[j + 1][k], dp[j][k - 1]);\n            }\n            if dp[j][k] > max {\n                max = dp[j][k];\n            }\n        }\n    }\n    max",
    "    let s = str.as_bytes();\n    let n = s.len();\n    let mut dp = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        dp[i][i] = 1;\n    }\n\n    for i in (0..n - 1).rev() {\n        for j in i + 1..n {\n            if s[i] == s[j] {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    dp[0][n - 1] as isize",
    "    let n = str.len();\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        dp[i][i] = 1;\n    }\n    for i in (0..n - 1).rev() {\n        for j in i + 1..n {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][n - 1]",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    let mut i = 0;\n    let mut j = 0;\n    let mut max = 0;\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for i in 0..str.len() - 1 {\n        if str.chars().nth(i).unwrap() == str.chars().nth(i + 1).unwrap() {\n            dp[i][i + 1] = 2;\n        } else {\n            dp[i][i + 1] = 1;\n        }\n    }\n    for k in 3..str.len() + 1 {\n        for i in 0..str.len() - k + 1 {\n            j = i + k - 1;\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1]",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for i in (0..str.len()).rev() {\n        for j in i + 1..str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1] as isize",
    "    let n = str.len();\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        dp[i][i] = 1;\n    }\n    for i in (0..n - 1).rev() {\n        for j in i + 1..n {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][n - 1] as isize",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for i in (0..str.len()).rev() {\n        for j in i + 1..str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1] as isize",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    let mut max = 0;\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n        if i < str.len() - 1 && str.chars().nth(i).unwrap() == str.chars().nth(i + 1).unwrap() {\n            dp[i][i + 1] = 2;\n            max = 2;\n        }\n    }\n    for i in (0..str.len()).rev() {\n        for j in i + 2..str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n            max = std::cmp::max(max, dp[i][j]);\n        }\n    }\n    max as isize",
    "    let n = str.len();\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        dp[i][i] = 1;\n    }\n    for i in (0..n - 1).rev() {\n        for j in i + 1..n {\n            if str.chars().nth(i) == str.chars().nth(j) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][n - 1] as isize",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    let mut max = 0;\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n        max = 1;\n    }\n    for i in 0..str.len() - 1 {\n        if str.chars().nth(i).unwrap() == str.chars().nth(i + 1).unwrap() {\n            dp[i][i + 1] = 2;\n            max = 2;\n        }\n    }\n    for i in 3..str.len() + 1 {\n        for j in 0..str.len() - i + 1 {\n            let k = j + i - 1;\n            if str.chars().nth(j).unwrap() == str.chars().nth(k).unwrap() {\n                dp[j][k] = dp[j + 1][k - 1] + 2;\n            } else {\n                dp[j][k] = std::cmp::max(dp[j + 1][k], dp[j][k - 1]);\n            }\n            max = std::cmp::max(max, dp[j][k]);\n        }\n    }\n    max",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    let mut i = 0;\n    while i < str.len() {\n        dp[i][i] = 1;\n        i += 1;\n    }\n    let mut i = str.len() - 1;\n    while i >= 0 {\n        let mut j = i + 1;\n        while j < str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n            j += 1;\n        }\n        i -= 1;\n    }\n    dp[0][str.len() - 1]",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for l in 2..str.len() + 1 {\n        for i in 0..str.len() - l + 1 {\n            let j = i + l - 1;\n            if str.chars().nth(i) == str.chars().nth(j) {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1]",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for i in (0..str.len()).rev() {\n        for j in i + 1..str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1] as isize",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for i in (0..str.len()).rev() {\n        for j in i + 1..str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1] as isize",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for i in (0..str.len()).rev() {\n        for j in i + 1..str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = std::cmp::max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1] as isize",
    "    let len = str.len() as isize;\n    let mut dp = vec![vec![0; len as usize]; len as usize];\n    for i in (0..len).rev() {\n        dp[i as usize][i as usize] = 1;\n        for j in (i + 1)..len {\n            if str.chars().nth(i as usize) == str.chars().nth(j as usize) {\n                dp[i as usize][j as usize] = 2 + dp[(i + 1) as usize][(j - 1) as usize];\n            } else {\n                dp[i as usize][j as usize] = max(dp[i as usize][(j - 1) as usize], dp[(i + 1) as usize][j as usize]);\n            }\n        }\n    }\n    dp[0][len - 1]",
    "    let mut dp = vec![vec![0; str.len()]; str.len()];\n    for i in 0..str.len() {\n        dp[i][i] = 1;\n    }\n    for i in (0..str.len() - 1).rev() {\n        for j in i + 1..str.len() {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = 2 + dp[i + 1][j - 1];\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][str.len() - 1]",
    "    let n = str.len();\n    let mut dp = vec![vec![0; n]; n];\n    for i in 0..n {\n        dp[i][i] = 1;\n    }\n    for i in (0..n - 1).rev() {\n        for j in i + 1..n {\n            if str.chars().nth(i).unwrap() == str.chars().nth(j).unwrap() {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    dp[0][n - 1] as isize",
    "    let str_len = str.len();\n    let mut dp = vec![vec![0; str_len]; str_len];\n\n    // All substrings of length 1 are palindromes\n    for i in 0..str_len {\n        dp[i][i] = 1;\n    }\n\n    // Build the table. Note that the lower diagonal values of table are\n    // useless and not filled in the process. The values are filled in a\n    // manner similar to Matrix Chain Multiplication DP solution (See\n    // https://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/\n    // clippy-ignore\n    for cl in 2..=str_len {\n        for i in 0..=(str_len - cl) {\n            let j = i + cl - 1;\n            if str.chars().nth(i) == str.chars().nth(j) && cl == 2 {\n                dp[i][j] = 2;\n            } else if str.chars().nth(i) == str.chars().nth(j) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::cmp::max(dp[i][j - 1], dp[i + 1][j]);\n            }\n        }\n    }\n\n    dp[0][str_len - 1] as isize"
  ]
}