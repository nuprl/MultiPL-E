{
  "name": "mbpp_771_check_expression",
  "language": "rs",
  "prompt": "/// Write a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\nfn check_expression(exp: String) -> bool {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = check_expression;\n    assert_eq!(candidate(String::from(\"{()}[{}]\")), true);\n    assert_eq!(candidate(String::from(\"{()}[{]\")), false);\n    assert_eq!(candidate(String::from(\"{()}[{}][]({})\")), true);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    let mut stack: Vec<char> = Vec::new();\n\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !is_matching_pair(top, c) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !is_matching_pair(top, c) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack = Vec::new();\n    for ch in exp.chars() {\n        match ch {\n            '(' | '[' | '{' => stack.push(ch),\n            ')' | ']' | '}' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !is_matching_pair(top, ch) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((c == ')' && top == '(') || (c == '}' && top == '{') || (c == ']' && top == '[')) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    return stack.is_empty();",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !is_matching_pair(top, c) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack = Vec::new();\n    let mut balanced = true;\n    let mut i = 0;\n    while balanced && i < exp.len() {\n        let c = exp.chars().nth(i).unwrap();\n        if c == '(' || c == '[' || c == '{' {\n            stack.push(c);\n        } else if c == ')' || c == ']' || c == '}' {\n            if stack.is_empty() {\n                balanced = false;\n            } else {\n                let top = stack.pop().unwrap();\n                if !((top == '(' && c == ')') || (top == '[' && c == ']') || (top == '{' && c == '}')) {\n                    balanced = false;\n                }\n            }\n        }\n        i += 1;\n    }\n    balanced && stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((c == ')' && top == '(') || (c == '}' && top == '{') || (c == ']' && top == '[')) {\n                    return false;\n                }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !is_matching_pair(top, c) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((c == ')' && top == '(') || (c == '}' && top == '{') || (c == ']' && top == '[')) {\n                    return false;\n                }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' => {\n                if stack.pop() != Some('(') {\n                    return false;\n                }\n            }\n            '}' => {\n                if stack.pop() != Some('{') {\n                    return false;\n                }\n            }\n            ']' => {\n                if stack.pop() != Some('[') {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    let mut balanced = true;\n    let mut index = 0;\n    while index < exp.len() && balanced {\n        let c = exp.chars().nth(index).unwrap();\n        if c == '(' || c == '[' || c == '{' {\n            stack.push(c);\n        } else if c == ')' || c == ']' || c == '}' {\n            if stack.is_empty() {\n                balanced = false;\n            } else {\n                let top = stack.pop().unwrap();\n                if !((top == '(' && c == ')') || (top == '[' && c == ']') || (top == '{' && c == '}')) {\n                    balanced = false;\n                }\n            }\n        }\n        index += 1;\n    }\n    balanced && stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((c == ')' && top == '(') || (c == '}' && top == '{') || (c == ']' && top == '[')) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((c == ')' && top == '(') || (c == '}' && top == '{') || (c == ']' && top == '[')) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for ch in exp.chars() {\n        match ch {\n            '(' | '{' | '[' => stack.push(ch),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((top == '(' && ch == ')') || (top == '{' && ch == '}') || (top == '[' && ch == ']')) {\n                    return false;\n                }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((c == ')' && top == '(') || (c == '}' && top == '{') || (c == ']' && top == '[')) {\n                    return false;\n                }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()",
    "    let mut stack = vec![];\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' | '}' | ']' => {\n                if stack.is_empty() {\n                    return false;\n                }\n                let top = stack.pop().unwrap();\n                if !((c == ')' && top == '(') || (c == '}' && top == '{') || (c == ']' && top == '[')) {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n\n    for c in exp.chars() {\n        match c {\n            '{' | '[' | '(' => stack.push(c),\n            '}' => {\n                if stack.pop() != Some('{') {\n                    return false;\n                }\n            }\n            ']' => {\n                if stack.pop() != Some('[') {\n                    return false;\n                }\n            }\n            ')' => {\n                if stack.pop() != Some('(') {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n\n    stack.is_empty()",
    "    let mut stack = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' => {\n                if stack.pop() != Some('(') {\n                    return false;\n                }\n            }\n            '}' => {\n                if stack.pop() != Some('{') {\n                    return false;\n                }\n            }\n            ']' => {\n                if stack.pop() != Some('[') {\n                    return false;\n                }\n            }\n            _ => (),\n        }\n    }\n    stack.is_empty()",
    "    let mut stack: Vec<char> = Vec::new();\n    for c in exp.chars() {\n        if c == '(' || c == '[' || c == '{' {\n            stack.push(c);\n        } else if c == ')' {\n            if stack.pop() != Some('(') {\n                return false;\n            }\n        } else if c == ']' {\n            if stack.pop() != Some('[') {\n                return false;\n            }\n        } else if c == '}' {\n            if stack.pop() != Some('{') {\n                return false;\n            }\n        }\n    }\n    stack.is_empty()",
    "    let mut stack = Vec::new();\n    for c in exp.chars() {\n        match c {\n            '(' | '{' | '[' => stack.push(c),\n            ')' => {\n                if stack.pop() != Some('(') {\n                    return false;\n                }\n            }\n            '}' => {\n                if stack.pop() != Some('{') {\n                    return false;\n                }\n            }\n            ']' => {\n                if stack.pop() != Some('[') {\n                    return false;\n                }\n            }\n            _ => {}\n        }\n    }\n    stack.is_empty()"
  ]
}