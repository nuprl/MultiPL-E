{
  "name": "mbpp_92_is_undulating",
  "language": "rs",
  "prompt": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        } else if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01eamqu8.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = prev < curr;\n    let mut is_decreasing = prev > curr;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr > next {\n            is_increasing = false;\n            is_decreasing = true;\n        } else if is_decreasing && curr < next {\n            is_increasing = true;\n            is_decreasing = false;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpvyrb9bj7.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > prev_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && curr_digit > prev_digit {\n            return false;\n        }\n        if !is_increasing && curr_digit < prev_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    let mut last = digits.pop().unwrap();\n    let mut last_was_odd = last % 2 == 1;\n    while let Some(d) = digits.pop() {\n        let is_odd = d % 2 == 1;\n        if is_odd == last_was_odd {\n            return false;\n        }\n        last_was_odd = is_odd;\n        last = d;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmp85e55hyv.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i) != s.chars().nth(j) {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp01kxy7fq.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_char = ' ';\n    let mut last_diff = 0;\n    for c in s.chars() {\n        if last_char != ' ' {\n            let diff = (c as isize) - (last_char as isize);\n            if last_diff == 0 {\n                last_diff = diff;\n            } else if last_diff != diff {\n                return false;\n            }\n        }\n        last_char = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpjpqlhbt9.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff != diff {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmproc4t5qq.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if diff == prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpzlu7nj_m.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp5whd_665.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    let mut increasing = true;\n\n    while n > 0 {\n        n /= 10;\n        let digit = n % 10;\n        if digit < last_digit {\n            increasing = false;\n        } else if digit > last_digit {\n            if !increasing {\n                return false;\n            }\n            increasing = true;\n        }\n        last_digit = digit;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpxx5jsye3.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        if s.chars().nth(i).unwrap().to_digit(10).unwrap() % 2 == 0 {\n            i += 1;\n            continue;\n        }\n        if s.chars().nth(i + 1).unwrap().to_digit(10).unwrap() % 2 == 0 {\n            return false;\n        }\n        i += 2;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpkxc5gfzm.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = -1;\n    let mut last_diff = -1;\n    let mut is_undulating = true;\n    for digit in n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize) {\n        if last_digit != -1 {\n            let diff = digit - last_digit;\n            if last_diff != -1 && diff != last_diff {\n                is_undulating = false;\n                break;\n            }\n            last_diff = diff;\n        }\n        last_digit = digit;\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp9xvwjn_u.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == last_digit {\n            return false;\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp2c7e42fm.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last = s.chars().next().unwrap();\n    let mut last_was_even = false;\n    for c in s.chars().skip(1) {\n        if c == last {\n            return false;\n        }\n        if c.to_digit(10).unwrap() % 2 == 0 {\n            if last_was_even {\n                return false;\n            }\n            last_was_even = true;\n        } else {\n            last_was_even = false;\n        }\n        last = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = prev < curr;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing {\n            if prev > curr {\n                return false;\n            }\n            if curr < next {\n                is_increasing = false;\n            }\n        } else {\n            if prev < curr {\n                return false;\n            }\n            if curr > next {\n                is_increasing = true;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp1gagrjaf.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_odd = last_digit.to_digit(10).unwrap() % 2 == 1;\n    for c in s.chars().skip(1) {\n        let is_odd = c.to_digit(10).unwrap() % 2 == 1;\n        if is_odd == last_was_odd {\n            return false;\n        }\n        last_was_odd = is_odd;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] % 2 == digits[i + 1] % 2 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ad64wtj.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_odd = last_digit.to_digit(10).unwrap() % 2 != 0;\n    for c in s.chars().skip(1) {\n        let is_odd = c.to_digit(10).unwrap() % 2 != 0;\n        if last_was_odd == is_odd {\n            return false;\n        }\n        last_was_odd = is_odd;\n        if last_digit == c {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap();\n        if (a < b && b > c) || (a > b && b < c) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    while n > 0 {\n        let digit = n % 10;\n        if last_digit == digit {\n            return false;\n        }\n        last_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = digits(n);\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < digits.len() {\n        if digits[i] == digits[j] || digits[j] == digits[k] || digits[i] == digits[k] {\n            return false;\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmppqonhgsx.rs:3:18\n  |\n3 |     let digits = digits(n);\n  |                  ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    let mut last_digit = digits[0];\n    let mut last_diff = None;\n    for digit in digits.iter().skip(1) {\n        let diff = digit - last_digit;\n        if last_diff.is_some() && last_diff != Some(diff) {\n            return false;\n        }\n        last_diff = Some(diff);\n        last_digit = *digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/arith.rs:240:1\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1;\n            continue;\n        }\n        if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            i += 2;\n            continue;\n        }\n        if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            i += 2;\n            continue;\n        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i] != digits[i - 1] && digits[i] != digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpkzctveh2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm8x5wnxa.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff * diff != -1 {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp3hq7tavx.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut current_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = current_digit > last_digit;\n    while n > 0 {\n        last_digit = current_digit;\n        current_digit = n % 10;\n        n /= 10;\n        if is_increasing && current_digit > last_digit {\n            return false;\n        }\n        if !is_increasing && current_digit < last_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        if s[i] == s[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp6z6ibdme.rs:6:12\n  |\n6 |         if s[i] == s[i + 1] {\n  |            ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp6z6ibdme.rs:6:20\n  |\n6 |         if s[i] == s[i + 1] {\n  |                    ^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n > 0 {\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_odd = last_digit.to_digit(10).unwrap() % 2 == 1;\n    for c in s.chars().skip(1) {\n        let is_odd = c.to_digit(10).unwrap() % 2 == 1;\n        if last_was_odd == is_odd {\n            return false;\n        }\n        last_was_odd = is_odd;\n        if last_digit == c {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).collect::<Vec<_>>();\n    let mut last_digit = digits[0];\n    let mut last_diff = 0;\n    for &digit in &digits[1..] {\n        let diff = last_digit - digit;\n        if diff == 0 {\n            return false;\n        }\n        if last_diff != 0 && diff != last_diff {\n            return false;\n        }\n        last_diff = diff;\n        last_digit = digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmphv47k5am.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxpo7z87_.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut state = if prev > curr {\n        if curr < next {\n            1\n        } else {\n            0\n        }\n    } else {\n        if curr > next {\n            -1\n        } else {\n            0\n        }\n    };\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if state == 1 {\n            if curr > next {\n                state = -1;\n            } else if curr < next {\n                return false;\n            }\n        } else if state == -1 {\n            if curr < next {\n                state = 1;\n            } else if curr > next {\n                return false;\n            }\n        } else {\n            if prev > curr {\n                if curr < next {\n                    state = 1;\n                } else if curr > next {\n                    return false;\n                }\n            } else {\n                if curr > next {\n                    state = -1;\n                } else if curr < next {\n                    return false;\n                }\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp3cwq1mnt.rs:62:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().nth(0).unwrap();\n    let mut last_diff = None;\n    for c in s.chars().skip(1) {\n        let diff = c.to_digit(10).unwrap() as isize - last_digit.to_digit(10).unwrap() as isize;\n        if last_diff.is_some() && last_diff.unwrap() != diff {\n            return false;\n        }\n        last_diff = Some(diff);\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpe3etnpet.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm8x5wnxa.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.reverse();\n    let mut last_digit = digits[0];\n    let mut is_increasing = true;\n    for digit in digits.iter().skip(1) {\n        if is_increasing {\n            if last_digit > *digit {\n                is_increasing = false;\n            }\n        } else {\n            if last_digit < *digit {\n                return false;\n            }\n        }\n        last_digit = *digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpndujnmk6.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    while j < s.len() {\n        if s[i..j].parse::<isize>().unwrap() % 2 == 0 {\n            return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprj3rz5u4.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] == digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp33jak3mn.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut num = n;\n    while num > 0 {\n        digits.push(num % 10);\n        num /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] % 2 == 0 && digits[i + 1] % 2 == 0 {\n            return false;\n        }\n        if digits[i] % 2 != 0 && digits[i + 1] % 2 != 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut prev = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let curr = n % 10;\n        if is_increasing {\n            if curr > prev {\n                return false;\n            }\n        } else {\n            if curr < prev {\n                return false;\n            }\n        }\n        prev = curr;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp2ls3wnqj.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut second_last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = second_last_digit > last_digit;\n    let mut is_undulating = true;\n    while n > 0 {\n        last_digit = second_last_digit;\n        second_last_digit = n % 10;\n        n /= 10;\n        if is_increasing && second_last_digit >= last_digit {\n            is_undulating = false;\n            break;\n        } else if !is_increasing && second_last_digit <= last_digit {\n            is_undulating = false;\n            break;\n        }\n        is_increasing = !is_increasing;\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    let mut prev = digits.pop().unwrap();\n    let mut is_increasing = true;\n    for d in digits {\n        if is_increasing {\n            if d > prev {\n                return false;\n            }\n        } else {\n            if d < prev {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev = d;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmpjuyblz7q.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n\n    let mut is_increasing = true;\n    let mut is_decreasing = true;\n    for i in 0..digits.len() - 1 {\n        if digits[i] > digits[i + 1] {\n            is_increasing = false;\n        }\n        if digits[i] < digits[i + 1] {\n            is_decreasing = false;\n        }\n    }\n    is_increasing || is_decreasing\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpcaz74vp6.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut s = n.to_string();\n    let mut t = s.clone();\n    s.pop();\n    t.remove(0);\n    s.parse::<isize>().unwrap() - t.parse::<isize>().unwrap() == 1\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp29dhng1x.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = prev < curr;\n    let mut is_decreasing = prev > curr;\n    while n > 0 {\n        if is_increasing && curr > next {\n            return false;\n        }\n        if is_decreasing && curr < next {\n            return false;\n        }\n        is_increasing = curr < next;\n        is_decreasing = curr > next;\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpblp0ru8o.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff != diff {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmproc4t5qq.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut prev_digit = 0;\n    let mut is_increasing = true;\n    let mut is_undulating = true;\n    for digit in n.to_string().chars() {\n        let digit = digit.to_digit(10).unwrap() as isize;\n        if prev_digit == 0 {\n            prev_digit = digit;\n            continue;\n        }\n        if is_increasing {\n            if digit < prev_digit {\n                is_increasing = false;\n            } else if digit == prev_digit {\n                is_undulating = false;\n                break;\n            }\n        } else {\n            if digit > prev_digit {\n                is_increasing = true;\n            } else if digit == prev_digit {\n                is_undulating = false;\n                break;\n            }\n        }\n        prev_digit = digit;\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        if c == last_digit {\n            return false;\n        }\n        if c > last_digit {\n            if last_was_increasing {\n                return false;\n            }\n            last_was_increasing = true;\n        } else {\n            if !last_was_increasing {\n                return false;\n            }\n            last_was_increasing = false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().nth(0).unwrap();\n    let mut last_diff = 0;\n    for c in s.chars().skip(1) {\n        let diff = (c as isize) - (last_digit as isize);\n        if last_diff == 0 {\n            last_diff = diff;\n        } else if last_diff * diff != -1 {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpun_hzfi2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    let mut last_digit = digits.pop().unwrap();\n    let mut last_diff = 0;\n    for digit in digits {\n        let diff = digit - last_digit;\n        if diff == 0 {\n            return false;\n        }\n        if last_diff != 0 && diff != last_diff {\n            return false;\n        }\n        last_diff = diff;\n        last_digit = digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmp6a5l4hm_.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    let mut is_undulating = true;\n    for i in 0..digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            is_undulating = false;\n            break;\n        }\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmph0vmjj0_.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmp13dr1slh.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    let mut is_decreasing = curr < prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr > next {\n            is_increasing = false;\n        }\n        if is_decreasing && curr < next {\n            is_decreasing = false;\n        }\n        if !is_increasing && !is_decreasing {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpgf5w8wr5.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        last_digit = digit;\n        n = n / 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpeo9a17oj.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last = s.chars().nth(0).unwrap();\n    let mut last_was_odd = false;\n    for c in s.chars().skip(1) {\n        let is_odd = c.to_digit(10).unwrap() % 2 == 1;\n        if last_was_odd == is_odd {\n            return false;\n        }\n        last = c;\n        last_was_odd = is_odd;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp596ix952.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap();\n        if (a < b && b > c) || (a > b && b < c) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        n /= 10;\n        if n > 0 {\n            let next = n % 10;\n            if prev == next {\n                return false;\n            }\n        }\n        prev = curr;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmphzyz2zpy.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] % 2 == 0 && digits[i + 1] % 2 == 0 {\n            return false;\n        }\n        if digits[i] % 2 != 0 && digits[i + 1] % 2 != 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let v: Vec<_> = s.chars().map(|c| c.to_digit(10).unwrap()).collect();\n    let mut i = 0;\n    let mut j = v.len() - 1;\n    while i < j {\n        if v[i] == v[j] {\n            i += 1;\n            j -= 1;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp7syno8nk.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n > 0 {\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n\n    let mut is_increasing = curr > prev;\n    let mut is_decreasing = curr < prev;\n\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n\n        if is_increasing && curr > next {\n            is_increasing = false;\n            is_decreasing = true;\n        } else if is_decreasing && curr < next {\n            is_increasing = true;\n            is_decreasing = false;\n        } else {\n            return false;\n        }\n    }\n\n    is_increasing || is_decreasing\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpzbvxbl67.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing {\n            if curr < prev {\n                return false;\n            }\n            if curr > next {\n                is_increasing = false;\n            }\n        } else {\n            if curr > prev {\n                return false;\n            }\n            if curr < next {\n                is_increasing = true;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpk1wkaofm.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut is_increasing = prev < curr;\n    while n > 0 {\n        let next = n % 10;\n        if is_increasing && next >= curr {\n            return false;\n        }\n        if !is_increasing && next <= curr {\n            return false;\n        }\n        prev = curr;\n        curr = next;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        if s[i] == s[i + 1] {\n            return false;\n        }\n        i += 2;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp2gkl4dp1.rs:6:12\n  |\n6 |         if s[i] == s[i + 1] {\n  |            ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp2gkl4dp1.rs:6:20\n  |\n6 |         if s[i] == s[i + 1] {\n  |                    ^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        let is_increasing = c > last;\n        if last_was_increasing == is_increasing {\n            return false;\n        }\n        last_was_increasing = is_increasing;\n        last = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().nth(0).unwrap();\n    let mut last_diff = 0;\n    for c in s.chars().skip(1) {\n        let diff = c as isize - last_digit as isize;\n        if diff == 0 {\n            return false;\n        }\n        if last_diff == 0 {\n            last_diff = diff;\n        } else if last_diff * diff != -1 {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpx14zdhs1.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    let mut last_digit = digits[0];\n    let mut last_diff = 0;\n    for &digit in digits.iter().skip(1) {\n        let diff = digit - last_digit;\n        if last_diff == diff {\n            return false;\n        }\n        last_diff = diff;\n        last_digit = digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbp3ly3be.rs:7:20\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm8x5wnxa.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] > digits[i] && digits[i] < digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp49pzsd4j.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        if a == b {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == last_digit {\n            return false;\n        }\n        if digit > last_digit && is_increasing {\n            return false;\n        }\n        if digit < last_digit && !is_increasing {\n            return false;\n        }\n        is_increasing = !is_increasing;\n        last_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp5680ot8d.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    let mut i = 0;\n    let mut j = digits.len() - 1;\n    while i < j {\n        if digits[i] != digits[j] {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmphozs7jdk.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        let is_increasing = c > last_digit;\n        if last_was_increasing == is_increasing {\n            return false;\n        }\n        last_was_increasing = is_increasing;\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == prev_digit {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n > 0 {\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n\n        if is_increasing {\n            if curr < prev {\n                return false;\n            }\n            if curr > next {\n                is_increasing = false;\n            }\n        } else {\n            if curr > prev {\n                return false;\n            }\n            if curr < next {\n                is_increasing = true;\n            }\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpiij5fdlu.rs:40:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = None;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff.is_some() && prev_diff != Some(diff.abs()) {\n            return false;\n        }\n        prev_diff = Some(diff.abs());\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut prev = s.chars().nth(0).unwrap();\n    let mut undulating = true;\n    for c in s.chars().skip(1) {\n        if c == prev {\n            undulating = false;\n            break;\n        }\n        prev = c;\n    }\n    undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = prev_digit > curr_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && prev_digit < curr_digit {\n            return false;\n        } else if !is_increasing && prev_digit > curr_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpxeg81s17.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut prev = s.chars().nth(0).unwrap();\n    let mut is_even = false;\n    for c in s.chars().skip(1) {\n        if prev == c {\n            return false;\n        }\n        if is_even {\n            if prev > c {\n                return false;\n            }\n        } else {\n            if prev < c {\n                return false;\n            }\n        }\n        is_even = !is_even;\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmptgexb2u6.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > prev_digit {\n                return false;\n            }\n        } else {\n            if digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpqz997nno.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_even = last_digit.to_digit(10).unwrap() % 2 == 0;\n    for c in s.chars().skip(1) {\n        let is_even = c.to_digit(10).unwrap() % 2 == 0;\n        if last_was_even == is_even {\n            return false;\n        }\n        last_was_even = is_even;\n        if last_digit == c {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap();\n        if a == b || b == c || a == c {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmplxhz750g.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < s.len() {\n        if s[i..i + 1] == s[j..j + 1] || s[j..j + 1] == s[k..k + 1] {\n            return false;\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n\n    while n > 0 {\n        if prev == curr || curr == next {\n            return false;\n        }\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n = n / 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpfxcplmbp.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if curr == prev {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] % 2 == 0 {\n            continue;\n        }\n        if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = prev_digit < curr_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && prev_digit < curr_digit {\n            return false;\n        }\n        if !is_increasing && prev_digit > curr_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_odd = last_digit.to_digit(10).unwrap() % 2 == 1;\n    for c in s.chars().skip(1) {\n        let is_odd = c.to_digit(10).unwrap() % 2 == 1;\n        if is_odd == last_was_odd {\n            return false;\n        }\n        last_was_odd = is_odd;\n        if c < last_digit {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpu_xir55z.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_even = last_digit.to_digit(10).unwrap() % 2 == 0;\n    for c in s.chars().skip(1) {\n        let is_even = c.to_digit(10).unwrap() % 2 == 0;\n        if last_was_even == is_even {\n            return false;\n        }\n        last_was_even = is_even;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    while n > 0 {\n        let digit = n % 10;\n        if prev_digit == digit {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] % 2 == 0 && digits[i + 1] % 2 == 0 {\n            return false;\n        }\n        if digits[i] % 2 != 0 && digits[i + 1] % 2 != 0 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = prev_digit > curr_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && prev_digit < curr_digit {\n            return false;\n        }\n        if !is_increasing && prev_digit > curr_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp1e2wl9sd.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == last_digit {\n            return false;\n        }\n        if is_increasing && digit > last_digit {\n            return false;\n        }\n        if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwtr0v3dx.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxpo7z87_.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    let mut last_digit = digits.pop().unwrap();\n    let mut is_increasing = true;\n    for digit in digits {\n        if is_increasing && digit > last_digit {\n            return false;\n        }\n        if !is_increasing && digit < last_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n        last_digit = digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmp1nez0ay3.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n > 0 {\n        let next = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        curr = next;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n != 0 {\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] == digits[i + 1] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp572z4m8q.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff != 0 && prev_diff != diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp46ytx9q5.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = prev_digit < curr_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && prev_digit < curr_digit {\n            return false;\n        }\n        if !is_increasing && prev_digit > curr_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n\n    let mut is_increasing = curr > prev;\n    let mut is_decreasing = curr < prev;\n\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n\n        if curr > prev && curr > next {\n            is_increasing = true;\n        } else if curr < prev && curr < next {\n            is_decreasing = true;\n        }\n\n        if is_increasing && is_decreasing {\n            return true;\n        }\n    }\n\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmps_hohr40.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && prev_diff != diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpvnjzsrii.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    let mut is_undulating = true;\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] + 1 != digits[i + 1] {\n            is_undulating = false;\n            break;\n        }\n        i += 2;\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp3cdw3pnb.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut s = n.to_string();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpu_c92xut.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        n /= 10;\n        last_digit = digit;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpt9wyzg5t.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > prev_digit {\n                return false;\n            }\n        } else {\n            if digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpqz997nno.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if diff == 0 {\n            return false;\n        }\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmphw1b0d7a.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] == digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        let is_increasing = c > last_digit;\n        if is_increasing == last_was_increasing {\n            return false;\n        }\n        last_was_increasing = is_increasing;\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut prev = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let curr = n % 10;\n        if is_increasing {\n            if curr > prev {\n                return false;\n            }\n        } else {\n            if curr < prev {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev = curr;\n        n = n / 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpiwo_ovkn.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = prev < curr;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr > next {\n            is_increasing = false;\n        } else if !is_increasing && curr < next {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpszmntzfn.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).collect::<Vec<isize>>();\n    digits.sort();\n    let mut is_undulating = true;\n    for i in 0..digits.len() - 1 {\n        if digits[i] + 1 != digits[i + 1] {\n            is_undulating = false;\n            break;\n        }\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpgfvk58ud.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n = n / 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpfxcplmbp.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 2\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp56v5df_t.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwkcsfl7k.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last = s.chars().nth(0).unwrap();\n    let mut last_was_even = last.to_digit(10).unwrap() % 2 == 0;\n    for c in s.chars().skip(1) {\n        let is_even = c.to_digit(10).unwrap() % 2 == 0;\n        if is_even == last_was_even {\n            return false;\n        }\n        last_was_even = is_even;\n        if c < last {\n            return false;\n        }\n        last = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpkmumjebn.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut curr_trend = curr_digit - last_digit;\n    while n != 0 {\n        last_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        let new_trend = curr_digit - last_digit;\n        if new_trend == curr_trend {\n            return false;\n        }\n        curr_trend = new_trend;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpwy519wiy.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut last_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - last_digit;\n        if last_diff == 0 {\n            last_diff = diff;\n        } else if last_diff != diff {\n            return false;\n        }\n        last_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpft1g6l5s.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = None;\n    let mut last_diff = None;\n    for digit in digits(n) {\n        if let Some(last_diff) = last_diff {\n            if last_diff * (digit - last_digit.unwrap()) < 0 {\n                return false;\n            }\n        }\n        last_diff = last_digit.map(|d| digit - d);\n        last_digit = Some(digit);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmpr4fxsjd4.rs:5:18\n  |\n5 |     for digit in digits(n) {\n  |                  ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = None;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if let Some(prev_digit) = prev_digit {\n            if is_increasing {\n                if digit > prev_digit {\n                    return false;\n                }\n            } else {\n                if digit < prev_digit {\n                    return false;\n                }\n            }\n        }\n        prev_digit = Some(digit);\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 2\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmptxvm8vl7.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff == diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpj6_k8b0f.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n = n / 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpfxcplmbp.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        let c1 = s.chars().nth(i).unwrap();\n        let c2 = s.chars().nth(i + 1).unwrap();\n        if c1 == c2 {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmp13dr1slh.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.reverse();\n    let mut last_digit = digits[0];\n    let mut last_diff = 0;\n    for digit in digits.iter().skip(1) {\n        let diff = digit - last_digit;\n        if diff == 0 {\n            return false;\n        }\n        if last_diff != 0 && diff != last_diff {\n            return false;\n        }\n        last_diff = diff;\n        last_digit = *digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/arith.rs:240:1\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 1;\n    while i < s.len() {\n        if s.chars().nth(i - 1).unwrap().to_digit(10).unwrap() % 2 == 0 {\n            if s.chars().nth(i).unwrap().to_digit(10).unwrap() % 2 == 0 {\n                return false;\n            }\n        } else {\n            if s.chars().nth(i).unwrap().to_digit(10).unwrap() % 2 != 0 {\n                return false;\n            }\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwkcsfl7k.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        if a == b {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = -1;\n    let mut last_diff = -1;\n    for digit in n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize) {\n        if last_digit != -1 {\n            let diff = digit - last_digit;\n            if last_diff != -1 && diff != last_diff {\n                return false;\n            }\n            last_diff = diff;\n        }\n        last_digit = digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbx66uzx1.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < s.len() {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(j).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(k).unwrap().to_digit(10).unwrap();\n        if a < b && b > c {\n            return true;\n        }\n        if a > b && b < c {\n            return true;\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] > digits[i] && digits[i] < digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp49pzsd4j.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122521,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    let mut last_digit = digits[0];\n    let mut last_diff = 0;\n    for digit in digits.iter().skip(1) {\n        let diff = digit - last_digit;\n        if last_diff == 0 {\n            last_diff = diff;\n        } else if last_diff != diff {\n            return false;\n        }\n        last_digit = *digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/arith.rs:240:1\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        } else if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01eamqu8.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwkcsfl7k.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_odd = last_digit.to_digit(10).unwrap() % 2 == 1;\n    for c in s.chars().skip(1) {\n        let digit = c.to_digit(10).unwrap();\n        let is_odd = digit % 2 == 1;\n        if is_odd == last_was_odd {\n            return false;\n        }\n        last_was_odd = is_odd;\n        if last_digit == c {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    let mut is_decreasing = curr < prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr > next {\n            is_increasing = false;\n        }\n        if is_decreasing && curr < next {\n            is_decreasing = false;\n        }\n        if !is_increasing && !is_decreasing {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpgf5w8wr5.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap() as isize;\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap() as isize;\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap() as isize;\n        if (a - b).abs() == (b - c).abs() {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr_digit = n % 10;\n        if prev_digit == curr_digit {\n            return false;\n        }\n        prev_digit = curr_digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut prev = s.chars().next().unwrap();\n    let mut is_increasing = false;\n    for c in s.chars().skip(1) {\n        if c == prev {\n            return false;\n        }\n        if c > prev {\n            if is_increasing {\n                return false;\n            }\n            is_increasing = true;\n        } else {\n            if !is_increasing {\n                return false;\n            }\n            is_increasing = false;\n        }\n        prev = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            continue;\n        }\n        if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            continue;\n        }\n        if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            continue;\n        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122522,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}