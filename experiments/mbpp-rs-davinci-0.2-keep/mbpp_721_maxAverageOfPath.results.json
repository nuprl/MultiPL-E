{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "rs",
  "prompt": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost.len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost.len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost.len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpo81jqsdf.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp: Vec<Vec<f64>> = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp6t1iizbw.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpwf46h1g1.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp6t1iizbw.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpnt7_yl0f.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp8jpiw0ti.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpqnn6xwj0.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpc0nvr3qe.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp6t1iizbw.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let m = cost[0].len();\n    let mut dp = vec![vec![0.0; m]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..m {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..m {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][m - 1] / (n + m - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.5`,\n right: `5.2`', /tmp/tmpbr9v_yfp.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp: Vec<Vec<f64>> = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp57d3_01j.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp89_xjopr.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / ((n * n) as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpknp7sty9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp1h4px7ch.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpozlt0fmv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpng9gh_9y.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpx0nnlitz.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp: Vec<Vec<f64>> = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    let mut count = 0;\n    let mut i = cost.len() - 1;\n    let mut j = cost[0].len() - 1;\n    while i > 0 || j > 0 {\n        count += 1;\n        if i > 0 && j > 0 {\n            if dp[i - 1][j] > dp[i][j - 1] {\n                i -= 1;\n            } else {\n                j -= 1;\n            }\n        } else if i > 0 {\n            i -= 1;\n        } else {\n            j -= 1;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / count as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `6.5`,\n right: `5.2`', /tmp/tmpuq48kfr6.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    let mut i = cost.len() - 1;\n    let mut j = cost[0].len() - 1;\n    let mut count = 0;\n    while i != 0 || j != 0 {\n        count += 1;\n        if i == 0 {\n            j -= 1;\n        } else if j == 0 {\n            i -= 1;\n        } else {\n            if dp[i - 1][j] > dp[i][j - 1] {\n                i -= 1;\n            } else {\n                j -= 1;\n            }\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / count as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `6.5`,\n right: `5.2`', /tmp/tmpm8ekrdwl.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp_lhrrux9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpng9gh_9y.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp6t1iizbw.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp_lhrrux9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp_lhrrux9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpc0nvr3qe.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (2 * n - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp46luqt2c.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpozlt0fmv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp1h4px7ch.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp1h4px7ch.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp_lhrrux9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpozlt0fmv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost.len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost.len() {\n            dp[i][j] = cost[i][j] + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost.len() - 1] as f64 / (cost.len() * 2 - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp: Vec<Vec<f64>> = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmps7v1l8ur.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpng9gh_9y.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp6t1iizbw.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpkv_3lsna.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp: Vec<Vec<f64>> = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpul5ayiz1.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let (m, n) = (cost.len(), cost[0].len());\n    let mut dp = vec![vec![0.0; n]; m];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..m {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..m {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[m - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpg88qdmhp.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpng9gh_9y.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp1h4px7ch.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    let mut i = cost.len() - 1;\n    let mut j = cost[0].len() - 1;\n    let mut count = 0;\n    while i > 0 || j > 0 {\n        if i == 0 {\n            j -= 1;\n        } else if j == 0 {\n            i -= 1;\n        } else {\n            if dp[i - 1][j] > dp[i][j - 1] {\n                i -= 1;\n            } else {\n                j -= 1;\n            }\n        }\n        count += 1;\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / count as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `6.5`,\n right: `5.2`', /tmp/tmpqamw75f8.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost.len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost.len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost.len() - 1] as f64 / (cost.len() * 2 - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    let mut sum = 0;\n    let mut i = cost.len() - 1;\n    let mut j = cost[0].len() - 1;\n    while i > 0 || j > 0 {\n        sum += cost[i][j];\n        if i > 0 && dp[i - 1][j] > dp[i][j - 1] {\n            i -= 1;\n        } else {\n            j -= 1;\n        }\n    }\n    sum as f64 / ((cost.len() + cost[0].len() - 1) as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpff5zb2mk.rs:21:42\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpozlt0fmv.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpc0nvr3qe.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpnt7_yl0f.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp_y0y23_b.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpbrfid3nb.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpc0nvr3qe.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / ((cost.len() + cost[0].len() - 1) as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpbrfid3nb.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpaio4f6zy.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j].max(dp[i][j - 1]) + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.75`,\n right: `5.2`', /tmp/tmpa80on5f7.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpng9gh_9y.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpl7yw2d2l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpng9gh_9y.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpkv_3lsna.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp1h4px7ch.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j].max(dp[i][j - 1]) + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.75`,\n right: `5.2`', /tmp/tmpa80on5f7.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp_lhrrux9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp6t1iizbw.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp0osx2cej.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpmb_wdwc2.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpr_vpxe6r.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (n * 2 - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp_lhrrux9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp36ra66h2.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpng9gh_9y.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmphwws8ddk.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124099,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpm4h113p5.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpgr21h7tx.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124098,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpqnn6xwj0.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmptj_3z32l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    }
  ]
}