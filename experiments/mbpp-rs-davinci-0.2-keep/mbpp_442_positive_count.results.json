{
  "name": "mbpp_442_positive_count",
  "language": "rs",
  "prompt": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py",
  "prompt_terminology": "verbatim",
  "tests": "}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    return (count as f64) / (nums.len() as f64);\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpj3h68wzi.rs:9:30\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return (count as f64) / (nums.len() as f64);\n    |                              ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp8g3g4knc.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for n in nums {\n        if n > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp4hxqegfx.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for n in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for n in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp8g3g4knc.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for n in nums {\n        if n > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp4hxqegfx.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for n in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for n in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count: usize = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp7d4tsiqb.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count: usize = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    return count as f64 / nums.len() as f64;\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpwdi95lvk.rs:9:27\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return count as f64 / nums.len() as f64;\n    |                           ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut pos_count = 0;\n    for num in nums {\n        if num > 0 {\n            pos_count += 1;\n        }\n    }\n    pos_count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpks1hkyle.rs:9:24\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut pos_count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     pos_count as f64 / nums.len() as f64\n    |                        ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    return count as f64 / nums.len() as f64;\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpwdi95lvk.rs:9:27\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return count as f64 / nums.len() as f64;\n    |                           ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    return (count as f64) / (nums.len() as f64);\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp96o4tfdq.rs:9:30\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return (count as f64) / (nums.len() as f64);\n    |                              ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for n in nums {\n        if n > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp4hxqegfx.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for n in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for n in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp8g3g4knc.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for n in nums {\n        if n > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp4hxqegfx.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for n in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for n in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    nums.iter().filter(|&n| *n > 0).count() as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0.5384615384615384`,\n right: `0.54`', /tmp/tmppuoiaupn.rs:8:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    return count as f64 / nums.len() as f64;\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpwdi95lvk.rs:9:27\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return count as f64 / nums.len() as f64;\n    |                           ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count: isize = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    return (count as f64) / (nums.len() as f64);\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpt9m9n5f4.rs:9:30\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count: isize = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return (count as f64) / (nums.len() as f64);\n    |                              ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    return count as f64 / nums.len() as f64;\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpwdi95lvk.rs:9:27\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return count as f64 / nums.len() as f64;\n    |                           ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums.iter() {\n        if *num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0.5384615384615384`,\n right: `0.54`', /tmp/tmpj_03jd_c.rs:14:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut positive_count = 0;\n    for num in nums {\n        if num > 0 {\n            positive_count += 1;\n        }\n    }\n    positive_count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpactb0t61.rs:9:29\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut positive_count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     positive_count as f64 / nums.len() as f64\n    |                             ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums.iter() {\n        if *num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0.5384615384615384`,\n right: `0.54`', /tmp/tmpj_03jd_c.rs:14:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for n in nums {\n        if n > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp4hxqegfx.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for n in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for n in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums.iter() {\n        if *num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `0.5384615384615384`,\n right: `0.54`', /tmp/tmpj_03jd_c.rs:14:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpg1c4_rnv.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for n in nums {\n        if n > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp4hxqegfx.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for n in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for n in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    (count as f64) / (nums.len() as f64)\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp8g3g4knc.rs:9:23\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     (count as f64) / (nums.len() as f64)\n    |                       ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for num in nums {\n        if num > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmp_1j6nj17.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut pos_count = 0;\n    for num in nums {\n        if num > 0 {\n            pos_count += 1;\n        }\n    }\n    pos_count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1666123838,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpks1hkyle.rs:9:24\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut pos_count = 0;\n4   |     for num in nums {\n    |                ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     pos_count as f64 / nums.len() as f64\n    |                        ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for num in &nums {\n    |                +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    count as f64 / nums.len() as f64\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpekjq19lf.rs:9:20\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     count as f64 / nums.len() as f64\n    |                    ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to find the ration of positive numbers in an array of integers.\nfn positive_count(nums: Vec<isize>) -> f64 {\n    let mut count = 0;\n    for i in nums {\n        if i > 0 {\n            count += 1;\n        }\n    }\n    return (count as f64) / (nums.len() as f64);\n}\n\nfn main() {\n    let candidate = positive_count;\n    assert_eq!(candidate(vec![0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.54);\n    assert_eq!(candidate(vec![2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.69);\n    assert_eq!(candidate(vec![2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.56);\n}\n",
      "timestamp": 1665509674,
      "stdout": "",
      "stderr": "error[E0382]: borrow of moved value: `nums`\n   --> /tmp/tmpj3h68wzi.rs:9:30\n    |\n2   | fn positive_count(nums: Vec<isize>) -> f64 {\n    |                   ---- move occurs because `nums` has type `Vec<isize>`, which does not implement the `Copy` trait\n3   |     let mut count = 0;\n4   |     for i in nums {\n    |              ---- `nums` moved due to this implicit call to `.into_iter()`\n...\n9   |     return (count as f64) / (nums.len() as f64);\n    |                              ^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `nums`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n4   |     for i in &nums {\n    |              +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}