name: HumanEval_10_make_palindrome
language: cs
prompt: "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\n\
  using System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass\
  \ Problem {\n    // Find the shortest palindrome that begins with a supplied string.\n\
  \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
  \ string that is a palindrome.\n    // - Append to the end of the string reverse\
  \ of a string prefix that comes before the palindromic suffix.\n    // >>> MakePalindrome((\"\
  \"))\n    // (\"\")\n    // >>> MakePalindrome((\"cat\"))\n    // (\"catac\")\n\
  \    // >>> MakePalindrome((\"cata\"))\n    // (\"catac\")\n    public static string\
  \ MakePalindrome(string str) {\n"
tests: "    }\n    public static void Main(string[] args) {\n    Debug.Assert(MakePalindrome((\"\
  \")).Equals((\"\")));\n    Debug.Assert(MakePalindrome((\"x\")).Equals((\"x\")));\n\
  \    Debug.Assert(MakePalindrome((\"xyz\")).Equals((\"xyzyx\")));\n    Debug.Assert(MakePalindrome((\"\
  xyx\")).Equals((\"xyx\")));\n    Debug.Assert(MakePalindrome((\"jerry\")).Equals((\"\
  jerryrrej\")));\n    }\n\n}\n"
completions: ["        // Find the longest palindromic suffix.\n        int suffix_len\
    \ = 0;\n        for (int i = 0; i < str.Length; i++) {\n            int j = 0;\n\
    \            while (i - j >= 0 && i + j < str.Length && str[i - j] == str[i +\
    \ j]) {\n                j++;\n            }\n            if (j > suffix_len)\
    \ {\n                suffix_len = j;\n            }\n        }\n        // Append\
    \ the reverse of the prefix to the end of the string.\n        return str + new\
    \ string(str.Substring(0, str.Length - suffix_len).Reverse().ToArray());", " \
    \       // Find the longest palindromic suffix.\n        int suffixLength = 0;\n\
    \        for (int i = 0; i < str.Length; i++) {\n            if (str[i] == str[str.Length\
    \ - 1 - i]) {\n                suffixLength++;\n            } else {\n       \
    \         break;\n            }\n        }\n        // Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        return str + new string(str.Substring(0, str.Length - suffixLength).Reverse().ToArray());",
  "        if (str.Length == 0) {\n            return str;\n        }\n        int[]\
    \ z = ZFunction(str);\n        int max = 0;\n        for (int i = 0; i < z.Length;\
    \ i++) {\n            if (z[i] > max) {\n                max = z[i];\n       \
    \     }\n        }\n        StringBuilder sb = new StringBuilder(str);\n     \
    \   sb.Append(new string(str.Take(str.Length - max).Reverse().ToArray()));\n \
    \       return sb.ToString();", "        if (str.Length == 0) {\n            return\
    \ str;\n        }\n        // Find the longest palindromic suffix.\n        int\
    \ palindrome_suffix_length = 0;\n        for (int i = 0; i < str.Length; i++)\
    \ {\n            if (str[i] == str[str.Length - 1 - i]) {\n                palindrome_suffix_length++;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n        return str + new string(str.Take(str.Length\
    \ - palindrome_suffix_length).Reverse().ToArray());", "        int n = str.Length;\n\
    \        int[] z = new int[n];\n        z[0] = 0;\n        int l = 0, r = 0;\n\
    \        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n          \
    \      z[i] = Math.Min(r - i + 1, z[i - l]);\n            }\n            while\
    \ (i + z[i] < n && str[z[i]] == str[i + z[i]]) {\n                z[i]++;\n  \
    \          }\n            if (i + z[i] - 1 > r) {\n                l = i;\n  \
    \              r = i + z[i] - 1;\n            }\n        }\n        int max =\
    \ 0;\n        for (int i = 0; i < n; i++) {\n            if (i + z[i] == n) {\n\
    \                max = Math.Max(max, z[i]);\n            }\n        }\n      \
    \  string prefix = str.Substring(0, n - max);\n        return str + new string(prefix.Reverse().ToArray());",
  "        int n = str.Length;\n        int[] z = new int[n];\n        z[0] = 0;\n\
    \        int l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n          \
    \  z[i] = Math.Max(0, Math.Min(r - i, z[i - l]));\n            while (i + z[i]\
    \ < n && str[z[i]] == str[i + z[i]]) {\n                z[i]++;\n            }\n\
    \            if (i + z[i] > r) {\n                l = i;\n                r =\
    \ i + z[i];\n            }\n        }\n        int max = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (z[i] == n - i && i > max) {\n        \
    \        max = i;\n            }\n        }\n        return str + new string(str.Take(n\
    \ - max).Reverse().ToArray());", "        int n = str.Length;\n        int[] z\
    \ = new int[n];\n        z[0] = n;\n        int l = 0, r = 0;\n        for (int\
    \ i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i] = Math.Min(r\
    \ - i + 1, z[i - l]);\n            }\n            while (i + z[i] < n && str[z[i]]\
    \ == str[i + z[i]]) {\n                z[i]++;\n            }\n            if\
    \ (i + z[i] - 1 > r) {\n                l = i;\n                r = i + z[i] -\
    \ 1;\n            }\n        }\n        int max = 0;\n        for (int i = 1;\
    \ i < n; i++) {\n            if (z[i] == i) {\n                max = i;\n    \
    \        }\n        }\n        return str + new string(str.Substring(0, n - max).Reverse().ToArray());",
  "        int n = str.Length;\n        if (n == 0) {\n            return \"\";\n\
    \        }\n        int[] z = new int[n];\n        int l = 0, r = 0;\n       \
    \ for (int i = 1; i < n; i++) {\n            if (i <= r) {\n                z[i]\
    \ = Math.Min(r - i + 1, z[i - l]);\n            }\n            while (i + z[i]\
    \ < n && str[z[i]] == str[i + z[i]]) {\n                z[i]++;\n            }\n\
    \            if (i + z[i] - 1 > r) {\n                l = i;\n               \
    \ r = i + z[i] - 1;\n            }\n        }\n        int max = 0;\n        for\
    \ (int i = 1; i < n; i++) {\n            if (z[i] == n - i && i > max) {\n   \
    \             max = i;\n            }\n        }\n        return str + new string(str.Take(n\
    \ - max).Reverse().ToArray());", "        var sb = new StringBuilder(str);\n \
    \       var suffix = new StringBuilder();\n        for (int i = str.Length - 1;\
    \ i >= 0; i--) {\n            suffix.Append(str[i]);\n            if (IsPalindrome(str\
    \ + suffix.ToString())) {\n                sb.Append(suffix.ToString());\n   \
    \             break;\n            }\n        }\n        return sb.ToString();",
  "        if (str.Length == 0) {\n            return str;\n        }\n        int\
    \ n = str.Length;\n        int[] z = new int[n];\n        z[0] = 0;\n        int\
    \ l = 0, r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r)\
    \ {\n                z[i] = Math.Min(r - i + 1, z[i - l]);\n            }\n  \
    \          while (i + z[i] < n && str[z[i]] == str[i + z[i]]) {\n            \
    \    z[i]++;\n            }\n            if (i + z[i] - 1 > r) {\n           \
    \     l = i;\n                r = i + z[i] - 1;\n            }\n        }\n  \
    \      int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (i\
    \ + z[i] == n) {\n                max = Math.Max(max, z[i]);\n            }\n\
    \        }\n        return str + new string(str.Substring(0, n - max).Reverse().ToArray());",
  "        var sb = new StringBuilder(str);\n        var palindrome = FindPalindrome(str);\n\
    \        var prefix = str.Substring(0, str.Length - palindrome.Length);\n    \
    \    sb.Append(prefix.Reverse());\n        return sb.ToString();", "        var\
    \ sb = new StringBuilder(str);\n        var rev = new string(str.Reverse().ToArray());\n\
    \        var n = str.Length;\n        var z = new int[2 * n + 1];\n        z[0]\
    \ = 0;\n        int l = 0, r = 0;\n        for (int i = 1; i < 2 * n + 1; i++)\
    \ {\n            if (i > r) {\n                l = r = i;\n                while\
    \ (r < 2 * n + 1 && str[(r - l) / 2] == rev[r - l]) r++;\n                z[i]\
    \ = r - l;\n                r--;\n            } else {\n                int k\
    \ = i - l;\n                if (z[k] < r - i + 1) {\n                    z[i]\
    \ = z[k];\n                } else {\n                    l = i;\n            \
    \        while (r < 2 * n + 1 && str[(r - l) / 2] == rev[r - l]) r++;\n      \
    \              z[i] = r - l;\n                    r--;\n                }\n  \
    \          }\n        }\n        var max = 0;\n        for (int i = 1; i < 2 *\
    \ n + 1; i++) {\n            if (z[i] == i) {\n                max = Math.Max(max,\
    \ z[i]);\n            }\n        }\n        sb.Append(rev.Substring(0, n - max));\n\
    \        return sb.ToString();", "        int n = str.Length;\n        int[] p\
    \ = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = 0;\n\
    \        }\n        int c = 0;\n        for (int i = 1; i < n; i++) {\n      \
    \      int j = p[i - c - 1];\n            while (j > 0 && str[i] != str[c - j])\
    \ {\n                j = p[j - 1];\n            }\n            if (str[i] == str[c\
    \ - j]) {\n                j++;\n            }\n            p[i - c] = j;\n  \
    \          if (i + j - 1 > c) {\n                c = i;\n            }\n     \
    \   }\n        int l = n - p[n - c - 1];\n        return str + new string(str.Substring(0,\
    \ l).Reverse().ToArray());", "        var s = str;\n        var r = new string(str.Reverse().ToArray());\n\
    \        var z = new int[s.Length + r.Length + 1];\n        for (int i = 1; i\
    \ < z.Length; i++) {\n            if (i < r.Length) {\n                z[i] =\
    \ Math.Max(0, Math.Min(z[i - 1], r.Length - i) + Match(s, r, i, i + z[i - 1]));\n\
    \            } else {\n                z[i] = Match(s, r, i, i - r.Length);\n\
    \            }\n        }\n        var max = 0;\n        var maxi = 0;\n     \
    \   for (int i = 1; i < z.Length; i++) {\n            if (z[i] > max) {\n    \
    \            max = z[i];\n                maxi = i;\n            }\n        }\n\
    \        return str + new string(str.Substring(max, str.Length - max).Reverse().ToArray());",
  "        int n = str.Length;\n        int[] z = new int[n];\n        int l = 0,\
    \ r = 0;\n        for (int i = 1; i < n; i++) {\n            if (i <= r) {\n \
    \               z[i] = Math.Min(r - i + 1, z[i - l]);\n            }\n       \
    \     while (i + z[i] < n && str[z[i]] == str[i + z[i]]) {\n                z[i]++;\n\
    \            }\n            if (i + z[i] - 1 > r) {\n                l = i;\n\
    \                r = i + z[i] - 1;\n            }\n        }\n        int max\
    \ = 0;\n        for (int i = 0; i < n; i++) {\n            if (i + z[i] == n)\
    \ {\n                max = Math.Max(max, z[i]);\n            }\n        }\n  \
    \      return str + new string(str.Substring(0, n - max).Reverse().ToArray());",
  "        var sb = new StringBuilder(str);\n        var palindrome = FindPalindrome(str);\n\
    \        sb.Append(new string(palindrome.Reverse().ToArray()));\n        return\
    \ sb.ToString();", "        var palindrome = str;\n        var suffix = str;\n\
    \        while (suffix.Length > 0) {\n            if (IsPalindrome(suffix)) {\n\
    \                palindrome += Reverse(str.Substring(0, str.Length - suffix.Length));\n\
    \                break;\n            }\n            suffix = suffix.Substring(1);\n\
    \        }\n        return palindrome;", "        if (str.Length == 0) {\n   \
    \         return str;\n        }\n        int maxLen = 0;\n        int maxStart\
    \ = 0;\n        for (int i = 0; i < str.Length; i++) {\n            int len =\
    \ 0;\n            for (int j = 0; j <= i; j++) {\n                if (str[i -\
    \ j] == str[i + j]) {\n                    len = j + 1;\n                } else\
    \ {\n                    break;\n                }\n            }\n          \
    \  if (len > maxLen) {\n                maxLen = len;\n                maxStart\
    \ = i - len + 1;\n            }\n        }\n        StringBuilder sb = new StringBuilder(str);\n\
    \        for (int i = 0; i < str.Length - maxLen; i++) {\n            sb.Append(str[str.Length\
    \ - 1 - i]);\n        }\n        return sb.ToString();", "        var n = str.Length;\n\
    \        var palindrome = str;\n        for (var i = 0; i < n; i++) {\n      \
    \      if (IsPalindrome(str.Substring(i))) {\n                palindrome += Reverse(str.Substring(0,\
    \ i));\n                break;\n            }\n        }\n        return palindrome;",
  "        // Find the longest palindromic suffix.\n        int suffix_len = 0;\n\
    \        for (int i = 0; i < str.Length; i++) {\n            if (str[i] == str[str.Length\
    \ - 1 - i]) {\n                suffix_len++;\n            } else {\n         \
    \       break;\n            }\n        }\n        // Append the reverse of the\
    \ prefix.\n        return str + new string(str.Substring(0, str.Length - suffix_len).Reverse().ToArray());"]
stop_tokens:
- "\n    }\n"
