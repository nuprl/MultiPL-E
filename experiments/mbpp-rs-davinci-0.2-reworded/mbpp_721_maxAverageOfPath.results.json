{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "rs",
  "prompt": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpmgdtmwy5.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp73hbjw98.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpelquw_ef.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpveq_o2fq.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpetsm_1ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmperje9b7n.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpetsm_1ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j].max(dp[i][j - 1]) + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.75`,\n right: `5.2`', /tmp/tmp50d0amwh.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (n * 2 - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpetsm_1ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp73hbjw98.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp73hbjw98.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64\n                + f64::max(dp[i - 1][j], dp[i][j - 1])\n                / f64::from(i + j);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `f64: From<usize>` is not satisfied\n  --> /tmp/tmphw3iod11.rs:15:19\n   |\n15 |                 / f64::from(i + j);\n   |                   ^^^^^^^^^ the trait `From<usize>` is not implemented for `f64`\n   |\n   = help: the following other types implement trait `From<T>`:\n             <f32 as From<i16>>\n             <f32 as From<i8>>\n             <f32 as From<u16>>\n             <f32 as From<u8>>\n             <f64 as From<f32>>\n             <f64 as From<i16>>\n             <f64 as From<i32>>\n             <f64 as From<i8>>\n           and 67 others\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpatlq3hrs.rs:13:37\n   |\n13 |             dp[i][j] = cost[i][j] + max(dp[i - 1][j], dp[i][j - 1]);\n   |                                     ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpm7duuk6u.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpetsm_1ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpcw2b03rd.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpelquw_ef.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmp4b7yusqa.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpelquw_ef.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost.len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost.len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost.len() - 1] as f64 / (2 * cost.len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + (dp[i - 1][j] + dp[i][j - 1]) / 2;\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.4444444444444446`,\n right: `5.2`', /tmp/tmpuawr9f3j.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp73hbjw98.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp3adc5nfr.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpetsm_1ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp221_3alr.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpab0cejx4.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp73hbjw98.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp: Vec<Vec<f64>> = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpdsj93l75.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpatlq3hrs.rs:13:37\n   |\n13 |             dp[i][j] = cost[i][j] + max(dp[i - 1][j], dp[i][j - 1]);\n   |                                     ^^^ not found in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost.len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost.len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost.len() {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[cost.len() - 1][cost.len() - 1] / (cost.len() as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp01s9ptqh.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1])) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `14.0`,\n right: `5.2`', /tmp/tmp_iq516_l.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpelquw_ef.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpj1aae0r4.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpo9kpz69f.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpmcnh3orr.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpetsm_1ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    for i in 0..cost.len() {\n        for j in 0..cost[0].len() {\n            if i == 0 && j == 0 {\n                dp[i][j] = cost[i][j] as f64;\n            } else if i == 0 {\n                dp[i][j] = dp[i][j - 1] + cost[i][j] as f64;\n            } else if j == 0 {\n                dp[i][j] = dp[i - 1][j] + cost[i][j] as f64;\n            } else {\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n            }\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.5`,\n right: `5.2`', /tmp/tmpe1sdh9os.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpeznmr26e.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpmcnh3orr.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / ((cost.len() + cost[0].len() - 1) as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / ((cost.len() + cost[0].len() - 1) as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpj1aae0r4.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp1u3qjzqm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpelquw_ef.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    let mut total = 0;\n    let mut i = cost.len() - 1;\n    let mut j = cost[0].len() - 1;\n    while i != 0 || j != 0 {\n        total += cost[i][j];\n        if i == 0 {\n            j -= 1;\n        } else if j == 0 {\n            i -= 1;\n        } else {\n            if dp[i - 1][j] > dp[i][j - 1] {\n                i -= 1;\n            } else {\n                j -= 1;\n            }\n        }\n    }\n    total as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `5.0`,\n right: `5.2`', /tmp/tmpyij4eflp.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp038r0i15.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j].max(dp[i][j - 1]) + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124096,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.75`,\n right: `5.2`', /tmp/tmp50d0amwh.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost.len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost.len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost.len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost.len() - 1] / (cost.len() as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpqja1v80n.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1])) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.666666666666667`,\n right: `5.2`', /tmp/tmpbmt6jck0.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (2 * n - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (n * 2 - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmpe2onl60f.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmprgxg12h_.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1])) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `4.666666666666667`,\n right: `5.2`', /tmp/tmp6uk8zlbl.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (2 * n - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1])) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `14.0`,\n right: `5.2`', /tmp/tmpbog1u2hq.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0];\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j];\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] as f64 / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpelquw_ef.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpfk09llse.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpveq_o2fq.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpmgdtmwy5.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp3adc5nfr.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (2 * n - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0; n]; n];\n    dp[0][0] = cost[0][0];\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] + std::cmp::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] as f64 / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp4740ewx_.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmp038r0i15.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmpx8cntlmm.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + f64::max(dp[i - 1][j], dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..cost[0].len() {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp81s373qi.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmp3adc5nfr.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..n {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmpelquw_ef.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpdrrd_ntj.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    let n = cost.len();\n    let m = cost[0].len();\n    dp[n - 1][m - 1] / (n + m - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpfmwf6wq2.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1]));\n        }\n    }\n    dp[n - 1][n - 1] / (n * n) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `2.888888888888889`,\n right: `5.2`', /tmp/tmprgxg12h_.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j] + dp[i][j - 1]) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `7.5`,\n right: `5.2`', /tmp/tmp73hbjw98.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n    }\n    for i in 1..n {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + cost[i][j] as f64) / 2.0;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `15.0`,\n right: `5.2`', /tmp/tmpetsm_1ds.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = cost[i][j] as f64 + dp[i - 1][j].max(dp[i][j - 1]);\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1] / (cost.len() + cost[0].len() - 1) as f64\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = cost[i][j] as f64 + (dp[i - 1][j].max(dp[i][j - 1])) / 2.0;\n        }\n    }\n\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1666124097,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `14.0`,\n right: `5.2`', /tmp/tmpnijzfuj5.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + cost[i][j] as f64).max(dp[i][j - 1] + cost[i][j] as f64);\n        }\n    }\n    dp[n - 1][n - 1] / (n as f64)\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `8.666666666666666`,\n right: `5.2`', /tmp/tmpveq_o2fq.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let n = cost.len();\n    let mut dp = vec![vec![0.0; n]; n];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..n {\n        dp[0][i] = dp[0][i - 1] + cost[0][i] as f64;\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for i in 1..n {\n        for j in 1..n {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[n - 1][n - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp1ma0t85m.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Given a square matrix of size N*N given as a vector of vectors, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfn maxAverageOfPath(cost: Vec<Vec<isize>>) -> f64 {\n    let mut dp = vec![vec![0.0; cost[0].len()]; cost.len()];\n    dp[0][0] = cost[0][0] as f64;\n    for i in 1..cost.len() {\n        dp[i][0] = dp[i - 1][0] + cost[i][0] as f64;\n    }\n    for j in 1..cost[0].len() {\n        dp[0][j] = dp[0][j - 1] + cost[0][j] as f64;\n    }\n    for i in 1..cost.len() {\n        for j in 1..cost[0].len() {\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) / 2.0 + cost[i][j] as f64;\n        }\n    }\n    dp[cost.len() - 1][cost[0].len() - 1]\n}\n\nfn main() {\n    let candidate = maxAverageOfPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![6, 5, 4], vec![7, 3, 9]]), 5.2);\n    assert_eq!(candidate(vec![vec![2, 3, 4], vec![7, 6, 5], vec![8, 4, 10]]), 6.2);\n    assert_eq!(candidate(vec![vec![3, 4, 5], vec![8, 7, 6], vec![9, 5, 11]]), 7.2);\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]), 5.8);\n}\n",
      "timestamp": 1665509922,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `22.5`,\n right: `5.2`', /tmp/tmp7r3pley7.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    }
  ]
}