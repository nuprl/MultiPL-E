{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "rs",
  "prompt": "/// Write a function to find k number of smallest pairs which consist of one element from the first vector and one element from the second vector.\nfn k_smallest_pairs(nums1: Vec<isize>, nums2: Vec<isize>, k: isize) -> Vec<Vec<isize>> {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\nfn main() {\n    let candidate = k_smallest_pairs;\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 2), vec![vec![1, 2], vec![1, 4]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 1), vec![vec![1, 2]]);\n    assert_eq!(candidate(vec![1, 3, 7], vec![2, 4, 6], 7), vec![vec![1, 2], vec![1, 4], vec![3, 2], vec![1, 6], vec![3, 4], vec![3, 6], vec![7, 2]]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse((_, i, j))) = heap.pop() {\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res.reverse();\n    res",
    "    let mut res = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push((-sum, (i, j)));\n            } else {\n                if -sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push((-sum, (i, j)));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let (sum, (i, j)) = heap.pop().unwrap();\n        res.push(vec![nums1[i], nums2[j]]);\n    }\n    res",
    "    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push((nums1[i] + nums2[0], i, 0));\n    }\n    while k > 0 && !heap.is_empty() {\n        let (sum, i, j) = heap.pop().unwrap();\n        result.push(vec![nums1[i], nums2[j]]);\n        if j + 1 < nums2.len() {\n            heap.push((nums1[i] + nums2[j + 1], i, j + 1));\n        }\n        k -= 1;\n    }\n    result",
    "    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse((sum, (i, j))));\n        }\n    }\n    let mut res = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res",
    "    let mut res = vec![];\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pq.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = pq.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res",
    "    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for (i, n1) in nums1.iter().enumerate() {\n        for (j, n2) in nums2.iter().enumerate() {\n            heap.push((*n1 + *n2, *n1, *n2));\n        }\n    }\n    for _ in 0..k {\n        if let Some((_, n1, n2)) = heap.pop() {\n            result.push(vec![n1, n2]);\n        }\n    }\n    result",
    "    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            if heap.len() < k as usize {\n                heap.push((nums1[i] + nums2[j], nums1[i], nums2[j]));\n            } else {\n                if nums1[i] + nums2[j] < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push((nums1[i] + nums2[j], nums1[i], nums2[j]));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let (sum, num1, num2) = heap.pop().unwrap();\n        result.push(vec![num1, num2]);\n    }\n    result",
    "    let mut res = vec![];\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    res.truncate(k as usize);\n    res",
    "    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], (i, j))));\n        }\n    }\n    let mut res = Vec::new();\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = heap.pop() {\n            res.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    res",
    "    let mut res = vec![];\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse((sum, vec![nums1[i], nums2[j]])));\n                }\n            }\n        }\n    }\n    for i in heap {\n        res.push(i.0);\n    }\n    res",
    "    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, isize, isize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push((nums1[i] + nums2[j], i, j));\n        }\n    }\n    for _ in 0..k {\n        if let Some((_, i, j)) = heap.pop() {\n            result.push(vec![nums1[i as usize], nums2[j as usize]]);\n        }\n    }\n    result",
    "    let mut result = Vec::new();\n    if nums1.len() == 0 || nums2.len() == 0 {\n        return result;\n    }\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push(Pair {\n            sum: nums1[i] + nums2[0],\n            index1: i,\n            index2: 0,\n        });\n    }\n    let mut count = 0;\n    while count < k && !heap.is_empty() {\n        let pair = heap.pop().unwrap();\n        result.push(vec![nums1[pair.index1], nums2[pair.index2]]);\n        count += 1;\n        if pair.index2 + 1 < nums2.len() {\n            heap.push(Pair {\n                sum: nums1[pair.index1] + nums2[pair.index2 + 1],\n                index1: pair.index1,\n                index2: pair.index2 + 1,\n            });\n        }\n    }\n    result",
    "    let mut result = Vec::new();\n    let mut pq = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            pq.push(Reverse((sum, (i, j))));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((_, (i, j)))) = pq.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result",
    "    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                let top = heap.peek().unwrap();\n                if sum < top.0 {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let top = heap.pop().unwrap();\n        result.push(vec![top.0]);\n    }\n    result",
    "    let mut result: Vec<Vec<isize>> = Vec::new();\n    let mut heap: BinaryHeap<(isize, usize, usize)> = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        heap.push((nums1[i] + nums2[0], i, 0));\n    }\n    while result.len() < k as usize && !heap.is_empty() {\n        let (sum, i, j) = heap.pop().unwrap();\n        result.push(vec![nums1[i], nums2[j]]);\n        if j + 1 < nums2.len() {\n            heap.push((nums1[i] + nums2[j + 1], i, j + 1));\n        }\n    }\n    result",
    "    let mut pairs = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            pairs.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    pairs.sort_by(|a, b| (a[0] + a[1]).cmp(&(b[0] + b[1])));\n    pairs.iter().take(k as usize).map(|x| x.to_vec()).collect()",
    "    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((sum, i, j))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result",
    "    let mut heap = BinaryHeap::new();\n    let mut result = Vec::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            heap.push(Reverse(sum));\n            if heap.len() > k as usize {\n                heap.pop();\n            }\n        }\n    }\n    while let Some(Reverse(sum)) = heap.pop() {\n        let mut pair = Vec::new();\n        pair.push(sum - nums2[0]);\n        pair.push(nums2[0]);\n        result.push(pair);\n    }\n    result",
    "    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            heap.push(Reverse((nums1[i] + nums2[j], i, j)));\n        }\n    }\n    for _ in 0..k {\n        if let Some(Reverse((sum, i, j))) = heap.pop() {\n            result.push(vec![nums1[i], nums2[j]]);\n        }\n    }\n    result",
    "    let mut result = Vec::new();\n    let mut heap = BinaryHeap::new();\n    for i in 0..nums1.len() {\n        for j in 0..nums2.len() {\n            let sum = nums1[i] + nums2[j];\n            if heap.len() < k as usize {\n                heap.push(Reverse(sum));\n            } else {\n                if sum < heap.peek().unwrap().0 {\n                    heap.pop();\n                    heap.push(Reverse(sum));\n                }\n            }\n        }\n    }\n    while !heap.is_empty() {\n        let Reverse(sum) = heap.pop().unwrap();\n        let mut pair = Vec::new();\n        for i in 0..nums1.len() {\n            for j in 0..nums2.len() {\n                if nums1[i] + nums2[j] == sum {\n                    pair.push(nums1[i]);\n                    pair.push(nums2[j]);\n                    break;\n                }\n            }\n            if !pair.is_empty() {\n                break;\n            }\n        }\n        result.push(pair);\n    }\n    result"
  ]
}