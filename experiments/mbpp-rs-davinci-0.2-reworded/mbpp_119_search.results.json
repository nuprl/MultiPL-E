{
  "name": "mbpp_119_search",
  "language": "rs",
  "prompt": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpokqjwr7s.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low: usize = 0;\n    let mut high: usize = arr.len() - 1;\n    let mut mid: usize = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            break;\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            break;\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while start < end {\n        let mid = (start + end) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2;\n            } else {\n                end = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    arr[start]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low < high {\n        mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\n    while left < right {\n        let mid = left + (right - left) / 2;\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid;\n\n    while low < high {\n        mid = low + (high - low) / 2;\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while start <= end {\n        let mid = start + (end - start) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2;\n            } else {\n                end = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    arr[start]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', /tmp/tmpq6oa7qbk.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid;\n\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpnng6eygi.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut l = 0;\n    let mut r = arr.len() - 1;\n    while l < r {\n        let m = (l + r) / 2;\n        if m % 2 == 0 {\n            if arr[m] == arr[m + 1] {\n                l = m + 2;\n            } else {\n                r = m;\n            }\n        } else {\n            if arr[m] == arr[m - 1] {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n    }\n    arr[l]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut l = 0;\n    let mut r = arr.len() - 1;\n    while l < r {\n        let m = (l + r) / 2;\n        if m % 2 == 0 {\n            if arr[m] == arr[m + 1] {\n                l = m + 2;\n            } else {\n                r = m;\n            }\n        } else {\n            if arr[m] == arr[m - 1] {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n    }\n    arr[l]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\n    while left < right {\n        let mid = (left + right) / 2;\n\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                left = mid + 1;\n            } else {\n                right = mid - 2;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                left = mid + 2;\n            } else {\n                right = mid - 1;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpbqoosvim.rs:9:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpasbh1nns.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpy7ix90tn.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n\n    while i < j {\n        let mid = (i + j) / 2;\n        if arr[mid] == arr[mid - 1] {\n            if (mid - i) % 2 == 0 {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (j - mid) % 2 == 0 {\n                j = mid - 1;\n            } else {\n                i = mid + 1;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp8_7se5pl.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp56bv9drj.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    let mut mid = 0;\n    while start <= end {\n        mid = (start + end) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2;\n            } else {\n                start = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                start = mid + 2;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid;\n\n    while low < high {\n        mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return arr[low];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left <= right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid - 1;\n            }\n        } else {\n            if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpquav1dwb.rs:11:25\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if mid == 0 {\n            return arr[mid];\n        }\n        if mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpt5hfgu8x.rs:35:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut l = 0;\n    let mut r = arr.len() - 1;\n    while l < r {\n        let m = l + (r - l) / 2;\n        if m % 2 == 0 {\n            if arr[m] == arr[m + 1] {\n                l = m + 2;\n            } else {\n                r = m;\n            }\n        } else {\n            if arr[m] == arr[m - 1] {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n    }\n    arr[l]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    let mut mid = 0;\n\n    while start <= end {\n        mid = (start + end) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2;\n            } else {\n                end = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n\n    arr[mid]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while start <= end {\n        let mid = (start + end) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2;\n            } else {\n                start = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                start = mid + 2;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n    arr[mid]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpp8s16f5n.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[low];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpt8bl6_li.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = (low + high) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low < high {\n        let mid = (low + high) / 2;\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left <= right {\n        let mid = left + (right - left) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\n    while left < right {\n        let mid = left + (right - left) / 2;\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpnfhwj2w2.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp1ettgesf.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', /tmp/tmp5q5no38t.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2;\n            } else {\n                return arr[mid];\n            }\n        } else {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                high = mid - 1;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                return arr[mid];\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp1r5r6jyh.rs:11:23\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = (low + high) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\n    while left < right {\n        let mid = (left + right) / 2;\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    0\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                j = mid - 2;\n            } else {\n                i = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                j = mid - 1;\n            } else {\n                i = mid + 2;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpxwky4c34.rs:7:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp1ettgesf.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', /tmp/tmp5q5no38t.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpvpi10vt2.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = (low + high) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp4tavajgq.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut l = 0;\n    let mut r = arr.len() - 1;\n    while l < r {\n        let m = l + (r - l) / 2;\n        if m % 2 == 0 {\n            if arr[m] == arr[m + 1] {\n                l = m + 2;\n            } else {\n                r = m;\n            }\n        } else {\n            if arr[m] == arr[m - 1] {\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n    }\n    arr[l]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[mid]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', /tmp/tmppkus0d1h.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid;\n    while low < high {\n        mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', /tmp/tmp5q5no38t.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2;\n            } else {\n                return arr[mid];\n            }\n        } else {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                high = mid - 1;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                return arr[mid];\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpka7ut8j4.rs:10:23\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpdd9npehn.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpasbh1nns.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = i + (j - i) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left <= right {\n        let mid = (left + right) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = (low + high) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[low];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', /tmp/tmphm_vbm9x.rs:8:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp1djx4x44.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 {\n            return arr[mid];\n        }\n        if mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpgn_krxeg.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while start <= end {\n        let mid = start + (end - start) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2;\n            } else {\n                start = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                start = mid + 2;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 {\n            if arr[mid] != arr[mid + 1] {\n                return arr[mid];\n            } else {\n                low = mid + 1;\n            }\n        } else if mid == arr.len() - 1 {\n            if arr[mid] != arr[mid - 1] {\n                return arr[mid];\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n                return arr[mid];\n            } else if arr[mid] == arr[mid - 1] {\n                if mid % 2 == 0 {\n                    high = mid - 2;\n                } else {\n                    low = mid + 1;\n                }\n            } else if arr[mid] == arr[mid + 1] {\n                if mid % 2 == 0 {\n                    low = mid + 2;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmptyi6171t.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpasbh1nns.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                i = mid + 1;\n            } else {\n                j = mid - 2;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                i = mid + 2;\n            } else {\n                j = mid - 1;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if arr[mid] == arr[mid - 1] {\n            if (mid - i) % 2 == 0 {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (j - mid) % 2 == 0 {\n                j = mid - 1;\n            } else {\n                i = mid + 1;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp6t2noxhq.rs:7:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2;\n            } else {\n                return arr[mid];\n            }\n        } else {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                high = mid - 1;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                return arr[mid];\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmphp8t9yy_.rs:11:23\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp3b2o5c_f.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpy7ix90tn.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpxikkwkrd.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    let mut mid = 0;\n    while start <= end {\n        mid = (start + end) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                start = mid + 2;\n            } else {\n                end = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    arr[mid]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', /tmp/tmp8__v30l5.rs:9:28\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = (low + high) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (mid + 1) % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp057tu1zi.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    let mut mid = 0;\n    while i <= j {\n        mid = (i + j) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                j = mid - 1;\n            } else {\n                i = mid + 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpaw2d_10v.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while start <= end {\n        let mid = start + (end - start) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if (mid - 1) % 2 == 0 {\n                end = mid - 2;\n            } else {\n                start = mid + 1;\n            }\n        } else {\n            if (mid - 1) % 2 == 0 {\n                start = mid + 2;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmp225ei99c.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpdd9npehn.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    let mut mid = 0;\n\n    while start <= end {\n        mid = (start + end) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2;\n            } else {\n                start = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                start = mid + 2;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpy7ix90tn.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low: usize = 0;\n    let mut high: usize = arr.len() - 1;\n    let mut mid: usize;\n\n    while low <= high {\n        mid = low + (high - low) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = (low + high) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] && mid % 2 == 0 {\n            low = mid + 1;\n        } else if arr[mid] == arr[mid + 1] && mid % 2 == 1 {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpmsbgdoq2.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high {\n        let mid = (low + high) / 2;\n\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `3`', /tmp/tmpy7ix90tn.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    while start <= end {\n        let mid = start + (end - start) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                end = mid - 2;\n            } else {\n                start = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                start = mid + 2;\n            } else {\n                end = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n    let mut mid = 0;\n    while start <= end {\n        mid = (start + end) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if (mid % 2 == 0 && arr[mid] == arr[mid + 1]) || (mid % 2 == 1 && arr[mid] == arr[mid - 1]) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                high = mid - 2;\n            } else {\n                return arr[mid];\n            }\n        } else {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                high = mid - 1;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                return arr[mid];\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpka7ut8j4.rs:10:23\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low <= high {\n        let mid = low + (high - low) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n\n    while low <= high {\n        mid = (low + high) / 2;\n        if mid == 0 || mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        } else if arr[mid] == arr[mid - 1] {\n            if mid % 2 == 0 {\n                high = mid - 2;\n            } else {\n                low = mid + 1;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if mid % 2 == 0 {\n                low = mid + 2;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut lo = 0;\n    let mut hi = arr.len() - 1;\n    while lo < hi {\n        let mid = lo + (hi - lo) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                lo = mid + 2;\n            } else {\n                hi = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                lo = mid + 1;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n    arr[lo]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = low + (high - low) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123362,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if arr[mid] == arr[mid - 1] {\n            if (mid - 1 - i) % 2 == 0 {\n                i = mid + 1;\n            } else {\n                j = mid - 2;\n            }\n        } else if arr[mid] == arr[mid + 1] {\n            if (j - mid - 1) % 2 == 0 {\n                j = mid - 1;\n            } else {\n                i = mid + 2;\n            }\n        } else {\n            return arr[mid];\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = (left + right) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    while low < high {\n        let mid = (low + high) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    arr[low]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut i = 0;\n    let mut j = arr.len() - 1;\n    while i < j {\n        let mid = (i + j) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                i = mid + 2;\n            } else {\n                j = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                i = mid + 1;\n            } else {\n                j = mid - 1;\n            }\n        }\n    }\n    arr[i]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut start = 0;\n    let mut end = arr.len() - 1;\n\n    while start <= end {\n        let mid = start + (end - start) / 2;\n\n        if mid % 2 == 0 {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                start = mid + 2;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                end = mid - 2;\n            } else {\n                return arr[mid];\n            }\n        } else {\n            if mid + 1 < arr.len() && arr[mid] == arr[mid + 1] {\n                end = mid - 1;\n            } else if mid - 1 >= 0 && arr[mid] == arr[mid - 1] {\n                start = mid + 1;\n            } else {\n                return arr[mid];\n            }\n        }\n    }\n\n    -1\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpdho7ifxs.rs:12:23\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n    while left < right {\n        let mid = left + (right - left) / 2;\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                left = mid + 2;\n            } else {\n                right = mid;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    arr[left]\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1665517410,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a rsthon function to find the element that appears only once in a sorted vector.\nfn search(arr: Vec<isize>) -> isize {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n    let mut mid = 0;\n    while low <= high {\n        mid = low + (high - low) / 2;\n        if mid == 0 {\n            return arr[mid];\n        }\n        if mid == arr.len() - 1 {\n            return arr[mid];\n        }\n        if arr[mid] != arr[mid - 1] && arr[mid] != arr[mid + 1] {\n            return arr[mid];\n        }\n        if mid % 2 == 0 {\n            if arr[mid] == arr[mid + 1] {\n                low = mid + 2;\n            } else {\n                high = mid - 2;\n            }\n        } else {\n            if arr[mid] == arr[mid - 1] {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n    }\n    return arr[mid];\n}\n\nfn main() {\n    let candidate = search;\n    assert_eq!(candidate(vec![1, 1, 2, 2, 3]), 3);\n    assert_eq!(candidate(vec![1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]), 8);\n    assert_eq!(candidate(vec![1, 2, 2, 3, 3, 4, 4]), 1);\n}\n",
      "timestamp": 1666123363,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}