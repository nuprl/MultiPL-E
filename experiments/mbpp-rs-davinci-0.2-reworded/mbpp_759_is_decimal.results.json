{
  "name": "mbpp_759_is_decimal",
  "language": "rs",
  "prompt": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            count += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n    }\n    let mut nums: Vec<&str> = num.split('.').collect();\n    if nums.len() == 1 {\n        return nums[0].parse::<i32>().is_ok();\n    }\n    if nums[1].len() > 2 {\n        return false;\n    }\n    nums[0].parse::<i32>().is_ok() && nums[1].parse::<i32>().is_ok()\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut is_decimal = false;\n    let mut decimal_count = 0;\n    let mut decimal_index = 0;\n    let mut is_negative = false;\n    let mut is_positive = false;\n    let mut is_zero = false;\n    let mut is_digit = false;\n    let mut is_digit_after_decimal = false;\n    let mut is_digit_before_decimal = false;\n    let mut is_digit_after_negative = false;\n    let mut is_digit_after_positive = false;\n    let mut is_digit_after_zero = false;\n    let mut is_digit_before_decimal_after_negative = false;\n    let mut is_digit_before_decimal_after_positive = false;\n    let mut is_digit_before_decimal_after_zero = false;\n    let mut is_digit_after_decimal_after_negative = false;\n    let mut is_digit_after_decimal_after_positive = false;\n    let mut is_digit_after_decimal_after_zero = false;\n\n    for (i, c) in num.chars().enumerate() {\n        if c == '-' {\n            if is_negative || is_positive || is_zero || is_digit || is_digit_after_decimal || is_digit_before_decimal {\n                return false;\n            }\n            is_negative = true;\n        } else if c == '+' {\n            if is_negative || is_positive || is_zero || is_digit || is_digit_after_decimal || is_digit_before_decimal {\n                return false;\n            }\n            is_positive = true;\n        } else if c == '0' {\n            if is_negative || is_positive || is_zero || is_digit || is_digit_after_decimal || is_digit_before_decimal {\n                return false;\n            }\n            is_zero = true;\n        } else if c == '.' {\n            if decimal_count > 0 || is_negative || is_positive || is_zero || is_digit || is_digit_after_decimal || is_digit\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1hy7z53b.rs:49:3\n   |\n2  | fn is_decimal(num: String) -> bool {\n   |                                    - unclosed delimiter\n...\n22 |     for (i, c) in num.chars().enumerate() {\n   |                                           - unclosed delimiter\n...\n38 |         } else if c == '.' {\n   |                            - this delimiter might not be properly closed...\n39 |             if decimal_count > 0 || is_negative || is_positive || is_zero || is_digit || is_digit_after_decimal || is_digit\n40 | }\n   | - ...as it matches this but it has different indentation\n...\n49 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp1hy7z53b.rs:40:1\n   |\n39 |             if decimal_count > 0 || is_negative || is_positive || is_zero || is_digit || is_digit_after_decimal || is_digit\n   |             -- this `if` expression has a condition, but no block\n40 | }\n   | ^ expected `{`\n\nerror[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmp1hy7z53b.rs:43:21\n   |\n43 |     let candidate = is_decimal;\n   |                     ^^^^^^^^^^\n   |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1hy7z53b.rs:22:5\n   |\n2  |   fn is_decimal(num: String) -> bool {\n   |                                 ---- expected `bool` because of return type\n...\n22 | /     for (i, c) in num.chars().enumerate() {\n23 | |         if c == '-' {\n24 | |             if is_negative || is_positive || is_zero || is_digit || is_digit_after_decimal || is_digit_before_decimal {\n25 | |                 return false;\n...  |\n48 | |     assert_eq!(candidate(String::from(\"1.1.11\")), false);\n49 | | }\n   | |__^ expected `bool`, found `()`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0434.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    let mut decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal {\n            count += 1;\n        }\n    }\n    count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num = num.chars();\n    let mut decimal = false;\n    let mut precision = 0;\n    while let Some(c) = num.next() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal {\n            precision += 1;\n        }\n    }\n    precision == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpu4oumkw8.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            break;\n        }\n    }\n    if decimal_index == 0 {\n        return false;\n    }\n    let decimal_part = &num[decimal_index + 1..];\n    if decimal_part.len() > 2 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpjg2anxi1.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut chars = num.chars();\n    let mut seen_decimal = false;\n    let mut seen_digit = false;\n    let mut seen_precision = 0;\n    while let Some(c) = chars.next() {\n        match c {\n            '0'...'9' => {\n                seen_digit = true;\n                if seen_decimal {\n                    seen_precision += 1;\n                }\n            }\n            '.' => {\n                if seen_decimal {\n                    return false;\n                }\n                seen_decimal = true;\n            }\n            _ => return false,\n        }\n    }\n    seen_digit && seen_precision <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut is_decimal = false;\n    let mut decimal_count = 0;\n    let mut is_negative = false;\n    let mut is_positive = false;\n    let mut is_zero = false;\n    let mut is_digit = false;\n    let mut is_dot = false;\n    let mut is_precision = false;\n\n    for c in num.chars() {\n        if c == '-' {\n            if is_negative || is_positive || is_zero || is_digit {\n                return false;\n            }\n            is_negative = true;\n        } else if c == '+' {\n            if is_negative || is_positive || is_zero || is_digit {\n                return false;\n            }\n            is_positive = true;\n        } else if c == '0' {\n            if is_zero || is_digit {\n                return false;\n            }\n            is_zero = true;\n        } else if c.is_digit(10) {\n            if is_zero || is_digit {\n                return false;\n            }\n            is_digit = true;\n        } else if c == '.' {\n            if is_dot {\n                return false;\n            }\n            is_dot = true;\n        } else {\n            return false;\n        }\n        if is_dot {\n            decimal_count += 1;\n        }\n        if decimal_count > 2 {\n            return false;\n        }\n    }\n    is_decimal = true;\n    is_decimal\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm0ukl1bz.rs:54:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut iter = num.chars();\n    let mut has_decimal = false;\n    let mut has_digit = false;\n    while let Some(c) = iter.next() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            has_digit = true;\n        } else {\n            return false;\n        }\n    }\n    if has_decimal && has_digit {\n        let mut iter = num.chars();\n        let mut decimal_count = 0;\n        while let Some(c) = iter.next() {\n            if c == '.' {\n                break;\n            }\n            decimal_count += 1;\n        }\n        if decimal_count > 1 {\n            return false;\n        }\n        let mut iter = num.chars().rev();\n        let mut decimal_count = 0;\n        while let Some(c) = iter.next() {\n            if c == '.' {\n                break;\n            }\n            decimal_count += 1;\n        }\n        if decimal_count > 2 {\n            return false;\n        }\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpzs0_ropa.rs:48:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n            continue;\n        }\n        if !decimal_found {\n            continue;\n        }\n        decimal_count += 1;\n        if decimal_count > 2 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp9gjvu73a.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num = num.chars();\n    let mut dot_count = 0;\n    let mut digit_count = 0;\n    while let Some(c) = num.next() {\n        if c == '.' {\n            dot_count += 1;\n            if dot_count > 1 {\n                return false;\n            }\n        } else if c.is_digit(10) {\n            digit_count += 1;\n            if digit_count > 2 {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmple_1ovjg.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut iter = num.chars();\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    let mut digit_count = 0;\n    while let Some(c) = iter.next() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n            continue;\n        }\n        if !c.is_digit(10) {\n            return false;\n        }\n        if decimal_found {\n            decimal_count += 1;\n        }\n        digit_count += 1;\n    }\n    if decimal_count > 2 {\n        return false;\n    }\n    if digit_count == 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut num_vec: Vec<&str> = num.split('.').collect();\n    if num_vec.len() == 1 {\n        return true;\n    }\n    if num_vec[1].len() > 2 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmptsprqmkz.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            } else {\n                has_decimal = true;\n            }\n        } else if !c.is_digit(10) {\n            return false;\n        } else if has_decimal {\n            decimal_count += 1;\n        }\n    }\n\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut num_count = 0;\n    let mut is_decimal = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            is_decimal = true;\n        } else if c.is_numeric() {\n            num_count += 1;\n        }\n    }\n\n    if decimal_count > 1 {\n        return false;\n    }\n\n    if is_decimal && num_count > 2 {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwyeuwiug.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num_chars = num.chars();\n    let mut decimal_found = false;\n    let mut decimal_count = 0;\n    let mut digit_count = 0;\n    while let Some(c) = num_chars.next() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n    if decimal_count > 2 {\n        return false;\n    }\n    if digit_count == 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    num.parse::<f64>().is_ok()\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpn8bpwegz.rs:10:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut dot_count = 0;\n    let mut digit_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            dot_count += 1;\n        } else if c.is_digit(10) {\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n    if dot_count > 1 {\n        return false;\n    }\n    if dot_count == 0 {\n        return true;\n    }\n    if digit_count > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp5lhzyg70.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            is_decimal = true;\n        } else if is_decimal {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpcrr5m5xd.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_index = 0;\n    let mut index = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            decimal_index = index;\n        }\n        index += 1;\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    if decimal_count == 0 {\n        return true;\n    }\n    if decimal_index + 3 < num.len() {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp66hzn4wb.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^-?\\d*\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpainjjgm8.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^-?\\d*\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num_chars = num.chars();\n    let mut has_decimal = false;\n    let mut has_digit = false;\n    while let Some(c) = num_chars.next() {\n        match c {\n            '0'...'9' => has_digit = true,\n            '.' => {\n                if has_decimal {\n                    return false;\n                }\n                has_decimal = true;\n            }\n            _ => return false,\n        }\n    }\n    has_digit && has_decimal\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpzjjte8c5.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    if has_decimal && decimal_count == 2 {\n        return true;\n    }\n\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num_chars = num.chars();\n    let mut decimal_found = false;\n    let mut decimal_count = 0;\n\n    while let Some(c) = num_chars.next() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal = false;\n    let mut precision = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal = true;\n        } else if c.is_digit(10) {\n            if decimal {\n                precision += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    precision <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            count += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n    }\n    let num_vec: Vec<&str> = num.split('.').collect();\n    if num_vec.len() == 1 {\n        return true;\n    }\n    if num_vec[1].len() > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmppe0cng1j.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        match c {\n            '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => {\n                if decimal_found {\n                    decimal_count += 1;\n                }\n            }\n            '.' => {\n                if decimal_found {\n                    return false;\n                }\n                decimal_found = true;\n            }\n            _ => return false,\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp52xgbvws.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n            continue;\n        }\n        if decimal_found {\n            decimal_count += 1;\n            if decimal_count > 2 {\n                return false;\n            }\n        }\n        if !c.is_digit(10) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_decimal = false;\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if has_decimal {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal = false;\n    let mut precision = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if c.is_digit(10) {\n            if decimal {\n                precision += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    precision <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut iter = num.chars();\n    let mut dot_count = 0;\n    let mut digit_count = 0;\n    while let Some(c) = iter.next() {\n        if c == '.' {\n            dot_count += 1;\n        } else if c.is_digit(10) {\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n    if dot_count == 1 && digit_count == 3 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpqla3f5nj.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            is_decimal = true;\n        }\n        if !c.is_digit(10) && c != '.' {\n            return false;\n        }\n    }\n    if is_decimal && decimal_count == 1 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpbog0h0rl.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num = num.chars();\n    let mut decimal = false;\n    let mut decimal_count = 0;\n    while let Some(c) = num.next() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_index = 0;\n    for (index, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_count += 1;\n            decimal_index = index;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    if decimal_count == 0 {\n        return true;\n    }\n    if decimal_index + 3 == num.len() {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpjnwuje41.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut is_decimal = false;\n    let mut decimal_count = 0;\n    let mut decimal_index = 0;\n    let mut is_negative = false;\n    let mut is_positive = false;\n    let mut is_zero = false;\n    let mut is_digit = false;\n    let mut is_precision = false;\n    let mut is_precision_zero = false;\n    let mut is_precision_digit = false;\n    let mut is_precision_decimal = false;\n    let mut is_precision_decimal_zero = false;\n    let mut is_precision_decimal_digit = false;\n    let mut is_precision_decimal_digit_zero = false;\n    let mut is_precision_decimal_digit_digit = false;\n    let mut is_precision_decimal_digit_digit_zero = false;\n    let mut is_precision_decimal_digit_digit_digit = false;\n    let mut is_precision_decimal_digit_digit_digit_zero = false;\n    let mut is_precision_decimal_digit_digit_digit_digit = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_zero = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit_zero = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit_digit = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit_digit_zero = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit_digit_digit = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit_digit_digit_zero = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit_digit_digit_digit = false;\n    let mut is_precision_decimal_digit_digit_digit_digit_digit_\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp9jzxdgy_.rs:30:64\n   |\n30 |     let mut is_precision_decimal_digit_digit_digit_digit_digit_\n   |                                                                ^ help: add `;` here\n31 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp9jzxdgy_.rs:2:31\n  |\n2 | fn is_decimal(num: String) -> bool {\n  |    ----------                 ^^^^ expected `bool`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    num.parse::<f64>().is_ok()\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpn8bpwegz.rs:10:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        }\n        if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 3\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpesya222t.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            is_decimal = true;\n            continue;\n        }\n        if is_decimal {\n            decimal_count += 1;\n        }\n        if !c.is_digit(10) {\n            return false;\n        }\n    }\n    if is_decimal && decimal_count == 2 {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[+-]?[0-9]*\\.[0-9]{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpz_r_0lxe.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[+-]?[0-9]*\\.[0-9]{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            count += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n    }\n    let mut split = num.split('.');\n    let left = split.next().unwrap();\n    let right = split.next().unwrap();\n    if left.len() > 0 && right.len() > 0 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmplivnk91n.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num_iter = num.chars();\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    let mut digit_count = 0;\n    while let Some(c) = num_iter.next() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n    if decimal_count > 2 || digit_count > 5 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_decimal = false;\n    let mut decimal_count = 0;\n\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if has_decimal {\n            decimal_count += 1;\n            if decimal_count > 2 {\n                return false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut num_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        } else if !c.is_numeric() {\n            return false;\n        } else {\n            num_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    if decimal_count == 1 && num_count > 3 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp5edujs04.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_digit = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        } else if c.is_digit(10) {\n            has_digit = true;\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 1 && has_digit\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpvghutlt0.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut dot_count = 0;\n    let mut num_count = 0;\n\n    for c in num.chars() {\n        if c == '.' {\n            dot_count += 1;\n        } else if c.is_digit(10) {\n            num_count += 1;\n        } else {\n            return false;\n        }\n    }\n\n    if dot_count > 1 {\n        return false;\n    }\n\n    if dot_count == 0 {\n        return true;\n    }\n\n    if dot_count == 1 && num_count <= 2 {\n        return true;\n    }\n\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpf7rubk7d.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpu4oumkw8.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n            continue;\n        }\n        if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    return decimal_count == 2;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpx2lrz3zm.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            count += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n    }\n    let mut split = num.split(\".\");\n    let left = split.next().unwrap();\n    let right = split.next();\n    if left.len() == 0 {\n        return false;\n    }\n    if right.is_none() {\n        return true;\n    }\n    let right = right.unwrap();\n    if right.len() > 2 {\n        return false;\n    }\n    for c in right.chars() {\n        if !c.is_digit(10) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmps8_s7hr3.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut it = num.chars();\n    let mut has_dot = false;\n    let mut has_digit = false;\n    let mut has_precision = false;\n    while let Some(c) = it.next() {\n        if c == '.' {\n            if has_dot {\n                return false;\n            }\n            has_dot = true;\n        } else if c.is_digit(10) {\n            has_digit = true;\n            if has_dot {\n                has_precision = true;\n            }\n        } else {\n            return false;\n        }\n    }\n    has_digit && has_precision\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpx013ckhb.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_dot = false;\n    let mut has_digit = false;\n    let mut has_digit_after_dot = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_dot {\n                return false;\n            }\n            has_dot = true;\n        } else if c.is_digit(10) {\n            if has_dot {\n                has_digit_after_dot = true;\n            } else {\n                has_digit = true;\n            }\n        } else {\n            return false;\n        }\n    }\n    has_digit && (has_digit_after_dot || !has_dot)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmppozla2e_.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            is_decimal = true;\n            continue;\n        }\n        if is_decimal {\n            count += 1;\n        }\n    }\n    count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpmu3y60_e.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            count += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n    }\n    let mut split = num.split(\".\");\n    let first = split.next().unwrap();\n    let second = split.next().unwrap();\n    if first.len() > 0 && second.len() > 2 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpjkm2yvbr.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpu4oumkw8.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n            if decimal_count > 2 {\n                return false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            break;\n        }\n    }\n    if decimal_index == 0 {\n        return false;\n    }\n    let mut has_decimal = false;\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            has_decimal = true;\n        }\n        if has_decimal {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 3 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpehuuicq_.rs:41:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut iter = num.chars();\n    let mut decimal_count = 0;\n    let mut digit_count = 0;\n    while let Some(c) = iter.next() {\n        if c == '.' {\n            decimal_count += 1;\n        } else if c.is_digit(10) {\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n    decimal_count == 1 && digit_count == 3\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpz6i8i5co.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut chars = num.chars();\n    let mut has_decimal = false;\n    let mut has_digit = false;\n    let mut has_digit_after_decimal = false;\n    while let Some(c) = chars.next() {\n        match c {\n            '0'...'9' => {\n                has_digit = true;\n                if has_decimal {\n                    has_digit_after_decimal = true;\n                }\n            }\n            '.' => {\n                if has_decimal {\n                    return false;\n                }\n                has_decimal = true;\n            }\n            _ => return false,\n        }\n    }\n    has_digit && (has_decimal && has_digit_after_decimal || !has_decimal)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpg28a_cxp.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    let mut decimal_count = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            decimal_count += 1;\n        }\n    }\n    if decimal_count == 0 {\n        return true;\n    }\n    let mut decimal_count = 0;\n    for c in num.chars().skip(decimal_index + 1) {\n        decimal_count += 1;\n    }\n    if decimal_count > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmppehz0264.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp52xgbvws.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut is_decimal = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            is_decimal = true;\n        }\n\n        if decimal_count > 1 {\n            return false;\n        }\n    }\n\n    if is_decimal {\n        let mut decimal_count = 0;\n        for c in num.chars().rev() {\n            if c == '.' {\n                break;\n            }\n            decimal_count += 1;\n        }\n\n        if decimal_count > 2 {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpmqtjsi66.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpu4oumkw8.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpu4oumkw8.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if has_decimal {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal = false;\n    let mut precision = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal {\n            precision += 1;\n        }\n    }\n    precision == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    let mut decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if c.is_digit(10) {\n            if decimal {\n                count += 1;\n            }\n            if count > 2 {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^-?\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmprmyf9q9j.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^-?\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut num_vec: Vec<&str> = num.split('.').collect();\n    if num_vec.len() == 1 {\n        return true;\n    }\n    if num_vec[1].len() > 2 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmptsprqmkz.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut dot_count = 0;\n    let mut digit_count = 0;\n    let mut is_valid = true;\n    for c in num.chars() {\n        if c == '.' {\n            dot_count += 1;\n        } else if c.is_digit(10) {\n            digit_count += 1;\n        } else {\n            is_valid = false;\n            break;\n        }\n    }\n    is_valid && dot_count <= 1 && digit_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpkqdmieiy.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    let mut decimal_count = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            decimal_count += 1;\n        }\n    }\n    if decimal_count == 0 {\n        return false;\n    }\n    let decimal_part = &num[decimal_index + 1..];\n    if decimal_part.len() > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxnpcyeid.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    num.parse::<f64>().is_ok()\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpn8bpwegz.rs:10:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp52xgbvws.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut is_decimal = false;\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            if decimal_count > 1 {\n                return false;\n            }\n        } else if !c.is_numeric() {\n            return false;\n        }\n    }\n    if decimal_count == 1 {\n        is_decimal = true;\n    }\n    is_decimal\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmplnvtkchg.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            count += 1;\n        }\n    }\n    if count > 1 {\n        return false;\n    }\n    let mut split = num.split('.');\n    let left = split.next().unwrap();\n    let right = split.next().unwrap();\n    if left.len() > 0 && right.len() > 0 && right.len() <= 2 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpecfw9ko5.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_decimal = false;\n    let mut decimal_count = 0;\n\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if has_decimal {\n            decimal_count += 1;\n        }\n    }\n\n    if has_decimal && decimal_count != 2 {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal = false;\n    let mut precision = 0;\n    for (i, c) in num.chars().enumerate() {\n        if i == 0 && c == '-' {\n            continue;\n        }\n        if c == '.' {\n            decimal = true;\n            continue;\n        }\n        if !c.is_digit(10) {\n            return false;\n        }\n        if decimal {\n            precision += 1;\n        }\n    }\n    precision <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut is_decimal = false;\n    let mut decimal_count = 0;\n    let mut is_negative = false;\n    let mut is_positive = false;\n    let mut is_zero = false;\n    let mut is_digit = false;\n    let mut is_dot = false;\n    let mut is_dot_digit = false;\n    let mut is_dot_digit_count = 0;\n    let mut is_dot_digit_count_max = 0;\n    let mut is_dot_digit_count_min = 0;\n    let mut is_dot_digit_count_min_max = 0;\n    let mut is_dot_digit_count_min_max_count = 0;\n    let mut is_dot_digit_count_min_max_count_max = 0;\n    let mut is_dot_digit_count_min_max_count_min = 0;\n    let mut is_dot_digit_count_min_max_count_min_max = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_max = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_min = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_min_max = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_min_max_count = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_min_max_count_max = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_min_max_count_min = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_min_max_count_min_max = 0;\n    let mut is_dot_digit_count_min_max_count_min_max_count_min_max_count\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp8nmb036v.rs:27:73\n   |\n27 |     let mut is_dot_digit_count_min_max_count_min_max_count_min_max_count\n   |                                                                         ^ help: add `;` here\n28 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmp8nmb036v.rs:2:31\n  |\n2 | fn is_decimal(num: String) -> bool {\n  |    ----------                 ^^^^ expected `bool`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num_chars = num.chars();\n    let mut decimal_found = false;\n    let mut decimal_count = 0;\n    let mut digit_count = 0;\n\n    while let Some(c) = num_chars.next() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n\n    if digit_count == 0 {\n        return false;\n    }\n\n    if decimal_found {\n        if decimal_count > 2 {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpu4oumkw8.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d*\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num = num.chars().peekable();\n    let mut has_decimal = false;\n    let mut has_digit = false;\n    while let Some(c) = num.next() {\n        match c {\n            '0'..='9' => has_digit = true,\n            '.' => {\n                if has_decimal {\n                    return false;\n                }\n                has_decimal = true;\n            }\n            _ => return false,\n        }\n    }\n    if has_decimal {\n        let mut decimal_count = 0;\n        while let Some(c) = num.next() {\n            match c {\n                '0'..='9' => decimal_count += 1,\n                _ => return false,\n            }\n        }\n        decimal_count == 2\n    } else {\n        has_digit\n    }\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpizf5nzk8.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_decimal = false;\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if has_decimal {\n            decimal_count += 1;\n            if decimal_count > 2 {\n                return false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            is_decimal = true;\n        }\n    }\n    if decimal_count == 1 {\n        return is_decimal;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpx6rskrx8.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut dot_count = 0;\n    let mut num_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            dot_count += 1;\n        } else if c.is_numeric() {\n            num_count += 1;\n        } else {\n            return false;\n        }\n    }\n    if dot_count > 1 {\n        return false;\n    }\n    if dot_count == 0 && num_count > 2 {\n        return false;\n    }\n    if dot_count == 1 && num_count > 4 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp7i5oiwhe.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut chars = num.chars();\n    let mut has_decimal = false;\n    let mut has_digit = false;\n    let mut has_digit_after_decimal = false;\n    while let Some(c) = chars.next() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                has_digit_after_decimal = true;\n            } else {\n                has_digit = true;\n            }\n        } else {\n            return false;\n        }\n    }\n    has_digit && (has_digit_after_decimal || !has_decimal)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp0k01f4_p.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            break;\n        }\n    }\n    if decimal_index == 0 {\n        return false;\n    }\n    if decimal_index == num.len() - 1 {\n        return false;\n    }\n    if decimal_index == num.len() - 2 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpj9ypwpxb.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    let mut decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal {\n            count += 1;\n        }\n    }\n    count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_decimal = false;\n    let mut decimal_count = 0;\n    let mut has_digit = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n            continue;\n        }\n        if c.is_digit(10) {\n            has_digit = true;\n            if has_decimal {\n                decimal_count += 1;\n            }\n            if decimal_count > 2 {\n                return false;\n            }\n            continue;\n        }\n        return false;\n    }\n    has_digit\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut dot_count = 0;\n    let mut num_count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            dot_count += 1;\n            if dot_count > 1 {\n                return false;\n            }\n        } else if c.is_digit(10) {\n            num_count += 1;\n            if num_count > 2 {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    }\n    if dot_count == 1 {\n        is_decimal = true;\n    }\n    is_decimal\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpeqhz6dyk.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal = false;\n    let mut precision = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal {\n                return false;\n            }\n            decimal = true;\n        } else if c.is_digit(10) {\n            if decimal {\n                precision += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    precision <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_digit = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        } else if c.is_digit(10) {\n            has_digit = true;\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 1 && has_digit\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpvghutlt0.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            is_decimal = true;\n        }\n        if decimal_count > 1 {\n            return false;\n        }\n    }\n    if is_decimal {\n        let nums: Vec<&str> = num.split('.').collect();\n        if nums[1].len() > 2 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpoiehq0fz.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n\n    if decimal_count > 1 {\n        return false;\n    }\n\n    let num_vec: Vec<&str> = num.split('.').collect();\n\n    if num_vec.len() == 1 {\n        return num_vec[0].parse::<i32>().is_ok();\n    }\n\n    if num_vec[1].len() > 2 {\n        return false;\n    }\n\n    num_vec[0].parse::<i32>().is_ok() && num_vec[1].parse::<i32>().is_ok()\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            is_decimal = true;\n            continue;\n        }\n        if is_decimal {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxn1i6x1_.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp52xgbvws.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[+-]?[0-9]*\\.[0-9]{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpz_r_0lxe.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[+-]?[0-9]*\\.[0-9]{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num = num.chars();\n    let mut decimal = false;\n    let mut precision = 0;\n    while let Some(c) = num.next() {\n        match c {\n            '0'..='9' => {\n                if decimal {\n                    precision += 1;\n                }\n            }\n            '.' => {\n                if decimal {\n                    return false;\n                }\n                decimal = true;\n            }\n            _ => return false,\n        }\n    }\n    precision <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut is_decimal = false;\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count == 1 {\n        is_decimal = true;\n    }\n    is_decimal\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpgschpu8a.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num_iter = num.chars();\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    while let Some(c) = num_iter.next() {\n        if c == '.' {\n            has_decimal = true;\n        } else if has_decimal {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmppzyb3kkd.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut dot_count = 0;\n    let mut digit_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            dot_count += 1;\n        } else if c.is_digit(10) {\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n    if dot_count > 1 {\n        return false;\n    }\n    if dot_count == 1 && digit_count > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpcnp8ecot.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut chars = num.chars();\n    let mut has_decimal = false;\n    let mut has_digit = false;\n    while let Some(c) = chars.next() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            has_digit = true;\n        } else {\n            return false;\n        }\n    }\n    if has_decimal && has_digit {\n        let parts: Vec<&str> = num.split('.').collect();\n        if parts.len() == 2 && parts[1].len() <= 2 {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if has_decimal {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num = num.chars();\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    let mut digit_count = 0;\n    while let Some(c) = num.next() {\n        match c {\n            '0'..='9' => digit_count += 1,\n            '.' => {\n                if decimal_found {\n                    return false;\n                }\n                decimal_found = true;\n            }\n            _ => return false,\n        }\n        if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    if decimal_found && decimal_count == 3 && digit_count == 3 {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwtslj9w3.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_decimal = false;\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    return decimal_count <= 2;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    let mut is_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            is_decimal = true;\n            continue;\n        }\n        if is_decimal {\n            count += 1;\n        }\n        if count > 2 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpzd4z3mkh.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp1uri1xnt.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut count = 0;\n    let mut has_dot = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_dot {\n                return false;\n            }\n            has_dot = true;\n        } else if c.is_digit(10) {\n            if has_dot {\n                count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    if has_dot {\n        count == 2\n    } else {\n        true\n    }\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_found = false;\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        }\n        if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 3 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpis8179pf.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    let mut decimal_found = false;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_found = true;\n            decimal_index = i;\n        }\n    }\n    if decimal_found {\n        if num.len() - decimal_index > 3 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxr4yjm00.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp52xgbvws.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+(\\.\\d{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            break;\n        }\n    }\n    if decimal_index == 0 {\n        return false;\n    }\n    if decimal_index == num.len() - 1 {\n        return false;\n    }\n    if decimal_index == num.len() - 2 {\n        return true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpj9ypwpxb.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    let mut decimal_count = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            decimal_count += 1;\n        }\n    }\n    if decimal_count == 0 {\n        return false;\n    }\n    let decimal_part = &num[decimal_index + 1..];\n    if decimal_part.len() > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxnpcyeid.rs:33:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut iter = num.chars();\n    let mut decimal_count = 0;\n    let mut digit_count = 0;\n    while let Some(c) = iter.next() {\n        if c == '.' {\n            decimal_count += 1;\n        } else if !c.is_digit(10) {\n            return false;\n        } else {\n            digit_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    if decimal_count == 0 {\n        return true;\n    }\n    digit_count - 1 <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpv95652eo.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n            has_decimal = true;\n        } else if !c.is_digit(10) {\n            return false;\n        }\n    }\n    if has_decimal && decimal_count == 1 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpasx14cus.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_index = 0;\n    let mut decimal_found = false;\n    for (index, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_found = true;\n            decimal_index = index;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    if decimal_found {\n        if decimal_count == 2 {\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        return true;\n    }\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_dot = false;\n    let mut has_num = false;\n    let mut after_dot = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if has_dot {\n                return false;\n            }\n            has_dot = true;\n        } else if c.is_digit(10) {\n            has_num = true;\n            if has_dot {\n                after_dot += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    if !has_num {\n        return false;\n    }\n    if has_dot && after_dot > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_found = true;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n    decimal_count == 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp90xbdmt2.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    let mut decimal_count = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            decimal_count += 1;\n        }\n    }\n    if decimal_count == 0 {\n        return false;\n    }\n    let decimal_part = &num[decimal_index + 1..];\n    if decimal_part.len() > 2 {\n        return false;\n    }\n    if decimal_part.len() == 0 {\n        return false;\n    }\n    let mut decimal_part_int = 0;\n    for c in decimal_part.chars() {\n        if !c.is_digit(10) {\n            return false;\n        }\n        decimal_part_int = decimal_part_int * 10 + c.to_digit(10).unwrap();\n    }\n    if decimal_part_int > 99 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpx1s8m985.rs:46:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut iter = num.chars();\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    while let Some(c) = iter.next() {\n        if c == '.' {\n            decimal_found = true;\n            continue;\n        }\n        if !decimal_found {\n            continue;\n        }\n        decimal_count += 1;\n        if decimal_count > 2 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp1io95qah.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut has_decimal = false;\n    for c in num.chars() {\n        if c == '.' {\n            if has_decimal {\n                return false;\n            }\n            has_decimal = true;\n        } else if c.is_digit(10) {\n            if has_decimal {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122994,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            decimal_count += 1;\n        }\n    }\n    if decimal_count > 1 {\n        return false;\n    }\n    let mut decimal_index = 0;\n    let mut decimal_count = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_index = i;\n            decimal_count += 1;\n        }\n    }\n    if decimal_count == 0 {\n        return true;\n    }\n    if num.len() - decimal_index - 1 > 2 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpx_8dnzu4.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1665510369,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpx12sjlz5.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^\\d+\\.\\d{2}$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal = false;\n    let mut precision = 0;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal = true;\n            continue;\n        }\n        if !c.is_digit(10) {\n            return false;\n        }\n        if decimal {\n            precision += 1;\n        }\n        if precision > 2 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_index = 0;\n    let mut is_decimal = false;\n    for (i, c) in num.chars().enumerate() {\n        if c == '.' {\n            decimal_count += 1;\n            decimal_index = i;\n        }\n    }\n    if decimal_count == 1 {\n        let decimal_part = num.chars().skip(decimal_index + 1);\n        if decimal_part.count() == 2 {\n            is_decimal = true;\n        }\n    }\n    is_decimal\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp01h1ta4d.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(num.as_str())\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpreo2625k.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]+(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut has_dot = false;\n    let mut has_digit = false;\n    let mut dot_count = 0;\n    for c in num.chars() {\n        if c == '.' {\n            if has_dot {\n                return false;\n            }\n            has_dot = true;\n            dot_count += 1;\n        } else if c.is_digit(10) {\n            has_digit = true;\n        } else {\n            return false;\n        }\n    }\n    if !has_digit {\n        return false;\n    }\n    if dot_count > 1 {\n        return false;\n    }\n    if has_dot {\n        let parts: Vec<&str> = num.split('.').collect();\n        if parts[1].len() > 2 {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    let mut num_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n            num_found = true;\n        } else {\n            return false;\n        }\n    }\n    if !num_found {\n        return false;\n    }\n    if decimal_count > 2 {\n        return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut num_chars = num.chars();\n    let mut decimal_count = 0;\n    let mut digit_count = 0;\n    let mut decimal_found = false;\n    while let Some(c) = num_chars.next() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n            decimal_count += 1;\n        } else if c.is_digit(10) {\n            digit_count += 1;\n        } else {\n            return false;\n        }\n    }\n    if decimal_count == 1 && digit_count == 3 {\n        return true;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpufngm5xg.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let re = Regex::new(r\"^[0-9]*(\\.[0-9]{1,2})?$\").unwrap();\n    re.is_match(&num)\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp_cgazft2.rs:3:14\n  |\n3 |     let re = Regex::new(r\"^[0-9]*(\\.[0-9]{1,2})?$\").unwrap();\n  |              ^^^^^ use of undeclared type `Regex`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0433`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if !c.is_digit(10) {\n            return false;\n        } else if decimal_found {\n            decimal_count += 1;\n        }\n    }\n\n    if decimal_count == 2 {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfn is_decimal(num: String) -> bool {\n    let mut decimal_count = 0;\n    let mut decimal_found = false;\n    for c in num.chars() {\n        if c == '.' {\n            if decimal_found {\n                return false;\n            }\n            decimal_found = true;\n        } else if c.is_digit(10) {\n            if decimal_found {\n                decimal_count += 1;\n            }\n        } else {\n            return false;\n        }\n    }\n    decimal_count <= 2\n}\n\nfn main() {\n    let candidate = is_decimal;\n    assert_eq!(candidate(String::from(\"123.11\")), true);\n    assert_eq!(candidate(String::from(\"e666.86\")), false);\n    assert_eq!(candidate(String::from(\"3.124587\")), false);\n    assert_eq!(candidate(String::from(\"1.11\")), true);\n    assert_eq!(candidate(String::from(\"1.1.11\")), false);\n}\n",
      "timestamp": 1666122995,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}