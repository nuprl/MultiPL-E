{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "rs",
  "prompt": "/// Write a function to find the largest sum of a contiguous vector in the modified vector which is formed by repeating the given vector k times.\nfn max_sub_array_sum_repeated(a: Vec<isize>, n: isize, k: isize) -> isize {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\nfn main() {\n    let candidate = max_sub_array_sum_repeated;\n    assert_eq!(candidate(vec![10, 20, -30, -1], 4, 3), 30);\n    assert_eq!(candidate(vec![-1, 10, 20], 3, 2), 59);\n    assert_eq!(candidate(vec![-1, -2, -3], 3, 3), -1);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "completions": [
    "    let mut max_sum = 0;\n    let mut curr_sum = 0;\n    let mut max_sum_k = 0;\n    let mut curr_sum_k = 0;\n    let mut max_sum_k_neg = 0;\n    let mut curr_sum_k_neg = 0;\n    let mut max_sum_k_pos = 0;\n    let mut curr_sum_k_pos = 0;\n    let mut max_sum_k_pos_neg = 0;\n    let mut curr_sum_k_pos_neg = 0;\n    let mut max_sum_k_neg_pos = 0;\n    let mut curr_sum_k_neg_pos = 0;\n    let mut max_sum_k_neg_pos_neg = 0;\n    let mut curr_sum_k_neg_pos_neg = 0;\n    let mut max_sum_k_pos_neg_pos = 0;\n    let mut curr_sum_k_pos_neg_pos = 0;\n    let mut max_sum_k_neg_pos_neg_pos = 0;\n    let mut curr_sum_k_neg_pos_neg_pos = 0;\n    let mut max_sum_k_pos_neg_pos_neg = 0;\n    let mut curr_sum_k_pos_neg_pos_neg = 0;\n    let mut max_sum_k_neg_pos_neg_pos_neg = 0;\n    let mut curr_sum_k_neg_pos_neg_pos_neg = 0;\n    let mut max_sum_k_pos_neg_pos_neg_pos = 0;\n    let mut curr_sum_k_pos_neg_pos_neg_pos = 0;\n    let mut max_sum_k_neg_pos_neg_pos_neg_pos = 0;\n    let mut curr_sum_k_neg_pos_neg_pos_neg_pos = 0;\n    let mut max_sum_k_pos_neg_pos_neg_pos_neg = 0;\n    let mut curr_sum_k_pos_neg_pos_neg_pos_neg =",
    "    let mut max_sum = std::isize::MIN;\n    let mut curr_sum = 0;\n\n    for i in 0..n {\n        curr_sum += a[i as usize];\n        if curr_sum > max_sum {\n            max_sum = curr_sum;\n        }\n        if curr_sum < 0 {\n            curr_sum = 0;\n        }\n    }\n\n    let mut max_wrap = 0;\n    for i in 0..n {\n        max_wrap += a[i as usize];\n        curr_sum += a[i as usize];\n        if curr_sum > max_sum {\n            max_sum = curr_sum;\n        }\n        if curr_sum < 0 {\n            curr_sum = 0;\n        }\n    }\n\n    if max_wrap > 0 {\n        return max_sum + (k - 2) * max_wrap;\n    } else {\n        return max_sum;\n    }",
    "    let mut max_sum = 0;\n    let mut curr_sum = 0;\n    for i in 0..n {\n        curr_sum += a[i as usize];\n        if curr_sum < 0 {\n            curr_sum = 0;\n        }\n        max_sum = max(max_sum, curr_sum);\n    }\n    let max_sum_all = max_sum;\n    let mut min_sum = 0;\n    curr_sum = 0;\n    for i in 0..n {\n        curr_sum += a[i as usize];\n        if curr_sum > 0 {\n            curr_sum = 0;\n        }\n        min_sum = min(min_sum, curr_sum);\n    }\n    let min_sum_all = min_sum;\n    let total_sum: isize = a.iter().sum();\n    if k == 1 {\n        return max_sum_all;\n    }\n    max(\n        max_sum_all,\n        total_sum * k - min_sum_all,\n        total_sum * k - min_sum_all + max_sum_all,\n    )",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n * k {\n        max_ending_here += a[i as usize % n];\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n    println!(\"{} {}\", start, end);\n    max_so_far",
    "    let mut max_sum = std::isize::MIN;\n    let mut curr_sum = 0;\n    for i in 0..n {\n        curr_sum += a[i as usize];\n        if curr_sum > max_sum {\n            max_sum = curr_sum;\n        }\n        if curr_sum < 0 {\n            curr_sum = 0;\n        }\n    }\n    let max_sum_all = curr_sum;\n    let mut min_sum = std::isize::MAX;\n    curr_sum = 0;\n    for i in 0..n {\n        curr_sum += a[i as usize];\n        if curr_sum < min_sum {\n            min_sum = curr_sum;\n        }\n        if curr_sum > 0 {\n            curr_sum = 0;\n        }\n    }\n    let min_sum_all = curr_sum;\n    let mut ans = max_sum;\n    for i in 1..k {\n        let max_val = max_sum_all + i * min_sum_all;\n        let min_val = min_sum_all + i * max_sum_all;\n        ans = std::cmp::max(ans, std::cmp::max(max_val, min_val));\n    }\n    ans",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n * k {\n        max_ending_here += a[i as usize % n];\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n    println!(\"{} {}\", start, end);\n    max_so_far",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n {\n        max_ending_here += a[i as usize];\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n\n    let mut min_so_far = std::isize::MAX;\n    let mut min_ending_here = 0;\n    let mut start_min = 0;\n    let mut end_min = 0;\n    let mut s_min = 0;\n\n    for i in 0..n {\n        min_ending_here += a[i as usize];\n\n        if min_so_far > min_ending_here {\n            min_so_far = min_ending_here;\n            start_min = s_min;\n            end_min = i;\n        }\n\n        if min_ending_here > 0 {\n            min_ending_here = 0;\n            s_min = i + 1;\n        }\n    }\n\n    let mut sum = 0;\n    for i in 0..n {\n        sum += a[i as usize];\n    }\n\n    let mut ans = max_so_far;\n\n    if sum > 0 {\n        ans = std::cmp::max(ans, sum * k);\n        ans = std::cmp::max(ans, (sum * (k - 2) + max_so_far));\n    } else {\n        ans = std::cmp::max(ans, max_so_far);\n    }\n\n    if sum < 0 {\n        ans = std::cmp::max(ans, (sum * (k - 2) + min_so_far));\n    }\n\n    ans",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n * k {\n        max_ending_here += a[(i % n) as usize];\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n\n    println!(\"{} {}\", start, end);\n    max_so_far",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n * k {\n        max_ending_here += a[i as usize % n];\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n    println!(\"{} {}\", start, end);\n    max_so_far",
    "    let mut max_so_far = 0;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n * k {\n        max_ending_here = max_ending_here + a[i as usize];\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n    println!(\"{} {}\", start, end);\n    max_so_far",
    "    let mut max_sum = 0;\n    let mut curr_sum = 0;\n    for i in 0..n {\n        curr_sum += a[i as usize];\n    }\n    max_sum = curr_sum;\n    let mut sum = curr_sum;\n    for i in 0..n {\n        sum = sum - a[i as usize] + a[i as usize] * k;\n        if sum > max_sum {\n            max_sum = sum;\n        }\n    }\n    max_sum",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut max_element = std::isize::MIN;\n    let mut min_element = std::isize::MAX;\n    let mut min_ending_here = 0;\n    let mut min_so_far = std::isize::MAX;\n\n    for i in 0..n {\n        max_ending_here = max_ending_here + a[i as usize];\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n        }\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n        }\n        if a[i as usize] > max_element {\n            max_element = a[i as usize];\n        }\n\n        min_ending_here = min_ending_here + a[i as usize];\n        if min_so_far > min_ending_here {\n            min_so_far = min_ending_here;\n        }\n        if min_ending_here > 0 {\n            min_ending_here = 0;\n        }\n        if a[i as usize] < min_element {\n            min_element = a[i as usize];\n        }\n    }\n\n    if k == 1 {\n        return max_so_far;\n    }\n\n    let mut max_sum = max_so_far;\n    let mut min_sum = min_so_far;\n    let mut total_sum = 0;\n    for i in 0..n {\n        total_sum += a[i as usize];\n    }\n\n    for i in 2..k + 1 {\n        if max_sum < 0 {\n            max_sum = 0;\n        }\n        max_sum = max_sum + total_sum;\n        if min_sum > 0 {\n            min_sum = 0;\n        }\n        min_sum = min_sum + total_sum;\n    }\n\n    if max_sum < max_element {\n        max_sum = max_element;\n    }\n    if min_sum > min",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n    for i in 0..n * k {\n        max_ending_here += a[i as usize];\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n    println!(\"{} {}\", start, end);\n    max_so_far",
    "    let mut max_sum = isize::min_value();\n    let mut current_sum = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n {\n        current_sum += a[i as usize];\n        if current_sum > max_sum {\n            max_sum = current_sum;\n            start = s;\n            end = i;\n        }\n        if current_sum < 0 {\n            current_sum = 0;\n            s = i + 1;\n        }\n    }\n\n    let mut min_sum = isize::max_value();\n    let mut current_sum = 0;\n    for i in 0..n {\n        current_sum += a[i as usize];\n        if current_sum < min_sum {\n            min_sum = current_sum;\n        }\n    }\n\n    let mut circular_sum = 0;\n    for i in 0..n {\n        circular_sum += a[i as usize];\n    }\n\n    let mut circular_max_sum = isize::min_value();\n    if circular_sum > max_sum {\n        circular_max_sum = circular_sum * k;\n    } else {\n        circular_max_sum = max_sum + (circular_sum - min_sum) * (k - 1);\n    }\n\n    circular_max_sum",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n {\n        max_ending_here = max_ending_here + a[i as usize];\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n\n    let mut max_wrap = 0;\n    let mut temp = 0;\n\n    for i in 0..n {\n        temp = temp + a[i as usize];\n        max_wrap = max(max_wrap, temp);\n        if temp < 0 {\n            temp = 0;\n        }\n    }\n\n    let mut max_wrap_k = max_wrap * k;\n\n    if max_wrap_k > max_so_far && max_wrap_k != 0 {\n        max_so_far = max_wrap_k;\n    }\n\n    max_so_far",
    "    let mut max_sum = std::isize::MIN;\n    let mut curr_sum = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n {\n        curr_sum += a[i as usize];\n        if curr_sum < 0 {\n            curr_sum = 0;\n            s = i + 1;\n        }\n        if curr_sum > max_sum {\n            max_sum = curr_sum;\n            start = s;\n            end = i;\n        }\n    }\n\n    let mut curr_sum = 0;\n    for i in 0..start {\n        curr_sum += a[i as usize];\n        if curr_sum > max_sum {\n            max_sum = curr_sum;\n        }\n    }\n\n    let mut curr_sum = 0;\n    for i in (end + 1)..n {\n        curr_sum += a[i as usize];\n        if curr_sum > max_sum {\n            max_sum = curr_sum;\n        }\n    }\n\n    max_sum * k - (sum_array(&a) - max_sum)",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n {\n        max_ending_here += a[i as usize];\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n\n    let mut max_wrap = 0;\n    let mut temp = 0;\n\n    for i in 0..n {\n        temp += a[i as usize];\n        if temp < 0 {\n            temp = 0;\n        }\n        max_wrap = std::cmp::max(temp, max_wrap);\n    }\n\n    if max_wrap > 0 {\n        max_wrap *= k;\n        max_wrap = std::cmp::max(max_wrap, max_so_far);\n    } else {\n        max_wrap = max_so_far;\n    }\n\n    max_wrap",
    "    let mut max_so_far = std::isize::MIN;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n * k {\n        max_ending_here += a[i as usize % n];\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n    println!(\"{} {}\", start, end);\n    max_so_far",
    "    let mut max_so_far = 0;\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n    let mut i = 0;\n    let mut max_sum = 0;\n    let mut max_index = 0;\n    let mut min_index = 0;\n    let mut min_sum = 0;\n    let mut min_so_far = 0;\n    let mut min_ending_here = 0;\n    let mut max_sum_index = 0;\n    let mut min_sum_index = 0;\n    let mut max_sum_ending_here = 0;\n    let mut min_sum_ending_here = 0;\n    let mut max_sum_so_far = 0;\n    let mut min_sum_so_far = 0;\n    let mut max_sum_start = 0;\n    let mut max_sum_end = 0;\n    let mut min_sum_start = 0;\n    let mut min_sum_end = 0;\n    let mut max_sum_s = 0;\n    let mut min_sum_s = 0;\n    let mut max_sum_i = 0;\n    let mut min_sum_i = 0;\n    let mut max_sum_index_start = 0;\n    let mut max_sum_index_end = 0;\n    let mut min_sum_index_start = 0;\n    let mut min_sum_index_end = 0;\n    let mut max_sum_index_s = 0;\n    let mut min_sum_index_s = 0;\n    let mut max_sum_index_i = 0;\n    let mut min_sum_index_i = 0;\n    let mut max_sum_index_so_far = 0;\n    let mut min_sum_index_so_far = 0;\n    let mut max_sum_index_ending_here = 0;\n    let mut min_sum_index_ending_here = 0;\n    let mut max_sum_index_start_index = 0;\n    let mut max_sum_index_end_index = 0;\n    let mut min_sum_",
    "    let mut max_so_far = isize::min_value();\n    let mut max_ending_here = 0;\n    let mut start = 0;\n    let mut end = 0;\n    let mut s = 0;\n\n    for i in 0..n * k {\n        max_ending_here += a[i as usize];\n\n        if max_so_far < max_ending_here {\n            max_so_far = max_ending_here;\n            start = s;\n            end = i;\n        }\n\n        if max_ending_here < 0 {\n            max_ending_here = 0;\n            s = i + 1;\n        }\n    }\n\n    println!(\"{} {}\", start, end);\n    max_so_far"
  ]
}