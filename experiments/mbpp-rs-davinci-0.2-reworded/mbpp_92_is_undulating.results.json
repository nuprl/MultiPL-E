{
  "name": "mbpp_92_is_undulating",
  "language": "rs",
  "prompt": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py",
  "prompt_terminology": "reworded",
  "tests": "}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff != diff {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmproc4t5qq.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpgzq6vgec.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut is_increasing = prev < curr;\n    while n > 0 {\n        let next = n % 10;\n        if (is_increasing && curr > next) || (!is_increasing && curr < next) {\n            return false;\n        }\n        prev = curr;\n        curr = next;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpbt5qk3g7.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == last_digit {\n            return false;\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        last_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpsxry8sgy.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut current_digit = n % 10;\n    n /= 10;\n    let mut increasing = current_digit > last_digit;\n    while n > 0 {\n        last_digit = current_digit;\n        current_digit = n % 10;\n        n /= 10;\n        if increasing && current_digit > last_digit {\n            return false;\n        }\n        if !increasing && current_digit < last_digit {\n            return false;\n        }\n        increasing = !increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > prev_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if (curr_digit > prev_digit) != is_increasing {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp8u7gecrc.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = to_digits(n);\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1;\n        } else if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            i += 2;\n        } else if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            i += 2;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `to_digits` in this scope\n --> /tmp/tmpr5j18gjr.rs:3:18\n  |\n3 |     let digits = to_digits(n);\n  |                  ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        } else if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpzgisz2wp.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff != diff {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmproc4t5qq.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    let mut is_increasing = true;\n    n /= 10;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp8u5x52q8.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        }\n        if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpd4fr29sk.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    let mut is_decreasing = curr < prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr > next {\n            is_increasing = false;\n        }\n        if is_decreasing && curr < next {\n            is_decreasing = false;\n        }\n        if !is_increasing && !is_decreasing {\n            return false;\n        }\n    }\n    is_increasing || is_decreasing\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp2wci_j9d.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] > digits[i] && digits[i] < digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp49pzsd4j.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        if s.chars().nth(i).unwrap() == s.chars().nth(i + 1).unwrap() {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff == diff {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpblbw6qd8.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    let mut last = digits.pop().unwrap();\n    let mut last_last = digits.pop().unwrap();\n    let mut undulating = true;\n    while let Some(d) = digits.pop() {\n        if last_last > d && last < d {\n            undulating = false;\n            break;\n        }\n        last_last = last;\n        last = d;\n    }\n    undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmp_1c74cdv.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        }\n        if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpd4fr29sk.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last = s.chars().next().unwrap();\n    let mut last_was_odd = false;\n    for c in s.chars().skip(1) {\n        if c == last {\n            return false;\n        }\n        if last_was_odd {\n            if c.to_digit(10).unwrap() % 2 == 0 {\n                return false;\n            }\n        } else {\n            if c.to_digit(10).unwrap() % 2 == 1 {\n                return false;\n            }\n        }\n        last = c;\n        last_was_odd = !last_was_odd;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && prev_diff != diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpvnjzsrii.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n > 0 {\n        let next = n % 10;\n        if (prev > curr && curr < next) || (prev < curr && curr > next) {\n            return false;\n        }\n        prev = curr;\n        curr = next;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0i5d1wv7.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        }\n        if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp5_cbwk3g.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    let mut is_undulating = true;\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            is_undulating = false;\n            break;\n        }\n        i += 1;\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1;\n        } else if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            i += 2;\n        } else if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            i += 2;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        let mut j = i + 1;\n        while j < s.len() - 1 {\n            if s[i..i + 1] == s[j..j + 1] {\n                return false;\n            }\n            j += 1;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpvompid6k.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing {\n            if curr < next {\n                return false;\n            }\n            if curr > next {\n                is_increasing = false;\n            }\n        } else {\n            if curr > next {\n                return false;\n            }\n            if curr < next {\n                is_increasing = true;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpkp9plze_.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == last_digit {\n            return false;\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprndbkqot.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|d| d.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmptgsbxld4.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = prev_digit > curr_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing {\n            if prev_digit < curr_digit {\n                return false;\n            }\n        } else {\n            if prev_digit > curr_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpykbwebux.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < s.len() {\n        if s[i..i + 1] == s[j..j + 1] || s[j..j + 1] == s[k..k + 1] {\n            return false;\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().nth(0).unwrap();\n    let mut last_diff = 0;\n    for c in s.chars().skip(1) {\n        let diff = c as isize - last_digit as isize;\n        if diff == 0 {\n            return false;\n        }\n        if last_diff == 0 {\n            last_diff = diff;\n        } else if last_diff * diff != -1 {\n            return false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpx14zdhs1.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut prev_digit = None;\n    let mut prev_prev_digit = None;\n    let mut is_increasing = None;\n\n    for digit in n.to_string().chars().map(|c| c.to_digit(10).unwrap()) {\n        if prev_digit.is_some() {\n            if prev_prev_digit.is_some() {\n                if is_increasing.unwrap() {\n                    if digit < prev_digit.unwrap() {\n                        return false;\n                    }\n                } else {\n                    if digit > prev_digit.unwrap() {\n                        return false;\n                    }\n                }\n            }\n\n            if digit > prev_digit.unwrap() {\n                is_increasing = Some(true);\n            } else if digit < prev_digit.unwrap() {\n                is_increasing = Some(false);\n            }\n        }\n\n        prev_prev_digit = prev_digit;\n        prev_digit = Some(digit);\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpcsxxnwj3.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n\n    while n > 0 {\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    for i in 0..digits.len() - 2 {\n        if (digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2]) ||\n           (digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2]) {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    let mut is_undulating = true;\n    for i in 0..digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            is_undulating = false;\n            break;\n        }\n    }\n    is_undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmph0vmjj0_.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1;\n        } else if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            i += 2;\n        } else if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            i += 2;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] == digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    let mut i = 0;\n    let mut j = digits.len() - 1;\n    while i < j {\n        if digits[i] + 1 != digits[i + 1] || digits[j] - 1 != digits[j - 1] {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprlbdg03e.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        }\n        if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp5_cbwk3g.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > last_digit;\n    while n != 0 {\n        last_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if curr_digit > last_digit && is_increasing {\n            return false;\n        }\n        if curr_digit < last_digit && !is_increasing {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).collect::<Vec<_>>();\n    digits.reverse();\n    let mut last_digit = digits[0];\n    let mut is_increasing = true;\n    for digit in digits.iter().skip(1) {\n        if is_increasing {\n            if digit > &last_digit {\n                return false;\n            }\n        } else {\n            if digit < &last_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        last_digit = *digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpp6hwe_x_.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if diff == 0 {\n            return false;\n        }\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmplkor43p0.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap();\n        if (a < b && b > c) || (a > b && b < c) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing {\n            if curr < next {\n                return false;\n            }\n        } else {\n            if curr > next {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpzwd1oehb.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        if c == last_digit {\n            return false;\n        }\n        if c > last_digit {\n            if last_was_increasing {\n                return false;\n            }\n            last_was_increasing = true;\n        } else {\n            if !last_was_increasing {\n                return false;\n            }\n            last_was_increasing = false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm8x5wnxa.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        if c == last_digit {\n            return false;\n        }\n        if last_was_increasing {\n            if c < last_digit {\n                last_was_increasing = false;\n            } else {\n                return false;\n            }\n        } else {\n            if c > last_digit {\n                last_was_increasing = true;\n            } else {\n                return false;\n            }\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > prev_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && curr_digit > prev_digit {\n            return false;\n        }\n        if !is_increasing && curr_digit < prev_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut last = digits[0];\n    let mut last_diff = 0;\n    for &d in &digits[1..] {\n        let diff = (d - last).abs();\n        if diff == last_diff {\n            return false;\n        }\n        last_diff = diff;\n        last = d;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp1awkg8db.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        if c == last_digit {\n            return false;\n        }\n        if c > last_digit {\n            if last_was_increasing {\n                return false;\n            }\n            last_was_increasing = true;\n        } else {\n            if !last_was_increasing {\n                return false;\n            }\n            last_was_increasing = false;\n        }\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && prev_diff != diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpvnjzsrii.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm8x5wnxa.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut last_digit = None;\n    let mut last_digit_was_odd = false;\n    for digit in n.to_string().chars().map(|c| c.to_digit(10).unwrap()) {\n        if let Some(last_digit) = last_digit {\n            let is_odd = digit % 2 == 1;\n            if last_digit_was_odd == is_odd {\n                return false;\n            }\n            last_digit_was_odd = is_odd;\n        }\n        last_digit = Some(digit);\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp_fe7cwhl.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp_mll22qs.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff * diff < 0 {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpdy6xepc7.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        if s[i] == s[i + 2] {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpy6_g_6vk.rs:6:12\n  |\n6 |         if s[i] == s[i + 2] {\n  |            ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpy6_g_6vk.rs:6:20\n  |\n6 |         if s[i] == s[i + 2] {\n  |                    ^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut next_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > prev_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = next_digit;\n        next_digit = n % 10;\n        n /= 10;\n        if is_increasing && curr_digit < next_digit {\n            return false;\n        }\n        if !is_increasing && curr_digit > next_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpstlk7_tx.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > prev_digit {\n                return false;\n            }\n        } else {\n            if digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpqz997nno.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && next > curr {\n            return false;\n        }\n        if !is_increasing && next < curr {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpd4nrue1w.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let cur = n % 10;\n        if cur == prev {\n            return false;\n        }\n        prev = cur;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut curr_state = curr_digit > last_digit;\n    while n > 0 {\n        last_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if curr_state == (curr_digit > last_digit) {\n            return false;\n        }\n        curr_state = !curr_state;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap();\n        if a == b || b == c || a == c {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmplxhz750g.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap();\n        if a > b && b < c {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprike8vaz.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == prev_digit {\n            return false;\n        }\n        if is_increasing {\n            if digit > prev_digit {\n                return false;\n            }\n        } else {\n            if digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpgwekn_xl.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            continue;\n        }\n        if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            continue;\n        }\n        if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            continue;\n        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp0q8qwus_.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > last_digit;\n    while n > 0 {\n        last_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && curr_digit > last_digit {\n            return false;\n        }\n        if !is_increasing && curr_digit < last_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff != diff {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmproc4t5qq.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut prev = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let curr = n % 10;\n        if is_increasing {\n            if curr > prev {\n                return false;\n            }\n        } else {\n            if curr < prev {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpjh4cel2f.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] == digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let curr_digit = n % 10;\n        let curr_diff = prev_digit - curr_digit;\n        if curr_diff == 0 || curr_diff == prev_diff {\n            return false;\n        }\n        prev_diff = curr_diff;\n        prev_digit = curr_digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut last_digit = digits[0];\n    let mut last_diff = 0;\n    for digit in digits.iter().skip(1) {\n        let diff = last_digit - digit;\n        if diff.abs() != 1 {\n            return false;\n        }\n        if last_diff == diff {\n            return false;\n        }\n        last_diff = diff;\n        last_digit = *digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        } else if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpfwa3d2h2.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut i = n;\n    while i > 0 {\n        digits.push(i % 10);\n        i /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n > 0 {\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() >= 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpep_z3zuj.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = None;\n    let mut prev_diff = None;\n    while n > 0 {\n        let digit = n % 10;\n        if let Some(prev_digit) = prev_digit {\n            let diff = prev_digit - digit;\n            if let Some(prev_diff) = prev_diff {\n                if diff != prev_diff {\n                    return false;\n                }\n            }\n            prev_diff = Some(diff);\n        }\n        prev_digit = Some(digit);\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpk1tff583.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = prev_digit > curr_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && prev_digit < curr_digit {\n            return false;\n        } else if !is_increasing && prev_digit > curr_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpxeg81s17.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > prev_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing {\n            if curr_digit > prev_digit {\n                return false;\n            }\n        } else {\n            if curr_digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm8x5wnxa.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = prev_digit > curr_digit;\n    while n != 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing {\n            if prev_digit < curr_digit {\n                return false;\n            }\n        } else {\n            if prev_digit > curr_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp7vikunl9.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    while j < s.len() {\n        if s[i..j].parse::<isize>().unwrap() % 2 == 0 {\n            return false;\n        }\n        i += 1;\n        j += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprj3rz5u4.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut increasing = curr > prev;\n    let mut decreasing = curr < prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if increasing && curr > next {\n            increasing = false;\n            decreasing = true;\n        } else if decreasing && curr < next {\n            increasing = true;\n            decreasing = false;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpp9o2rp9j.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if curr == prev {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() {\n        if digits[i - 1] == digits[i] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n        if curr == prev {\n            continue;\n        }\n        if is_increasing && curr < prev {\n            return false;\n        }\n        if !is_increasing && curr > prev {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwdy6hjka.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == prev_digit {\n            return false;\n        }\n        if is_increasing && digit > prev_digit {\n            return false;\n        }\n        if !is_increasing && digit < prev_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpsjzipjzr.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwkcsfl7k.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] > digits[i] && digits[i] < digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp49pzsd4j.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpq57tb6bi.rs:17:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpm8x5wnxa.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        if (digits[i] > digits[i + 1]) != (digits[i + 1] > digits[i + 2]) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmph7mzr8ig.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut increasing = curr > prev;\n    let mut decreasing = curr < prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        increasing = increasing || (curr > prev && curr > next);\n        decreasing = decreasing || (curr < prev && curr < next);\n    }\n    increasing && decreasing\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp64ec254i.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 1..digits.len() - 1 {\n        if digits[i - 1] > digits[i] && digits[i] < digits[i + 1] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp49pzsd4j.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff == 0 {\n            prev_diff = diff;\n        } else if prev_diff != diff {\n            return false;\n        }\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpyr5r8wpp.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if (curr > next) != is_increasing {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpjj9nyj1s.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last = s.chars().nth(0).unwrap();\n    let mut last_was_same = false;\n    for c in s.chars().skip(1) {\n        if c == last {\n            last_was_same = true;\n        } else if last_was_same {\n            return false;\n        }\n        last = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i) == s.chars().nth(j) {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpws24jngy.rs:18:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        if s.chars().nth(i).unwrap().to_digit(10).unwrap() % 2 == 0 {\n            if s.chars().nth(i + 1).unwrap().to_digit(10).unwrap() % 2 == 0 {\n                return false;\n            }\n        } else {\n            if s.chars().nth(i + 1).unwrap().to_digit(10).unwrap() % 2 != 0 {\n                return false;\n            }\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing {\n            if curr > next {\n                return false;\n            }\n        } else {\n            if curr < next {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 1 {\n        if s.chars().nth(i).unwrap() == s.chars().nth(i + 1).unwrap() {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxpo7z87_.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().nth(0).unwrap();\n    let mut last_diff = 0;\n    let mut undulating = true;\n    for c in s.chars().skip(1) {\n        let diff = c as isize - last_digit as isize;\n        if diff == 0 {\n            undulating = false;\n            break;\n        }\n        if last_diff != 0 && diff != last_diff {\n            undulating = false;\n            break;\n        }\n        last_diff = diff;\n        last_digit = c;\n    }\n    undulating\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpzjja6c0n.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            continue;\n        }\n        if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            continue;\n        }\n        if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            continue;\n        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpjggx_4h3.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut last_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - last_digit;\n        if last_diff == 0 {\n            last_diff = diff;\n        } else if last_diff != diff {\n            return false;\n        }\n        last_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpft1g6l5s.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr < next {\n            return false;\n        } else if !is_increasing && curr > next {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp_9ujht7f.rs:28:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        if s[i] == s[i + 2] {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpy6_g_6vk.rs:6:12\n  |\n6 |         if s[i] == s[i + 2] {\n  |            ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpy6_g_6vk.rs:6:20\n  |\n6 |         if s[i] == s[i + 2] {\n  |                    ^^^^^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    while n > 0 {\n        if prev > curr {\n            if prev <= n % 10 {\n                return false;\n            }\n        } else if prev < curr {\n            if prev >= n % 10 {\n                return false;\n            }\n        } else {\n            return false;\n        }\n        prev = curr;\n        curr = n % 10;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp911bs3h1.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if diff == 0 {\n            return false;\n        }\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmplkor43p0.rs:25:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let cur_digit = n % 10;\n        if is_increasing {\n            if cur_digit > prev_digit {\n                return false;\n            }\n        } else {\n            if cur_digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev_digit = cur_digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpxztzyflf.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = curr_digit - prev_digit;\n    let mut curr_diff;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        curr_diff = curr_digit - prev_digit;\n        if prev_diff * curr_diff >= 0 {\n            return false;\n        }\n        prev_diff = curr_diff;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == last_digit {\n            return false;\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp2c7e42fm.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr_digit = n % 10;\n        if prev_digit == curr_digit {\n            return false;\n        }\n        prev_digit = curr_digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 1 {\n        if digits[i] == digits[i + 1] {\n            return false;\n        }\n        i += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut prev_digit = n % 10;\n    let mut n = n / 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > prev_digit {\n                return false;\n            }\n        } else {\n            if digit < prev_digit {\n                return false;\n            }\n        }\n        prev_digit = digit;\n        n = n / 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpzcpionh1.rs:26:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut current_digit = n % 10;\n    n /= 10;\n    let mut current_state = current_digit > last_digit;\n    while n > 0 {\n        last_digit = current_digit;\n        current_digit = n % 10;\n        n /= 10;\n        if current_state != (current_digit > last_digit) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp_h7c7gi9.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut curr_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = curr_digit > prev_digit;\n    while n > 0 {\n        prev_digit = curr_digit;\n        curr_digit = n % 10;\n        n /= 10;\n        if is_increasing && curr_digit > prev_digit {\n            return false;\n        }\n        if !is_increasing && curr_digit < prev_digit {\n            return false;\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < s.len() {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(j).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(k).unwrap().to_digit(10).unwrap();\n        if a == b || b == c || a == c {\n            return false;\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpf3_xo1z4.rs:23:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = None;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff.is_some() && prev_diff != Some(diff) {\n            return false;\n        }\n        prev_diff = Some(diff);\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpkwjf8ph5.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp01ux398h.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    let mut is_increasing = true;\n    n /= 10;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp7xnq51y3.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 2\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp0wv2ypzo.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwkcsfl7k.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut it = s.chars();\n    let mut last = it.next().unwrap();\n    let mut last_diff = 0;\n    for c in it {\n        let diff = (c as isize) - (last as isize);\n        if last_diff == 0 {\n            last_diff = diff;\n        } else if last_diff * diff != -1 {\n            return false;\n        }\n        last = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpmzj267f0.rs:21:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut last_digit = s.chars().next().unwrap();\n    let mut last_was_increasing = false;\n    for c in s.chars().skip(1) {\n        let is_increasing = c > last_digit;\n        if is_increasing == last_was_increasing {\n            return false;\n        }\n        last_was_increasing = is_increasing;\n        last_digit = c;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = None;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff.is_some() && prev_diff != Some(diff.signum()) {\n            return false;\n        }\n        prev_diff = Some(diff.signum());\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpke1006s5.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr = n % 10;\n        if prev == curr {\n            return false;\n        }\n        prev = curr;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap() as isize).collect::<Vec<_>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 2\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmptxvm8vl7.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpnly0rion.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > prev_digit {\n                return false;\n            }\n        } else {\n            if digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpqz997nno.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<_>>();\n    let mut last_digit = digits[0];\n    let mut last_diff = None;\n    for &digit in digits.iter().skip(1) {\n        let diff = (last_digit as isize) - (digit as isize);\n        if last_diff.is_some() && last_diff.unwrap() != diff {\n            return false;\n        }\n        last_diff = Some(diff);\n        last_digit = digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpus9q5ftk.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = digit - prev_digit;\n        if prev_diff != 0 && prev_diff != diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpvnjzsrii.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < s.len() {\n        if s[i..i + 1].parse::<isize>().unwrap() + s[k..k + 1].parse::<isize>().unwrap() ==\n           s[j..j + 1].parse::<isize>().unwrap() * 2 {\n            i += 1;\n            j += 1;\n            k += 1;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp7t5lxdnn.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = 1;\n    let mut k = 2;\n    while k < s.len() {\n        if s.chars().nth(i).unwrap() == s.chars().nth(j).unwrap() {\n            return false;\n        }\n        if s.chars().nth(i).unwrap() < s.chars().nth(j).unwrap() && s.chars().nth(j).unwrap() > s.chars().nth(k).unwrap() {\n            i += 1;\n            j += 1;\n            k += 1;\n        } else if s.chars().nth(i).unwrap() > s.chars().nth(j).unwrap() && s.chars().nth(j).unwrap() < s.chars().nth(k).unwrap() {\n            i += 1;\n            j += 1;\n            k += 1;\n        } else {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let str_n = n.to_string();\n    let mut last_digit = 0;\n    let mut last_diff = 0;\n    for c in str_n.chars() {\n        let digit = c.to_digit(10).unwrap() as isize;\n        let diff = digit - last_digit;\n        if last_diff != 0 && last_diff != diff {\n            return false;\n        }\n        last_diff = diff;\n        last_digit = digit;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp6ra1c0tk.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    digits.dedup();\n    digits.len() > 1\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmpbqsycw09.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut current_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = current_digit > last_digit;\n    while n > 0 {\n        last_digit = current_digit;\n        current_digit = n % 10;\n        n /= 10;\n        if is_increasing {\n            if current_digit > last_digit {\n                return false;\n            }\n        } else {\n            if current_digit < last_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = curr > prev;\n    let mut is_decreasing = curr < prev;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr > next {\n            is_increasing = false;\n        }\n        if is_decreasing && curr < next {\n            is_decreasing = false;\n        }\n        if !is_increasing && !is_decreasing {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpgf5w8wr5.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev = n % 10;\n    n /= 10;\n    let mut curr = n % 10;\n    n /= 10;\n    let mut next = n % 10;\n    n /= 10;\n    let mut is_increasing = prev < curr;\n    let mut is_decreasing = prev > curr;\n    while n > 0 {\n        prev = curr;\n        curr = next;\n        next = n % 10;\n        n /= 10;\n        if is_increasing && curr > next {\n            is_increasing = false;\n            is_decreasing = true;\n        } else if is_decreasing && curr < next {\n            return false;\n        }\n    }\n    is_increasing || is_decreasing\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpqedf99pi.rs:29:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    for i in 0..digits.len() - 2 {\n        if digits[i] == digits[i + 1] || digits[i + 1] == digits[i + 2] {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1;\n            continue;\n        }\n        if digits[i] > digits[i + 1] && digits[i + 1] < digits[i + 2] {\n            i += 2;\n            continue;\n        }\n        if digits[i] < digits[i + 1] && digits[i + 1] > digits[i + 2] {\n            i += 2;\n            continue;\n        }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing && digit > last_digit {\n            return false;\n        }\n        if !is_increasing && digit < last_digit {\n            return false;\n        }\n        last_digit = digit;\n        is_increasing = !is_increasing;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpd4fr29sk.rs:24:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff != 0 && diff != prev_diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpnly0rion.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = digits(n);\n    let mut prev = digits.next().unwrap();\n    let mut curr = digits.next().unwrap();\n    let mut next = digits.next().unwrap();\n    let mut is_increasing = prev < curr;\n    while next != None {\n        if is_increasing {\n            if curr > next.unwrap() {\n                return false;\n            }\n        } else {\n            if curr < next.unwrap() {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev = curr;\n        curr = next.unwrap();\n        next = digits.next();\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmp68pnbzpp.rs:3:22\n  |\n3 |     let mut digits = digits(n);\n  |                      ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if digit == last_digit {\n            return false;\n        }\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122519,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmprndbkqot.rs:30:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > prev_digit {\n                return false;\n            }\n        } else {\n            if digit < prev_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpqz997nno.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    while n > 0 {\n        let curr_digit = n % 10;\n        if prev_digit == curr_digit {\n            return false;\n        }\n        prev_digit = curr_digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    while i < s.len() - 2 {\n        let a = s.chars().nth(i).unwrap().to_digit(10).unwrap();\n        let b = s.chars().nth(i + 1).unwrap().to_digit(10).unwrap();\n        let c = s.chars().nth(i + 2).unwrap().to_digit(10).unwrap();\n        if (a > b && b < c) || (a < b && b > c) {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut current_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = current_digit > last_digit;\n    while n > 0 {\n        last_digit = current_digit;\n        current_digit = n % 10;\n        n /= 10;\n        if is_increasing {\n            if current_digit > last_digit {\n                return false;\n            }\n        } else {\n            if current_digit < last_digit {\n                return false;\n            }\n        }\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut current_digit = n % 10;\n    n /= 10;\n    let mut current_state = current_digit > last_digit;\n    while n > 0 {\n        last_digit = current_digit;\n        current_digit = n % 10;\n        n /= 10;\n        if current_state {\n            if current_digit > last_digit {\n                return false;\n            }\n        } else {\n            if current_digit < last_digit {\n                return false;\n            }\n        }\n        current_state = !current_state;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut is_increasing = true;\n    while n > 0 {\n        let digit = n % 10;\n        if is_increasing {\n            if digit > last_digit {\n                return false;\n            }\n        } else {\n            if digit < last_digit {\n                return false;\n            }\n        }\n        last_digit = digit;\n        n /= 10;\n        is_increasing = !is_increasing;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1665510012,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp0ppf8o1d.rs:27:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let digits = digits(n);\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 2] {\n            return true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `digits` in this scope\n --> /tmp/tmpp1h1xspy.rs:3:18\n  |\n3 |     let digits = digits(n);\n  |                  ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let s = n.to_string();\n    let mut i = 0;\n    let mut j = s.len() - 1;\n    while i < j {\n        if s.chars().nth(i).unwrap() != s.chars().nth(j).unwrap() {\n            return false;\n        }\n        i += 1;\n        j -= 1;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpxpo7z87_.rs:19:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut prev_digit = n % 10;\n    n /= 10;\n    let mut prev_diff = 0;\n    while n > 0 {\n        let digit = n % 10;\n        let diff = prev_digit - digit;\n        if prev_diff != 0 && prev_diff != diff {\n            return false;\n        }\n        prev_diff = diff;\n        prev_digit = digit;\n        n /= 10;\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp46ytx9q5.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = Vec::new();\n    let mut n = n;\n    while n > 0 {\n        digits.push(n % 10);\n        n /= 10;\n    }\n    digits.reverse();\n    let mut i = 0;\n    while i < digits.len() - 2 {\n        if digits[i] == digits[i + 1] {\n            i += 1;\n        } else if digits[i] > digits[i + 1] {\n            if digits[i + 1] < digits[i + 2] {\n                i += 2;\n            } else {\n                return false;\n            }\n        } else {\n            if digits[i + 1] > digits[i + 2] {\n                i += 2;\n            } else {\n                return false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 2\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp56v5df_t.rs:12:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut digits = n.to_string().chars().map(|c| c.to_digit(10).unwrap()).collect::<Vec<u32>>();\n    digits.sort();\n    digits.dedup();\n    digits.len() == 3\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpwkcsfl7k.rs:11:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// Write a function to check whether the given number is undulating or not.\nfn is_undulating(n: isize) -> bool {\n    let mut n = n;\n    let mut last_digit = n % 10;\n    n /= 10;\n    let mut current_digit = n % 10;\n    n /= 10;\n    let mut current_state = current_digit > last_digit;\n    while n > 0 {\n        last_digit = current_digit;\n        current_digit = n % 10;\n        n /= 10;\n        if current_state != (current_digit > last_digit) {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = is_undulating;\n    assert_eq!(candidate(1212121), true);\n    assert_eq!(candidate(1991), false);\n    assert_eq!(candidate(121), true);\n}\n",
      "timestamp": 1666122520,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmp_h7c7gi9.rs:22:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    }
  ]
}