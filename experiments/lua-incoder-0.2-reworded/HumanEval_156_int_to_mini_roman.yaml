name: HumanEval_156_int_to_mini_roman
language: lua
prompt: "-- Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  -- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n-- Examples:\n\
  -- >>> int_to_mini_roman(19)\n-- 'xix'\n-- >>> int_to_mini_roman(152)\n-- 'clii'\n\
  -- >>> int_to_mini_roman(426)\n-- 'cdxxvi'\nlocal function int_to_mini_roman(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
  \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
  \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
  \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
  \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
  \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
  \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
  \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
  \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- Base case: if the number is 1, return the letter 'x'.\n  if number\
    \ == 1 then\n    return 'x'\n  end", "  -- Base case\n  if number <= 0 then\n\
    \    return nil\n  end", "  -- Base case\n  if number <= 0 then\n    return nil\n\
    \  end", "  local roman = roman_to_int()\n  local roman_numeral = ''\n  local\
    \ i = 1\n  while i <= number do\n    local roman_digit = roman[i]\n    roman_numeral\
    \ = roman_numeral .. roman_digit\n    i = i + 1\n  end\n  return roman_numeral:lower()\n\
    end", "  local roman = roman_to_int()\n  local roman_num = 0\n  local roman_num_str\
    \ = ''\n  local roman_num_str_len = #roman_num_str\n  local roman_num_len = #roman\n\
    \  local roman_num_i = 0\n  while roman_num_i < roman_num_len do\n    local roman_num_char\
    \ = roman[roman_num_i]\n    roman_num_str = roman_num_str .. roman_num_char\n\
    \    roman_num_i = roman_num_i + 1\n    if roman_num_i == roman_num_len then\n\
    \      roman_num_str = roman_num_str .. roman_num_char\n      roman_num_i = roman_num_i\
    \ + 1\n    end\n  end\n  local roman_num_len = #roman_num_str\n  local roman_num_i\
    \ = 0\n  while roman_num_i < roman_num_len do\n    local roman_num_char = roman_num_str[roman_num_i]\n\
    \    roman_num = roman_num + (roman_to_int[roman_num_char] - 1)\n    roman_num_i\
    \ = roman_num_i + 1\n  end\n  local roman_num_len = #roman_num_str\n  local roman_num_i\
    \ = 0\n  while roman_num_i < roman_num_len do\n    local roman_num_char = roman_num_str[roman_num_i]\n\
    \    roman_num = roman_num + (roman_to_int[roman_num_char] - 1)\n    roman_num_i\
    \ = roman_num_i + 1\n  end\n  local roman_num_len = #roman_num_str\n  local roman_num_i\
    \ = 0\n  while roman_num_i < roman_num_len do\n    local roman_num_char = roman_num_str[roman_num_i]\n\
    \    roman_num = roman_num + (roman_to_int[roman_num_char] - 1)\n    roman_num_i\
    \ = roman_num_i + 1\n  end\n  local roman_num_len = #roman_num_str\n  local roman_num_i\
    \ = 0\n  while roman_num_i < roman_num_len do\n    local roman_num_char = roman_num_str[roman_num_i]\n\
    \    roman_num = roman_num + (roman_to_int[roman_num_char] - 1)\n    roman_num_i\
    \ = roman_num_i + 1\n  end\n  local roman_num_len = #roman_num_str\n  local roman_num_i\
    \ = 0\n  while roman_num_i < roman_num_len do\n    local roman_num_char = roman_num_str[roman_num_i]\n\
    \    ro", "  assert(number >= 1 and number <= 1000, 'Invalid input: number must\
    \ be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <= number\
    \ do\n    roman = roman .. roman_table[i]\n    i = i + 1\n  end\n  return roman:lower()\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  -- Base\
    \ case\n  if number <= 0 then\n    return ''\n  end", "  local roman = roman_to_int()\n\
    \  local roman_num = 0\n  local roman_num_str = ''\n  while number > 0 do\n  \
    \  local remainder = number % 100\n    number = number / 100\n    roman_num =\
    \ roman_num + roman[remainder]\n    roman_num_str = roman_num_str .. roman[remainder]\n\
    \  end\n  return roman_num_str:lower()\nend", "  -- Base case\n  if number <=\
    \ 0 then\n    return nil\n  end", "  -- Base case: if the number is 1, return\
    \ 'i'.\n  if number == 1 then\n    return 'i'\n  end\n  -- Base case: if the number\
    \ is 10, return 'd'.\n  if number == 10 then\n    return 'd'\n  end\n  -- Base\
    \ case: if the number is 100, return 'c'.\n  if number == 100 then\n    return\
    \ 'c'\n  end\n  -- Base case: if the number is 1000, return 'x'.\n  if number\
    \ == 1000 then\n    return 'x'\n  end\n  -- Base case: if the number is 10000,\
    \ return 'l'.\n  if number == 10000 then\n    return 'l'\n  end\n  -- Base case:\
    \ if the number is 100000, return 'xl'.\n  if number == 100000 then\n    return\
    \ 'xl'\n  end\n  -- Base case: if the number is 1000000, return 'xxl'.\n  if number\
    \ == 1000000 then\n    return 'xxl'\n  end\n  -- Base case: if the number is 10000000,\
    \ return 'xxxl'.\n  if number == 10000000 then\n    return 'xxxl'\n  end\n  --\
    \ Base case: if the number is 100000000, return 'xlxxl'.\n  if number == 100000000\
    \ then\n    return 'xlxxl'\n  end\n  -- Base case: if the number is 1000000000,\
    \ return 'xxxxl'.\n  if number == 1000000000 then\n    return 'xxxxl'\n  end\n\
    \  -- Base case: if the number is 10000000000, return 'xxxxl'.\n  if number ==\
    \ 10000000000 then\n    return 'xxxxl'\n  end\n  -- Base case: if the number is\
    \ 100000000000, return 'xxxxl'.\n  if number == 100000000000 then\n    return\
    \ 'xxxxl'\n  end\n  -- Base case: if the number is 1000000000000, return 'xxxxxl'.\n\
    \  if number == 1000000000000 then\n    return 'xxxxxl'\n  end\n  -- Base case:\
    \ if the number is 10000000000000, return 'xxxxxxl'.\n  if number == 10000000000000\
    \ then\n    return 'xxxxxxl'\n  end\n  -- Base case: if the number is 100000000000000,\
    \ return 'xxxxxxxl'.\n  if number == 100000000000000 then\n    return 'xxxxxxxl'\n\
    \  end\n  -- Base case: if the number is 1000000000000000, return 'xxxxxxxxl'.\n\
    \  if number == 1000000000000000 then\n    return 'xxxxxxxxl'\n  end\n  -- Base\
    \ case: if the number is 10000000000000000, return 'xxxxxxxxxl'.\n  if number\
    \ == 10000000000000000 then\n    return 'xxxxxxxxxl'\n  end\n  -- Base case: if\
    \ the number is 100000000000000000, return 'xxxxxxxxxx", "  local roman = roman_numeral()\n\
    \  local roman_number = ''\n  local i = 1\n  while i <= number do\n    local roman_number\
    \ = roman_number .. roman[i]\n    i = i + 1\n  end\n  return roman_number:lower()\n\
    end", "  -- Base case\n  if number <= 0 then\n    return nil\n  end", "  local\
    \ roman = roman_to_int()\n  local roman_numeral = ''\n  local roman_numeral_length\
    \ = roman:len()\n  local roman_numeral_length = roman_numeral_length - 1\n  while\
    \ number > 0 do\n    local remainder = number % roman_numeral_length\n    roman_numeral\
    \ = roman:sub(1, roman_numeral_length - remainder) .. roman_numeral\n    number\
    \ = math.floor(number / roman_numeral_length)\n  end\n  return roman_numeral:lower()\n\
    end", "  assert(number >= 1 and number <= 1000)\n  local roman = roman_numerals[number]\n\
    \  if roman == nil then\n    roman = roman_numerals[number] = roman_numerals[number]\n\
    \    for i = 1, number do\n      roman = roman .. roman_numerals[i]\n    end\n\
    \  end\n  return roman:lower()\nend", "  assert(number >= 1 and number <= 1000,\
    \ 'number must be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while\
    \ i <= number do\n    roman = roman .. roman_numeral(i)\n    i = i + 1\n  end\n\
    \  return roman:lower()\nend", "  assert(number >= 1 and number <= 1000, 'number\
    \ must be between 1 and 1000')\n  local roman = ''\n  local i = 1\n  while i <=\
    \ number do\n    roman = roman .. mini_roman[i]\n    i = i + 1\n  end\n  return\
    \ roman\nend", "  -- Base case\n  if number <= 0 then\n    return nil\n  end",
  "  local roman = roman_numeral()\n  local roman_numeral = ''\n  local i = 0\n  while\
    \ i < number do\n    roman_numeral = roman_numeral .. roman[i]\n    i = i + 1\n\
    \  end\n  return roman_numeral:lower()\nend", "  -- Base case\n  if number <=\
    \ 0 then\n    return nil\n  end"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
