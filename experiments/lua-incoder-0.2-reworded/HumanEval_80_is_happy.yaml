name: HumanEval_80_is_happy
language: lua
prompt: "-- You are given a string s.\n-- Your task is to check if the string is haplua\
  \ or not.\n-- A string is haplua if its length is at least 3 and every 3 consecutive\
  \ letters are distinct\n-- For example:\n-- >>> is_happy(a)\n-- false\n-- >>> is_happy(aa)\n\
  -- false\n-- >>> is_happy(abcd)\n-- true\n-- >>> is_happy(aabb)\n-- false\n-- >>>\
  \ is_happy(adb)\n-- true\n-- >>> is_happy(xyy)\n-- false\nlocal function is_happy(s)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = is_happy\n\
  \    lu.assertEquals(candidate('a'), false)\n    lu.assertEquals(candidate('aa'),\
  \ false)\n    lu.assertEquals(candidate('abcd'), true)\n    lu.assertEquals(candidate('aabb'),\
  \ false)\n    lu.assertEquals(candidate('adb'), true)\n    lu.assertEquals(candidate('xyy'),\
  \ false)\n    lu.assertEquals(candidate('iopaxpoi'), true)\n    lu.assertEquals(candidate('iopaxioi'),\
  \ false)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  -- base case\n  if #s < 3 then return false end\n  -- base case\n\
    \  if #s == 3 then return true end\n  -- recursive case\n  local last_letter =\
    \ s[1]\n  local last_letter_count = s[1]\n  local last_letter_index = #s\n  local\
    \ last_letter_count = 1\n  for i = 2, #s do\n    if s[i] ~= last_letter then\n\
    \      last_letter = s[i]\n      last_letter_count = s[i]\n      last_letter_index\
    \ = i\n      last_letter_count = 1\n    else\n      last_letter_count = last_letter_count\
    \ + 1\n    end\n  end\n  return last_letter_count >= 3 and last_letter_count ==\
    \ last_letter_index\nend", "  -- base case\n  if #s < 3 then return false end\n\
    \  -- base case\n  if #s == 3 then return true end\n  -- recursive case\n  if\
    \ s[2] ~= s[3] then return false end\n  return is_happy(s[3])\nend", "  -- base\
    \ case\n  if #s < 3 then\n    return false\n  end", "  -- base case\n  if #s <\
    \ 3 then return false end\n  -- base case\n  if #s == 3 then return true end\n\
    \  -- recursive case\n  local first_letter = s[1]\n  local second_letter = s[2]\n\
    \  local third_letter = s[3]\n  -- base case\n  if first_letter == second_letter\
    \ and second_letter == third_letter then return true end\n  -- recursive case\n\
    \  if first_letter == second_letter or first_letter == third_letter then\n   \
    \ return is_happy(s[2:])\n  end\n  -- base case\n  if second_letter == third_letter\
    \ then return false end\n  -- recursive case\n  return is_happy(s[2:])\nend",
  "  local n = #s\n  if n < 3 then return false end\n  for i = 1, n do\n    if s[i]\
    \ ~= s[i] then return false end\n  end\n  return true\nend", "  -- base case\n\
    \  if #s < 3 then return false end\n  -- base case\n  if #s == 3 then return true\
    \ end\n  -- recursive case\n  local happy = false\n  for i = 1, #s do\n    if\
    \ s[i] ~= s[i - 1] then\n      happy = false\n      break\n    end\n  end\n  return\
    \ happy\nend", "    local count = 0\n    for i = 1, #s do\n        if s[i] ~=\
    \ s[count] then\n            count = count + 1\n        else\n            count\
    \ = count + 1\n        end\n    end\n    return count >= 3 and count % 3 == 0\n\
    end", "    local n = 1\n    for i = 1, #s do\n        if s[n] == s[n - 1] then\n\
    \            n = n + 1\n        else\n            if n >= 3 then\n           \
    \     return false\n            end\n            n = 1\n        end\n    end\n\
    \    return true\nend", "    local count = 0\n    for i = 1, #s do\n        if\
    \ s[i] ~= s[i - 1] then\n            count = count + 1\n        end\n    end\n\
    \    return count >= 3 and count == #s and #s % 3 == 0\nend", "  -- Your code\
    \ here\n  local count = 0\n  local is_happy = false\n  for i = 1, #s do\n    if\
    \ s[i] == s[i - 1] or s[i] == s[i - 2]\n    then\n      count = count + 1\n  \
    \  elseif count == 3 then\n      is_happy = true\n      count = 0\n    end\n \
    \ end\n  return is_happy\nend", "    local count = 0\n    for i = 1, #s do\n \
    \       if s[i - 1] ~= s[i] then\n            count = count + 1\n        end\n\
    \    end\n    return count >= 3 and count == #s and #s % 3 == 0\nend", "  -- base\
    \ case\n  if #s < 3 then return false end\n  -- base case\n  if #s == 3 then return\
    \ true end\n  -- recursive case\n  local happy = false\n  for i = 1, #s do\n \
    \   if s[i] ~= s[(i + 1) % #s] then\n      happy = false\n      break\n    end\n\
    \  end\n  return happy\nend", "  -- base case\n  if #s < 3 then return false end\n\
    \  -- check every 3 consecutive letters are distinct\n  for i = 1, #s - 1, 3 do\n\
    \    if s[i] ~= s[i + 1] then return false end\n  end\n  return true\nend", " \
    \ -- base case\n  if #s <= 3 then\n    return true\n  end", "  local count = 0\n\
    \  for i = 1, #s do\n    count = count + 1\n    if count == 3 then\n      count\
    \ = count + 1\n    end\n  end\n  if #s <= 3 then\n    return true\n  end\n  for\
    \ i = 1, #s do\n    if s[i] ~= s[i] then\n      return false\n    end\n  end\n\
    \  return true\nend", "  -- base case\n  if #s < 3 then return false end\n  --\
    \ base case\n  if #s == 3 then return true end\n  -- recursive case\n  local first\
    \ = s[1]\n  local rest = s[2:]\n  -- base case\n  if first ~= rest[1] then return\
    \ false end\n  -- recursive case\n  local rest2 = rest[2]\n  -- base case\n  if\
    \ rest2 ~= rest[1] then return false end\n  -- recursive case\n  local rest3 =\
    \ rest[3]\n  -- base case\n  if rest3 ~= rest[1] then return false end\n  -- recursive\
    \ case\n  local rest4 = rest[4]\n  -- base case\n  if rest4 ~= rest[1] then return\
    \ false end\n  -- recursive case\n  local rest5 = rest[5]\n  -- base case\n  if\
    \ rest5 ~= rest[1] then return false end\n  -- recursive case\n  local rest6 =\
    \ rest[6]\n  -- base case\n  if rest6 ~= rest[1] then return false end\n  -- recursive\
    \ case\n  local rest7 = rest[7]\n  -- base case\n  if rest7 ~= rest[1] then return\
    \ false end\n  -- recursive case\n  local rest8 = rest[8]\n  -- base case\n  if\
    \ rest8 ~= rest[1] then return false end\n  -- recursive case\n  local rest9 =\
    \ rest[9]\n  -- base case\n  if rest9 ~= rest[1] then return false end\n  -- recursive\
    \ case\n  local rest10 = rest[10]\n  -- base case\n  if rest10 ~= rest[1] then\
    \ return false end\n  -- recursive case\n  local rest11 = rest[11]\n  -- base\
    \ case\n  if rest11 ~= rest[1] then return false end\n  -- recursive case\n  local\
    \ rest12 = rest[12]\n  -- base case\n  if rest12 ~= rest[1] then return false\
    \ end\n  -- recursive case\n  local rest13 = rest[13]\n  -- base case\n  if rest13\
    \ ~= rest[1] then return false end\n  -- recursive case\n  local rest14 = rest[14]\n\
    \  -- base case\n  if rest14 ~= rest[1] then return false end\n  -- recursive\
    \ case\n  local rest15 = rest[15]\n  -- base case\n  if rest15 ~= rest[1] then\
    \ return false end\n  -- recursive case\n  local rest16 = rest[16]\n  -- base\
    \ case\n  if rest16 ~= rest[1] ", "  -- base case\n  if #s < 3 then return false\
    \ end", "  local count = 0\n  local last_letter = nil\n  for letter in s:gmatch(\"\
    [%a]+\") do\n    if letter == last_letter then\n      count = count + 1\n    else\n\
    \      if count >= 3 then\n        return false\n      end\n      count = 0\n\
    \    end\n    last_letter = letter\n  end\n  return true\nend", "  local count\
    \ = 0\n  local last = ''\n  for i = 1, #s do\n    local c = s[i]\n    if last\
    \ ~= c and last ~= '' then\n      count = count + 1\n    end\n    last = c\n \
    \ end\n  return count >= 3 and count % 3 == 0\nend", "  local len = #s\n  if len\
    \ < 3 then return false end\n  for i = 1, len do\n    if s[i] != s[i] then return\
    \ false end\n  end\n  return true\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
