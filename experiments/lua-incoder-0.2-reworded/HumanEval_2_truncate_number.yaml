name: HumanEval_2_truncate_number
language: lua
prompt: "-- Given a positive floating point number, it can be decomposed into\n--\
  \ and integer part (largest integer smaller than given number) and decimals\n--\
  \ (leftover part always smaller than 1).\n-- Return the decimal part of the number.\n\
  -- >>> truncate_number(3.5)\n-- 0.5\nlocal function truncate_number(number)\n"
tests: "lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = truncate_number\n\
  \    lu.assertEquals(candidate(3.5), 0.5)\n    lu.assertEquals(candidate(1.25),\
  \ 0.25)\n    lu.assertEquals(candidate(123.0), 0.0)\nend\n\nos.exit(lu.LuaUnit.run())"
completions: ["  local decimals = math.floor(math.log10(number))\n  local integer_part\
    \ = math.trunc(number)\n  local decimal_part = number - integer_part\n  return\
    \ decimal_part / 10^decimals, integer_part, decimals\nend", "  local integer_part,\
    \ decimals = math.modf(number)\n  return integer_part * math.pow(10, math.floor(decimals))\n\
    end", "  local decimals = math.floor(math.log(number, 10) + 1)\n  local integer_part\
    \ = math.trunc(number)\n  return integer_part / 10^decimals, integer_part % 10^decimals\n\
    end", "  local decimals = math.floor(math.log(number, 10) + 1)\n  return math.modf(number\
    \ * 10^decimals)[1]\nend", "  local decimals = math.floor(math.log(number, 10)\
    \ + 1)\n  return math.floor(number / 10^decimals) / 10^decimals\nend", "  local\
    \ decimals = math.floor(math.log(number, 10))\n  local integer_part = math.trunc(number)\n\
    \  return integer_part / 10^decimals, integer_part % 10^decimals\nend", "  local\
    \ decimals = math.floor(math.log(number, 10) + 1)\n  return math.floor(number\
    \ / 10^decimals) / 10^decimals\nend", "  local decimal_part = math.floor(number)\n\
    \  local integer_part = math.trunc(number)\n  local remainder = number - integer_part\n\
    \  return decimal_part + remainder\nend", "  local integer_part = math.floor(number)\n\
    \  local decimal_part = math.modf(number - integer_part)[1]\n  return integer_part\
    \ + decimal_part\nend", "  if number < 0 then\n    return nil\n  end\n  local\
    \ decimals = math.floor(math.log(number) / math.log(10) + 1)\n  return math.floor(number\
    \ * 10^decimals) / 10^decimals\nend", "  local decimal_part = math.floor(number)\n\
    \  local integer_part = math.trunc(number)\n  return decimal_part + (integer_part\
    \ - decimal_part) / math.pow(10, math.floor(math.log(number, 10)))\nend", "  local\
    \ integer_part, decimal_part = math.modf(number)\n  return decimal_part * 100\n\
    end", "  if number < 1 then\n    return 0\n  end\n  local factor = 1\n  local\
    \ decimal_part = 1\n  local integer_part = 1\n  local decimal_part_remainder\n\
    \  local integer_part_remainder\n  while number > 1 do\n    decimal_part_remainder\
    \ = math.modf(number)\n    integer_part_remainder = math.modf(integer_part)\n\
    \    factor = math.floor(decimal_part_remainder[1])\n    decimal_part = decimal_part_remainder[2]\n\
    \    integer_part = integer_part_remainder[1]\n    number = number * factor\n\
    \  end\n  return decimal_part\nend", "  local decimals = math.floor(math.log(number,\
    \ 10) + 1)\n  local integer_part = math.trunc(number)\n  local fraction = number\
    \ - integer_part\n  return integer_part, decimals, fraction\nend", "  local integer_part,\
    \ decimals = math.modf(number)\n  return integer_part * math.pow(10, math.floor(decimals))\n\
    end", "  local decimal_part = math.floor(number)\n  local integer_part = math.trunc(number)\n\
    \  return decimal_part + (integer_part - decimal_part) / math.pow(10, math.floor(math.log(number,\
    \ 10)))\nend", "    local decimals = math.floor(math.log(number, 10) + 1)\n  \
    \  return math.floor(number / 10^decimals) / 10^decimals\nend", "  local sign\
    \ = math.sign( number )\n  local integer = math.floor( number )\n  local decimals\
    \ = math.abs( number - integer )\n  local fraction = decimal / 10\n  local remainder\
    \ = decimal % 10\n  return sign * integer + fraction + remainder\nend", "  if\
    \ number < 0 then\n    return 0\n  end\n  local integer_part = math.floor(number)\n\
    \  local decimal_part = math.modf(number - integer_part)[1]\n  return integer_part\
    \ + decimal_part\nend", "  local decimals = math.floor(math.log10(number))\n \
    \ local integer_part = math.pow(10, decimals)\n  local trunc_part = number - integer_part\n\
    \  return trunc_part / integer_part\nend"]
stop_tokens:
- "\nlocal"
- "\nfunction"
- "\n--"
- "\n\n"
