name: HumanEval_26_remove_duplicates
language: js
prompt: "//From an array of integers, remove all elements that occur more than once.\n\
  // Keep order of elements left the same as in the input.\n// >>> remove_duplicates([1,\
  \ 2, 3, 2, 4])\n// [1, 3, 4]\nfunction remove_duplicates(numbers){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = remove_duplicates;\n  assert.deepEqual(candidate([]),[]);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 4]),[1, 2, 3, 4]);\n  assert.deepEqual(candidate([1, 2, 3, 2, 4, 3, 5]),[1,\
  \ 4, 5]);\n}\n\ntest();"
completions: ["    const map = new Map();\n    for(const [key, value] of numbers){\n\
    \        if(map.has(key)){\n            map.set(key, map.get(key) + value)\n \
    \       } else {\n            map.set(key, value);\n        }\n    }\n    return\
    \ Array.from(map.values()).sort();\n}\n", "  var output = [];\n  for (var i =\
    \ 0; i < numbers.length; i++){\n    if (output.indexOf(numbers[i]) == -1){\n \
    \     output.push(numbers[i]);\n    }\n  }\n  return output;\n}\n", "  var output\
    \ = [];\n  var seen = [];\n  for(var i = 0; i < numbers.length; i++){\n    if\
    \ (seen.indexOf(numbers[i]) !== -1) continue;\n    seen.push(numbers[i]);\n  \
    \  output.push(numbers[i]);\n  }\n  return output;\n}\n", "  var result = [];\n\
    \  var seen = {};\n  for(var i = 0; i < numbers.length; i++){\n    var num = numbers[i];\n\
    \    if(seen[num]){\n      continue;\n    }\n    seen[num] = true;\n    result.push(num);\n\
    \  }\n  return result;\n}\n", "    let newArray = [];\n    for (let i = 0; i <\
    \ numbers.length; i++){\n        if (newArray.indexOf(numbers[i]) == -1){\n  \
    \          newArray.push(numbers[i]);\n        }\n    }\n    return newArray;\n\
    }", "\tvar i,\n\t\tj,\n\t\tlen=numbers.length,\n\t\tout=[],\n\t\tobj={},\n\t\t\
    arr=[];\n\n\tfor (i=0; i < len; i+=1){\n\t\tobj[numbers[i]] = true;\n\t}\n\n\t\
    for (j=0; j < len; j+=1){\n\t\tif (obj[numbers[j]]){\n\t\t\tarr.push(numbers[j]);\n\
    \t\t\tobj[numbers[j]] = false;\n\t\t}\n\t}\n\n\treturn arr;\n}", "    var counts\
    \ = d3.map();\n    numbers.forEach(function(d){\n        var count = (counts.get(d)\
    \ || 0) + 1;\n        counts.set( d, count );\n    });\n\n    return numbers.filter(function(d){\n\
    \        return counts.get(d) == 1;\n    });\n}\n", "  let seen = [];\n  let uniques\
    \ = [];\n  for (let i = 0; i < numbers.length; i++){\n    if (seen.indexOf(numbers[i])\
    \ > -1){\n      continue;\n    }\n    seen.push(numbers[i]);\n    uniques.push(numbers[i]);\n\
    \  }\n  return uniques;\n}", "    var newArray = [];\n    for(var i = 0; i < numbers.length;\
    \ i++){\n        if(newArray.indexOf(numbers[i]) == -1) newArray.push(numbers[i]);\n\
    \    }\n    return newArray;\n}\n", "  let counts = numbers.reduce((counts, number)\
    \ => {\n    counts[number] = (counts[number]) ? counts[number] + 1 : 1;\n    return\
    \ counts;\n  }, {});\n  return Object.keys(counts).reduce((uniques, number) =>\
    \ {\n    if (counts[number] > 1) {\n      uniques.push(number);\n    }\n    return\
    \ uniques;\n  }, []);\n}\n", "  var ret = [];\n  for(var i = 1; i < numbers.length;\
    \ i++){\n    if(numbers[i] === numbers[i-1]) ret.push(numbers[i]);\n  }\n  return\
    \ ret;\n}\n", "\tvar new_array = [];\n\tfor(var i=0, len=numbers.length; i<len;\
    \ i++){\n\t\tif(numbers.indexOf(numbers[i])>-1){\n\t\t\tnew_array.push(numbers[i]);\n\
    \t\t}\n\t}\n\treturn new_array;\n}\n", "  var output = [];\n  for (var i = 0;\
    \ i < numbers.length; i++){\n    if (output.indexOf(numbers[i]) === -1){\n   \
    \   output.push(numbers[i]);\n    }\n  }\n  return output;\n}\n", "    var result\
    \ = [];\n    var len = numbers.length;\n    var prev_value = -1;\n    for(var\
    \ i=0; i<len; i++){\n        var value = numbers[i];\n        if(value === prev_value){\n\
    \            continue;\n        }\n        result.push(value);\n        prev_value\
    \ = value;\n    }\n    return result;\n}\n\n", "  let result = [];\n  for(let\
    \ i=0, len=numbers.length; i < len; i++){\n    if (result.indexOf(numbers[i])\
    \ === -1) {\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n",
  "  var result = [];\n  _.each(numbers, function(value){\n    if ( _.contains(result,\
    \ value) ) {\n      result = _.without(result, value);\n    }\n    result.push(value);\n\
    \  });\n  return result;\n}\n", "  var new_arr = [];\n  for(var i = 0, len = numbers.length;\
    \ i < len; i++){\n    if(new_arr.indexOf(numbers[i]) == -1) new_arr.push(numbers[i]);\n\
    \  }\n  return new_arr;\n}\n", "  var new_arr = [], hash = [];\n  for(var i in\
    \ numbers){\n    if (hash.indexOf(numbers[i]) == -1){\n      new_arr.push(numbers[i]);\n\
    \      hash.push(numbers[i]);\n    }\n  }\n  return new_arr;\n}\n", "  var hash\
    \ = {}\n  numbers.forEach(function(e){hash[e] = 1})\n  return Object.keys(hash)\n\
    }\n", "\tvar seen = [];\n\tfor(var i = 0; i < numbers.length; i++){\n\t\tif(!seen.includes(numbers[i])){\n\
    \t\t\tseen.push(numbers[i]);\n\t\t}\n\t}\n\treturn seen;\n}\n", "    numbers =\
    \ array_copy( numbers );\n    var result = [],\n        seen = [];\n    for(var\
    \ i = 0; i < numbers.length; i++){\n        if(numbers[i] in seen){\n        \
    \    result.push(numbers[i]);\n        } else {\n            seen.push( numbers[i]\
    \ );\n        }\n    }\n    return result;\n}\n", "  var result = [];\n  for(var\
    \ i=0; i<numbers.length; i++){\n    if(result.indexOf(numbers[i]) == -1){\n  \
    \    result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n", "  var newArray\
    \ = []\n  var newIndex = 0\n  var index\n\n  for(index in numbers){\n    if(numbers[index]\
    \ == numbers[newIndex]){\n      newIndex++\n      continue\n    }\n    newArray.push(numbers[index])\n\
    \  }\n\n  for(index in numbers){\n    if(numbers[index] == numbers[newIndex]){\n\
    \      newArray.push(numbers[newIndex])\n      newIndex++\n      continue\n  \
    \  }\n  }\n\n  return newArray\n}\n\n", "  const map = new Map();\n  const result\
    \ = [];\n  for(let i = 0; i < numbers.length; i++){\n    if(map.has(numbers[i])){\n\
    \      continue;\n    }\n    map.set(numbers[i], i);\n    result.push(numbers[i]);\n\
    \  }\n  return result;\n}\n", "  var unique_numbers = [];\n  for (var i = 0; i\
    \ < numbers.length; i++){\n    if (unique_numbers.indexOf(numbers[i]) === -1){\n\
    \      unique_numbers.push(numbers[i]);\n    }\n  }\n  return unique_numbers;\n\
    }\n", "  var output = [];\n  \n  for(var i=0;i<numbers.length;i++){\n    if(!output.includes(numbers[i])){\n\
    \      output.push(numbers[i]);\n    }\n  }\n  \n  return output;\n}\n", "   \
    \ var output = [];\n    var seen = [];\n    for(var i = 0; i < numbers.length;\
    \ i++){\n        if(seen.indexOf(numbers[i]) == -1){\n            seen.push(numbers[i]);\n\
    \            output.push(numbers[i]);\n        }\n    }\n    return output;\n\
    }\n", "\tvar result = [];\n\tfor(var i = 0; i < numbers.length; i++){\n\t\tvar\
    \ el = numbers[i];\n\t\tif(result.indexOf(el) === -1) result.push(el);\n\t}\n\t\
    return result;\n}\n\n", "    var output = [];\n    \n    for(var i = 0; i < numbers.length;\
    \ i++){\n        var count = 0;\n        for(var j = 0; j < numbers.length; j++){\n\
    \            if(numbers[i] == numbers[j]){\n                count++;\n       \
    \     }\n        }\n        if(count > 1){\n            output.push(numbers[i]);\n\
    \        }\n    }\n    return output;\n}\n", "  // From the array numbers, remove\
    \ all elements that occur more than once.\n  //Keep order of elements left the\
    \ same as in the input.\n  return numbers.length !== numbers.reduce(function(a,\
    \ b){\n    return a + (numbers[b] ? 1 : 0);\n  }, 0);\n}\n", "  var result = [];\n\
    \  for(var i = 0; i < numbers.length; i++){\n    if(numbers.indexOf(numbers[i])\
    \ != i){\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\n\
    var remove_duplicates_test = function(numbers){\n  assert(remove_duplicates(numbers)\
    \ == [1,3,4], \"Unexpected output\");\n  assert(remove_duplicates([1,2,3,1,2])\
    \ == [1,2,3,4], \"Unexpected output\");\n  assert(remove_duplicates([]) == [],\
    \ \"Unexpected output\");\n  assert(remove_duplicates([1,4,4,3,2]) == [1,3,2],\
    \ \"Unexpected output\");\n};\n", "  let obj = {};\n  let res = [];\n  for(let\
    \ num of numbers){\n    obj[num] = (obj[num] || 0) + 1;\n  }\n  for(let num in\
    \ obj){\n    if(obj[num] === 1){\n      res.push(num);\n    }\n  }\n  return res;\n\
    }\n", "    let sorted = numbers.slice();\n    sorted.sort();\n    return sorted.filter(function(item,\
    \ pos, self){\n        return self.indexOf(item) == pos;\n    });\n}\n", "\tvar\
    \ unique = [];\n\n\tfor(var i = 0; i < numbers.length; i++){\n\t\tvar current\
    \ = numbers[i];\n\n\t\tfor(var j = 0; j < unique.length; j++){\n\t\t\tif(current\
    \ === unique[j]){\n\t\t\t\t//number found, remove it\n\t\t\t\tunique.splice(j,\
    \ 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(unique.length === 0){\n\t\t\t\
    unique.push(current);\n\t\t}\n\t}\n\n\treturn unique;\n}\n", "  var seen = [];\n\
    \  var nodupes = [];\n\n  for (var i = 0; i < numbers.length; i++) {\n    if (!seen[numbers[i]])\
    \ {\n      seen[numbers[i]] = true;\n      nodupes.push(numbers[i]);\n    }\n\
    \  }\n  return nodupes;\n}\n", "    var output = [];\n    var seen = [];\n   \
    \ for(var i = 0; i < numbers.length; i++){\n        if(seen.indexOf(numbers[i])\
    \ !== -1){\n            continue;\n        }\n        seen.push(numbers[i]);\n\
    \        output.push(numbers[i]);\n    }\n    return output;\n}\n", "  numbers.sort();\n\
    \  var result = [];\n  var last = numbers[0];\n  for (var i = 0; i < numbers.length;\
    \ i++){\n    if (numbers[i] === last){\n      continue;\n    }\n    result.push(last);\n\
    \    last = numbers[i];\n  }\n  return result;\n}\n</code>\nI used the .sort()\
    \ function on an array of numbers, and I used the Array.prototype function indexOf()\
    \ to get the index of each number in the array. That way you get the index of\
    \ the last number added to the result array. I added the variable last to keep\
    \ the previous last number in order to know when to stop adding to the result\
    \ array.\nHope this helps you!\n<|/ a tags=algorithm,arrays,javascript,sorting\
    \ |>\n<| c |>\nThanks for your reply.\n\nIt's not about removing duplicates from\
    \ an array of numbers. My question was about how to sort the array while retaining\
    \ the order of the elements. I have added an example to my question which I hope\
    \ clarifies what I want.\n<|/ c |>\n<| a tags=algorithm,arrays,javascript,sorting\
    \ |>\nA simple approach would be to create a map of keys and sort them accordingly,\
    \ then rebuild the array:\n\n<code>\nlet arr = [1,2,3,3,4,4,5,5,5];\nlet res =\
    \ [];\nlet map = {};\nfor(let i=0; i<arr.length; i++){\n  if (!map[arr[i]]) map[arr[i]]\
    \ = i;\n}\n\nObject.keys(map).sort().forEach((key) => res.push(map[key]));\n",
  "  var hash = {};\n  for(var i = 0; i < numbers.length; i++){\n    hash[numbers[i]]\
    \ = true;\n  }\n  return Object.keys(hash);\n}\n", "    let result = new Set()\n\
    \    for (let num of numbers){\n        if (!result.has(num)){\n            result.add(num)\n\
    \        }\n    }\n    return Array.from(result)\n}", "  return [...new Set(numbers)];\n\
    }\n", "  var result = [];\n  for(var i=0;i<numbers.length;i++){\n    if(result.indexOf(numbers[i])\
    \ == -1){\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n</code></pre>\n\
    </section>\n\n<section>\n    <h2>Filter Function</h2>\n    <p>\n        A filter\
    \ function allows you to alter the values that get passed into the callback. This\
    \ can be useful for creating complex filtering functions.\n    </p>\n    <pre><code\
    \ class=\"hljs js\">// Filter function that only keeps odd numbers when adding\
    \ them\nvar filterOdds = function(number) {\n  return number % 2 === 1;\n}\n",
  "\tvar result = new Array();\n\tvar j=0;\n\n\tfor(var i =0;i<numbers.length;i++){\n\
    \t\tvar element = numbers[i];\n\t\tif(result.indexOf(element) == -1){\n\t\t\t\
    j++;\n\t\t\tresult[result.length] = element;\n\t\t}\n\t}\n\treturn result;\n}\n",
  "  var ret = [];\n  for(var i = 0; i < numbers.length; i++){\n    var number = numbers[i];\n\
    \    if(ret.indexOf(number) == -1) ret.push(number);\n  }\n  return ret;\n}\n\n",
  "    var hash = {}, i, n=numbers.length;\n    for(i = 0; i < n; i++){\n        if\
    \ (!hash[numbers[i]]) hash[numbers[i]] = true;\n    }\n    return numbers.filter(function(it){\n\
    \        return !hash[it];\n    });\n}\n</code>\n<|/ a |>\n<| c |>\nThank you\
    \ for the solution, but I used a different approach. See my answer below.\n<|/\
    \ c |>\n<| c |>\nSure, that solution was actually pretty interesting. But I wouldn't\
    \ use it to solve your problem :)\n<|/ c |>\n<| c |>\nYes, I agree with you. I\
    \ wanted to keep it simple. I will update my answer to show how I did it.\n<|/\
    \ c |>\n<| a |>\nHere's my solution:\n<code>", "   let new_array = new Array();\n\
    \   numbers.forEach(number => {\n     if(new_array.indexOf(number) === -1) new_array.push(number);\n\
    \   });\n   return new_array;\n}\n", "  var i, j, k, number, newArray, uniques\
    \ = [];\n  for (i = 0; i < numbers.length; i++){\n    if (uniques.indexOf(numbers[i])\
    \ != -1) continue;\n    uniques.push(numbers[i]);\n    for (j = i + 1; j < numbers.length;\
    \ j++){\n      if (uniques.indexOf(numbers[j]) == -1) continue;\n      number\
    \ = numbers[j];\n      newArray = [];\n      for (k = j - 1; k >= i; k--){\n \
    \       if (uniques.indexOf(numbers[k]) == -1) continue;\n        newArray.push(numbers[k]);\n\
    \      }\n      uniques = newArray;\n    }\n  }\n  return uniques;\n}", "  var\
    \ output = [];\n  var count = 0;\n  var i;\n  for(i = 0; i < numbers.length; i++){\n\
    \    output.push(numbers[i]);\n    count++;\n  }\n  for(i = 0; i < numbers.length;\
    \ i++){\n    if(count > 1){\n      output.push(numbers[i]);\n      count--;\n\
    \    }\n  }\n  return output;\n}\n", "  return numbers.filter((e, i, a) => {\n\
    \    return a.indexOf(e) === i\n  })\n}\n", "\tlet uniques = [];\n\tfor (let i\
    \ = 0; i < numbers.length; i++) {\n\t\tif (uniques.indexOf(numbers[i]) < 0) {\n\
    \t\t\tuniques.push(numbers[i]);\n\t\t}\n\t}\n\treturn uniques;\n}\n", "  let unique\
    \ = []\n  for(var i = 0; i < numbers.length; i++){\n    if(!numbers.includes(i)){\n\
    \      unique.push(numbers[i])\n    }\n  }\n  return unique\n}\n", "  var i=0,j=0;\n\
    \  var temp=[];\n  var hash={};\n  for(i=0;i<numbers.length;i++){\n    var number=numbers[i];\n\
    \    if(hash[number]){\n      j=j+1;\n    }else{\n      hash[number]=true;\n \
    \     temp.push(number);\n    }\n  }\n  for(j=0;j<temp.length;j++){\n    numbers[j]=temp[j];\n\
    \  }\n  return numbers;\n}\n", "  // Create a hash table from the numbers.\n \
    \ var hashes = numbers.reduce(function(prev,current){\n    prev[current] = 1;\n\
    \    return prev;\n  },{});\n  // Filter out any numbers that occur more than\
    \ once.\n  return numbers.filter(function(el,ix){\n    return !(ix in hashes)\
    \ || (hashes[ix] === 1);\n  });\n}", "    for(var i=0, l=numbers.length, out =\
    \ []; i < l; i++){\n        for(var j=i+1, k=out.length; j<k; j++){\n        \
    \    if(numbers[i] == out[j]){\n                out.splice(j, 1);\n          \
    \  }\n        }\n        out.splice(i, 1);\n    }\n    return out;\n}\n", "  var\
    \ unique_numbers = [];\n  for (var i = 0; i < numbers.length; i++){\n    if (unique_numbers.indexOf(numbers[i])\
    \ == -1){\n      unique_numbers.push(numbers[i]);\n    }\n  }\n  return unique_numbers;\n\
    }\n", "\treturn _.filter(numbers, function(val){\n\t\treturn _.uniq(numbers).indexOf(val)\
    \ === -1;\n\t});\n}\n", "  if(numbers.indexOf(numbers[0]) != -1){\n    return\
    \ numbers.filter(function(num, i){\n      return numbers.indexOf(num) == i;\n\
    \    });\n  }\n  return numbers;\n}\n", "  const set = new Set(numbers);\n  return\
    \ [...set];\n}\n", "    var i, hash = {};\n    var new_array = [];\n    for(i\
    \ = 0; i < numbers.length; i++){\n        if (hash[numbers[i]] == null){\n   \
    \         new_array.push(numbers[i]);\n            hash[numbers[i]] = 1;\n   \
    \     }\n    }\n    return new_array;\n}\n", "    let unique = [];\n    let uniqueNumbers\
    \ = [];\n\n    numbers.forEach(function(number){\n        if(uniqueNumbers.indexOf(number)\
    \ === -1) unique.push(number);\n        uniqueNumbers.push(number);\n    });\n\
    \n    return unique;\n}\n", "\tvar result = [];\n\tfor (var i = 0, l = numbers.length;\
    \ i < l; i++){\n\t\tvar x = numbers[i];\n\t\tfor (var j = i + 1; j < l; j++){\n\
    \t\t\tif (x === numbers[j]){\n\t\t\t\tresult.push(numbers[j]);\n\t\t\t\tnumbers.splice(j,\
    \ 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\t", "    var\
    \ newArray=[];\n    for (var i=0,len=numbers.length;i<len;i++)\n        if (newArray.indexOf(numbers[i])==-1)\
    \ newArray.push(numbers[i]);\n    return newArray;\n}", "  var i, current,\n \
    \     output = [];\n\n  numbers.forEach(function(val){\n    for(i = 0; i < output.length;\
    \ i++){\n      current = output[i];\n      if(current == val){\n        output.splice(i,\
    \ 1);\n      }\n    }\n    output.push(val);\n  });\n\n  return output;\n}\n\n\
    var remove_duplicates = remove_duplicates\n  || function(numbers){\n    var i,\
    \ current,\n        output = [];\n\n    numbers.forEach(function(val){\n     \
    \ for(i = 0; i < output.length; i++){\n        current = output[i];\n        if(current\
    \ == val){\n          output.splice(i, 1);\n        }\n      }\n      output.push(val);\n\
    \    });\n\n    return output;\n  }\n;\n\n", "    var result = [];\n    var seen\
    \ = [];\n    for(var i = 0; i < numbers.length; i++){\n        var number = numbers[i];\n\
    \        if(seen.indexOf(number) == -1){\n            seen.push(number);\n   \
    \         result.push(number);\n        }\n    }\n    return result;\n}\n", " \
    \   var results = [];\n    for(var i = 0; i < numbers.length; i++){\n        for(var\
    \ j = i+1; j < numbers.length; j++){\n            if(numbers[i] == numbers[j]){\n\
    \                numbers.splice(j, 1);\n            }\n        }\n    }\n    return\
    \ results;\n}\n", "  var output = [];\n  var seen = [];\n  for (var i = 0; i <\
    \ numbers.length; i++){\n    var n = numbers[i];\n    if (seen.indexOf(n) > -1){\n\
    \      continue;\n    }\n    seen.push(n);\n    output.push(n);\n  }\n  return\
    \ output;\n}\n", "  var output = [];\n  var lookup = {};\n  \n  for (var i=0,\
    \ len=numbers.length; i<len; i++){\n    if (!lookup[numbers[i]]) output.push(numbers[i]);\n\
    \    lookup[numbers[i]] = true;\n  }\n  \n  return output;\n}\n", "    var result\
    \ = [];\n    for(var i = 0; i < numbers.length; i++){\n        var number = numbers[i];\n\
    \        if(result.indexOf(number) == -1) result.push(number);\n    }\n    return\
    \ result;\n}\n</code></pre>\n        </section>\n\n        <section>\n       \
    \     <h2>Functions</h2>\n        </section>\n\n        <section>\n          \
    \  <h3>Function constructor</h3>\n            <pre><code data-trim>", "    return\
    \ numbers.filter(function(elem, index, self) {\n        return self.indexOf(elem)\
    \ === index;\n    });\n}\n</code>\n<|/ a tags=javascript,arrays dscore=4 |>\n\
    <| a |>\n<code>\nvar arr = [1, 2, 3, 2, 4];", "  var result = [];\n  var j = 0;\n\
    \  for(var i = 0; i < numbers.length; i++){\n    var current = numbers[i];\n \
    \   while(j < result.length && current == result[j++]);\n    result.push(current);\n\
    \  }\n  return result;\n}", "  var unique = [...new Set(numbers)];\n  return unique.sort();\n\
    }\n</code>\n<|/ a |>\n<| a tags=javascript,arrays |>\n<code>\nvar arr = [1,2,2,2,3,3,4,4,5,5];\n",
  "  var filtered = [];\n  var count = 0;\n  numbers.forEach(function(element){\n\
    \    if (filtered.indexOf(element) === -1){\n      filtered[count] = element;\n\
    \      count++;\n    }\n  });\n  return filtered;\n}\n\n", "  let output = []\n\
    \  for (let i = 0; i < numbers.length; i++){\n    if (output.includes(numbers[i]))\
    \ {\n      continue\n    }\n    output.push(numbers[i])\n  }\n  return output\n\
    }\n", "  var o = {}, i, l = numbers.length;\n  for(i = 0; i < l; i++){\n    o[numbers[i]]\
    \ = true;\n  }\n  numbers = [];\n  for(i in o){\n    numbers.push(i);\n  }\n \
    \ return numbers;\n}\n", "  var obj = {};\n\n  numbers.forEach(function(num){\n\
    \    if (obj[num]){\n      delete obj[num];\n    } else {\n      obj[num] = 1;\n\
    \    }\n  });\n\n  var new_numbers = [];\n  Object.keys(obj).forEach(function(num){\n\
    \    new_numbers.push(num);\n  });\n\n  return new_numbers;\n}", "  var hash =\
    \ {}\n  for(var i=0;i<numbers.length;i++){\n    if(!hash.hasOwnProperty(numbers[i])){\n\
    \      hash[numbers[i]] = true\n    }\n  }\n  return hash\n}\n", "  var i, length\
    \ = numbers.length;\n  var filtered = [];\n\n  for (i = 1, j = 1; i < length;\
    \ i++){\n    if (numbers[i] === numbers[j]){\n      filtered.push(numbers[i]);\n\
    \      j++;\n    }\n  }\n  filtered.pop();\n  filtered.shift();\n\n  return filtered;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease consider adding an explanation\
    \ to your answer, instead of just providing a solution.\n<|/ c |>\n<| a dscore=0\
    \ tags=javascript,arrays,duplicate-removal,sorting |>\n<code>", "  var new_arr\
    \ = []\n  for(var i = 0; i < numbers.length; i++){\n    if(new_arr.indexOf(numbers[i])\
    \ < 0){\n      new_arr.push(numbers[i])\n    }\n  }\n  return new_arr\n}\n", " \
    \   let unique = [];\n    for(let i=0; i < numbers.length; i++){\n        let\
    \ j = numbers.indexOf(numbers[i], i+1);\n        if(j != -1) unique.push(numbers[j]);\n\
    \    }\n    return unique;\n}\n", "    var output = [];\n    for (var i = 0; i\
    \ < numbers.length; i++){\n        if (output.indexOf(numbers[i]) == -1){\n  \
    \          output.push(numbers[i])\n        }\n    }\n    return output\n}", " \
    \ var new_arr = [];\n  var count = 0;\n  for(var i = 0; i < numbers.length; i++){\n\
    \    var number = numbers[i];\n    while(new_arr.indexOf(number) !== -1){\n  \
    \    count++;\n      number = numbers[(i - count)]\n    }\n    new_arr.push(number);\n\
    \  }\n  return new_arr;\n}\n", "\tvar i=0, length=numbers.length;\n\tvar indexMap\
    \ = {};\n\t\n\tfor (; i < length; i++){\n\t\tindexMap[numbers[i]] = numbers[i];\n\
    \t}\n\t\n\tfor(i = length - 1; i >= 0; i--){\n\t\tif (indexMap.hasOwnProperty(numbers[i])){\n\
    \t\t\tnumbers.splice(i, 1);\n\t\t}\n\t}\n\t\n\treturn numbers;\n}\n", "  var filtered\
    \ = [];\n  for (var i = 0; i < numbers.length; i++){\n    var number = numbers[i];\n\
    \    var found = false;\n    for (var j = 0; j < filtered.length; j++){\n    \
    \  if (filtered[j] == number){\n        found = true;\n      }\n    }\n    if\
    \ (!found){\n      filtered.push(number);\n    }\n  }\n  return filtered;\n};\n",
  "  var i,\n    length = numbers.length,\n    new_numbers = [],\n    unique_numbers\
    \ = [];\n\n  for(i = 0; i < length; i++){\n    if(unique_numbers.indexOf(numbers[i])\
    \ == -1) unique_numbers.push(numbers[i]);\n  }\n  for(i = 0; i < unique_numbers.length;\
    \ i++){\n    new_numbers.push(unique_numbers[i]);\n  }\n  return new_numbers;\n\
    }\n\n", "  var uniques = [];\n  for (var i = 0; i < numbers.length; i++) {\n \
    \   if (uniques.indexOf(numbers[i]) < 0){\n      uniques.push(numbers[i]);\n \
    \   }\n  }\n  return uniques;\n}\n", "  var results = [];\n  for(var i = 0, length\
    \ = numbers.length; i < length; i++) {\n    if(results.indexOf(numbers[i]) ===\
    \ -1) {\n        results.push(numbers[i]);\n    }\n  }\n  return results;\n}\n",
  "    var output = [];\n    var outputSet = {}; //Maps values from numbers to whether\
    \ they've been seen\n    numbers.forEach(function(number) {\n        if(!outputSet[number]){\n\
    \            outputSet[number] = true;\n            output.push(number);\n   \
    \     }\n    });\n    return output;\n}\n</code>\n<|/ a tags=javascript,arrays\
    \ |>\n<| c |>\nThe downside is that this won't work in older browsers, such as\
    \ IE8 or IE7. [This solution](http://stackoverflow.com/a/19604718/690344) would\
    \ work in those older browsers too.\n<|/ c |>\n<| c |>\nIf that's the case, then\
    \ perhaps you should include that in your question. IE8 does have support for\
    \ [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map),\
    \ but I don't know how far back it goes. [Here's](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Browser_compatibility)\
    \ a link to the MDN description.\n<|/ c |>\n<| c |>\nYeah, I meant that IE8 and\
    \ IE7 would not be compatible, which is why I included the \"older browsers\"\
    \ in the question. My apologies if I came off a bit harsh, but it's what it is.\n\
    <|/ c |>\n<| c |>\nI wasn't criticizing your question. I was just letting you\
    \ know that there are some caveats to the `Map` object in some versions of IE.\
    \ Hopefully that helps.\n<|/ c |>\n<| a dscore=0 tags=javascript,arrays |>\nHere\
    \ is one way of doing this using a while loop. Basically it looks at the length\
    \ of the array and increases i until it reaches the end and then starts over.\
    \ The first time through the loop it checks to see if the current value already\
    \ exists in the array. If not, it adds it to the array and starts over. On the\
    \ second pass through the loop, it checks to see if the current value already\
    \ exists in the array. If it does, then it ignores that value. Once the loop has\
    \ finished (meaning when i is equal to the length of the array), the array contains\
    \ all the unique values.\n<code>\nvar numbers = [1,3,5,4,2,7,9,1,5,4,3,5,7,3];\n\
    var newNums = [];\nvar i = 0;\nwhile (i < numbers.length) {\n    if (newNums.indexOf(numbers[i])\
    \ == -1) {\n        newNums.push(numbers[i]);\n    }\n    i++;\n}\n", "  numbers\
    \ = _.uniq(numbers);\n  return _.uniq(numbers);\n}\n", "    var results = [];\n\
    \    var seen = [];\n\n    for (var i=0; i < numbers.length; i++){\n        var\
    \ n = numbers[i];\n\n        if (seen.indexOf(n) == -1){\n            results.push(n);\n\
    \            seen.push(n);\n        }\n    }\n\n    return results;\n}\n", "\t\
    var len = numbers.length;\n\tvar new_numbers = [];\n\tfor(var i = 0; i < len;\
    \ i++){\n\t\tvar current = numbers[i];\n\t\tvar found = false;\n\t\tfor(var j\
    \ = i + 1; j < len; j++){\n\t\t\tif(numbers[j] == current){\n\t\t\t\tfound = true;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found){\n\t\t\tnew_numbers.push(current);\n\
    \t\t}\n\t}\n\treturn new_numbers;\n}\n", "  var results = [];\n\n  for(var i =\
    \ 0; i < numbers.length; i++){\n    var found = false;\n    for (var j = 0; j\
    \ < results.length; j++){\n      if(numbers[i] === results[j]){\n        found\
    \ = true;\n        break;\n      }\n    }\n    if(!found){\n      results.push(numbers[i]);\n\
    \    }\n  }\n\n  return results;\n}", "  const set = new Set(numbers);\n  return\
    \ [...set];\n}\n", "  let result = [];\n  for(let n of numbers){\n    if(result.indexOf(n)\
    \ === -1){\n      result.push(n);\n    }\n  }\n  return result;\n}\n", "\tnumbers.sort(function(n1,\
    \ n2){ return n1 - n2; });\n\tvar output = [];\n\tvar seen = {};\n\tnumbers.forEach(function(item){\n\
    \t  if (seen[item]){\n\t\treturn;\n\t  }\n\t  if (item != numbers[0]) {\n\t\t\
    output.push(item);\n\t  }\n\t  seen[item] = 1;\n\t});\n\treturn output;\n};\n",
  "  var unique = {};\n  numbers.forEach(function(val){\n    unique[val] = (unique[val]\
    \ || 0) + 1;\n  });\n  var newArr = [];\n  for(var i in unique) newArr.push(unique[i]);\n\
    \  return newArr.sort();\n}\n", "  return numbers.filter((n, i, self) => self.indexOf(n)\
    \ == i);\n}\n", "  var result = [];\n  var seen = {};\n  for(var i = 0; i < numbers.length;\
    \ i++){\n    var number = numbers[i];\n    if(number in seen){\n      continue;\n\
    \    }\n    seen[number] = true;\n    result.push(number);\n  }\n  return result;\n\
    }\n", "    var uniques = [];\n    for (var i = 0; i < numbers.length; i++){\n\
    \        if (uniques.indexOf(numbers[i]) === -1){\n            uniques.push(numbers[i]);\n\
    \        }\n    }\n    return uniques;\n}\n", "  var seen = [];\n  for(var i=0,\
    \ l=numbers.length; i < l; ++i){\n    var num = numbers[i];\n    var inc = seen.indexOf(num);\n\
    \    if(inc !== -1) seen.splice(inc, 1);\n    else seen.push(num);\n  }\n  return\
    \ seen.filter(function(v, i, a){\n    return i === a.indexOf(v);\n  });\n}\n",
  "\tvar numbers = _.toArray(arguments);\n\tvar newArray = [];\n\t_.each(numbers,\
    \ function(val){\n\t\tif (newArray.indexOf(val) == -1){\n\t\t\tnewArray.push(val);\n\
    \t\t}\n\t});\n\treturn newArray;\n}\n", "    var output = [];\n    for (var i\
    \ = 0, len = numbers.length; i < len; i++){\n        if (output.indexOf(numbers[i])\
    \ === -1){\n            output.push(numbers[i]);\n        }\n    }\n    return\
    \ output;\n}\nexports.remove_duplicates = remove_duplicates;\n", "\tvar o = {};\n\
    \tfor(var i = 0, l = numbers.length; i < l; ++i){\n\t\tvar num = numbers[i];\n\
    \t\tif(!(num in o)){\n\t\t\to[num] = num;\n\t\t}\n\t}\n\treturn numbers;\n}\n",
  "    var uniques = [];\n    numbers.forEach(function(num){\n        if(uniques.indexOf(num)\
    \ < 0){\n            uniques.push(num);\n        }\n    });\n    return uniques;\n\
    }\n", "\tvar output = [];\n\tvar hash_table = {};\n\n\tfor (var i = 0, len = numbers.length;\
    \ i < len; i++) {\n\t\tvar element = numbers[i];\n\t\tif (!hash_table[element])\
    \ {\n\t\t\toutput.push(element);\n\t\t\thash_table[element] = true;\n\t\t}\n\t\
    }\n\treturn output;\n}\n", "  var unique = [];\n  for(var i=0; i<numbers.length;\
    \ i++){\n    if(unique.indexOf(numbers[i]) === -1) unique.push(numbers[i]);\n\
    \  }\n  return unique;\n}\n", "    var result = []\n    , seen = {}\n    for(var\
    \ i = 0; i < numbers.length; i++){\n        var number = numbers[i];\n       \
    \ if(seen[number]) continue;\n        seen[number] = true;\n        result.push(number);\n\
    \    }\n    return result;\n}\n", "    var new_array = [];\n    for(var i = 0;\
    \ i < numbers.length; i++){\n        if (new_array.indexOf(numbers[i]) == -1){\n\
    \            new_array.push(numbers[i]);\n        }\n    }\n    return new_array;\n\
    }\n</code>\n<|/ a |>\n<| a tags=arrays,javascript dscore=0 |>\nI know this is\
    \ an old thread, but I thought it would be useful to show an example of a different\
    \ approach to the problem that avoids creating a new array in memory.\nThe challenge\
    \ here is to get the most frequent item of an unsorted array, while preserving\
    \ the order of items encountered during the sort.  Here is one approach using\
    \ the ES6 Set object (see Set on Mozilla Developer Network):\n\n<code>", "  var\
    \ ret = [];\n  for(var i = 0; i < numbers.length; i++){\n    if(ret.indexOf(numbers[i])\
    \ == -1) ret.push(numbers[i]);\n  }\n  return ret;\n}\n", "\tvar counter = {};\n\
    \treturn numbers.filter(function(num){\n\t\treturn !(num in counter);\n\t});\n\
    }\n", "    var i, j, current, currentIndex;\n    for (i = 0; i < numbers.length;\
    \ i++){\n        current = numbers[i];\n        currentIndex = 0;\n        for\
    \ (j = 0; j < i; j++){\n            if (current === numbers[j]){\n           \
    \     currentIndex++;\n            }\n        }\n        if (currentIndex > 1){\n\
    \            numbers.splice(i, currentIndex - 1);\n            i--;\n        }\n\
    \    }\n    return numbers;\n}", "  var counts = {};\n  var uniqueNumbers = [];\n\
    \  numbers.forEach(function(num){\n    if(counts[num]){\n      counts[num]++;\n\
    \    } else {\n      counts[num] = 1;\n      uniqueNumbers.push(num);\n    }\n\
    \  });\n  return uniqueNumbers;\n}\n", "    let output = [];\n    let seen = [];\n\
    \    for(let i = 0; i < numbers.length; i++){\n        if(seen.indexOf(numbers[i])\
    \ !== -1){\n            continue;\n        }\n        seen.push(numbers[i]);\n\
    \        output.push(numbers[i]);\n    }\n    return output;\n}", "  var i, len\
    \ = numbers.length, out=[];\n  for (i = 0; i < len; ++i){\n    if (numbers.indexOf(numbers[i])\
    \ == numbers.lastIndexOf(numbers[i])){\n      continue;\n    }\n    out.push(numbers[i]);\n\
    \  }\n  return out;\n}\n", "  var output = [], i, j;\n  for (i = 0; i < numbers.length;\
    \ i++){\n     j = i;\n     while(j < numbers.length && numbers[j] === numbers[i]){\n\
    \      j++;\n     }\n     if (j > i){\n      output.push(numbers[i]);\n     }\n\
    \  }\n  return output;\n}\n\n", "\treturn numbers.filter(function(elem, index,\
    \ self){\n\t\treturn index === self.indexOf(elem);\n\t});\n}\n", "\tconst seen\
    \ = {};\n\tnumbers.sort((a,b) => a-b);\n\treturn numbers.filter((el,i) => seen[el]?\
    \ false : seen[el] = true);\n}\n</textarea></div>\n\n    <script>\n      var editor\
    \ = CodeMirror.fromTextArea(document.getElementById(\"code\"), {\n        lineNumbers:\
    \ true,\n        matchBrackets: true,\n        mode: \"text/x-csrc\"\n      });\n\
    \    </script>\n\n    <p><strong>MIME types defined:</strong> <code>text/x-csrc</code>.</p>\n\
    \  </article>\n\n<|/ file ext=.html filename=index.html dstars=1 |>\n<| c |>\n\
    Thanks, that is very helpful. It looks like the example code doesn't work for\
    \ me (it looks like it's expecting C or C++). Do you have any idea why?\n<|/ c\
    \ |>\n<| c |>\nI just realized that I may have accidentally deleted some of those\
    \ extra curly braces in the example code while I was writing it, but those curly\
    \ braces are still there in the actual source code.\n<|/ c |>\n<| c |>\nOh well.\
    \ I'll edit the code in the question to fix that. Thanks for letting me know.\n\
    <|/ c |>\n<| c |>\nI've edited the question to include a fully-working example\
    \ of the code I wrote in my question.\n<|/ c |>\n<| c |>\nI copied your code to\
    \ a file and it works perfectly fine for me. I'm pretty sure it's because I did\
    \ something wrong in copying the code to the question that lead to it not working\
    \ for me before. But I can't tell what it was. Maybe the browser? Or a bad keyboard/mouse\
    \ combo?\n<|/ c |>\n<| a tags=javascript,codemirror,html,css |>\nYour code works\
    \ perfectly fine (it runs):\nhttp://jsfiddle.net/2yvk7yh7/1/\nYour problem must\
    \ be somewhere else in your code. Maybe you tried to copy paste your code and\
    \ just replaced the curly braces with an extra one somewhere or something along\
    \ those lines?\n<|/ a dscore=1 |>\n<| c |>\nI edited the question to include a\
    \ fully-working example of the code I wrote in my question.\n<|/ c |>\n<| c |>\n\
    I copied your code to a file and it works perfectly fine for me. I'm pretty sure\
    \ it's because I did something wrong in copying the code to the question that\
    \ lead to it not working for me before. But I can't tell what it was. Maybe the\
    \ browser? Or a bad keyboard/mouse combo?\n<|/ c |>\n<| a tags=javascript", " \
    \   var result = [];\n    for(var i = 0; i < numbers.length; i++){\n        var\
    \ count = 0;\n        for (var j = 0; j < result.length; j++){\n            if\
    \ (result[j] == numbers[i]){\n                count++;\n            }\n      \
    \  }\n        if (count == 0){\n            result.push(numbers[i]);\n       \
    \ }\n    }\n    return result;\n}\n", "    var result = [];\n    for(var i = 0;\
    \ i < numbers.length; i++){\n        if(numbers.indexOf(numbers[i]) === i){\n\
    \            result.push(numbers[i]);\n        }\n    }\n    return result;\n\
    }\n", "\tvar results = [];\n\tfor(var i = 0; i < numbers.length; i++){\n\t\tif(!contains(results,\
    \ numbers[i])){\n\t\t\tresults.push(numbers[i]);\n\t\t}\n\t}\n\treturn results;\n\
    }\n", "\tnumbers = numbers.slice();\n\tnumbers.sort();\n\tvar seen = {};\n\tvar\
    \ unique = [];\n\tfor(var i = 0, len = numbers.length; i < len; i++){\n\t\tif(seen[numbers[i]])\
    \ continue;\n\t\tunique.push(numbers[i]);\n\t\tseen[numbers[i]] = 1;\n\t}\n\t\
    return unique;\n}\n", "    return _.uniqWith(numbers, function(number){\n    \
    \    return _.contains(numbers, number);\n    });\n}\n", "    var output = [];\n\
    \    for(var i=0; i<numbers.length; i++){\n        var occurances = numbers.filter(function(num){return\
    \ num == numbers[i]}).length;\n        if(occurances > 1) output.push(numbers[i]);\n\
    \    }\n    return output;\n}\n", "  // Keep track of previous values\n  var prev\
    \ = [];\n  // Scratch an array to hold unique values\n  var unique = [];\n  for(var\
    \ i=0; i<numbers.length; i++){\n    if(!numbers[i] && !prev[i]){\n      // Only\
    \ push values onto the unique array if they're not already in\n      // there\
    \ (ie. if they're new, or if we've already compared them to\n      // the previous\
    \ value)\n      unique.push(numbers[i]);\n    }else{\n      if(numbers[i] == prev[i]){\n\
    \        // If the previous value is equal to the current value, add it to\n \
    \       // the unique array. Otherwise, push the current value onto the unique\n\
    \        // array.\n        unique.push(numbers[i]);\n      }else{\n        //\
    \ Push the current value onto the unique array.\n        unique.push(prev[i]);\n\
    \        unique.push(numbers[i]);\n      }\n    }\n    prev = numbers[i];\n  }\n\
    \  return unique;\n}\n", "  var hash = {};\n  for(var i = 0; i < numbers.length;\
    \ i++){\n    if(hash.hasOwnProperty(numbers[i])){\n      delete hash[numbers[i]];\n\
    \    }else{\n      hash[numbers[i]] = true;\n    }\n  }\n  return Object.keys(hash);\n\
    }\n", "  var output = [];\n  var seen = {};\n  for(var i = 0; i < numbers.length;\
    \ i++){\n    if(seen[numbers[i]]) continue;\n    output.push(numbers[i]);\n  \
    \  seen[numbers[i]] = true;\n  }\n  return output;\n}\n", "  var output = [];\n\
    \  numbers.forEach(function(number){\n    output.push(number);\n  });\n  return\
    \ output\n}\n", "  // create an object that stores the unique number\n  var uniques\
    \ = {};\n  var newNumbers = [];\n\n  // loop through each number in the array\n\
    \  for (var i = 0, len = numbers.length; i < len; i++){\n    // if the number\
    \ does not exist in the uniques object, add it to the uniques object with the\
    \ value of the number as the key\n    if(!uniques[numbers[i]]) uniques[numbers[i]]\
    \ = numbers[i];\n  }\n\n  // loop through the uniques object and copy all the\
    \ values into a new array\n  for (var key in uniques){\n    newNumbers.push(uniques[key]);\n\
    \  }\n\n  return newNumbers;\n}\n", "  var unique = [];\n  var result = [];\n\
    \  for(var i = 0; i<numbers.length;i++){\n    if ( unique.indexOf(numbers[i])\
    \ === -1 ){\n      unique.push(numbers[i]);\n      result.push(numbers[i]);\n\
    \    }\n  }\n  return result;\n}\n", "\tconst arrayCopy = Array.from(numbers);\n\
    \tconst unique = new Set();\n\tlet duplicates = 0;\n\tfor (const number of arrayCopy)\
    \ {\n\t\tif (!unique.has(number)) {\n\t\t\tunique.add(number);\n\t\t} else {\n\
    \t\t\tduplicates++;\n\t\t}\n\t}\n\treturn arrayCopy.filter((number) => {\n\t\t\
    unique.delete(number);\n\t\treturn duplicates--;\n\t});\n}\n", "  var out = [];\n\
    \  for(var i = 0; i < numbers.length; i++){\n    if(out.indexOf(numbers[i]) <\
    \ 0){\n      out.push(numbers[i]);\n    }\n  }\n  return out;\n}\n", "  return\
    \ numbers.filter( function (val, ind, arr) {\n    return ind !== arr.lastIndexOf(val);\n\
    \  });\n}\n", "    var output = [];\n    var seen = [];\n    for(var i=0;i<numbers.length;i++){\n\
    \        var number = numbers[i];\n        if(seen.indexOf(number) == -1){\n \
    \           seen.push(number);\n            output.push(number);\n        }\n\
    \    }\n    return output;\n}", "  var filtered = [];\n  for(var i=0;i<numbers.length;i++){\n\
    \    if(filtered.indexOf(numbers[i]) == -1){\n      filtered.push(numbers[i]);\n\
    \    }\n  }\n  return filtered;\n}\n", "  var i, unique = [];\n  \n  for(i=0;\
    \ i<numbers.length; i++){\n    if(unique.indexOf(numbers[i]) == -1){\n      unique.push(numbers[i]);\n\
    \    }\n  }\n  \n  return unique;\n}\n", "  const removed = new Set(numbers);\n\
    \  return Array.from(removed);\n}\n", "  const newArr = numbers.reduce((ac,el,i)\
    \ => {\n    return el == ac[ac.length-1]? ac : [...ac,el]\n  }, [])\n  return\
    \ newArr\n}\n", "  return numbers.filter((element, index, self) => index === self.indexOf(element));\n\
    }\n", "  var result = [];\n  for (var i = 0; i < numbers.length; i++) {\n    if\
    \ (numbers.lastIndexOf(numbers[i]) == i) {\n      result.push(numbers[i]);\n \
    \   }\n  }\n  return result;\n}\n", "  let counter = {};\n  let newArr = [];\n\
    \  \n  for(let num of numbers){\n    if(counter[num] == null){\n      newArr.push(num);\n\
    \      counter[num] = 1;\n    }else{\n      counter[num] += 1;\n    }\n  }\n \
    \ \n  return newArr;\n}\n", "    var result = [];\n    for(var i = 0; i < numbers.length;\
    \ i++){\n        var element = numbers[i];\n        for(var j = 0; j < i; j++){\n\
    \            if(element == numbers[j]){\n                break;\n            }\n\
    \        }\n        if(j == i){\n            result.push(element);\n        }\n\
    \    }\n    return result;\n}\n", "  var result = [];\n  for(var i = 0; i < numbers.length;\
    \ i++){\n    if(result.indexOf(numbers[i]) == -1){\n      result.push(numbers[i]);\n\
    \    }\n  }\n  return result;\n}\n", "  let map = new Map();\n  return numbers.filter(\
    \ n => map.get(n) ? false : map.set(n, true) );\n}\n", "    var output = [];\n\
    \    for (var i=0; i<numbers.length; i++)\n        var current = numbers[i];\n\
    \        output.push(current);\n        for (var j=i+1; j<numbers.length; j++)\n\
    \            if (numbers[j] == current)\n                numbers.splice(j, 1);\n\
    \    return output.sort();\n}\n", "\tvar output = [];\n\tnumbers.forEach(function(num,\
    \ index, arr){\n\t\tif (output.indexOf(num) === -1)\n\t\t\toutput.push(num);\n\
    \t})\n\treturn output;\n}\n", "  const newArr = []\n  for (let i = 0; i < numbers.length;\
    \ i++) {\n    if (numbers.indexOf(newArr[i]) === -1) {\n      newArr.push(numbers[i])\n\
    \    }\n  }\n  return newArr\n}", "  var hash = {};\n\n  numbers.forEach(function(num){\n\
    \    if (hash[num]) {\n      hash[num]--;\n    } else {\n      hash[num] = 1;\n\
    \    }\n  });\n\n  var new_array = [];\n\n  for(var num in hash) {\n    new_array.push(num);\n\
    \  }\n\n  return new_array;\n}\n", "\tvar hash = {};\n\treturn numbers.filter(function(n){\n\
    \t\tif(hash[n]){\n\t\t\treturn false;\n\t\t}\n\t\thash[n] = true;\n\t\treturn\
    \ true;\n\t});\n}", "    var newArray = [];\n    var uniqueValues = {};\n    for(var\
    \ i = 0, l = numbers.length; i < l; i++){\n        if(uniqueValues[numbers[i]]\
    \ === undefined){\n            newArray.push(numbers[i]);\n            uniqueValues[numbers[i]]\
    \ = true;\n        }\n    }\n    return newArray;\n}\n</code>\nThis approach is\
    \ fairly efficient since it only traverses the array once.\n<|/ a |>\n<| c |>\n\
    I like this answer, but you can improve it a little by using the fact that the\
    \ arrays are guaranteed to be strictly increasing. i.e. `uniqueValues[numbers[i]\
    \ - 1]` would always be true for the first element. Also, `uniqueValues[numbers[i]]`\
    \ might be undefined so you can just do a null check `uniqueValues[numbers[i]]\
    \ && uniqueValues[numbers[i]] === undefined`. Also, you could do `uniqueValues[numbers[i]\
    \ || 1]` since `undefined` evaluates to `1`. Lastly, a little less verbose would\
    \ be `numbers[i] || 1`, since `null` and `undefined` both evaluate to `0`, but\
    \ this would evaluate to `1` for `false` when used in `uniqueValues`. +1 because\
    \ this solves a problem and adds new ones for me :)\n<|/ c |>\n<| c |>\nAhh I\
    \ thought of that too but didn't think of that because I'm assuming he's only\
    \ dealing with integers. I'll edit my answer with the changes so no one else has\
    \ to think about it any more.\n<|/ c |>\n<| c |>\nThanks, this was helpful. I\
    \ wanted to use a single loop, so this helped.\n<|/ c |>\n<| a dscore=2 tags=javascript\
    \ |>\n<code>", "    var i, j, newArray=[], hashMap={}; //initialize hashMap\n\
    \    for(i=0; i<numbers.length; i++){ //iterate through array\n        if(hashMap[numbers[i]])\
    \ continue; //check if it exists\n        else hashMap[numbers[i]]=1;\n      \
    \  newArray.push(numbers[i]); //add to new array\n    }\n    return newArray;\
    \ //return new array\n}\n</code>\n<|/ a |>\n<| c |>\nThis solution is definitely\
    \ more elegant than mine. Thank you for sharing.\n<|/ c |>\n<| a |>\nThis is my\
    \ solution\n<code>\nvar data = [\"1\", \"2\", \"3\", \"1\", \"2\", \"3\", \"4\"\
    , \"1\", \"2\", \"4\", \"5\", \"1\", \"2\", \"3\", \"4\"];\nvar array1 = data.filter((item,index)\
    \ => data.indexOf(item) == index);", "    let newArray = [];\n    let numArray\
    \ = numbers.map(x => x);\n\n    for (let i = 0; i < numArray.length; i++){\n \
    \       let unique = false;\n        for (let j = 0; j < i; j++){\n          \
    \  if (numArray[i] == numArray[j]){\n                unique = true;\n        \
    \        break;\n            }\n        }\n\n        if (!unique){\n         \
    \   newArray.push(numArray[i]);\n        }\n    }\n\n    return newArray;\n}\n",
  "    var hash = {};\n    numbers.forEach(function(n) {\n        if (hash[n]) {\n\
    \            hash[n]++;\n        } else {\n            hash[n] = 1;\n        }\n\
    \    });\n    var unique = [];\n    Object.keys(hash).forEach(function(key){\n\
    \        if (hash[key] === 1) {\n            unique.push(key);\n        }\n  \
    \  });\n    return unique;\n}\n</code></pre>\n        </article>\n    </section>\n\
    \n\n\n\n</div>\n\n<nav>\n    <h2><a href=\"index.html\">Home</a></h2><h3>Modules</h3><ul><li><a\
    \ href=\"module-capsula.Capsule.html\">Capsule</a></li><li><a href=\"module-capsula.Data.html\"\
    >Data</a></li><li><a href=\"module-capsula.ElementRef.html\">ElementRef</a></li><li><a\
    \ href=\"module-capsula.Hook.html\">Hook</a></li><li><a href=\"module-capsula.Input.html\"\
    >Input</a></li><li><a href=\"module-capsula.Loop.html\">Loop</a></li><li><a href=\"\
    module-capsula.Operation.html\">Operation</a></li><li><a href=\"module-capsula.Output.html\"\
    >Output</a></li><li><a href=\"module-html.Element.html\">Element</a></li><li><a\
    \ href=\"module-html.HasRootHTML.html\">HasRootHTML</a></li><li><a href=\"module-html.Template.html\"\
    >Template</a></li><li><a href=\"module-html.Text.html\">Text</a></li><li><a href=\"\
    module-services.ErrorMessage.html\">ErrorMessage</a></li><li><a href=\"module-services.Request.html\"\
    >Request</a></li><li><a href=\"module-sm.StateMachine.html\">StateMachine</a></li></ul><h3>Namespaces</h3><ul><li><a\
    \ href=\"module-capsula.Errors.html\">Errors</a></li><li><a href=\"module-capsula.ServiceType.html\"\
    >ServiceType</a></li><li><a href=\"module-html.Errors.html\">Errors</a></li><li><a\
    \ href=\"module-html.ServiceType.html\">ServiceType</a></li><li><a href=\"module-services.Errors.html\"\
    >Errors</a></li><li><a href=\"module-services.ServiceType.html\">ServiceType</a></li><li><a\
    \ href=\"module-sm.Errors.html\">Errors</a></li></ul>\n</nav>\n\n<br class=\"\
    clear\">\n\n<footer>\n    Documentation generated by <a href=\"https://github.com/jsdoc3/jsdoc\"\
    >JSDoc 3.5.5</a> on Fri Dec 14 2018 14:56:57 GMT+0100 (Central Europe Standard\
    \ Time)\n</footer>\n\n<script> prettyPrint(); </script>\n<script src=\"scripts/linenumber.js\"\
    > </script>\n</body>\n</html>\n\n<|/ file dstars=1 ext=.html source=github |><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|><|endofmask|>\n\
    \t\t\t<div class=\"linenumber linenumber--90\">  90\n\t\t\t</div>\n\t\t\t<div\
    \ class=\"linenumber linenumber--90\">  90\n\t\t\t</div>\n\t\t\t<div class=\"\
    linenumber linenumber--90\">  90\n\t\t\t</div>\n\t\t\t<div class=\"linenumber\
    \ linenumber--90\">  90\n\t\t\t</div>\n\t\t\t<div class=\"linenumber linenumber--90\"\
    >  90", "\tlet newArr = []\n\tfor(let i = 0; i < numbers.length; i++){\n\t\tlet\
    \ number = numbers[i]\n\t\tlet index = newArr.indexOf(number)\n\t\tif(index ==\
    \ -1){\n\t\t\tnewArr.push(number)\n\t\t} else {\n\t\t\tnewArr.splice(index, 1)\n\
    \t\t}\n\t}\n\treturn newArr\n}\n", "  numbers = remove_duplicates_helper(numbers,\
    \ []);\n  return numbers.map(Number);\n}\n", "    var result = [];\n    for(var\
    \ i = 0; i < numbers.length; i++){\n        var element = numbers[i];\n      \
    \  if(result.indexOf(element) === -1){\n            result.push(element);\n  \
    \      }\n    }\n    return result;\n}", "    numbers = _.uniq(numbers);\n   \
    \ var result = [];\n    _.each(numbers, function(num){\n        if(numbers.indexOf(num)\
    \ == -1) result.push(num);\n    });\n    return result;\n}", "  let newArray =\
    \ [];\n  for (let i = 0; i < numbers.length; i++){\n    let element = numbers[i]\n\
    \    let index = 0;\n    while (newArray[index] && newArray[index] == element){\n\
    \      index++\n    }\n    newArray.push(numbers[i])\n  }\n  return newArray;\n\
    }\n", "  var seen = [];\n  return numbers.filter(function(n){\n    if (seen.indexOf(n)\
    \ > -1) return false; // don't add the same number twice\n    seen.push(n);\n\
    \    return true; // elements must be in the same order as the input array\n \
    \ });\n}\n", "  return numbers.reduce((acc, curr)=>{\n    if (acc.indexOf(curr)\
    \ == -1) acc.push(curr);\n    return acc;\n  }, []);\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=arrays,javascript,algorithm |>\nThis is my solution based on solution\
    \ of Krishna Chinnapuram.\n<code>", "  var filtered = [];\n  for(var i = 0, len\
    \ = numbers.length; i < len; i++){\n    var num = numbers[i];\n    if(filtered.indexOf(num)\
    \ == -1){\n      filtered.push(num);\n    }\n  }\n  return filtered;\n}\n", " \
    \ if(Array.isArray(numbers)){\n    var output = []\n    numbers.forEach(function(x){\n\
    \      if(output.indexOf(x) < 0){\n        output.push(x)\n      }\n    })\n \
    \   return output\n  }else{\n    console.error('Only array of integers is accepted')\n\
    \  }\n}\n", "    var result = [];\n    for(var i = 0;i < numbers.length;i++){\n\
    \        if(numbers.indexOf(result[i]) == -1){\n            result.push(numbers[i]);\n\
    \        }\n    }\n    return result;\n}\n", "  var seen = {};\n  var out = [];\n\
    \  for(var i = 0; i < numbers.length; i++){\n    var n = numbers[i];\n    if(seen[n]\
    \ !== 1){\n      seen[n] = 1;\n      out.push(n);\n    }\n  }\n  return out;\n\
    };", "\tvar ret = [];\n\tvar seen = {};\n\tfor(var i=0;i<numbers.length;++i){\n\
    \t\tvar num = (numbers[i] in seen) ? seen[numbers[i]] : numbers[i];\n\t\tret.push(num);\n\
    \t\tseen[num] = num;\n\t}\n\treturn ret;\n}\n\n", "\tvar newArr = [];\n\t\n\t\
    for(var i=0; i<numbers.length; i++){\n\t\tif(numbers[i] !== numbers[i-1]){\n\t\
    \t\tnewArr.push(numbers[i]);\n\t\t}\n\t}\n\treturn newArr;\n}\n", "  if(numbers.length\
    \ <= 1) return numbers;\n  let newArray = [];\n  let lastItem = numbers[0];\n\
    \  for(let i = 1; i < numbers.length; i++){\n    if(numbers[i] === lastItem){\n\
    \      i++;\n    } else {\n      newArray.push(numbers[i]);\n      lastItem =\
    \ numbers[i];\n    }\n  }\n  return newArray;\n}\n", "    var numbers_dict = {};\n\
    \    var num_count = 1;\n    for (var i=0; i<numbers.length; i++){\n        numbers_dict[numbers[i]]\
    \ = num_count;\n        num_count++;\n    }\n    var new_numbers = [];\n    for\
    \ (var key in numbers_dict){\n        if (numbers_dict.hasOwnProperty(key)){\n\
    \            new_numbers.push(key);\n        }\n    }\n    return new_numbers;\n\
    }\n", "  var i, length, uniques = [];\n  for (i = 0, length = numbers.length;\
    \ i < length; i++){\n    if(uniques.indexOf(numbers[i]) == -1){\n      uniques.push(numbers[i]);\n\
    \    }\n  }\n  return uniques;\n}\n", "\tnumbers = numbers.filter(function(elem,\
    \ pos) {\n\t\treturn numbers.indexOf(elem) === pos;\n\t});\n\treturn numbers;\n\
    }", "    numbers = numbers.slice();\n    numbers.sort();\n\n    var output = [];\n\
    \    var seen = [];\n\n    for (var i = 0; i < numbers.length; i++){\n       \
    \ var number = numbers[i];\n        if (seen[number] !== undefined){\n       \
    \     continue;\n        }\n\n        seen[number] = 1;\n        output.push(number);\n\
    \    }\n\n    return output;\n}\n", "    let result = [];\n    for(let i = 0;\
    \ i < numbers.length; i++){\n        for(let j = 0; j < result.length; j++){\n\
    \            if(numbers[i] == result[j]){\n                result.splice(j, 1);\n\
    \                j--;\n            }\n        }\n        result.push(numbers[i]);\n\
    \    }\n    return result;\n}\n", "  var unique = [numbers[0]],\n      rest =\
    \ [],\n      j,\n      i;\n  for(i = 0; i < numbers.length; i++){\n    for(j =\
    \ i+1; j < numbers.length; j++){\n      if(numbers[i] === numbers[j]){\n     \
    \   unique.push(numbers[j]);\n        rest.push(numbers[i]);\n      }\n    }\n\
    \  }\n  unique.push(rest);\n  return unique;\n}\n", "  var newArray = [];\n  for(var\
    \ i =0; i < numbers.length; i++){\n    var element = numbers[i];\n    var newElement\
    \ = newArray.indexOf(element);\n    if(newElement == -1)\n      newArray.push(element);\n\
    \  }\n  return newArray;\n}\n", "    var i, l, o = {};\n    for(i=0, l=numbers.length;\
    \ i<l; ++i){\n        if(!o[numbers[i]]){\n            o[numbers[i]] = numbers[i];\n\
    \        } else {\n            delete o[numbers[i]];\n        }\n    }\n    return\
    \ o.length ? o : null;\n};\n", "  var output = []\n  var seen = {}\n  for (var\
    \ i = 0; i < numbers.length; i++){\n    var curr = numbers[i]\n    if (seen[curr]){\n\
    \      output.push(curr)\n    } else {\n      seen[curr] = true;\n    }\n  }\n\
    \  return output;\n}", "  return numbers.reduce(function(result, number){\n  \
    \  if (result.indexOf(number) === -1) result.push(number);\n    return result;\n\
    \  }, []);\n}\n", "  numbers = numbers.filter(function(item, index, arr){\n  \
    \  return index === arr.indexOf(item);\n  });\n  return numbers;\n}\n", "  var\
    \ result = [];\n  for (var i = 0; i < numbers.length; i++){\n    if (result.indexOf(numbers[i])\
    \ == -1){\n      result.push(numbers[i]);\n    }\n  }\n  return result;\n}\n\n",
  "  let result = []\n  numbers.forEach(number => {\n    let count = 1\n    result.forEach(elm\
    \ => {\n      if (number === elm) {\n        count += 1;\n      }\n    });\n \
    \   if (count > 1) {\n      result.push(number)\n    }\n  })\n  return result\n\
    }\n", "  numbers = numbers.filter((v, i, a) => a.indexOf(v) === i);\n  return\
    \ numbers;\n}\n", "\t\n\tvar new_array = [];\n\t\n\tfor(var i = 0;i < numbers.length;i++){\n\
    \t\t\n\t\tvar number = numbers[i];\n\t\t\n\t\tvar count = 0;\n\t\t\n\t\tfor(var\
    \ x = 0;x < new_array.length;x++){\n\t\t\t\n\t\t\tif(new_array[x] == number){\n\
    \t\t\t\t\n\t\t\t\tcount++;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\
    \tif(count == 0){\n\t\t\t\n\t\t\tnew_array.push(number);\n\t\t}\n\t}\n\t\n\treturn\
    \ new_array;\n}\n\n", "    var newArray = [];\n    var counts = {};\n    for(var\
    \ i=numbers.length-1; i>=0; i--){\n        var n = numbers[i];\n        if(counts[n]\
    \ === undefined){\n            newArray.push(n);\n            counts[n] = 1;\n\
    \        }\n        else{\n            counts[n]++;\n        }\n    }\n    return\
    \ newArray;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for the answer. This\
    \ is better than the other answers as it's more efficient because I'm using a\
    \ hash of counts and I only need to iterate through the array once to determine\
    \ the duplicates.\n<|/ c |>\n<| c |>\nSorry, I forgot to mark this as the correct\
    \ answer. Thanks again.\n<|/ c |>\n<| c |>\nI thought it was the right answer\
    \ :) I just missed the hash. Just for my benefit, do you know if there's a way\
    \ to keep the \"counts\" object around? My other solution involves creating a\
    \ copy of this array each time the function is called.\n<|/ c |>\n<| c |>\nNo\
    \ worries, glad to help!\n<|/ c |>\n<| c |>\nA `for(;;)` loop is *not* an \"infinite\
    \ loop\", it is a \"while loop\". The loop is exited when a certain condition\
    \ evaluates to `false`.\n<|/ c |>\n<| a dscore=0 |>\nA solution using Array.indexOf(),\
    \ Array.reduce(), Array.slice()\nThe function below removes duplicates of an array\
    \ using Array.reduce().\n\n<code>\nconst removeDuplicates = (arr) => arr.reduce((acc,\
    \ item) => {\n  if (arr.indexOf(item) > -1) acc.push(item);\n  return acc;\n},\
    \ []);\n", "    var i, len = numbers.length\n    var newArr = new Array(len)\n\
    \    var found = new Array(len)\n    for(i=0;i<len;i++){\n        var el = numbers[i]\n\
    \        for(j=0;j<len;j++){\n            if(el == numbers[j]){\n            \
    \    found[j]++\n            }\n        }\n        if(!found.length){\n      \
    \      newArr.push(el)\n        }\n    }\n    return newArr\n}\n", "    var output\
    \ = [];\n    var seen = [];\n    for (var i = 0; i < numbers.length; i++){\n \
    \       if (seen.indexOf(numbers[i]) > -1) continue;\n        seen.push(numbers[i]);\n\
    \        output.push(numbers[i]);\n    }\n    return output;\n}\n", "   var nums_sorted_by_value\
    \ = numbers.sort();\n   var seen = {};\n   var unique_numbers = [];\n   for(var\
    \ i = 0; i < nums_sorted_by_value.length; i++){\n      var num = nums_sorted_by_value[i];\n\
    \      if(!seen[num]){\n         seen[num] = true;\n         unique_numbers.push(num);\n\
    \      }\n   }\n   return unique_numbers;\n}\n", "    var result = [];\n    for(var\
    \ i = 0; i < numbers.length; i++){\n        if(result.indexOf(numbers[i]) ===\
    \ -1){\n            result.push(numbers[i]);\n        }\n    }\n    return result;\n\
    }\n", "\tvar output = [], i=0;\n\twhile(i < numbers.length){\n\t\tif(output.indexOf(numbers[i])\
    \ == -1) output.push(numbers[i]);\n\t\ti++;\n\t}\n\treturn output;\n}\n", "  numbers\
    \ = Array.from(numbers);\n  var result = [];\n\n  for(var n = 0; n < numbers.length;\
    \ n++){\n    if(numbers.indexOf(n) > -1){\n      result.push(n);\n    }\n  }\n\
    \n  return result;\n}\n", "  var newArray = [];\n  var newArrayIndex = 0;\n  var\
    \ number = 0;\n\n  var isDuplicate = false;\n  for (var i =0; i<numbers.length;\
    \ i++){\n    number = numbers[i];\n    isDuplicate = (newArrayIndex != i);\n\n\
    \    if (isDuplicate){\n      newArray[newArrayIndex] = number;\n      newArrayIndex++;\n\
    \    }else{\n      newArray.push(number);\n    }\n  }\n  return newArray;\n}\n",
  "  numbers = numbers.filter(function(elem, index, self){\n    return self.indexOf(elem)\
    \ === index\n  })\n  return numbers;\n}\n", "    var i, k, len, new_array;\n \
    \   for (i = 0, len = numbers.length; i < len; i++) {\n        k = i;\n      \
    \  while (k < (len - 1) && numbers[k] == numbers[k+1]) {k++;}\n        if (k ==\
    \ len)\n            return numbers.slice(0, k+1);\n        new_array = numbers.slice(k,\
    \ len+1);\n        new_array.push(numbers[i]);\n        return new_array;\n  \
    \  }\n}\n</code>\n<|/ a tags=javascript,arrays,unique |>\n<| a dscore=2 |>\n<code>\n\
    const arr = [1, 2, 3, 4, 5, 2, 3];\n\nlet uniqueValues = [];\n\narr.forEach((item)\
    \ => {\n  if (uniqueValues.indexOf(item) === -1) {\n    uniqueValues.push(item);\n\
    \  }\n});\n", "\tvar unique = [];\n\t\n\tnumbers.map(function (x) {\n\t\tif (unique.indexOf(x)\
    \ === -1) {\n\t\t\tunique.push(x);\n\t\t}\n\t});\n\treturn unique;\n}\n", "  var\
    \ index = [];\n  var result = [];\n  \n  for(var i=0,n=numbers.length;i<n;i++){\n\
    \    if(index[numbers[i]]==undefined){\n      index[numbers[i]]=true;\n      result.push(numbers[i]);\n\
    \    }\n  }\n  return result;\n}\n", "    var newArray=[];\n    for (var i=0;\
    \ i<numbers.length;i++){\n        if (!inArray(numbers[i], newArray)){\n     \
    \       newArray.push(numbers[i]);\n        }\n    }\n    return newArray;\n}\n",
  "  let index = 0;\n  \n  return numbers.filter(function(num) {\n    if(num > numbers[index])\
    \ {\n      index = num;\n    }\n    \n    return num > numbers[index];\n  });\n\
    }\n", "\tvar newArray = [];\n\tfor(var i=0;i<numbers.length;i++)\n\t\tnewArray.push([numbers[i]]);\n\
    \t\n\tfor(var j=1;j<newArray.length;j++)\n\t{\n\t\tfor(var k=j;k<newArray.length;k++)\n\
    \t\t{\n\t\t\tif(newArray[j][0] == newArray[k][0])\n\t\t\t\tnewArray.splice(k,1);\n\
    \t\t\t\n\t\t}\n\t}\n\treturn newArray[0];\n}\n\n", "  return numbers.filter( function(elem,\
    \ index, self) {\n    return self.indexOf(elem) === index;\n  });\n}\n", "   \
    \ return _.uniq(numbers);\n}", "    var new_arr = [];\n    for (var i = 0; i <\
    \ numbers.length; i++) {\n        if (new_arr.indexOf(numbers[i]) == -1) {\n \
    \           new_arr.push(numbers[i]);\n        }\n    }\n    return new_arr;\n\
    }", "  var newNumbers = [];\n  for(var i = numbers.length - 1; i >= 0; i--){\n\
    \    if(newNumbers.indexOf(numbers[i]) == -1){\n      newNumbers.push(numbers[i]);\n\
    \    }\n  }\n  return newNumbers;\n}\n", "  var result = [];\n  for(var i = 0;\
    \ i < numbers.length; i++){\n    if(numbers[i] in result){\n      result.splice(i,\
    \ 1);\n      i--;\n    }else{\n      result.push(numbers[i]);\n    }\n  }\n  return\
    \ result;\n}\n", "    numbers = numbers.sort();\n    var unique = [];\n    for\
    \ (var i = 0; i < numbers.length; i++) {\n        if(unique.indexOf(numbers[i])\
    \ == -1){\n            unique.push(numbers[i]);\n        }\n    }\n    return\
    \ unique;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
