name: HumanEval_10_make_palindrome
language: js
prompt: "//Find the shortest palindrome that begins with a supplied string.\n// Algorithm\
  \ idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n\
  // - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"\
  cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunction make_palindrome(string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = make_palindrome;\n  assert.deepEqual(candidate(\"\"),\"\");\n  assert.deepEqual(candidate(\"\
  x\"),\"x\");\n  assert.deepEqual(candidate(\"xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"\
  xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"jerry\"),\"jerryrrej\");\n}\n\n\
  test();"
completions: ["    string = string.toLowerCase().replace(/\\s/g, \"\");\n    var len\
    \ = string.length,\n        prefix  = string.substr(0, len/2),\n        reversed\
    \ = string.substr(len/2, len),\n        postfix = string.substr(0, len/2),\n \
    \       result,\n        i;\n\n    for(i = 0; i < len; i++){\n        result =\
    \ prefix + reversed + postfix;\n        if(make_palindrome(result) === result){\n\
    \            return result;\n        }\n    }\n}\n</code>\n<|/ a tags=javascript,palindrome,algorithm,string\
    \ |>\n<| c |>\nThis is definitely the most elegant solution!\n<|/ c |>\n<| c |>\n\
    This is a very clever solution, but there is a bug in the code. For example, make_palindrome(\"\
    abcc\") returns \"abccc\", which is wrong. It should be: \"abcca\" instead of\
    \ \"abccac\".\n<|/ c |>\n<| a |>\n<code>", "    if(string == \"\"){\n        return\
    \ \"\"\n    }\n    let max_len = string.length\n    let max_len_palindromic =\
    \ 0\n    let i = 0\n    let j = max_len - 1 //i is reversed string of j\n    let\
    \ string_palindromic = \"\"\n    let char\n    while(i < max_len && j >= 0){\n\
    \        char = string[i]\n        if(char !== string[j]){\n            string_palindromic\
    \ = `${string_palindromic}${char}`\n            i--\n            j--\n       \
    \ }\n        else{\n            i--\n            j--\n        }\n    }\n    while(i\
    \ >= 0){\n        string_palindromic = `${string_palindromic}${string[i]}`\n \
    \       i--\n    }\n    while(j >= 0){\n        string_palindromic = `${string[j]}${string_palindromic}`\n\
    \        j--\n    }\n    return string_palindromic\n}\n</code>\n<|/ a tags=javascript,string,palindrome\
    \ |>\n<| c |>\nThe accepted answer will run into problems with very large strings.\
    \ A solution which uses less memory can be found here: https://stackoverflow.com/questions/4386928/reverse-a-string-in-javascript-without-using-built-in-string-methods.\
    \ However, it's much more difficult to understand for beginners.\n<|/ c |>\n<|\
    \ c |>\nThis algorithm is very unefficient. As pointed out, it uses unnecessary\
    \ memory (creating a string with repeated characters). You also cannot use backtracking\
    \ to solve this problem efficiently.\n<|/ c |>\n<| c |>\nThis algorithm is also\
    \ very unefficient. As pointed out, it uses unnecessary memory (creating a string\
    \ with repeated characters). You also cannot use backtracking to solve this problem\
    \ efficiently.\n<|/ c |>\n<| a dscore=2 |>\nThis is an inefficient solution that\
    \ uses backtracking. The optimal solution is O(n).\n<code>", "  // Find palindromic\
    \ suffix that ends with supplied string\n  let suffixes = [];\n  for (let i =\
    \ 0; i < string.length; i++){\n    if (string[i] !== string[string.length - i\
    \ - 1])\n      suffixes.push(string[i]);\n  }\n  // Reverse suffixes if there\
    \ are any\n  if (suffixes.length > 0){\n    for (let i = 0; i < suffixes.length;\
    \ i++){\n      suffixes[i] = suffixes[suffixes.length - i - 1];\n    }\n  }\n\
    \  // Reverse the rest of the string\n  return string.concat(suffixes.reverse());\n\
    }\n", "  if (string == \"\") return \"\";\n  \n  var reverse = make_palindrome(string.slice(0,-1));\n\
    \  \n  return string.slice(0,-1) + reverse + string.slice(-1)\n}\n", "    // If\
    \ no string provided return empty string.\n    if (string === '') return '';\n\
    \    // Build a postfix of supplied string that is a palindrome by adding reverse\
    \ of the prefix that is before the palindromic suffix.\n    let postfix = `${string.slice(0,-1)}${string[string.length-1]}`;\n\
    \    let reversePrefix = postfix.split('').reverse().join('');\n    return `${reversePrefix}${postfix}`;\n\
    }\n", "  let postfix = \"\";\n  let palindrome = \"\";\n  let suffix_len = string.length\
    \ - 1;\n  let prefix_len = string.length - 1;\n  while (prefix_len > 0) {\n  \
    \  postfix = string.substring(prefix_len, prefix_len + 1);\n    palindrome = string.substring(0,\
    \ suffix_len);\n    if (palindrome.length >= postfix.length) {\n      let palindrome_suffix\
    \ = \"[\" + palindrome.toLowerCase() + \"]\";\n      string += palindrome_suffix;\n\
    \      postfix += palindrome_suffix;\n      prefix_len -= palindrome_suffix.length;\n\
    \    }\n    else {\n      string += postfix;\n      postfix = \"\";\n      prefix_len\
    \ -= postfix.length;\n    }\n  }\n  return string;\n}\n", "  if(string == \"\"\
    ){\n    return \"\";\n  }\n  var p = \"\";\n  for(var i=0; i<string.length; i++){\n\
    \    var is_reverse = (i%2 === 0) ? true : false;\n    var reversed = (is_reverse)\
    \ ? string.substring(string.length - i - 1, string.length - i - 1) : \"\";\n \
    \   var suffix = (is_reverse) ? reversed.substring(reversed.length-i) : reversed.substring(reversed.length-i+1);\n\
    \    p = (p.length < string.length) ? p + string + suffix : p + suffix;\n  }\n\
    \  return p;\n}\n", "\tif(string == \"\"){\n\t\treturn \"\"\n\t}\n\tvar result\
    \ = string\n\tvar max_length = string.length\n\tvar min_length = string.length\n\
    \tvar reverse_string = string\n\tfor(var i = min_length-1; i>=0; i--){\n\t\treverse_string\
    \ += string[i]\n\t\tvar palindromic_suffix = reverse(reverse_string)\n\t\treverse_string\
    \ = reverse_string.slice(0, palindromic_suffix.length) + palindromic_suffix\n\t\
    \tmax_length = Math.max(max_length, palindromic_suffix.length)\n\t\tmin_length\
    \ = Math.min(min_length, palindromic_suffix.length)\n\t\tresult = result + palindromic_suffix\n\
    \t}\n\treturn result\n}\n", "    if(string.length <= 1) return string;\n    var\
    \ postfix = \"\";\n    var prefix_palindrome = string.substring(0, string.length-1);\n\
    \    var suffix_palindrome = string.substring(string.length-1);\n    while(prefix_palindrome\
    \ != suffix_palindrome){\n        postfix += String.fromCharCode(prefix_palindrome.charCodeAt(0)+suffix_palindrome.charCodeAt(0)-1);\n\
    \        prefix_palindrome = prefix_palindrome.substring(1) + string.substring(0,\
    \ string.length-1);\n        suffix_palindrome = suffix_palindrome.substring(1)\
    \ + string.substring(string.length-1);\n    }\n    postfix += String.fromCharCode(prefix_palindrome.charCodeAt(0)+suffix_palindrome.charCodeAt(0)-1);\n\
    \    return postfix;\n}", "  string = string.replace(\" \", \"\");\n  string =\
    \ string.toLowerCase();\n  \n  // Start with longest palindrome\n  var max_palindrome\
    \ = string;\n  \n  // Find postfix that is palindrome\n  var palindrome = \"\"\
    ;\n  var i = 0;\n  while (i<string.length && palindrome.charAt(0) == string.charAt(i)){\n\
    \    palindrome = palindrome + string.charAt(i);\n    i++;\n  }\n  \n  // Append\
    \ reverse of postfix to longest palindrome\n  i = palindrome.length - 1;\n  while\
    \ (i >= 0 && palindrome.charAt(i) == string.charAt(i)){\n    max_palindrome =\
    \ max_palindrome + palindrome.charAt(i);\n    i--;\n  }\n  \n  // Return longest\
    \ palindrome\n  return max_palindrome;\n}\n", "    string += string.substr(0,1);\n\
    \    var new_string = string;\n    while(new_string != string){\n        string\
    \ += string.substr(0,1)\n        new_string = new_string.replace(string,'')\n\
    \    }\n    return string\n}\n", "    console.log(\"make_palindrome(\"+string+\"\
    ) called\");\n    //console.log(\"length: \"+string.length);\n    // Find longest\
    \ possible postfix for string\n    var postfix = [];\n    for(var i = string.length-1;\
    \ i>=0; i--){\n        postfix.push(string.charAt(i));\n    }\n    //console.log(postfix);\n\
    \    // Now reverse\n    while(postfix.length>0){\n        var reverse = \"\"\
    ;\n        for(var i = postfix.length-1; i>=0; i--){\n            reverse += postfix.charAt(i);\n\
    \        }\n        postfix.splice(0, reverse.length);\n    }\n    console.log(\"\
    postfix after reverse: \"+postfix);\n    return string+postfix;\n}", "    var\
    \ l = (string.length < 2 || string[1] != string[string.length-1])? 1 : 2;\n  \
    \  var rev = 0;\n    while(l-- > 0){\n        rev = rev*10 + string.charCodeAt(string.length\
    \ - 1 - l);\n    }\n    return string.substr(0, string.length - 1) + rev;\n}",
  "    if (string.length == 0){\n        return \"\";\n    }\n    let reversed_string\
    \ = string.reverse();\n    if (string.length <= 2){\n        return string;\n\
    \    }\n    let postfix_substring = string.slice(0,string.length - 1);\n    if\
    \ (string.length - 1 === string.indexOf(postfix_string)){\n        return string\
    \ + reversed_string;\n    }\n    let prefix_substring = string.slice(0, string.indexOf(postfix_string));\n\
    \    let new_string = prefix_substring + postfix_substring + reversed_string;\n\
    \    return new_string;\n}\n</code>\n<|/ a |>\n<| c |>\nThis would require O(n^2)\
    \ time complexity, where n is the length of the string given in the question\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "    if (string === \"\"){\n        return\
    \ \"\";\n    }\n\n    var max_postfix = \"\";\n\n    for(var i = 0; i < string.length;\
    \ i++){\n        var postfix = string.substr(i, string.length);\n\n        var\
    \ palindrome_pending = \"\";\n        var palindrome = \"\";\n\n        for(var\
    \ j = i; j < string.length; j++){\n            var char = string.substr(j, 1);\n\
    \n            if (palindrome_pending.indexOf(char) === -1){\n                palindrome_pending\
    \ = palindrome_pending + char;\n                palindrome = palindrome + char;\n\
    \            }\n        }\n\n        if (max_postfix.indexOf(palindrome_pending)\
    \ === -1){\n            max_postfix = max_postfix + palindrome_pending;\n    \
    \    }\n    }\n\n    return string + max_postfix.split('').reverse().join('');\n\
    }\n", "    var length = string.length;\n    var revString = \"\";\n    for(var\
    \ i = 0; i < length; i++){\n        var letter = string.charAt(i);\n        var\
    \ revLetter = revString.charAt(length);\n        revString = revString.concat(String.fromCharCode(revLetter+32));\n\
    \        if(letter === revString[length]){\n            break;\n        }\n  \
    \  }\n    return string.slice(0, length).concat(revString);\n}\n", "    var reversed_string\
    \ = \"\";\n    var postfix_length = 0;\n    for (var i = 1; i < string.length;\
    \ i++){\n        if (string[i] === string[string.length-(i-1)]){\n           \
    \ postfix_length = i;\n        }\n    }\n    reversed_string += string.slice(0,postfix_length);\n\
    \    reversed_string += string.reverse();\n    \n    \n    return reversed_string;\n\
    }\n\n", "    var new_string = string;\n\n    if(string == \"\"){\n        return\
    \ \"\";\n    }\n\n    var prefix_start_index;\n    var postfix_end_index;\n  \
    \  var postfix_length;\n    var start_palindrome_index;\n\n    var reverse_string\
    \ = \"\";\n\n    //Find prefix of supplied string that is a palindrome\n    for(var\
    \ i = 0; i <= string.length; i++){\n        prefix_start_index = i;\n\n      \
    \  //Find postfix that is a palindrome\n        postfix_end_index = string.length;\n\
    \        for(var j = i; j <= string.length; j++){\n            postfix_end_index\
    \ = j;\n            postfix_length = string.length - j;\n            var substring\
    \ = string.substring(i, j);\n            var reverse_substring = reverseString(substring);\n\
    \            if(substring == reverse_substring){\n                start_palindrome_index\
    \ = j;\n                postfix_end_index = start_palindrome_index + postfix_length;\n\
    \                break;\n            }\n        }\n\n        if(postfix_end_index\
    \ == string.length){\n            reverse_string = reverse_string + string.substring(prefix_start_index,\
    \ i);\n        }\n    }\n\n    new_string = new_string + reverse_string;\n\n \
    \   return new_string;\n}\n", "    // Step 1: Find the longest palindrome prefix\
    \ of the supplied string\n    // If palindrome prefix is empty, then return supplied\
    \ string.\n    var postfix_longest_prefix_string = get_longest_postfix_string(string);\n\
    \    if (!postfix_longest_prefix_string) return string;\n    // Step 2: Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix\n    var postfix_longest_prefix_string = postfix_longest_prefix_string\
    \ + get_reversed_string(string, postfix_longest_prefix_string);\n    // Step 3:\
    \ Return result of the above 2 steps\n    return postfix_longest_prefix_string;\n\
    }\n", "    var stringLength      = string.length, resultLength = 0, \n       \
    \ stringPrefix      = string.substr(0,stringLength), \n        stringReverse \
    \    = string.slice(0,stringLength).split(\"\").reverse().join(\"\"),\n      \
    \  stringPostfix     = string.slice(stringLength,stringLength+stringReverse.length);\n\
    \        \n    if (stringReverse === stringPostfix){\n        return stringPrefix\
    \ + stringPostfix;\n    }\n\n    if (stringReverse !== stringPostfix){\n     \
    \   throw 'No Palindrome found!';\n    }\n\n    resultLength += stringPrefix.length\
    \ + stringPostfix.length;\n\n    return make_palindrome(string.slice(0,stringLength-resultLength));\n\
    }\n", "  return string.split(\"\").reverse().join(\"\") + reverse(string.substr(0,\
    \ string.lastIndexOf(string.split(\"\").reverse())));\n}\n", "\tstring = (string\
    \ == null ? \"\" : string.toLowerCase());\n\tvar postfix = \"\";\n\tvar suffixLength\
    \ = 0;\n\tvar longestPalindrome = \"\";\n\n\tfor(var i = 0; i < string.length;\
    \ i++){\n\t\tpostfix = string.substring(0, i + 1);\n\t\tsuffixLength = postfix.length;\n\
    \t\tlongestPalindrome = postfix.substring(0, longestPalindrome.length - suffixLength);\n\
    \t\tvar reversePostfix = \"\";\n\n\t\tfor (var j = longestPalindrome.length -\
    \ 1; j >= 0; j--){\n\t\t\treversePostfix = reversePostfix + longestPalindrome[j];\n\
    \t\t}\n\n\t\tif (reversePostfix === postfix){\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\
    return longestPalindrome + reversePostfix;\n}\n", "\tstring = string.toString().split(\"\
    \").reverse().join(\"\");\n\twhile(string.length < string.length/2) string = string\
    \ + string;\n\treturn string.toString();\n}", "    if(string.length == 0){\n \
    \       return \"\"\n    }\n\n    // Find the longest palindrome that begins with\
    \ a supplied string.\n    var longestPalindrome = find_longest_palindrome_prefix(string);\n\
    \    var longestPalindromeLength = longestPalindrome.length;\n\n    // Now append\
    \ the reverse of the string prefix before the longest palindromic suffix.\n  \
    \  var newString = string.substr(0, longestPalindromeLength) + string.palindromic_suffix(string);\n\
    \    return newString;\n}\n", "  var strings = string.split('');\n  strings.reverse();\n\
    \  strings.reverse();\n  var new_string = \"\";\n  for(var i = 0; i < strings.length;\
    \ i++){\n    new_string += strings[i];\n  }\n  return new_string;\n}\n", "   \
    \ var length= string.length;\n    var new_string=\"\";\n    var postfix=\"\";\n\
    \    for(let i= length-1; i>=0; i--){\n        postfix += string[i];\n    }\n\
    \    for(i=0; i<length; i++){\n        new_string += postfix.substring(0,i) +\
    \ string.padEnd(length-i, string[i]);\n    }\n    return new_string;\n}\n\n",
  "    let palindrome=string;\n    for(i=string.length-1;i>=0;i--){\n        palindrome=palindrome+make_reverse_of_string(i)+palindrome.substring(0,i)+make_reverse_of_string(i+1);\n\
    \    }\n    return palindrome;\n}", "    //If string is empty, return an empty\
    \ string\n    if(string === \"\") return \"\";\n    //If string has one character,\
    \ return it\n    if(string.length === 1) return string;\n    //Find the longest\
    \ postfix of supplied string that is a palindrome\n    var longest_postfix = find_longest_postfix(string);\n\
    \    //Get the string prefix before postfix and reverse it\n    var postfix =\
    \ string.substring(0, longest_postfix);\n    var reversed_postfix = reverse(postfix);\n\
    \    //Return the string concatenated with postfix reversed string and palindromic\
    \ suffix\n    return string.substring(longest_postfix, string.length) + reversed_postfix;\n\
    }\n", "  let l=string.length\n  if(l<=1){\n    return string\n  }\n  let s=string\n\
    \  let r=make_palindrome(string[0])\n  let p=r\n  for(let i=0;i<l-1;i++){\n  \
    \  let p=p+string[i]\n    r=r+p\n  }\n  return r\n}\n", "    if(string.length\
    \ === 0) return \"\";\n    let longestPalindrome = string.trim().replace(/[^a-zA-Z]/g,\
    \ \"\");\n    let reversedPrefix = string.substr(0, string.length - longestPalindrome.length);\n\
    \    let reversedSuffix = string.replace(longestPalindrome, reversedPrefix).substr(0,\
    \ string.length - longestPalindrome.length);\n    return reversedPrefix + reversedSuffix\
    \ + longestPalindrome;\n}\n", "    let str = string.split(\"\").reverse().join(\"\
    \");\n    let postfix = str.split(\"\").filter(char => char === str[0]);\n   \
    \ postfix.push(str);\n    return postfix.reverse().join(\"\");\n}\n", "    //\
    \ No string is a palindrome.\n    if(string === \"\"){\n        return \"\";\n\
    \    }\n    // No string is a palindrome without spaces.\n    if(string.trim()\
    \ === \"\"){\n        return string;\n    }\n    // No string is a palindrome\
    \ that has spaces.\n    if(string.toLowerCase().trim() === \"\"){\n        return\
    \ string;\n    }\n    // String is a palindrome.\n    string = string.toLowerCase();\n\
    \    let longestPalindrome = string.substr(0, string.length - 1).split(\"\").reverse().join(\"\
    \");\n    return string.slice(0, string.length - 1) + longestPalindrome;\n}\n",
  "  var postfix_string = \"\";\n  for(i = 0; i < string.length; i++){\n    switch(string[i]){\n\
    \      case \"c\":\n        postfix_string = postfix_string + \"ca\";\n      \
    \  break;\n      case \"a\":\n        postfix_string = postfix_string + \"ata\"\
    ;\n        break;\n      case \"t\":\n        postfix_string = postfix_string\
    \ + \"at\";\n        break;\n      case \"g\":\n        postfix_string = postfix_string\
    \ + \"ag\";\n        break;\n      default:\n        postfix_string = postfix_string\
    \ + string[i];\n        break;\n    }\n  }\n  postfix_string = postfix_string.replace(/^(.)\\\
    1$/, \"$1\")\n  return postfix_string;\n}\n\n", "\tvar prefix = '';\n\tvar suffix\
    \ = '';\n\tvar reversed_string = '';\n\tvar longest_palindrome = '';\n\tvar palindromic_suffix\
    \ = '';\n\t\n\t//Find longest palindrome postfix\n\tlongest_palindrome = string.substring(0,string.length/2);\n\
    \t\n\tlongest_palindrome = longest_palindrome.split('').reverse().join('');\n\t\
    \n\tlongest_palindrome = longest_palindrome+longest_palindrome;\n\t\n\t//Add the\
    \ reverse of the string prefix to the end of the longest palindrome postfix.\n\
    \tlongest_palindrome = longest_palindrome + string.substring(string.length/2,string.length);\n\
    \t\n\t\n\t//Find palindromic suffix.\n\tpalindromic_suffix = string.substring(string.length/2+1,string.length);\n\
    \t\n\tlongest_palindrome = longest_palindrome + reversed_string.substring(reversed_string.length/2+1,reversed_string.length);\n\
    \t\n\treturn longest_palindrome+palindromic_suffix;\n}\n", "  var palindrome =\
    \ \"\";\n\n  if(string.length <= 1){\n    return string;\n  }\n\n  var start_index\
    \ = string.length -1, end_index = string.length -1, suffix;\n\n  //Find the longest\
    \ postfix that is a palindrome\n  while(start_index >= 0 && end_index >= 0){\n\
    \    suffix = string.substring(start_index).concat(string.reverse(string[start_index]));\n\
    \    if(suffix.length < string.length){\n      end_index = start_index - 1;\n\
    \    }\n    else{\n      palindrome = suffix.concat(palindrome);\n      start_index\
    \ = end_index - 1;\n      end_index = start_index;\n    }\n  }\n\n  return palindrome;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=0 tags=javascript |>\nHere is a simple algorithm\
    \ that does not require recursion.  It can find the longest palindrome in a string\
    \ in less than O(n).\n<code>", "  if(string === \"\" || string.length <= 1){\n\
    \    return string\n  }\n  let longestPalindromicPrefix = 0\n  let longestPalindromicSuffix\
    \ = 0\n  let longestPalindromicLength = 0\n  \n  let longestPalindromic = string\n\
    \  for(let i = string.length-2; i >= 0; --i){\n    const currentChar = string[i]\n\
    \    const reversedChar = string[string.length - 1 - i]\n    if( currentChar ===\
    \ reversedChar ){\n      continue\n    }\n    let prefixLength = 0\n    while(currentChar\
    \ === string[prefixLength]){\n      prefixLength++\n    }\n    let suffixLength\
    \ = 0\n    while(currentChar === reversedChar){\n      suffixLength++\n    }\n\
    \    if(prefixLength > longestPalindromicPrefix){\n      longestPalindromicPrefix\
    \ = prefixLength\n    }\n    if(suffixLength > longestPalindromicSuffix){\n  \
    \    longestPalindromicSuffix = suffixLength\n    }\n    if(prefixLength > longestPalindromicLength){\n\
    \      longestPalindromicLength = prefixLength\n    }\n    if(suffixLength > longestPalindromicLength){\n\
    \      longestPalindromicLength = suffixLength\n    }\n  }\n  if(longestPalindromicLength\
    \ > longestPalindromicPrefix){\n    longestPalindromic = string+string.reverse()\n\
    \  }\n  return longestPalindromic\n}", "  var prefix;\n  var suffix;\n  if(string.length\
    \ == 0){\n    return \"\";\n  }\n  if(string.length == 1){\n    return string;\n\
    \  }\n  for(var i = 0, max = string.length; i < max; i++){\n    var s = string.substring(0,\
    \ i);\n    var sf = string.substring(i, max);\n    if(sf != s + ''){\n      prefix\
    \ = string.substring(0, i);\n      suffix = make_palindrome(string.substring(i+1,\
    \ max));\n      if(i == 0){\n        return prefix + suffix;\n      }\n      if(s[i]\
    \ == s[s.length-1]){\n        return prefix + suffix + \"m\";\n      }\n     \
    \ if(s[s.length-1] == s[s.length-2]) {\n        return prefix + suffix + \"mm\"\
    ;\n      }\n      return prefix + suffix + \"mmm\";\n    }\n  }\n}\n", "  var\
    \ l = string.length;\n  if(l < 2) return string;\n  if(is_palindrome(string))\
    \ return string;\n  var prefix;\n  var suffix;\n  for(var i=0; i<l; i++){\n  \
    \  if(is_palindrome(string.substr(i))){\n      prefix = string.substr(0, i);\n\
    \      suffix = string.substr(i);\n      break;\n    }\n  }\n  if(prefix === undefined){\n\
    \    prefix = string;\n    suffix = \"!\";\n  }\n  var reversed_prefix = prefix.split(\"\
    \").reverse().join(\"\");\n  reversed_prefix = reversed_prefix + \"!\";\n  suffix\
    \ = suffix + reversed_prefix + suffix;\n  if(suffix.length > string.length){\n\
    \    return make_palindrome(string.substr(0, string.length - 1)) + suffix;\n \
    \ }\n  return string;\n}", "    string = string.split('');\n    let palindrome\
    \ = \"\";\n    for(let i = 0; i < string.length; i++){\n        palindrome = `${palindrome}${string[string.length\
    \ -1 -i]}`\n    }\n    return palindrome;\n}\n</code>\n<|/ a tags=javascript,palindrome,string\
    \ dscore=1 |>\n<| a tags=javascript,palindrome,string |>\n<code>", "\tif(string\
    \ === \"\") return \"\";\n\tlet palindrome = reverse(string);\n\treturn string\
    \ + palindrome;\n}\n", "  if(string.length == 0) return \"\";\n  // Find the longest\
    \ postfix that is a palindrome.\n  var best_len = string.length;\n  var best_prefix\
    \ = \"\";\n  var best_suffix = \"\";\n  for(var i=0; i<string.length; i++){\n\
    \    var curr_char = string.substr(i,1);\n    var curr_len = string.length;\n\
    \    // Find the longest postfix that is a palindrome of curr_char.\n    while(curr_len\
    \ > i){\n      var curr_postfix = string.substr(i,curr_len);\n      var curr_char_postfix\
    \ = curr_char + curr_postfix;\n      var curr_len = string.length;\n      if(make_palindrome(curr_char_postfix).indexOf(curr_char_postfix)\
    \ == 0){\n        // Found the postfix of the longest palindrome palindrome of\
    \ curr_char.\n        var longest_palindrome = curr_char_postfix;\n        var\
    \ palindrome_len = curr_len;\n      }\n      i++;\n    }\n    if(longest_palindrome.length\
    \ > best_len){\n      best_prefix = longest_palindrome;\n      best_suffix = string.substr(0,i);\n\
    \      best_len = longest_palindrome.length;\n    }\n  }\n  var palindrome = best_prefix\
    \ + best_suffix;\n  return palindrome;\n}\n</code>\n<|/ a tags=python,javascript\
    \ |>\n<| c |>\nHe wants a dynamic programming solution. Your solution is O(n^4)\
    \ for all cases.\n<|/ c |>\n<| c |>\nAh, I didn't see that. Edited.\n<|/ c |>\n\
    <| c |>\nIt would be interesting to see how this compares to other solutions given.\n\
    <|/ c |>\n<| c |>\nThis solution works in both languages.  I ran some benchmarking\
    \ tests on it and found that it performed very well for most inputs.  I did find\
    \ it slower than other solutions.  I also found that it wasn't the fastest solution\
    \ because it was O(n^4).\n<|/ c |>\n<| a dscore=2 tags=python,javascript |>\n\
    Here's a solution in javascript that works for all cases, even non-palindromic\
    \ ones.\nIt uses the fact that if you can build a string from left to right, that\
    \ you can build a reverse from right to left.\nThe algorithm is simple: build\
    \ the prefix and the suffix of the largest palindrome (longest palindromic substring)\
    \ starting at the start of the string, and compare the prefix with the suffix\
    \ of the largest palindrome (longest palindromic substring) starting at the end.\n\
    If it matches, add the ", "    //Get longest postfix palindrome.\n    var postfix\
    \ = \"\";\n    var max_len = 0;\n    for(var i = 0; i < string.length; i++){\n\
    \        if(string[i] === string[string.length-i-1]){\n            postfix +=\
    \ string[i];\n            max_len = Math.max(string.length, i+1);\n        }\n\
    \    }\n    //Get string prefix that comes before it.\n    var prefix = string.slice(0,\
    \ max_len-1);\n    //Reverse prefix.\n    prefix = prefix.split('').reverse().join('');\n\
    \    return prefix+postfix;\n}\n", "  var s = string || '';\n  var is_palindrome\
    \ = true;\n  var start = 0, end = s.length - 1;\n  while(start < end){\n    if(s.charAt(start)\
    \ !== s.charAt(end)){\n      is_palindrome = false;\n      break;\n    }\n   \
    \ start++;\n    end--;\n  }\n  if(is_palindrome){\n    var rev_start = 0, rev_end\
    \ = s.length - 1;\n    while(rev_start < rev_end){\n      if(s.charAt(rev_start)\
    \ !== s.charAt(rev_end)){\n        break;\n      }\n      rev_start++;\n     \
    \ rev_end--;\n    }\n    return s.slice(0,rev_start) + s.slice(rev_end) + s.slice(0,rev_start)\
    \ + s.slice(rev_end);\n  }\n  return string;\n}\n", "\tlet longest_palindrome\
    \ = \"\";\n\tfor(let i = 0; i <= string.length; i++){\n\t\tlet postfix_palindrome\
    \ = string.slice(i).reverse();\n\t\tlet prefix_palindrome = string.slice(0, i);\n\
    \t\tif(prefix_palindrome.indexOf(postfix_palindrome) !== -1){\n\t\t\tlongest_palindrome\
    \ = `${prefix_palindrome}${postfix_palindrome}`;\n\t\t}\n\t}\n\treturn longest_palindrome;\n\
    }\n", "    var prefix = '';\n    var suffix = '';\n    var longestPrefix = '';\n\
    \    var longestSuffix = '';\n    var longestPostfix = '';\n    for(var i=0;i<string.length;i++){\n\
    \        if(string.charAt(i)==='-'){\n            longestPrefix = string.substring(i+1);\n\
    \            longestPrefix = longestPrefix.replace(/-$/g,'');\n            longestPostfix\
    \ = longestPrefix + string.substr(i);\n        }\n        if(string.charAt(i)==='+'){\n\
    \            longestSuffix = string.substring(i+1);\n            longestSuffix\
    \ = longestSuffix.replace(/-$/g,'');\n            longestPostfix = longestPostfix.substring(0,\
    \ longestPostfix.length-longestSuffix.length) + longestSuffix;\n        }\n  \
    \  }\n    longestPrefix = longestPrefix.replace(/-$/g,'');\n    longestSuffix\
    \ = longestSuffix.replace(/-$/g,'');\n    longestPostfix = longestPostfix.substring(0,\
    \ longestPostfix.length-longestSuffix.length) + longestSuffix;\n    var prefixPalindrome\
    \ = longestPrefix + longestPostfix;\n    var suffixPalindrome = longestSuffix\
    \ + longestPostfix;\n    var reversedPrefix = prefixPalindrome.substring(0,prefixPalindrome.length-1)\
    \ + prefixPalindrome.substring(prefixPalindrome.length-1);\n    var reversedSuffix\
    \ = suffixPalindrome.substring(0,suffixPalindrome.length-1) + suffixPalindrome.substring(suffixPalindrome.length-1);\n\
    \    return reversedPrefix + reversedSuffix;\n}\n", "    var reversed_string =\
    \ \"\";\n    for (var i = string.length - 1; i >= 0; i--){\n        reversed_string\
    \ += string[i];\n    }\n    var palindrome = reversed_string + reversed_string.reverse();\n\
    \    return string + palindrome;\n}\n</script>\n    </body>\n</html>\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis is not true. According to the spec, \"The algorithm\
    \ must behave correctly in a situation where the string [...] contains two or\
    \ more occurrences of its characters in any order.\" Your algorithm breaks that\
    \ requirement. Try it with \"aba\".\n<|/ c |>\n<| c |>\nIt does NOT say that it\
    \ must work correctly. The spec says it must work correctly if the string starts\
    \ with the same characters, which is exactly what my implementation does.\n<|/\
    \ c |>\n<| c |>\nYou say \"The algorithm must behave correctly in a situation\
    \ where the string [...] contains two or more occurrences of its characters in\
    \ any order.\" This is not true. Try it with: \"aba\".\n<|/ c |>\n<| c |>\n\"\
    aba\" is a valid string that passes my test. My algorithm produces \"abaaba\"\
    \ which is correct according to the spec you quoted.\n<|/ c |>\n<| c |>\n`aba`\
    \ is not a valid string because of the `a`, which doesn't appear twice, as the\
    \ first character.\n<|/ c |>\n<| a tags=algorithm,string,palindrome,javascript\
    \ dscore=3 |>\nThis doesn't quite answer your question but just wanted to point\
    \ out that this problem was the one that motivated my curiosity in the first place.\
    \ I looked at the answers and thought they were incomplete or just horribly inefficient.\
    \ \nThe problem\nThe problem states:\n\nWrite a function that accepts a string\
    \ and returns a string that is a palindrome of the original.\n\nThe obvious way\
    \ to do this would be to simply iterate over the characters in the original and\
    \ append the reverse of each in turn to the end of the string. However this fails\
    \ when the input string is empty, or has a single character (that is not a palindrome).\
    \ Furthermore the time complexity is quadratic.\nThe solution\nThere is a slightly\
    \ more clever way of doing this that doesn't require linear complexity, by building\
    \ a palindrome as a linked list that starts with every character. \nThe palindrome\
    \ can then be built by walking the list from the end, looking up the character\
    \ that was encountered and appending the reverse of that. \nThis solution will\
    \ also handle cases where the input string is not a palindrome ", "    let longestPalIndex=0;\n\
    \    let longestPalChar=\"\";\n    let longestPal=\"\";\n    for(let i=string.length;i>0;i--){\n\
    \        let temp=string[i-1-i];\n        longestPal+=temp;\n        if(temp==temp.toUpperCase()){\n\
    \            longestPalIndex=i;\n            longestPalChar=temp;\n        }\n\
    \    }\n    return string.slice(0,longestPalIndex+longestPalChar.length)+string[longestPalIndex+longestPalChar.length-1]+string[longestPalIndex-longestPalChar.length-1]+longestPal;\n\
    }\n", "    var longestPalindrome = 0;\n    var longestPalindromicString = \"\"\
    ;\n    var middleOfLongestPalindrome = 0;\n    var stringLength = string.length;\n\
    \    for(var i = 0; i < stringLength; i++){\n        var letter = string[i];\n\
    \        var reversedLetter = letter;\n        var reversedString = \"\";\n  \
    \      while(letter !== reversedLetter){\n            reversedString = reversedString\
    \ + letter;\n            reversedLetter = string[stringLength - i - 1];\n    \
    \    }\n        if(reversedString.length > longestPalindrome){\n            longestPalindrome\
    \ = reversedString.length;\n            longestPalindromicString = reversedString;\n\
    \            middleOfLongestPalindrome = i;\n        }\n    }\n    if(longestPalindrome){\n\
    \        string = string.substr(0, middleOfLongestPalindrome) + longestPalindromicString\
    \ + string.substr(middleOfLongestPalindrome + longestPalindrome);\n    }\n   \
    \ return string;\n}", "  var str = string;\n  var reversed_str = reverseString(str);\n\
    \  var post_palindromic_length = findPostPalindromicStrLength(string, reversed_str);\n\
    \  var post_palindromic_str = reverseString(str.substr(post_palindromic_length));\n\
    \  var full_palindrome = str + post_palindromic_str;\n  return full_palindrome;\n\
    }\n", "    if(string === undefined || string === null){\n        return \"\";\n\
    \    }\n    // Get the longest palindromic suffix that starts with the given string.\n\
    \    var reverse_palindromic = reverse_string_palindrome(string);\n    var prefix_reverse_palindromic\
    \ = string+reverse_palindromic;\n    var post_reverse_palindromic = reverse_palindromic+string;\n\
    \    // Find the prefix that ends with this longest palindromic suffix.\n    var\
    \ palindromic_suffix = reverse_string_palindrome(string);\n    var postfix_palindromic_suffix\
    \ = string+palindromic_suffix;\n    var post_palindromic_suffix = palindromic_suffix+string;\n\
    \    \n    // Find the prefix that starts with this longest palindromic suffix.\n\
    \    var palindromic_prefix_end = reverse_string_palindrome(postfix_palindromic_suffix);\n\
    \    var postfix_palindromic_prefix_end = postfix_palindromic_suffix+palindromic_prefix_end;\n\
    \    var post_palindromic_prefix_end = palindromic_prefix_end+postfix_palindromic_suffix;\n\
    \n    // Combine these two prefixes in such a way that the original string ends\
    \ with this palindromic suffix.\n    return prefix_reverse_palindromic+post_palindromic_prefix_end;\n\
    }\n", "    \n    // Check if string is a palindrome\n    if (string == string.toLowerCase()){\n\
    \        return string;\n    }\n    \n    // Find largest postfix of a string\
    \ that is a palindrome.\n    let postfix_begin = find_longest_palindrome_substr(string);\n\
    \    \n    // Reverse the string found at the previous step.\n    let postfix_end\
    \ = string.slice(postfix_begin).split('').reverse().join('');\n    \n    // Return\
    \ the string prefixed with the reversed postfix string found at previous step.\n\
    \    return string.slice(0, postfix_begin) + postfix_end;\n}\n", "    var reversed_str\
    \ = string.replace(/[-]+/g,\"\");\n    var longest = longestPalindrome(string);\n\
    \    return reverse + longest;\n}\n", "\tstring = string || \"\";\n\tvar string_length\
    \ = string.length;\n\tvar palindrome = \"\";\n\tvar reverse_string = \"\";\n\t\
    var i = 0;\n\t\n\t//Find longest palindrome\n\tfor(i=0;i<string_length;i++){\n\
    \t\tvar reverse_letter = string.charAt(string_length-1-i);\n\t\tvar letter = string.charAt(i);\n\
    \t\t\n\t\tif(palindrome.length == 0){\n\t\t\tpalindrome = letter + reverse_letter;\n\
    \t\t\tbreak;\n\t\t}else{\n\t\t\tif(palindrome.charAt(0) != letter){\n\t\t\t\t\
    palindrome = palindrome + letter + reverse_letter;\n\t\t\t\tbreak;\n\t\t\t}else{\n\
    \t\t\t\tif(palindrome.charAt(0) == letter){\n\t\t\t\t\tpalindrome = palindrome\
    \ + reverse_letter + letter;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\t\n\t//Prepend reverse string to the palindrome string\n\tfor(i=0;i!=string_length;i++){\n\
    \t\treverse_string += string.charAt(i);\n\t}\n\t\n\treturn palindrome + reverse_string;\n\
    }\n", "    let longestPalindrome = \"\";\n    let longestPostfix = 0;\n    for(i\
    \ = 0 ; i < string.length ; i++){\n        for(j = string.length - 1; j >= i ;\
    \ j--){\n            if(string[i] == string[j]){\n                let palindrome\
    \ = string.slice(0,i) + string.slice(i,string.length) + string.slice(j+1, string.length);\n\
    \                let postfix = string.slice(0,j) + string.slice(j+1);\n      \
    \          if(palindrome.length <= longestPalindrome.length){\n              \
    \      longestPalindrome = palindrome;\n                    longestPostfix = postfix;\n\
    \                }\n            }\n        }\n    }\n    return longestPalindrome;\n\
    }\n", "    if(string.length <= 1){\n        return string;\n    }\n    \n    //Find\
    \ the longest palindromic suffix that comes before the given string\n    const\
    \ lp_string = longestPalindromicSuffix(string, string.length);\n    \n    //Get\
    \ a reverse of the string starting before the longest palindromic suffix\n   \
    \ const reversed = string.substring(0, lp_string.length) + reverseString(string.substring(lp_string.length));\n\
    \    \n    //Append to the longest palindromic suffix at the end of original string\n\
    \    return string.substring(0, lp_string.length) + reversed + lp_string;\n}\n",
  "  var suffix;\n  var reverse_suffix;\n  var max_length = 0;\n  var reverse_max_length\
    \ = 0;\n  for(var i=0; i < string.length; i++){\n    suffix = '';\n    if(string[i]\
    \ == string.length){\n      suffix += string[i];\n    }else{\n      for(var j\
    \ = string.length-1; j >=i; j--){\n        suffix = string[j] + suffix;\n    \
    \  }\n    }\n    reverse_suffix = '';\n    if(string[i] == string.length){\n \
    \     reverse_suffix += string[i];\n    }else{\n      for(var j = string.length-1;\
    \ j >=i; j--){\n        reverse_suffix = string[j] + reverse_suffix;\n      }\n\
    \    }\n    if(suffix != reverse_suffix && suffix.length >= max_length){\n   \
    \   max_length = suffix.length;\n    }\n    if(reverse_suffix != suffix && reverse_suffix.length\
    \ >= reverse_max_length){\n      reverse_max_length = reverse_suffix.length;\n\
    \    }\n  }\n  var palindrome = string.slice();\n  var start = palindrome.indexOf(string[0]);\n\
    \  if(start == -1){\n    return string\n  }\n  var end = palindrome.indexOf(string.slice(-1));\n\
    \  if(end == -1){\n    return string\n  }\n  for(var i=0; i < max_length; i++){\n\
    \    palindrome[start+i] = reverse_suffix[i];\n  }\n  return palindrome\n}\n",
  "  //O(n) algorithm for finding longest palindrome\n  if(!string){\n    return \"\
    \";\n  }\n\n  let longest_palindrome = \"\";\n  let index_of_end_of_palindrome\
    \ = 0;\n  let index_of_end_of_longest_palindrome = 0;\n  for(const char of string){\n\
    \    //Find longest palindrome prefix that ends with the character to be reversed.\n\
    \    //Use longest prefix prefix of length 1 to find shortest suffix.\n    let\
    \ is_palindrome = true;\n    let palindrome_prefix = \"\";\n    for(i = 1; i <\
    \ longest_palindrome.length; i++){\n      //Add one to index since it starts from\
    \ 0.\n      if(longest_palindrome[i] !== longest_palindrome[i-1]){\n        break;\n\
    \      }\n      palindrome_prefix += longest_palindrome[i];\n    }\n    if(palindrome_prefix\
    \ !== string){\n      is_palindrome = false;\n    }\n    if(!is_palindrome){\n\
    \      continue;\n    }\n    //Find longest palindrome suffix that starts with\
    \ the same character.\n    let palindrome_suffix = \"\";\n    for(i = longest_palindrome.length;\
    \ i >= 0; i--){\n      palindrome_suffix += longest_palindrome[i];\n    }\n  \
    \  if(longest_palindrome.length !== string.length){\n      continue;\n    }\n\
    \    //Add prefix to suffix.\n    palindrome_suffix += palindrome_prefix;\n  \
    \  if(longest_palindrome.length < string.length){\n      continue;\n    }\n  \
    \  //Check if suffix is a palindrome.\n    //Check if palindrome prefix and suffix\
    \ are equal.\n    if(longest_palindrome_prefix !== palindrome_suffix &&\n    \
    \  longest_palindrome_prefix !== string){\n      is_palindrome = false;\n    }\n\
    \    if(!is_palindrome){\n      continue;\n    }\n    //If this string is a palindrome,\
    \ check it against the longest palindrome found so far.\n    //If longest palindrome\
    \ prefix and suffix match, then longest palindrome is found.\n    if(longest_palindrome_prefix\
    \ === palindrome_prefix &&\n      longest_palindrome_suffix === palindrome_suffix){\n\
    \      if(longest_palindrome.length < string.length){\n        continue;\n   \
    \   }\n      longest_palindrome = palindrome_prefix + palin", "    // Create a\
    \ copy of the string\n    var reverseString = string.reverse().split(\"\").join(\"\
    \");\n\n    // Create an array of all potential palindromes\n    var possiblePalindromes\
    \ = [];\n    for (var i = 0; i < string.length; i++) {\n        var postfix =\
    \ string.slice(i);\n        // Check if this potential palindrome could be the\
    \ suffix for the prefix before the suffix\n        if (string.slice(i-1).reverse().split(\"\
    \").join(\"\") == postfix) {\n            // We found a potential palindrome,\
    \ now check if it is the shortest so far\n            var shortestPalindromeLength\
    \ = 0;\n            for (var j = 0; j < possiblePalindromes.length; j++) {\n \
    \               var possiblePalindrome = possiblePalindromes[j];\n           \
    \     var possiblePalindromeLength = possiblePalindrome.length;\n            \
    \    if (possiblePalindrome.indexOf(postfix, shortestPalindromeLength) == 0) {\n\
    \                    // Found a shorter palindrome, break out of loop\n      \
    \              break;\n                }\n                shortestPalindromeLength\
    \ += possiblePalindromeLength;\n            }\n            // Add this potential\
    \ palindrome to the list of possible palindromes.\n            if (possiblePalindromes.length\
    \ < shortestPalindromeLength) {\n                possiblePalindromes.push(postfix);\n\
    \            }\n        }\n    }\n\n    // Return the shortest palindrome\n  \
    \  if (possiblePalindromes.length < 1) return \"\";\n    return possiblePalindromes[0];\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| a tags=javascript dscore=2 |>\nThe shortest\
    \ solution is probably this:\n<code>", "  var longest = \"\";\n  var longestPalindrome\
    \ = \"\";\n  for(var i = string.length-1; i>=0; i--){\n    var palindrome = string.substring(0,i+1);\n\
    \    if(longest != \"\"){\n      palindrome += longest;\n      longestPalindrome\
    \ = palindrome;\n    }\n    longest = palindrome;\n  }\n  return longestPalindrome;\n\
    }", "    var reversed_string = string.reverse ();\n    var palindrome_prefix;\n\
    \    var palindrome_suffix;\n    var longest_prefix;\n    var shortest_suffix;\n\
    \n    shortest_suffix = string.substr (0,1);\n    longest_prefix = string.substr\
    \ (0,longestPalindromePrefix_length (string));\n    palindrome_prefix = reversed_string.substr\
    \ (0, longestPalindromePrefix_length (reversed_string));\n    palindrome_suffix\
    \ = string.substr (longestPalindromeSuffix_length (string));\n\n    return palindrome_prefix\
    \ + shortest_suffix + palindrome_suffix;\n}\n", "    var original_string = string;\n\
    \    var palindromic_postfix = string.split('').reverse().join('');\n    var new_string\
    \ = original_string.slice(0,1) + palindromic_postfix + original_string.slice(-1);\n\
    \    return new_string;\n}\n", "    if (string === \"\"){\n        return \"\"\
    \n    }\n    let longestPalindromicPostfix, shortestPalindromicPrefix, longestPalindromicSuffix\n\
    \    if (string.length < 2){\n        longestPalindromicPostfix = string\n   \
    \     shortestPalindromicPrefix = string\n        longestPalindromicSuffix = string\n\
    \    } else {\n        longestPalindromicPostfix = string.substring(string.length\
    \ / 2)\n        shortestPalindromicPrefix = string.substring(0, string.length\
    \ / 2)\n        longestPalindromicSuffix = longestPalindromicPostfix.substring(0,\
    \ longestPalindromicPostfix.length - longestPalindromicPrefix.length)\n    }\n\
    \    let reversedPostfixString = longestPalindromicPostfix.split(\"\").reverse().join(\"\
    \").split(\"\").reverse().join(\"\")\n    let prefixString = shortestPalindromicPrefix\
    \ + reversedPostfixString\n    return prefixString + longestPalindromicSuffix\n\
    }\n", "    //Step 1: Find longest palindrome in the string that can be built from\
    \ the shortest prefix.\n    var longest_postfix_substring = longest_palindromic_substring(string);\n\
    \    \n    //Step 2: Append the longest postfix string to the shortest prefix.\n\
    \    string += reversed_string_before_longest_postfix_substring(longest_postfix_substring);\n\
    \    \n    //Step 3: Return constructed string.\n    return string;\n}\n", " \
    \   string = string.replace(/^[\\s\\.]+/, '').trim();\n\n    var postfix = \"\"\
    ;\n    var longest = \"\";\n\n    // Find the longest postfix string which is\
    \ a palindrome.\n    for(let i = 0; i < string.length; i++){\n        var c =\
    \ string[i];\n\n        if(c != string[string.length - i - 1]){\n            if(postfix.length\
    \ < longest.length){\n                longest = postfix;\n            }\n    \
    \        postfix = c;\n        }else{\n            postfix += c;\n        }\n\
    \    }\n\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    longest = longest + reverse(string);\n\
    \n    return longest;\n}\n", "  let postfix = \"\";\n  let prefix = \"1\";\n \
    \ for(let i = 1; i < string.length; i++){\n    postfix = postfix + string[i];\n\
    \    if(postfix.endsWith(prefix)){\n      postfix = postfix.slice(0,-1);\n   \
    \   prefix = prefix + (postfix.slice(0,-1) + string[i]);\n    }\n  }\n  return\
    \ postfix;\n}\n", "  string += string.substr(0,1)\n  var start = 0, end = string.length\n\
    \  while (start < end - 1){\n    while (start < end && string.substr(start,1)\
    \ != string.substr(end,1)){\n      start++\n    }\n    if (start == end - 1)\n\
    \      return string\n    while (start < end && string.substr(end-1,1) != string.substr(start,1)){\n\
    \      end--\n    }\n    if (start == end)\n      return string\n    string +=\
    \ string.charAt(start)\n    string += string.charAt(end)\n    start += 1\n   \
    \ end--\n  }\n  return string\n}\n</cell>\n<code language=julia-1.5>\n#Run this\
    \ cell to reload the function definition and restart the kernel.\n@time make_palindrome(\"\
    \")\n@time make_palindrome(\"cat\")\n</cell>\n<code language=julia-1.5>\n# ##\
    \ Exercise 2: Palindrome\n# Write a function that takes a string and returns a\
    \ boolean, whether the input is a palindrome.\n# >>> is_palindrome(\"racecar\"\
    )\n# true\n# >>> is_palindrome(\"racecars\")\n# false", "    //Find longest postfix\
    \ that can be made from palindrome\n    let length = find_longest(string);\n \
    \   //Make suffix of the longest postfix palindrome that begins with its prefix\n\
    \    let suffix = string.slice(0, length).reverse() + string.slice(length);\n\
    \    //Return appended string\n    return string;\n}\n", "    if (string === undefined\
    \ || string === null || string === \"\"){\n        return \"\";\n    }\n    var\
    \ palindrome = \"\";\n    var max_length_postfix = 0;\n    var max_length_prefix\
    \ = 1;\n    var max_index = 0;\n    for (var index = 0; index < string.length;\
    \ index++){\n        var character = string[index];\n        max_length_postfix\
    \ += 1;\n        if (max_length_postfix > max_length_prefix){\n            max_length_prefix\
    \ = max_length_postfix;\n        }\n        palindrome += character;\n       \
    \ if (max_length_postfix > max_length_prefix){\n            max_length_postfix\
    \ = max_length_prefix;\n        }\n    }\n    if (max_length_postfix <= max_length_prefix){\n\
    \        return string;\n    }\n    for (var index = max_index; index >= 0; index--){\n\
    \        var character = string[index];\n        palindrome += character;\n  \
    \  }\n    return palindrome;\n}", "    if(string.length === 0)\n        return\
    \ \"\"\n    let postfix = getPostfix(string)\n    let prefix = getPrefix(postfix)\n\
    \    let reversed = reverse(prefix)\n    return reversed + postfix\n}\n", "  \
    \  for(let i=string.length-1;i>=0;i--){\n        let revString = \"\";\n     \
    \   for(let j=0;j<i;j++){\n            revString += string[j];\n        }\n  \
    \      string += revString;\n    }\n    return string;\n}\n", "  var l = string.length;\n\
    \  var prefix;\n  var suffix;\n\n  //If no string is supplied, or string is empty,\
    \ return an empty string\n  if (string === null || string === undefined || string\
    \ === \"\" || string.length < 2) return \"\";\n\n  prefix = string.substring(0,\
    \ l/2);\n  suffix = string.substring(l/2);\n\n  return prefix + reverseString(suffix);\n\
    }\n", "    var i, j, prefix_length, suffix_length;\n    if(!string){\n       \
    \ return \"\";\n    }\n\n    prefix_length = string.length;\n    suffix_length\
    \ = string.length/2;\n    for(i=prefix_length-1; i>=0; i--){\n        if(isPalindrome(string.substring(0,i))){\n\
    \            break;\n        }\n    }\n\n    for(i=prefix_length; i<suffix_length;\
    \ i++){\n        if(isPalindrome(string.substring(0,i))){\n            j = i+1;\n\
    \            break;\n        }\n    }\n\n    string = string.substring(0,i) +\
    \ string.substring(j);\n\n    return string;\n}\n", "    var postfix = longestPalindromicPrefix(string);\n\
    \    var middle = postfix.length + string.length;\n    var prefixReversed = prefix.slice(0,middle).reverse().slice(0,middle);\n\
    \    return prefixReversed + postfix;\n}\n", "    var stringLength;\n    var stringPrefix\
    \ = \"\";\n    var stringSuffix = \"\";\n    var longestPostfix = 0;\n    var\
    \ longestPalindrome = \"\";\n    //Find the longest postfix of the supplied string.\n\
    \    longestPostfix = find_longest_postfix_of_string(string);\n    //Find the\
    \ postfix that comes before the longest postfix. \n    stringPrefix = string.substr(0,longestPostfix);\n\
    \    stringLength = string.length;\n    //For every character in the string, find\
    \ its suffix that is a palindrome.\n    for (var i = 0; i < stringLength; i++)\n\
    \    {\n        stringSuffix = (string.substr(i,1))+stringSuffix;\n        var\
    \ reversed = stringSuffix.split(\"\").reverse().join(\"\");\n        if (stringSuffix\
    \ === reversed){\n            longestPalindrome = stringPrefix+stringSuffix;\n\
    \            longestPostfix = longestPostfix+1;\n        }\n    }\n    return\
    \ longestPalindrome;\n}\n", "    return string.replace(/(\\w*?)([a-z]+|$)/g,\n\
    \        function(str, prefix, suffix){\n            var i = suffix.length - suffix.match(/(?=(.*[a-z]){1})/)[1]\
    \ - prefix.length;\n            return prefix + suffix.substr(i, 1) + make_palindrome(suffix.substr(0,\
    \ i) + suffix.substr(i + 1));\n        }\n    );\n}\n", "    var prefix = string.substr(0,string.length/2);\n\
    \    var suffix = string.substr(string.length/2, string.length);\n    return prefix\
    \ + reverseString(prefix) + suffix;\n}\n", "  if (string == null || string.length\
    \ < 2){\n    return string\n  }\n  var rev_string = \"\"\n  var start_char = string.length\n\
    \  var end_char = start_char\n  while (start_char > 0) {\n    rev_string += string.charAt(start_char--)\n\
    \  }\n  var rev_string = rev_string\n  rev_string += string\n  var start_char\
    \ = start_char\n  var end_char = end_char\n  while (end_char < string.length)\
    \ {\n    rev_string += string.charAt(end_char++)\n  }\n  rev_string += string\n\
    \  return rev_string\n}\n\nvar reverse = function(s) {\n  var chars = s.split('').reverse().join('')\n\
    \  return chars\n}\n", "    string = string.toLowerCase().replace(/\\s+/g,\"\"\
    );\n    \n    // First reverse the string\n    var rev_string = reverse(string);\n\
    \    \n    // Then check it for palindromic suffix and append if found\n    var\
    \ palindrome_string = string;\n    var postfix_idx = rev_string.indexOf(string);\n\
    \    while(postfix_idx >= 0){\n        if(postfix_idx % 2 != 0){\n           \
    \ palindrome_string += rev_string.substr(0, postfix_idx);\n        }\n       \
    \ rev_string = rev_string.substr(0, postfix_idx);\n        postfix_idx = rev_string.indexOf(string);\n\
    \    }\n    palindrome_string += rev_string;\n    \n    return palindrome_string;\n\
    }\n", "    let longestPalindrome = getLongestPalindrome(string);\n    let start\
    \ = string.indexOf(longestPalindrome);\n    let end = longestPalindrome.length\
    \ - 1;\n    let reversedString = string[start : end + 1];\n    return string +\
    \ reversedString;\n}\n", "    //Create palindrome string\n    var post_string\
    \ = string.replace(/[^a-z]+/g,\"\").replace(/[a-z]+/g,\"\").toLowerCase();\n \
    \   var pre_string = \"\";\n    \n    //Find longest postfix palindromic suffix\
    \ and append it to pre-string.\n    for(let x = post_string.length-1;x>=0;x--){\n\
    \        var current_char = post_string[x];\n        var is_postfix = true;\n\
    \        \n        //If current character is a letter.\n        if(current_char>='a'\
    \ && current_char<='z'){\n            //If current character is at the end of\
    \ the supplied string.\n            if(x===0){\n                pre_string +=\
    \ current_char;\n                is_postfix = false;\n            }else{\n   \
    \             //If current character is not at the end of the supplied string.\n\
    \                if(x===post_string.length-1){\n                    pre_string\
    \ += current_char;\n                    is_postfix = false;\n                }else{\n\
    \                    //If current character is at the middle of the supplied string.\n\
    \                    if(post_string[x]===post_string[x-1]){\n                \
    \        pre_string += current_char;\n                        is_postfix = false;\n\
    \                    }\n                }\n            }\n        }else{\n   \
    \         //If current character is not a letter.\n            pre_string += current_char;\n\
    \            is_postfix = false;\n        }\n        \n        //If current character\
    \ is not a letter.\n        if(is_postfix){\n            //If current character\
    \ is at the end of the supplied string.\n            if(x===0){\n            \
    \    pre_string += current_char;\n            }else{\n                //If current\
    \ character is not at the end of the supplied string.\n                if(x===post_string.length-1){\n\
    \                    pre_string += current_char;\n                }else{\n   \
    \                 //If current character is at the middle of the supplied string.\n\
    \                    if(post_string[x]===post_string[x-1]){\n                \
    \        pre_string += current_char;\n                    }\n                }\n\
    \            }\n        }\n    }\n    \n    //Return new string.\n    return pre_string\
    \ + post_string.replace(/[^a-zA-Z0-9]+/g,\"\").replace(/[a-zA-Z0-9]+/g,\"\");\n\
    }", "    //console.log(\"make palindrome\", string)\n    //console.log(\"length\
    \ of string\", string.length)\n    if(string.length == 0){\n        return string\n\
    \    }\n\n    //Find the longest postfix that is palindrome.\n    var postfix\
    \ = \"\"\n    var longestPostfix = 0\n    for(var i = string.length-1; i >= 0;\
    \ i--){\n        //console.log(\"loop for\", string, i)\n        if(string[i]\
    \ == string[string.length-1]){\n            postfix += string[i]\n           \
    \ longestPostfix = i\n        } else {\n            break\n        }\n    }\n\n\
    \    //Find prefix before palindrome suffix\n    var prefix = string.substring(0,\
    \ longestPostfix)\n    var reverse = reverse(prefix)\n\n    return prefix + reverse\n\
    }\n", "    //base case: string is a palindrome return string\n    if(string ==\
    \ \"\") return string;\n    //find the longest palindrome in the string from the\
    \ beginning\n    var longestPalindrome = findLongestPalindrome(string);\n    //append\
    \ the reverse of the string preceding the longest palindrome\n    return string\
    \ + reversePostfixOfLongestPalindrome(longestPalindrome);\n}", "\t\n\tvar startIndex\
    \ = string.lastIndexOf('') + 1;\n\tstring = string.replace(/[^a-zA-Z ]/g, \"\"\
    );\n\tvar endIndex = string.length-1;\n\t\n\tvar longestPalindromicSuffix = string.substr(startIndex,endIndex);\n\
    \tlongestPalindromicSuffix = longestPalindromicSuffix.replace(/ /g, \"\");\n\t\
    var longestPalindromicSuffix = longestPalindromicSuffix.toLowerCase();\n\t\n\t\
    var palindromicSuffix = \"\";\n\t\n\tfor(var i = 0; i < longestPalindromicSuffix.length;i++){\n\
    \t\tpalindromicSuffix += string[longestPalindromicSuffix.length-i-1];\n\t}\n\t\
    \n\tvar palindromicString = \"\";\n\t\n\tvar postFixEndIndex = string.length-1;\n\
    \t\n\tfor(var i = 0; i < string.length;i++){\n\t\tvar currentChar = string[i];\n\
    \t\t\n\t\tif(i + postFixEndIndex == string.length-1){\n\t\t\tpalindromicString\
    \ += currentChar;\n\t\t}else{\n\t\t\tpalindromicString += currentChar + palindromicSuffix;\n\
    \t\t}\n\t}\n\t\n\treturn palindromicString;\n}\n\n", "  // find the longest palindrome\n\
    \  let longestPalindrome = findLongestPalindrome(string);\n  \n  // now reverse\
    \ the postfix of this palindrome\n  let reversedPostfix = reversePostfix(longestPalindrome);\n\
    \  \n  // Now add the reverse of string prefix that comes before \n  // the reverse\
    \ of the palindromic suffix\n  string += reversedPostfix;\n  \n  return string;\n\
    }\n", "    \n    if (string === '') {\n        return '';\n    }\n\n    let max_len\
    \ = string.length - 1;\n    let max_len = string.length - 1;\n    \n    \n   \
    \ for (let i = 0; i < string.length; i++) {\n        \n        if (string[i] ===\
    \ string[max_len]) {\n            \n            \n            max_len = i;\n \
    \           \n            \n        }\n    }\n    \n    \n    return string +\
    \ string.slice(max_len);\n    \n}\n", "  let reverse = string.reverse();\n  let\
    \ longestPalSuffix = \"\";\n  let longestPalSuffix_length = string.length;\n\n\
    \  // Find longest postfix that is palindrome.\n  for(let i = string.length -\
    \ 1; i >= 0; i--){\n    let p = string.length - (i + 1);\n    let palindrome =\
    \ string.slice(0, p) + reverse + string.slice(p);\n    if (palindrome == string){\n\
    \      longestPalSuffix = palindrome;\n      longestPalSuffix_length = p;\n  \
    \  }\n  }\n\n  return string.slice(0, longestPalSuffix_length) + longestPalSuffix;\n\
    }\n", "  var palindrome = \"\";\n  var prefix = \"\";\n  var suffix = \"\";\n\
    \  \n  for(var i = 0; i < string.length; i++){\n    prefix += string[i]\n  }\n\
    \  \n  for(var j = 0; j < string.length; j++){\n    suffix += string[j]\n  }\n\
    \  \n  var reversed_prefix = reverse(prefix);\n  \n  if(reversed_prefix === \"\
    \"){\n    prefix = \"\";\n  }else{\n    prefix = reversed_prefix +  prefix;\n\
    \  }\n  \n  if(suffix === prefix){\n    palindrome = prefix + suffix;\n  }else{\n\
    \    while(suffix.length > 0){\n      reversed_suffix = reverse(suffix);\n   \
    \   if(reversed_suffix === \"\"){\n        suffix = \"\";\n      }else{\n    \
    \    suffix = reversed_suffix +  suffix;\n      }\n      \n      if(suffix ===\
    \ prefix){\n        palindrome = prefix + suffix;\n        break;\n      }\n \
    \   }\n  }\n  \n  return palindrome;\n}\n", "  let re = new RegExp(`^${string}`,\
    \ \"g\")\n  let match = string.match(re)\n  let postfix = string.slice(string.length\
    \ - match[0].length, string.length)\n  let reverse_suffix = postfix.split(\"\"\
    ).reverse().join(\"\")\n  string = string.replace(match[0], `${string}` + reverse_suffix)\n\
    \  return string\n}\n", "    let palindrome_suffix=\"\";\n    let reversed_string=\"\
    \";\n    for(let i = 0; i<string.length;i++){\n        if(isPalindrome(string.slice(i,i+1)))\
    \ palindrome_suffix=palindrome_suffix.concat(string.slice(i,i+1));\n        else\
    \ reversed_string=reversed_string.concat(string.slice(i,i+1));\n    }\n    return\
    \ reversed_string+palindrome_suffix;\n}", "    string += string.reverse();\n \
    \   var i = string.length - 1;\n    var longest = null;\n    while (string[i]\
    \ !== string[string.length - 1 - i]) {\n        i--;\n        if (i > 0 && string[i]\
    \ === string[string.length - 1 - i]) {\n            break;\n        }\n    }\n\
    \    longest = string.length - (string.length - i) + 1;\n    var start = i - longest;\n\
    \    var end = i + longest;\n    return string.slice(0, start) + string.reverse().slice(start,\
    \ end);\n}", "  // If the string is a palindrome, the return string is the same\
    \ string.\n  if(is_palindrome(string)) { return string; }\n  // Start from the\
    \ end, find the longest postfix that is a palindrome.\n  string = $.trim(string);\n\
    \  string = string.replace(/^\\s+|\\s+$/g, \"\");\n  for(var i = 0; i < string.length;\
    \ i++) {\n    var p = string;\n    while(p && p.length > 0) {\n      p = p + string.reverse();\n\
    \    }\n    string = string.substr(0, i) + p;\n  }\n  return string;\n}\n", "\t\
    var rev_string, prefix, suffix;\n\trev_string = string.replace(/^(.+?)(.)$/,\"\
    $2$1\");\n\tprefix = string.match(/^(.{0,})(.+)$/)[1];\n\tsuffix = string.match(/^(.{0,})(.*[^\\\
    s])$/)[2];\n\treturn prefix + rev_string + suffix;\n}\n", "    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longest_palindromic_index\
    \ = 0;\n    var longest_palindromic_char = \"\";\n    var palindromic_suffix_length\
    \ = 0;\n    var longest_palindromic = \"\";\n    for (var i = 0, str_length =\
    \ string.length; i < str_length; i++){\n        palindromic_suffix_length = Math.max(palindromic_suffix_length,\
    \ palindromic_suffix_length + string.charAt(i).match(/[aeiou]/).length);\n   \
    \     longest_palindromic_index++;\n        if (longest_palindromic_index == longest_palindromic_char.length){\n\
    \            longest_palindromic_char += string.charAt(i);\n        }\n      \
    \  else{\n            longest_palindromic_char = string.charAt(i);\n        }\n\
    \        if (longest_palindromic_index == palindromic_suffix_length){\n      \
    \      longest_palindromic += longest_palindromic_char;\n            longest_palindromic_index\
    \ = 0;\n            palindromic_suffix_length = 0;\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    longest_palindromic += string.slice(longest_palindromic_index)\
    \ + string.reverse(longest_palindromic_char.slice(0, longest_palindromic_char.length));\n\
    \    return longest_palindromic;\n}", "    if (string === null || string === undefined)\
    \ {\n        throw TypeError(\"Invalid input!\");\n    }\n    \n    if (string.length\
    \ <= 1) {\n        return string;\n    }\n    \n    let max_prefix = string.replace(/./g,\
    \ (char) => {\n        if (char === \".\"){\n            return \"\";\n      \
    \  }\n        return char;\n    }).split('');\n    \n    let min_suffix = max_prefix.reverse().join('');\n\
    \    let max_suffix = string.replace(/./g, (char) => {\n        if (char === \"\
    .\"){\n            return \"\";\n        }\n        return char;\n    }).split('');\n\
    \    \n    let prefix_len = min_suffix.length;\n    let suffix_len = max_suffix.length;\n\
    \    \n    let prefix_end = min_suffix.length - 1;\n    let suffix_start = min_suffix.length\
    \ - 1;\n    \n    while (prefix_end >= 0 && suffix_start >= 0) {\n        if (max_suffix[suffix_start]\
    \ === max_prefix[prefix_end]){\n            suffix_start--;\n        } else if\
    \ (max_suffix[suffix_start] < max_prefix[prefix_end]){\n            suffix_end--;\n\
    \        } else {\n            prefix_end--;\n            suffix_start--;\n  \
    \      }\n    }\n    \n    let palindrome = string.substring(0, prefix_len) +\
    \ max_suffix[suffix_start] + string.substring(prefix_end);\n    \n    if (string.length\
    \ > palindrome.length){\n        palindrome = make_palindrome(palindrome);\n \
    \   }\n    \n    return palindrome;\n}\n", "\tvar i, palindrome, len = string.length;\n\
    \t// Start with an empty string, then append the longest postfix that is a palindrome.\n\
    \tpalindrome = \"\";\n\tfor (i = 0; i < len; i++){\n\t\t// Find the longest postfix\
    \ of string that is a palindrome\n\t\tif (is_palindrome(string[i])){\n\t\t\tpalindrome\
    \ += string[i];\n\t\t}\n\t\t// Find a postfix of string that is not a palindrome\n\
    \t\telse{\n\t\t\tif (string[i - 1] !== string[i]){\n\t\t\t\tpalindrome += string[i];\n\
    \t\t\t}\n\t\t}\n\t}\n\t// Append to the end of string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n\tpalindrome += string[len - i -\
    \ 1] + string[len - i - 1];\n\treturn palindrome;\n}\n", "    var index = findLongestPalindromeInPrefix(string);\n\
    \    \n    if(index == string.length - 1){\n        return string;\n    }\n  \
    \  \n    //Add the reverse of the string before the palindromic suffix.\n    var\
    \ result = string.slice(0, index) + stringReverse(string,index,string.length -\
    \ 1);\n    \n    //Add the palindromic suffix to the end of the string.\n    result\
    \ += string.slice(index,string.length);\n    \n    return result;\n}\n", "  if\
    \ (string === \"\") {\n    return \"\";\n  }\n  let palindrome = \"\";\n  let\
    \ reversed = \"\";\n  let max = 0;\n  let index = 0;\n  let end = string.length\
    \ - 1;\n\n  while (end >= 0) {\n    if (string[index] !== string[end]) {\n   \
    \   break;\n    }\n    index++;\n    end--;\n  }\n\n  while (end >= 0) {\n   \
    \ max = Math.max(max, end - index);\n    if (reverse === \"\") {\n      reverse\
    \ = string[index];\n    }\n    reversed = reversed + reverse;\n    index++;\n\
    \    end--;\n  }\n\n  while (index >= 0) {\n    if (string[index] === reversed)\
    \ {\n      palindrome = palindrome + string[index];\n      index--;\n    }\n \
    \   index--;\n  }\n\n  return palindrome;\n}\n", "    if (string == undefined\
    \ || string == \"\" || string.length <= 1) {\n        return string;\n    }\n\
    \    var reverse_str = \"\";\n    var min_len = string.length-1;\n    var max_len\
    \ = 0;\n    for(var i = 0;i<string.length;i++){\n        if(string[i] != string[string.length-1]){\n\
    \            min_len = i;\n        }\n        max_len = i;\n    }\n    for(var\
    \ i = string.length-2;i>-1;i--){\n        var cur_str = string.substr(i,i+1);\n\
    \        reverse_str = reverse_str.substr(0,reverse_str.length-1)+cur_str;\n \
    \   }\n    return string.substr(0,max_len+1) + reverse_str;\n}\n", "  var new_string\
    \ = \"\";\n  if(string == \"\"){\n    return \"\";\n  }\n  var last_string = \"\
    \";\n  for(var i = 0; i < string.length; i++){\n    var letter = string.charAt(i);\n\
    \    if(last_string == letter){\n      new_string += letter;\n    }\n    else{\n\
    \      last_string = letter;\n      new_string += letter.split(\"\").reverse().join(\"\
    \");\n    }\n  }\n  return new_string;\n}\n", "    if(!string){\n        return\
    \ \"\";\n    }\n    let prefix_len = string.length;\n    let suffix_len = string.length;\n\
    \    for(let i=0; i<suffix_len/2; i++){\n        let start = Math.max(0, suffix_len\
    \ - 1 - i);\n        let end = suffix_len - 1 - i;\n        if(string.charAt(start)\
    \ === string.charAt(end)){\n            prefix_len = start;\n            suffix_len\
    \ = end;\n        }\n    }\n    return string.substr(0, prefix_len) + string.reverse().substr(0,\
    \ suffix_len);\n}\n", "   var regex = /^(\\S+)([^\\s]+)?(\\S+)?$/;\n   var match\
    \ = regex.exec(string);\n   var prefix = match[1];\n   var postfix = match[2];\n\
    \   var suffix = match[3];\n\n   if (suffix === undefined) {\n      suffix = '';\n\
    \   }\n\n   var palindrome_suffix;\n   var reversed_prefix;\n\n   if (prefix ===\
    \ undefined) {\n      palindrome_suffix = '';\n      reversed_prefix = postfix;\n\
    \   } else {\n      var reversed_string = prefix + reversed_prefix_reverse(postfix);\n\
    \      var palindrome_start = reversed_string.substr(0, 1);\n      var palindrome_end\
    \ = reversed_string.substr(-1);\n      palindrome_suffix = reversed_string.substr(1,\
    \ reversed_string.length-1);\n      reversed_prefix = reversed_string.substr(0,\
    \ 1) + palindrome_start + palindrome_end;\n   }\n\n   return prefix + palindrome_suffix\
    \ + postfix;\n}\n", "    var prefix = \"\";\n    var palindrome = \"\";\n    var\
    \ suffix = \"\";\n    while(prefix.length < string.length){\n        suffix =\
    \ string.slice(string.length - prefix.length, string.length);\n        prefix\
    \ = prefix + suffix;\n        palindrome = palindrome + prefix + suffix;\n   \
    \     string = string.slice(string.length - suffix.length, string.length);\n \
    \   }\n    return palindrome;\n}\n", "  return [string].concat(findPrefix(string,\
    \ string).map(function(str){\n    return str+string+str;\n  })).slice(string.length-findSuffix(string).length);\n\
    }\n", "  let start = string.indexOf(\"a\") //Find index of first character of\
    \ a palindrome\n  let end = string.indexOf(\"z\") //Find index of last character\
    \ of a palindrome\n  let palindrome = string\n  let startString = \"\"\n  let\
    \ endString = \"\"\n  let reversed = \"\"\n  for(let i = start; i <= end; i++){\n\
    \    start += 1\n    end -= 1\n    startString += string.charAt(start)\n    endString\
    \ += string.charAt(end)\n    reversed = endString + startString\n  }\n  return\
    \ palindrome + reversed\n}\n", "  return string +\n    reverse_suffix(\n     \
    \ reverse_prefix(\n        string.match(/\\S+/g).reverse().join(\"\"),\n     \
    \   string.match(/\\S+/g)\n      ).join(\"\")\n    ).join(\"\");\n}", "    //\
    \ Return nothing, or an error.\n    if (string == \"\") return null;\n    // Do\
    \ nothing, if the string is already a palindrome.\n    if (is_palindrome(string))\
    \ return string;\n    // Find the longest postfix of supplied string that is a\
    \ palindrome.\n    var longest_postfix = postfix_of_palindrome(string);\n    //\
    \ If no such postfix exists, return nothing.\n    if (longest_postfix == null)\
    \ return null;\n    // Build a string that has a reversed prefix and suffix.\n\
    \    var reversed_prefix = reversed_prefix_of_palindrome(string, longest_postfix);\n\
    \    var reversed_suffix = reversed_suffix_of_palindrome(string, longest_postfix);\n\
    \    // Return the result.\n    return reversed_prefix + longest_postfix + reversed_suffix;\n\
    }\n", "  // If the string is empty, return the empty string.\n  if (string.length\
    \ == 0){\n    return string\n  }\n  // Find the longest palindrome that can be\
    \ constructed from the first characters of the string.\n  var longest_postfix\
    \ = reverse(string);\n  // Now try to find all strings in postfix form, and reverse\
    \ the string suffix that comes before it.\n  var reversed_suffixes = [];\n  for\
    \ (var i = 0; i < (longest_postfix/2); i++){\n    var postfix = string.substr(0,\
    \ i) + string.substr(i);\n    var reversed_suffix = reverse(postfix);\n    var\
    \ appended = reversed_suffix + postfix.substr(0, i) + postfix.substr(i);\n   \
    \ reversed_suffixes.push(appended);\n  }\n  // Return the first postfix string\
    \ that is palindromic.\n  return reversed_suffixes.find(function(string){\n  \
    \  return string == reverse(string);\n  });\n}\n", "  if(string == null || string.length\
    \ <= 1) return string\n  let [first, last] = string.split(\" \")\n  let postfix\
    \ = first.substr(-last.length)\n  let [suffix] = string.split(postfix, 1)\n  return\
    \ first+suffix+postfix\n}\n", "    string=string.replace(\" \",\"\");//Remove\
    \ whitespace\n    string=string.toLowerCase();//Make everything lower case\n \
    \   var string_palindrome=\"\";//Create a empty string to append the palindrome\n\
    \    var palindrome=\"\";//Create a empty string to append the palindrome\n  \
    \  var length=string.length;//Find the length of the string\n    var first_letter=string[0];//Find\
    \ first letter\n    //console.log(\"first_letter\",first_letter)\n    var string_length=string.length;//Find\
    \ the length of the string\n    //console.log(\"string_length\",string_length)\n\
    \    for(i=0;i<string_length;i++){//Look for palindromes in the string\n     \
    \   if(first_letter==string[string_length-i-1]){\n            palindrome+=string[i];\n\
    \        }\n    }//Look for palindromes in the string\n    string_palindrome+=first_letter;//Append\
    \ the first letter to the palindrome\n    for(i=0;i<palindrome.length;i++){//Look\
    \ for palindromes in the string\n        string_palindrome+=palindrome.substring(i,palindrome.length);//Append\
    \ the palindrome to the palindrome string\n    }//Look for palindromes in the\
    \ string\n    return string_palindrome;//Return the palindrome string\n}\n", " \
    \ var longest = find_longest(string);\n  longest = longest + \"\\u202A\";\n  longest\
    \ = longest.slice(0, -4);\n  \n  var rev_prefix_prefix_end = \"\\u202C\" + string.slice(0,longest.length);\n\
    \  var rev_prefix_suffix_end = rev_prefix_prefix_end + string.slice(longest.length);\n\
    \  \n  var rev_prefix_prefix_end = rev_prefix_prefix_end.slice(0, -1);\n  var\
    \ rev_prefix_suffix_end = rev_prefix_suffix_end.slice(0, -1);\n  \n  var reversed_str\
    \ = rev_prefix_prefix_end + rev_prefix_suffix_end;\n  \n  return string + reversed_str;\n\
    }", "    \n    var palindrome = \"\",\n        prefix     = \"\";\n        \n\
    \    for(var i = string.length; i >= 0; i--){\n        \n        prefix = prefix\
    \ + string.charAt(i);\n        \n        if(is_palindrome(prefix)){\n        \
    \    palindrome = palindrome + prefix + string.slice(i).reverse();\n         \
    \   break;\n        }\n    }\n    \n    return palindrome;\n}\n", "    // Find\
    \ the longest postfix that is a palindrome.\n    var postfix = string;\n    var\
    \ palindrome = \"\";\n    var l = 0;\n    while(postfix[l] != \"!\"){\n      \
    \  postfix[l+1] = postfix[l];\n        l++;\n    }\n    postfix[l+1] = \"!\";\n\
    \    var n = postfix.length;\n    var m = 0;\n    var s = \"\";\n    while(m <\
    \ n){\n        s += postfix[m] + postfix[m+1];\n        m++;\n    }\n    for(var\
    \ k = m - 1; k >= 0; k--){\n        if(k >= n - m){\n            palindrome =\
    \ s + palindrome;\n        }else{\n            palindrome = s + postfix[k];\n\
    \        }\n    }\n    palindrome = palindrome.reverse();\n    palindrome = s\
    \ + palindrome;\n    return palindrome;\n}\n", "    var length = string.length;\n\
    \    var longest = 0;\n    var prefix = '';\n    for(var i = 0; i < length - 1;\
    \ i++){\n        prefix = prefix + string.charAt(i);\n        longest = Math.max(longest,\
    \ prefix_length(prefix, string));\n    }\n    var longest = longest + 1;\n   \
    \ var suffix = '';\n    var suffixLength = 0;\n    for(i = length; i > 0; i--){\n\
    \        suffix = string.charAt(i) + suffix;\n        suffixLength = Math.min(suffix_length(suffix,\
    \ string), longest - suffix_length(suffix, string));\n    }\n    suffix = string.charAt(0)\
    \ - suffix;\n    suffixLength += 1;\n    return prefix + suffix;\n}\n", "    var\
    \ string_palindrome = string\n    \n    for(\n    var prefix_len = string.length\n\
    \    ; string.length >= prefix_len\n    ; prefix_len++\n    ){\n        var prefix_reverse_string\
    \ = ''\n        for( var i = prefix_len-1 ; i >= 0 ; i-- ){\n            prefix_reverse_string\
    \ += string.charAt(i)\n        }\n        var postfix_len = string.length-prefix_len\n\
    \        if( string_palindrome === prefix_reverse_string ){\n            string_palindrome\
    \ += postfix_len\n        }\n    }\n    return string_palindrome\n}\n", "    let\
    \ prefix;\n    if(!string){\n        return \"\";\n    }else{\n        let postfix\
    \ = string.split(\"\").reverse().join(\"\");\n        prefix = string.substr(0,prefix.length/2+1);\n\
    \    }\n\n    let palindrome = prefix;\n    let count = 1;\n    while(count<postfix.length/2){\n\
    \        if(postfix[count]!=postfix[count+1])\n            break;\n        palindrome\
    \ += postfix[count];\n        count++;\n    }\n    return palindrome;\n}", " \
    \   if(string.length == 0){\n        return \"\";\n    }\n    //Find the longest\
    \ palindrome that begins with a supplied string.\n    let longest = \"\";\n  \
    \  for(let i = 0; i < string.length; i++){\n        let j = i;\n        //Find\
    \ the palindrome suffix that begins at the supplied character.\n        while(j\
    \ > 0 && string[j] != string[j-1])\n            j--;\n        let prefix_str =\
    \ string.substr(0, j);\n        //Find the palindrome suffix that starts at the\
    \ middle of the supplied string.\n        let suffix_str = \"\";\n        for(let\
    \ k = j + 1; k < string.length; k++){\n            suffix_str = suffix_str + string[k];\n\
    \        }\n        //Find the reverse of the palindrome suffix that starts at\
    \ the middle of the supplied string.\n        let reverse_str = suffix_str + prefix_str\
    \ + string[j];\n        let reverse_str = reverse_str.split(\"\").reverse().join(\"\
    \");\n        //Find the longest postfix that is a palindrome.\n        if(reverse_str.length\
    \ >= longest.length){\n            longest = reverse_str;\n        }\n    }\n\
    \    return longest;\n}\n", "    string = string.toString();\n    \n    if(string\
    \ === \"\" || string === \" \"){\n        return \"\";\n    }\n    \n    string\
    \ = (string + \"x\").replace(/([a-z]+)/gi, function (s) {\n        return s.toLowerCase();\n\
    \    });\n    \n    // find the longest postfix that is palindrome and use it\
    \ to find the next palindrome\n    var palindrome = findLongestPalindrome(string);\n\
    \    \n    // build the string backwards from longest postfix to first char\n\
    \    var palindrome_chars = palindrome.substr(0, palindrome.length-1); // the\
    \ characters before the palindrome suffix\n    \n    // build the string backwards\
    \ from first char to longest postfix\n    string += palindrome_chars.substr(0,\
    \ palindrome_chars.length-1); // the characters before the palindrome prefix\n\
    \    \n    // return the completed string\n    return string;\n}\n", "  let maxLen\
    \ = find_longest_postfix(string).length - 1;\n  let prefix = string.slice(0, maxLen);\n\
    \  let suffix = string.slice(maxLen + 1);\n  return prefix + (string.reverse().slice(find_longest_prefix(prefix,\
    \ suffix).length - 1)) + suffix;\n}\n", "    var postfix = string + \" \";\n \
    \   var reverse_postfix = \"\";\n    var max_palindrome = \"\"\n    while ( postfix.length\
    \ ) {\n        var postfix_palindrome = suffix_to_palindrome( postfix.substring(0,\
    \ postfix.length-1) );\n        if (postfix_palindrome > max_palindrome){\n  \
    \          max_palindrome = postfix_palindrome;\n        }\n        postfix =\
    \ postfix.substring(0,postfix.length-1);\n        reverse_postfix += postfix_palindrome;\n\
    \    }\n    return reverse_postfix;\n}\n", "  var s = string\n    , r = \"\";\n\
    \  for (var i = 0; i < s.length; i++){\n    if (s[i] === \" \"){\n      r = r.concat(s.slice(i,\
    \ s.length));\n      i = s.length;\n    }\n    else{\n      var palindrome = check_for_palindrome(s.slice(0,\
    \ i+1));\n      if (palindrome){\n        r = r.concat(s.slice(0, i+1));\n   \
    \     r = r.concat(palindrome);\n        i = s.length-palindrome.length;\n   \
    \   }\n    }\n  }\n  return r;\n}", "    var reverse = string\n    var longestPrefix\
    \ = 0\n    for (var i = string.length - 2; i >= 0; i--){\n        if (string[i]\
    \ !== string[i + 1])\n        {\n            longestPrefix = i\n            break;\n\
    \        }\n    }\n    if (longestPrefix > 0)\n    {\n        var postfix = string.substr(longestPrefix\
    \ + 1, string.length - longestPrefix - 1)\n        reverse = reverse + postfix.split(\"\
    \").reverse().join(\"\")\n    }\n    return reverse\n}", "    console.log(\"Entering\
    \ make_palindrome()\");\n    let max_length = 0;\n    for(let i = 0; i < string.length;\
    \ i++){\n        if(string.charAt(i) != string.charAt(string.length - 1 - i)){\n\
    \            max_length++;\n        }\n    }\n    console.log(\"max length = \"\
    \ + max_length);\n    string += string.reverse();\n    console.log(string);\n\
    \    return string;\n}\n", "  let reverse_palindrome = '';\n  let start_index\
    \ = -1;\n  let end_index = -1;\n  let palindrome = '';\n  for(const c of string){\n\
    \    if(c !== string[string.length - 1 - c]){\n      start_index = end_index +\
    \ 1;\n    }\n    reverse_palindrome += string[start_index] + c;\n    end_index++;\n\
    \  }\n  for(const c of reverse_palindrome){\n    palindrome += c;\n  }\n  return\
    \ palindrome;\n}\n", "\tif(string === \"\" || string === undefined){\n\t\treturn\
    \ \"\";\n\t}\n\n\tvar suffixes = [];\n\n\tfor(var i = 0; i < string.length; i++){\n\
    \t\tif(string[i] === \"/\"){\n\t\t\tvar next_char = string.substr(i + 1, 1);\n\
    \n\t\t\tif(next_char === \"/\" || next_char === \"\\\\\"){\n\t\t\t\tsuffixes.push(\"\
    \\\\\\\\\");\n\t\t\t}else{\n\t\t\t\tsuffixes.push(next_char);\n\t\t\t}\n\n\t\t\
    \ti += 1;\n\t\t}else{\n\t\t\tsuffixes.push(string[i]);\n\t\t}\n\t}\n\n\tvar longest\
    \ = 0;\n\tvar longest_postfix = \"\";\n\n\tfor(var i = 0; i < suffixes.length;\
    \ i++){\n\t\tvar postfix = \"\";\n\t\tvar postfix_char = \"\";\n\t\tvar postfix_char_length\
    \ = string.length - i;\n\t\tvar suffixes_i = suffixes.slice(i, i + 1);\n\n\t\t\
    for(var i = 0; i < suffixes_i.length; i++){\n\t\t\tif(suffixes_i[i] === \"\\\\\
    \"){\n\t\t\t\tpostfix_char = postfix_char + suffixes_i[i];\n\t\t\t}else{\n\t\t\
    \t\tpostfix_char = postfix_char + suffixes_i[i];\n\t\t\t}\n\t\t}\n\n\t\tvar length_postfix\
    \ = string.length - i;\n\t\tpostfix = postfix + postfix_char;\n\t\tpostfix = postfix.substr(0,\
    \ postfix_char_length);\n\n\t\tif(postfix === string.substr(i, postfix_char_length)){\n\
    \t\t\tvar length_prefix = string.length - i;\n\t\t\tvar length_prefix_postfix\
    \ = string.length - i - postfix_char_length;\n\n\t\t\tif(length_prefix_postfix\
    \ > longest){\n\t\t\t\tlongest = length_prefix_postfix;\n\t\t\t\tlongest_postfix\
    \ = postfix_char + postfix.substr(0, postfix_char_length);\n\t\t\t}\n\t\t}\n\t\
    }\n\n\tif(longest_postfix === string){\n\t\treturn longest_postfix;\n\t}else{\n\
    \t\treturn string;\n\t}\n}\n", "\tvar new_string = string;\n\tvar longest_prefix\
    \ = 0;\n\tvar longest_prefix_index = 0;\n\tfor(var i = 0; i < string.length; i++){\n\
    \t\tif(string[i] == string[string.length -1-i]){\n\t\t\t//Find longest prefix\
    \ that is a palindrome.\n\t\t\tfor(var j = 0; j < longest_prefix; j++){\n\t\t\t\
    \tif(string[i + j] != string[string.length -1-i])\n\t\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t\tif(j == longest_prefix){\n\t\t\t\tlongest_prefix = j + 1;\n\t\t\t\tlongest_prefix_index\
    \ = i;\n\t\t\t}\n\t\t}\n\t}\n\tif(longest_prefix == 0)\n\t\treturn \"\";\n\t\n\
    \t//Append reversed prefix to the new string from the longest prefix.\n\tvar prefix\
    \ = string.slice(0, longest_prefix_index + longest_prefix);\n\tvar suffix = string.slice(longest_prefix_index\
    \ + longest_prefix, string.length);\n\tnew_string += prefix + reverseString(suffix);\n\
    \treturn new_string;\n}\n\n", "\tif(!string) string = \"\";\n\tlet postfix = \"\
    \";\n\tlet index = 0;\n\twhile(true){\n\t\tindex++;\n\t\tpostfix = string.substr(0,index)\
    \ + string.substr(index).reverse() + postfix;\n\t\tif(!is_palindrome(postfix))\
    \ break;\n\t}\n\treturn postfix;\n}\n", "    const len = string.length;\n    let\
    \ max_len = 0;\n    let pos = -1;\n    let reversed = '';\n    while(len > 0){\n\
    \        reversed = string.slice((pos == -1)? 0:(len-pos), len).reverse() + reversed;\n\
    \        max_len = Math.max(max_len, pos == -1? len-pos : reversed.length);\n\
    \        len--;\n        pos++;\n    }\n    return string + reversed;\n}\n", " \
    \   \n    //Base case\n    if (string == \"\"){\n        return \"\";\n    }\n\
    \    \n    //Find the longest palindrome prefix that starts with the string\n\
    \    let prefixPalindrome = longestPalindromePrefix(string);\n    \n    //Find\
    \ the longest palindrome suffix that ends with the string\n    let suffixPalindrome\
    \ = longestPalindromeSuffix(string);\n    \n    //Find the longest palindrome\
    \ common prefix and suffix that starts with the string\n    let commonPrefix =\
    \ longestCommonPrefix(string, suffixPalindrome);\n    \n    //Append the reverse\
    \ of the prefix to the end of the suffix\n    suffixPalindrome = suffixPalindrome.concat(make_palindrome(commonPrefix));\n\
    \    \n    //Append the reverse of the suffix to the beginning of the prefix\n\
    \    prefixPalindrome = prefixPalindrome.concat(make_palindrome(suffixPalindrome));\n\
    \    \n    //Append the reverse of the common prefix to the end of the suffix\n\
    \    suffixPalindrome = suffixPalindrome.concat(make_palindrome(commonPrefix));\n\
    \    \n    //Append the reverse of the suffix to the beginning of the prefix\n\
    \    prefixPalindrome = prefixPalindrome.concat(make_palindrome(suffixPalindrome));\n\
    \    \n    //Return the concatenation of the prefixPalindrome and the suffixPalindrome\n\
    \    return prefixPalindrome.concat(suffixPalindrome);\n}\n", "  if (string ==\
    \ null || string === \"\") return string;\n  \n  var palindrome = string;\n  var\
    \ suffixes = \"\";\n  var suffixes_index = 0;\n  \n  //Find longest palindrome\n\
    \  var longest_palindrome = longest_palindrome_length(string, longest_palindrome_length_memo,\
    \ suffixes_index);\n  \n  //Find longest postfix of longest palindrome\n  var\
    \ longest_postfix_of_longest_palindrome = longest_palindrome_postfix(longest_palindrome,\
    \ longest_palindrome_length_memo, suffixes_index, palindrome);\n  \n  //Append\
    \ reverse of the longest postfix of longest palindrome\n  palindrome += string.reverse(longest_postfix_of_longest_palindrome);\n\
    \  \n  //Insert longest postfix to suffix of longest palindrome\n  suffixes +=\
    \ longest_postfix_of_longest_palindrome;\n  \n  return palindrome + suffixes;\n\
    }\n", "    if (string === \"\") return \"\"\n\n    var postfix = string\n    var\
    \ reversed_postfix = reverse(postfix)\n\n    var palindrome = \"\"\n    var possible_prefixes\
    \ = []\n    for (var i = 0, len = postfix.length; i < len; i++) {\n        var\
    \ letter = string.charAt(i)\n        if (letter === letter.toLowerCase()) {\n\
    \            if (letter === letter.toUpperCase()) {\n                letter =\
    \ letter.toLowerCase()\n            }\n            palindrome += letter\n    \
    \    }\n        else {\n            possible_prefixes.push(letter)\n        }\n\
    \    }\n\n    possible_prefixes.push(postfix)\n    possible_prefixes.push(reversed_postfix)\n\
    \n    for (var j = 0, len2 = possible_prefixes.length; j < len2; j++) {\n    \
    \    var prefix = possible_prefixes[j].slice(0)\n        if (prefix[0] !== prefix[0].toLowerCase())\
    \ {\n            possible_prefixes.splice(j, 1)\n            j--\n        }\n\
    \    }\n\n    for (var k = 0, len3 = possible_prefixes.length; k < len3; k++)\
    \ {\n        var prefix2 = possible_prefixes[k].slice(0)\n\n        var suffix2\
    \ = prefix2.slice(0, -postfix2.length)\n        var suffix3 = prefix2.slice(postfix2.length)\n\
    \n        if (prefix2 === reversed_postfix) {\n            if (suffix2.length\
    \ <= suffix3.length) {\n                prefix = prefix2.slice(0, -postfix2.length)\n\
    \                palindrome += prefix\n            }\n        }\n    }\n\n   \
    \ return palindrome\n}\n", "  if(string == null || string.length == 0){\n    return\
    \ string;\n  }\n  let start = 0;\n  let end = string.length - 1;\n  while (start\
    \ < end){\n    let middle = Math.floor((start + end) / 2);\n    if(middle == start){\n\
    \      start += 1;\n      end -= 1;\n    }\n    else if(middle == end){\n    \
    \  end -= 1;\n    }\n    else{\n      if(middle == start || middle == end){\n\
    \        middle = middle + 1;\n      }\n      let middleStr = string.substring(middle,\
    \ middle + 1);\n      if(middleStr == middleStr.reverse && middleStr.length <=\
    \ string.length){\n        string += string.substring(start, middle + 1);\n  \
    \      string = string.replace(middleStr, middleStr);\n        start += middle;\n\
    \        end += middle;\n      }\n      else{\n        start += 1;\n        end\
    \ -= 1;\n      }\n    }\n  }\n  return string;\n}", "  var palindrome = string.split(\"\
    \").reverse().join(\"\");\n  return string + palindrome;\n}\n</code>\n<|/ a tags=algorithm,performance,javascript\
    \ dscore=0 |>\n<| a dscore=0 tags=algorithm,performance,javascript |>\nHere are\
    \ some benchmarks to get an idea of how fast some simple JS implementations are:\n\
    <code>", "    var reverse = string.reverse();\n    var prefixLength = 0,\n   \
    \     suffixLength = 0,\n        suffixIndex = 0,\n        palSuffix = \"\",\n\
    \        palPrefix = \"\";\n    while(prefixLength < string.length && suffixLength\
    \ < string.length){\n        var postfix = string.substr(prefixLength, string.length\
    \ - suffixLength);\n        var palindrome = reverse.substr(0, reverse.length\
    \ - suffixLength) + postfix;\n        if (palindrome === palindrome.toLowerCase()){\n\
    \            palPrefix = prefix.substr(0, prefixLength) + postfix;\n         \
    \   palSuffix = palindrome.substr(0, palindrome.length - suffixLength);\n    \
    \        break;\n        }\n        prefixLength += 1;\n        suffixLength +=\
    \ 1;\n    }\n    var palindrome = prefixLength > suffixLength ? palPrefix + palSuffix\
    \ : string.substr(0, prefixLength) + reverse.substr(0, reverse.length - suffixLength);\n\
    \    return palindrome;\n}\n</code>\n<|/ a dscore=0 tags=python,algorithm |>\n\
    <| a |>\nI find this version more easy to read and understand:\n<code>\ndef make_palindrome(string):\n\
    \    \n    palindrome = \"\"\n    \n    if string == string[::-1]:\n        \n\
    \        if string[0] != string[len(string)-1]:\n            \n            firstChar\
    \ = string[0]\n            lastChar = string[len(string)-1]\n            \n  \
    \          palindrome = firstChar + string[len(string)-1:0:-1] + lastChar + string[0:len(string)-1]\n\
    \    \n    return palindrome\n\nstring = 'cata'\nprint(make_palindrome(string))\n\
    </code>\n<|/ a tags=python,algorithm dscore=0 |>\n<| a |>\n<code>\ndef make_palindrome(string):\n\
    \    length = (len(string) / 2) + 1\n    \n    if string[:length] == string[::-1]:\n\
    \        \n        first = string[:length]\n        \n        if len(first) !=\
    \ len(first[::-1]):\n            \n            first = first[::-1]\n         \
    \   \n        last = string[:length - 1][::-1]\n        \n        if len(last)\
    \ != len(last):\n            \n            last = last[::-1]\n            \n \
    \       return first + last\n    else:\n    \n        return string\n    \nprint(make_palindrome('cata'))\n\
    </code>\n<|/ a tags=python,algorithm dscore=0 |>\n<| c |>\nPlease don't post only\
    \ code as answer, but also provide an explanation what your code does and how\
    \ it solves the problem of the question. Answers with an explanation are usually\
    \ more helpful and of better ", "    if(string === \"\"){\n        return \"\"\
    ;\n    }\n    var longest_prefix = string.substring(0, string.length - 1);\n \
    \   var reverse_of_longest_prefix = reverseString(longest_prefix);\n    \n   \
    \ var palindrome = string;\n    \n    while(string.substr(0, string.length - 1)\
    \ === reverse_of_longest_prefix && string.length <= longest_prefix.length){\n\
    \        var index = string.lastIndexOf(longest_prefix, string.length - 1);\n\
    \        palindrome = string.substring(0, index) + reverseString(string.substr(index\
    \ + 1)) + palindrome;\n        \n        if(string.length === index + 1 && longest_prefix.length\
    \ > 0){\n            return palindrome;\n        }\n        string = string.substr(0,\
    \ index) + string.substr(index + 1);\n    }\n    \n    if(string.length > longest_prefix.length){\n\
    \        return palindrome;\n    }\n    return \"\";\n}\n", "    var startPalindrome\
    \ = find_longest_postfix_that_is_palindrome(string);\n    var endPalindrome =\
    \ startPalindrome;\n    var reverse = string.slice(startPalindrome);\n    while\
    \ (reverse != make_palindrome(string).slice(startPalindrome))\n    {\n       \
    \ endPalindrome++;\n        reverse = string.slice(endPalindrome);\n    }\n  \
    \  return startPalindrome+endPalindrome+reverse;\n}\n", "    // Get length of\
    \ string\n    var length = string.length;\n    // Create new empty string\n  \
    \  var new_string = \"\";\n    // If string is of length 0 or 1\n    if(length\
    \ == 0 || length == 1){\n        return string;\n    }\n    // If no letters are\
    \ in the string\n    if(string.length != 0){\n        // Find the first character\
    \ in the string that is not a letter\n        var first_nonletter = string[0];\n\
    \        // Create a variable that holds the index of the character \n       \
    \ // we are looking at\n        var index_of_first_nonletter = string.indexOf(first_nonletter);\n\
    \        // Create a new variable that holds the first index of the string\n \
    \       var first_index_of_string = string.indexOf(first_nonletter) + 1;\n   \
    \     // Create a new variable that holds the length of the string\n        var\
    \ length_string = string.length;\n        // Loop through the string backwards\n\
    \        for(var i = length_string; i >= 0; i--){\n            // Check to see\
    \ if the character at the index is the same\n            // as the character at\
    \ the first index\n            if(string[index_of_first_nonletter] == string[first_index_of_string]){\n\
    \                // If it is the same, skip to the next index\n              \
    \  index_of_first_nonletter += 1;\n                first_index_of_string += 1;\n\
    \            }else{\n                // If it isn't the same, add the letter to\
    \ the new_string\n                new_string += string[first_index_of_string];\n\
    \                // Increment the index to the first nonletter\n             \
    \   index_of_first_nonletter = string.indexOf(first_nonletter) + 1;\n        \
    \        // Increment the first index to the first nonletter\n               \
    \ first_index_of_string = string.indexOf(first_nonletter) + 1;\n             \
    \   // Create a new variable that holds the index of the character \n        \
    \        // we are looking at\n                index_of_first_nonletter = string.indexOf(first_nonletter)\
    \ + 1;\n            }\n        }\n    }\n    return new_string;\n}\n", "  var\
    \ string = string.trim();\n  if(string == \"\"){\n    return \"\";\n  }\n  var\
    \ postfix = get_longest(string, true);\n  if(postfix == null){\n    return \"\"\
    ;\n  }\n  var first = string.slice(0, postfix.length);\n  var reversed = reverse_string(first);\n\
    \  var result = string.slice(postfix.length, string.length) + reversed;\n  return\
    \ result;\n}\n", "  //Find palindrome suffix\n  var suffixLength = (string.length\
    \ >= 1)? string.length - 1 : 0;\n  var palindrome = string.reverse();\n  var postfix\
    \ = \"\";\n  \n  for(var i = 0; i < suffixLength; i++){\n    postfix = palindrome;\n\
    \    \n    //append reverse of a string prefix that comes before the palindromic\
    \ suffix\n    postfix = palindrome[i - 1] + postfix;\n  }\n  \n  //append the\
    \ string post palindrome\n  postfix += string;\n  \n  return postfix;\n}\n\nvar\
    \ solution = make_palindrome(prompt(\"Enter a string for searching.\"));", " \
    \ if(string.length == 0){\n    return \"\"\n  }\n  let long_string = string.substr(0,string.length)\n\
    \  let reversed_string = make_palindrome(string.substr(string.length,string.length))\n\
    \  let start_index = long_string + reversed_string\n  return start_index\n}\n",
  "\tvar postfix = string.slice(0,-1);\n\tvar reversePostfix = string.reverse().slice(0,-1);\n\
    \treturn string.slice(0,-1) + reversePostfix;\n}\n", "    let longestPostfixString\
    \ = find_longest_postfix_string(string);\n    let longestPalindromicSuffix = longest_palindromicSuffix(longestPostfixString);\n\
    \    let longestPalindromicString = prefix + longestPalindromicSuffix;\n    return\
    \ longestPalindromicString;\n}", "  let postfix = string.reverse();\n  let prefix\
    \ = string.slice(0,string.length-postfix.length);\n  return prefix+postfix;\n\
    }\n", "  var reverseString = string.split(\"\").reverse().join(\"\");\n  return\
    \ string + reverseString;\n}\n", "  let prefix_re = /([^a-zA-Z])([a-zA-Z])/g;\n\
    \  let postfix_re = /(.*)([a-zA-Z])([^a-zA-Z])/g;\n  let match = prefix_re.exec(string);\n\
    \  if(match === null){\n    match = postfix_re.exec(string);\n  }\n  if(match\
    \ === null){\n    return string;\n  }\n  let prefix = match[1];\n  let postfix\
    \ = match[3];\n  let reversed_postfix = postfix.split('').reverse().join('');\n\
    \  return prefix + reversed_postfix;\n}\n", "    // reverse the supplied string\
    \ and find longest postfix of it.\n    // >>> find_longest_postfix(\"cata\")\n\
    \    // 4\n    // >>> find_longest_postfix(\"cat\")\n    // 5\n    var postfix\
    \ = string.length\n    for (var i=string.length-1; i>=0; i--){\n        if (string[i]\
    \ === string[string.length-i-1]){\n            postfix--\n        }\n    }\n \
    \   // append it to end of the string and reverse the suffix.\n    string = string\
    \ + string.reverse().slice(postfix, string.length)\n    // return it.\n    return\
    \ string\n}\n", "  let result = \"\";\n  let longestPalindrome = \"\";\n  if(string.length\
    \ == 0){\n    return result;\n  }\n  for(let i = 0; i < string.length; i++){\n\
    \    let currentChar = string[i];\n    let currentPalindrome = currentChar + currentChar;\n\
    \    if(currentPalindrome == make_palindrome(currentChar)){\n      result = result\
    \ + currentChar;\n    } else {\n      result = result + make_palindrome(currentPalindrome)\
    \ + currentChar;\n      longestPalindrome = currentPalindrome;\n    }\n  }\n \
    \ return result + longestPalindrome;\n}", "\tlet longestPalindrome = \"\";\n\t\
    let longestPalindromeLength = 0;\n\tlet longestPalindromeBeginsAt = 0;\n\tlet\
    \ longestPalindromeSuffix = \"\";\n\tlet longestPalindromeSuffixLength = 0;\n\n\
    \tfor (let i = 0; i < string.length; i++){\n\t\tlet currentChar = string.charAt(i);\n\
    \t\tlet currentCharLength = currentChar.length;\n\n\t\tif (longestPalindromeLength\
    \ < currentCharLength){\n\t\t\tlongestPalindrome = string.substring(0, i);\n\t\
    \t\tlongestPalindromeLength = currentCharLength;\n\t\t\tlongestPalindromeBeginsAt\
    \ = i;\n\t\t}\n\n\t\tif (i == string.length - 1){\n\t\t\tlet currentSuffixStart\
    \ = longestPalindromeBeginsAt + longestPalindromeLength - 1;\n\t\t\tlet currentSuffixEnd\
    \ = i;\n\t\t\tlongestPalindromeSuffix = string.substring(currentSuffixStart, currentSuffixEnd);\n\
    \t\t}\n\n\t\tlet currentCharReverse = currentChar.split(\"\").reverse().join(\"\
    \");\n\n\t\tif (currentCharReverse != currentChar){\n\t\t\tlet currentSuffixStartReverse\
    \ = longestPalindromeSuffix.length;\n\t\t\tlet currentSuffixEndReverse = i;\n\t\
    \t\tlet currentSuffixStart = longestPalindromeBeginsAt + longestPalindromeLength\
    \ - 1 - longestPalindromeSuffixLength;\n\t\t\tlet currentSuffixEnd = i;\n\n\t\t\
    \tif (currentChar.length <= longestPalindromeSuffixLength){\n\t\t\t\tlet currentSuffixStartLength\
    \ = longestPalindromeSuffixLength;\n\t\t\t\tlet currentSuffixEndLength = currentChar.length\
    \ - longestPalindromeSuffixLength;\n\t\t\t\tlet currentSuffixStart = longestPalindromeBeginsAt\
    \ + longestPalindromeLength - 1 - longestPalindromeSuffixLength;\n\t\t\t\tlet\
    \ currentSuffixEnd = i;\n\t\t\t} else {\n\t\t\t\tlet currentSuffixStartLength\
    \ = longestPalindromeSuffixLength - currentCharReverse.length;\n\t\t\t\tlet currentSuffixEndLength\
    \ = currentChar.length - longestPalindromeSuffixLength - currentCharReverse.length;\n\
    \t\t\t\tlet currentSuffixStart = longestPalindromeBeginsAt + longestPalindromeLength\
    \ - 1 - longestPalindromeSuffixLength - currentCharReverse.length;\n\t\t\t\tlet\
    \ currentSuffixEnd = i - currentCharReverse.length;\n\t\t\t}\n\n\t\t\tlet currentCharReverseSuffix\
    \ = string.substring(currentSuffixStart, currentSuffixEnd);\n\t\t\tlet currentCharReverseSuffix\
    \ = currentCharReverseSuffix.split(\"\").reverse().join(\"\");\n\n\t\t\tif (currentCharReverseSuffix\
    \ != currentCharReverse){\n\t\t\t\tlet currentSuffixStartReverseSuffix = longestPalindromeSuffi",
  "  var longest = find_longest_palindrome(string)\n  longest = longest.slice(0,longest.length/2)\n\
    \  var reverse_string = string.slice(0,longest.length) + string.slice(longest.length,string.length)\n\
    \  return reverse_string + longest\n}\n", "    var len = string.length;\n    if(len\
    \ <= 1){\n        return string;\n    }\n    var first_postfix = string[len-1];\n\
    \    var other_string = string.substring(0, len-1);\n    var postfix_reverse =\
    \ reverse(first_postfix);\n    return other_string + postfix_reverse;\n}\n", " \
    \   let len = string.length;\n    let reversed_str = string.repeat(len);\n   \
    \ let min_postfix_len = Math.ceil(len / 2) - 1;\n\n    while(min_postfix_len >\
    \ 0) {\n        let postfix_len = len - min_postfix_len;\n        let postfix_str\
    \ = string.substring(0, postfix_len);\n        let postfix_reversed_str = reversed_str.substring(0,\
    \ postfix_len);\n\n        if(postfix_str === postfix_reversed_str) {\n      \
    \      reversed_str = string.repeat(postfix_len) + reversed_str.substring(postfix_len);\n\
    \            min_postfix_len--;\n        } else {\n            reversed_str =\
    \ string.repeat(postfix_len) + reversed_str.substring(postfix_len) + string.substring(min_postfix_len);\n\
    \            break;\n        }\n    }\n\n    return reversed_str;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nAh I see, it doesn't really work the way I'd want it to, but\
    \ that makes it a lot easier to understand. Thanks!\n<|/ c |>\n<| c |>\nI added\
    \ a function that can make palindromes from a list of words (not just one word\
    \ but a list), but I'm sure you can figure out how to do that yourself.\n<|/ c\
    \ |>\n<| a tags=palindrome,javascript,loops dscore=1 |>\n<code>\nconst isPalindrome\
    \ = num => {\n    num = String(num);\n    let revNum = \"\";\n    for (let i =\
    \ num.length; i >= 0; i--) {\n        revNum += num[i];\n    }\n    return num\
    \ === revNum;\n};\n", "  return string.repeat(2);\n}\n", "  var reversed_string\
    \ = \"\";\n  var prefix_string = string.substr(0,string.length-1);\n  var postfix_string\
    \ = string.substr(string.length-1,string.length);\n  var prefix_length = prefix_string.length;\n\
    \  var postfix_length = postfix_string.length;\n  var suffix_length = postfix_string.length/2;\n\
    \n  if(postfix_length == 1){\n    return prefix_string + postfix_string;\n  }\n\
    \n  for(var i = 1; i < postfix_length/2 + 1; i++){\n    reversed_string += postfix_string.charAt(i);\n\
    \  }\n\n  reversed_string = reversed_string.split('').join('');\n\n  return prefix_string\
    \ + reversed_string + postfix_string;\n}\n", "    // Convert to string to array\
    \ of characters.\n    var chars = string.toString().split(\"\");\n    // Find\
    \ max length of the prefix that is a palindrome.\n    var prefixLength = 0;\n\
    \    while(chars[prefixLength].match(/\\w/)){\n        prefixLength += 1;\n  \
    \  }\n    // Find the longest postfix that is a palindrome.\n    var longestPostfixLength\
    \ = 0;\n    while(chars[longestPostfixLength].match(/\\w/) == null && longestPostfixLength\
    \ < prefixLength){\n        longestPostfixLength += 1;\n    }\n    // Convert\
    \ longest postfix to array of characters.\n    var longestPostfix = new Array();\n\
    \    for(var i = 0; i < longestPostfixLength; i++){\n        longestPostfix.push(chars[longestPostfixLength\
    \ - i - 1]);\n    }\n    // Append reverse of longest postfix to prefix.\n   \
    \ longestPostfix.reverse();\n    longestPostfix.push(chars[prefixLength]);\n \
    \   return longestPostfix.join(\"\");\n}\n", "  string += \"\";\n  if (string.length\
    \ <= 1) {\n    return string;\n  }\n\n  var first = string.substr(0,1);\n  var\
    \ last = string.substr(string.length-1);\n  string = string.substr(1,string.length-1);\n\
    \n  var pal_suffix = \"\";\n  var pal_suffix = make_palindrome(string);\n\n  while\
    \ (pal_suffix.length >= first.length && pal_suffix.length < string.length) {\n\
    \    pal_suffix = pal_suffix + (pal_suffix.substr(0,first.length) + string);\n\
    \  }\n\n  string = string.substr(0, first.length) + pal_suffix + first;\n\n  return\
    \ string;\n}\n", "  if(!string || string === \"\")\n    return \"\";\n\n  var\
    \ length = string.length,\n      chars = string.split(\"\"),\n      suffixPalindromes\
    \ = [],\n      prefixPalindromes = [],\n      longestPalindrome = null;\n\n  //\
    \ Go through each character in the given string and build suffixPalindromes and\
    \ prefixPalindromes.\n  for(var i=0; i<length; i++){\n    if(chars[i].length >=\
    \ longestPalindrome.length){ // If the current character length is greater than\
    \ the longest palindrome so far.\n      // If this is not a palindrome then find\
    \ the longest palindrome that ends with this character.\n      for(var j=i; j<length;\
    \ j++){\n        if(string[j] === string[i]){\n          suffixPalindromes.push(string.substring(i,\
    \ j+1));\n          break;\n        }\n      }\n      // If this is not a palindrome\
    \ then find the longest palindrome that begins with this character.\n      for(var\
    \ j=i; j<length; j++){\n        if(string[j] === string[i]){\n          prefixPalindromes.push(string.substring(0,\
    \ j));\n          break;\n        }\n      }\n      longestPalindrome = suffixPalindromes.reverse().join(\"\
    \"); // Build the new longest palindrome.\n      longestPalindrome += prefixPalindromes.reverse().join(\"\
    \"); // Build the new longest palindrome.\n      suffixPalindromes = []; // Clear\
    \ the suffix palindromes array.\n      prefixPalindromes = []; // Clear the prefix\
    \ palindromes array.\n    }\n  }\n\n  return longestPalindrome;\n}\n", "    if(string.length\
    \ < 2) return string;\n    var palindrome = string;\n    var prefix_reverse =\
    \ string.reverse();\n    while(prefix_reverse.length >= string.length){\n    \
    \    if(prefix_reverse.slice(0,string.length) == palindrome.slice(0,string.length))\
    \ palindrome = prefix_reverse.slice(0,string.length) + palindrome.slice(string.length);\n\
    \        palindrome = prefix_reverse.slice(0,string.length) + palindrome.slice(string.length);\n\
    \        prefix_reverse = prefix_reverse.reverse();\n    }\n    return palindrome;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,string,palindrome,java |>\n\
    The easiest way is to check whether there is a palindrome in the string itself\
    \ and in the reversed string. If there is one then compare them using the String.equals\
    \ method.\nExample:\n<code>\npublic boolean isPalindrome(String s) {\n    if (s.equals(s.reverse()))\
    \ {\n        return true;\n    }\n    return false;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWhat does that have to do with solving the problem?\n<|/ c |>\n\
    <| c |>\nThe question asks for an algorithm to determine whether a word is a palindrome.\
    \ That algorithm compares 2 strings, therefore it is an answer to this question.\n\
    <|/ c |>\n<| a dscore=0 |>\nYou can try with this:\n<code>\nimport java.util.*;\n\
    class StringPalindrome{\n    public static void main(String args[]){\n       \
    \ Scanner sc=new Scanner(System.in);\n        System.out.println(\"Enter string\"\
    );\n        String a=sc.nextLine();\n        String b=new StringBuffer(a).reverse().toString();\n\
    \        System.out.println(a);\n        System.out.println(b);\n        if(a.equals(b)){\n\
    \            System.out.println(\"String is palindrome\");\n        }else{\n \
    \           System.out.println(\"String is not palindrome\");\n        }\n   \
    \ }\n}\n</code>\n<|/ a tags=algorithm,string,palindrome,java |>\n<| c |>\nWhy\
    \ would you reverse a StringBuffer instead of just reversing the string?\n<|/\
    \ c |>\n<| c |>\ni used StringBuffer because it will reverse the string for me\
    \ but now it also reverses the stringbuffer.\n<|/ c |>\n<| c |>\nYeah, StringBuffer\
    \ was the wrong choice, sorry.\n<|/ c |>\n<| a |>\nYou can use String.equals(String)\
    \ to compare strings\n<|/ a tags=algorithm,string,palindrome", "  var str = \"\
    \";\n  var palindrome = \"\";\n\n  for(var i = 0; i < string.length; i++){\n \
    \   //Check whether current character is a palindrome\n    if(is_palindrome(string.charAt(i))\
    \ == true)\n      palindrome += string.charAt(i);\n\n    //Append to string the\
    \ reverse of string prefix that comes before the palindromic suffix.\n    str\
    \ += string.substring(i - 1, i) + palindrome;\n\n    //Remove the character that\
    \ was added previously.\n    string = string.substring(0, i) + string.substring(i\
    \ + 1);\n  }\n\n  return str;\n}\n", "  string = string.replace(/^\\s+/g,\"\"\
    );\n  var reverse = \"\";\n  for(var i=string.length-1;i>=0;i--){\n    reverse\
    \ += string[i];\n  }\n  reverse = make_palindrome_reverse(reverse);\n  if(reverse.length\
    \ > string.length){\n    return string;\n  }\n  return string.slice(0,reverse.length)\
    \ + reverse + string.slice(reverse.length);\n}", "    var string = string.replace(/\\\
    s+/g, \" \").split(\" \");\n    var longest = 0;\n    var longestString = \"\"\
    ;\n    var longestPalindrome = \"\";\n    var lastString = string[0];\n    for(var\
    \ i = 0; i < string.length; i++){\n        var tempString = \"\";\n        var\
    \ tempPalindrome = \"\";\n        var tempStringPrefix = \"\";\n        for(var\
    \ j = longestString.length - 1; j >= 0; j--){\n            tempStringPrefix =\
    \ tempStringPrefix + string[j];\n            tempString = tempString + string[j];\n\
    \            tempPalindrome = tempPalindrome + string[j];\n        }\n       \
    \ longestString = tempStringPrefix;\n        longestPalindrome = tempPalindrome;\n\
    \        longest = tempString.length;\n        if(tempPalindrome == tempString.split(tempPalindrome).join(tempPalindrome)){\n\
    \            break;\n        }\n    }\n    longestString = longestString.split(tempString).join(tempString);\n\
    \    if(string[string.length - 1] == longestPalindrome){\n        longestString\
    \ = longestString + string[string.length - 2] + string[string.length - 1];\n \
    \       longestPalindrome = longestPalindrome + tempStringPrefix + tempString[longestString.length\
    \ - 2];\n        longest = longestString.length;\n    }\n    longestString = longestString.split(tempString).join(tempString);\n\
    \    return longestString;\n}\n", "  // Create empty string for palindromes.\n\
    \  let palindrome = \"\";\n  \n  // If the string is empty.\n  // Return empty\
    \ string.\n  if (string === \"\") return \"\";\n  \n  // If the string is not\
    \ a palindrome.\n  // Return the original string.\n  if (string.length !== string.toUpperCase().length)\
    \ return string;\n  \n  // Create a reversed version of the string using the reverse\
    \ method of the String object.\n  let reversed_string = \"\" + string.toUpperCase().reverse();\n\
    \  \n  // Create a postfix version of the string using the substring method of\
    \ the String object.\n  let postfix_string = string.substring(0, string.length\
    \ - 1);\n  \n  // If the postfix string is the same as the reverse of the original\
    \ string.\n  // Then the string is a palindrome.\n  if (postfix_string === reversed_string)\
    \ {\n    palindrome = string;\n  }\n  \n  // If the postfix string has a length\
    \ greater than 1.\n  // Reverse the postfix string and append it to palindrome\
    \ string.\n  if (postfix_string.length > 1) {\n    palindrome = reversed_string\
    \ + postfix_string;\n  }\n  \n  // Return the palindrome string.\n  return palindrome;\n\
    }\n", "  // Return empty string if no string supplied.\n  if (!string)\n    return\
    \ \"\";\n\n  // Use a palindromic substring as our \"start point\".\n  var start_pos\
    \ = string.length\n\n  // Find the longest postfix of supplied string that is\
    \ a palindrome.\n  while (string.length < start_pos){\n    if (string.match(/.*(.)\\\
    1/)){\n      start_pos = string.length\n      break;\n    }\n    string+= string;\n\
    \  }\n\n  // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n  string += string[start_pos-1] + string.slice(0,\
    \ start_pos-1)\n\n  // Return our new palindrome string.\n  return string\n}\n",
  "    let result=\"\";\n    let longest = longestPalindrome(string);\n    let start\
    \ = string.length-longest.length-1;\n    for(let i=0;i<=start;i++){\n        result\
    \ = result + string[i];\n    }\n    result = result + string.reverse();\n    return\
    \ result;\n}\n", "  // Find the longest postfix that is a palindrome.\n  // Algorithm\
    \ idea is simple:\n  // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n  // - Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n  // >>> make_palindrome(\"\")\n\
    \  // \"\"\n  // >>> make_palindrome(\"cat\")\n  // \"catac\"\n  // >>> make_palindrome(\"\
    cata\")\n  // \"catac\"\n  // >>> make_palindrome(\"aaabba\")\n  // \"aabbaa\"\
    \n  const maxLen = string.length\n  let longestPalindrome = string\n  let index\
    \ = 0\n  while(index <= maxLen){\n    const substring = string.substr(index,1)\n\
    \    const newString = string.substr(0,index) + substring.reverse() + string.substr(index+1)\n\
    \    if(newString === longestPalindrome){\n      longestPalindrome = newString\n\
    \    }\n    index = index + 1\n  }\n  return longestPalindrome\n}\n", "    let\
    \ reverse = \"\";\n    for(let i = 0; i < string.length; i++){\n        reverse\
    \ += string[i];\n    }\n    reverse = reverse.reverse();\n    string += reverse;\n\
    \    for(let i = 0; i < string.length; i++){\n        if(string[i] !== reverse[i]){\n\
    \            break;\n        }\n    }\n    return string;\n}\n</code>\n<|/ a tags=algorithm,string,palindrome\
    \ dscore=4 |>\n<| a dscore=2 tags=algorithm,string,palindrome |>\nThe most efficient\
    \ solution would be to first check for palindromes, if found just return the palindrome\
    \ without reversing it else reverse the string and check again for palindrome,\
    \ if found return it, else return the string as is.\n<code>\nstring reverse_palindrome(string\
    \ s){\n  if(s.empty()) return s;\n  if(is_palindrome(s)) return s;\n  string r\
    \ = reverse(s);\n  return is_palindrome(r) ? r : s;\n}\n</code>\n<|/ a |>\n<|\
    \ a tags=algorithm,string,palindrome |>\nMy answer to this question was to reverse\
    \ the string and compare it to its mirror string, if the two matches, reverse\
    \ the result to its original form. If they don't match or there is no such string,\
    \ then reverse the original string.\n<code>\nString palindrome(String str) {\n\
    \    String result = \"\";\n    if (str.length() < 1) return \"\";\n    for (int\
    \ i = 0; i < str.length(); i++) {\n        for (int j = i; j < str.length(); j++)\
    \ {\n            if (str.charAt(i) == str.charAt(j)) {\n                for (int\
    \ k = i; k < ((i < j) ? j : i); k++) {\n                    if (str.charAt(i)\
    \ != str.charAt(k)) {\n                        result += str.charAt(i);\n    \
    \                    break;\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks for this simple solution, I've been trying to get this to work\
    \ for some time but I can't understand what's going wrong.\n<|/ c |>\n<| a dscore=2\
    \ tags=algorithm,string,palindrome |>\nHere is my solution. \nIt uses two pointers,\
    \ one for reverse the string and another for compare the reverse string with original.\n\
    <code>", "    if(string.length <= 1) return string;\n\n    // Find longest postfix\
    \ that is a palindrome.\n    var max_postfix = [];\n    var palindrome = false;\n\
    \n    for(var i = 0, n = string.length; i < n; i++){\n        for(var j = 0, m\
    \ = string.length - i - 1; j < m; j++){\n            var prefix = string.substr(0,\
    \ j);\n            var suffix = string.substr(j + 1);\n\n            if(prefix_is_palindrome(prefix)\
    \ && suffix_is_palindrome(suffix)){\n                postfix_is_palindrome(suffix,\
    \ max_postfix);\n                palindrome = true;\n                break;\n\
    \            }\n        }\n    }\n\n    // If no palindromes found, return the\
    \ original string.\n    if(!palindrome){\n        return string;\n    }\n\n  \
    \  // Add the reverse of a postfix string to the beginning.\n    max_postfix.reverse();\n\
    \    var reversed_string = \"\";\n\n    for(var i = 0; i < max_postfix.length;\
    \ i++){\n        reversed_string += max_postfix[i];\n    }\n\n    return reversed_string;\n\
    }\n", "    var len = string.length\n    var reversed_string = \"\";\n    var postfix_string;\n\
    \    for(var i = 0; i < len; i++){\n        if(string[i] === string[len-i-1]){\n\
    \            postfix_string = string.substring(0,i) + string[len-i-1] + string.substring(i+1)\n\
    \        }else{\n            postfix_string = string.substring(0,i) + string[i]\
    \ + string.substring(i+1)\n        }\n        reversed_string = reversed_string\
    \ + postfix_string;\n    }\n    return reversed_string;\n}\n", "  if (string ===\
    \ null || string.length == 0) return string;\n\n  var re = new RegExp(\"^\" +\
    \ reverse_repeat(string));\n  var matches = string.match(re);\n\n  if (matches)\
    \ {\n    string = matches[0] + string.substr(matches[0].length,string.length);\n\
    \  }\n  return string;\n}\n", "    let reverse_string = string\n    if(string.length\
    \ <= 1){\n        return string\n    }\n    let end_index = string.length - 1;\n\
    \    let prefix = '', postfix = string\n\n    while(end_index >= 0){\n       \
    \ if(string[end_index] === string[end_index].toUpperCase()){\n            postfix\
    \ = (string[end_index].toLowerCase() + postfix).toLowerCase()\n            end_index\
    \ -= 1\n        } else {\n            postfix = (string[end_index].toLowerCase()\
    \ + postfix).toLowerCase()\n            end_index += 1\n        }\n    }\n   \
    \ postfix = reverse_string.slice(0,end_index) + postfix\n\n    prefix = reverse_string.slice(end_index)\n\
    \    string = prefix + postfix\n    return string\n}\n", "\tlet postfix = find_postfix_of_string(string);\n\
    \tlet reversed_postfix = reverse_postfix(postfix);\n\tlet prefix = string.slice(0,\
    \ postfix.length);\n\treturn prefix + reversed_postfix;\n}\n", "\tvar start =\
    \ string.split(\"\").reverse().join(\"\");\n\tvar end   = string.split(\"\").join(\"\
    \").split(\"\").reverse().join(\"\") + start;\n\treturn string.split(\"\").join(\"\
    \") == end ? string : make_palindrome(start+end);\n}\n", "    string += string.reverse();\n\
    \    string += string.substr(0,string.length-1);\n    return string;\n}\n", " \
    \ var prefix = string;\n  var suffix = string;\n  var longest_postfix_palindrome\
    \ = longest_palindrome_postfix(prefix);\n  var palindrome = longest_postfix_palindrome.reverse\
    \ + longest_postfix_palindrome;\n  if (prefix.length > 0) palindrome += longest_postfix_palindrome;\n\
    \  return palindrome;\n}", "    if (string.length < 2) return string;\n    let\
    \ postfix = string.slice(0,string.length-1);\n    let prefix = string.slice(0,string.length-1);\n\
    \    let reverse = reverse(prefix.toString());\n    let palindrome = postfix +\
    \ reverse + postfix;\n    return palindrome;\n}\n", "  string = string.toLowerCase();\n\
    \  var palindrome = \"\";\n  var postfix_length = 0;\n  while(postfix_length <\
    \ string.length){\n    var palindromic_suffix = reverseString(string.substr(postfix_length));\n\
    \    var palindromic_sub_string = string.substr(0, postfix_length + 1) + palindromic_suffix;\n\
    \    palindrome += palindromic_sub_string;\n    postfix_length += palindromic_suffix.length;\n\
    \  }\n  return palindrome;\n}\n", "    const prefix = string.substr(0, string.length\
    \ - 1);\n    const suffix = string.substr(string.length - 1, string.length);\n\
    \    let palindrome = `${prefix}${reverse(prefix)}{suffix}`;\n    \n    // Check\
    \ to see if the supplied string is a palindrome.\n    if(palindrome === string){\n\
    \        return palindrome;\n    }\n\n    // Continue to remove last char from\
    \ reversed suffix.\n    if(suffix.length > 0){\n        palindrome = `${palindrome.substr(0,\
    \ palindrome.length - 1)}${reverse(suffix)}`;\n    }\n\n    // Continue to remove\
    \ first char from reversed prefix.\n    if(prefix.length > 0){\n        palindrome\
    \ = `${reverse(prefix)}{palindrome.substr(1, palindrome.length - 1)}`;\n    }\n\
    \n    // Continue to remove first char from reversed suffix and prefix\n    if(suffix.length\
    \ > 0){\n        palindrome = `${reverse(suffix)}{palindrome.substr(1, palindrome.length\
    \ - 1)}`;\n    }\n\n    // Continue to remove last char from reversed suffix and\
    \ prefix.\n    if(prefix.length > 0){\n        palindrome = `${reverse(prefix)}{palindrome.substr(0,\
    \ palindrome.length - 1)}`;\n    }\n    \n    return palindrome;\n}\n", "  if\
    \ (string.length < 2)\n    return string\n\n  const postfix_reversed = string.reduceRight(\n\
    \    function(previous, current){\n      return previous + current.toUpperCase()\n\
    \    },\n    \"\"\n  )\n\n  const prefix = string.slice(0, string.length - string.length\
    \ - postfix_reversed.length)\n  const suffix = string.slice(string.length - string.length\
    \ - postfix_reversed.length)\n\n  return prefix + postfix_reversed + suffix\n\
    }\n\nconst palindromes = [\n  \"aaaax\",\n  \"aaaxa\",\n  \"aaaxaa\",\n  \"aaaxxa\"\
    ,\n  \"axaax\",\n  \"axaay\",\n  \"axaaya\",\n  \"aaayx\",\n  \"aaaxx\",\n  \"\
    axxaa\",\n  \"axxaa\",\n  \"axxay\",\n  \"axxay\",\n  \"axxaya\",\n  \"ayaax\"\
    ,\n  \"ayaay\",\n  \"ayaaya\",\n  \"axaa\",\n  \"axaax\",\n  \"axaay\",\n  \"\
    axaaya\",\n  \"ayxaax\",\n  \"ayxaa\",\n  \"ayxaa\",\n  \"ayxay\",\n  \"ayxaya\"\
    ,\n  \"axxaa\",\n  \"axxaax\",\n  \"axxaay\",\n  \"axxaaya\",\n  \"ayxax\",\n\
    \  \"ayxay\",\n  \"ayxaya\",\n  \"ayxax\",\n  \"ayxay\",\n  \"ayxaya\",\n  \"\
    axax\",\n  \"axaxa\",\n  \"axaxax\",\n  \"axaxay\",\n  \"axaxaya\",\n  \"axay\"\
    ,\n  \"axaya\",\n  \"ayax\",\n  \"ayay\",\n  \"ayaya\",\n  \"axay\",\n  \"axaya\"\
    ,\n  \"ayxa\",\n  \"ayxax\",\n  \"ayxay\",\n  \"ayxaya\",\n  \"axay\",\n  \"axaya\"\
    ,\n  \"ayxa\",\n  \"ayxax\",\n  \"ayxay\",\n  \"ayxaya\",\n  \"axay\",\n  \"axaya\"\
    ,\n  \"ayxa\",\n  \"ayxax\",\n  \"ayxay\",\n  \"ayxaya\",\n  \"axay\",\n  \"axaya\"\
    \n]\n\npalindromes.forEach(function(string){\n  console.log(string + \" -> \"\
    \ + make_palindrome(string))\n})</code>\n\nAnd finally, here is a version that\
    \ uses native JS:\n\n<code>\nconst make", "    var string = string.toString();\n\
    \    //Find longest palindrome that can be made from the string\n    var longest\
    \ = 0;\n    var longest_palindrome = \"\";\n    var is_palindrome = function(){\n\
    \        var length = (longest - longest%2)/2;\n        var is_palindrome = string.length\
    \ == length && string.split(\"\").reverse().join(\"\") == string;\n        return\
    \ is_palindrome;\n    };\n    for(var i = 0; i < string.length; i++){\n      \
    \  var length = string.length - i;\n        var current_palindrome = string.length\
    \ == length ? string[i] : string.slice(0,length).split(\"\").reverse().join(\"\
    \");\n        if(is_palindrome()){\n            longest = i;\n            longest_palindrome\
    \ = current_palindrome;\n        }\n    }\n    return longest_palindrome;\n}\n\
    </code>\n<|/ a dscore=1 tags=string,javascript |>\n<| a dscore=0 tags=string,javascript\
    \ |>\nThis is my solution. \nI took idea of Shreyas's answer and modified it a\
    \ little bit.\n<code>", "  string = string.toLowerCase();\n  var new_string =\
    \ string.length !== string.replace(/[a-z]/g, function(s){return s.replace(/[-_]/g,\"\
    \")}).length ? \"\" : string.replace(/[a-z]/g, function(s){return s.replace(/[-_]/g,\"\
    \")});\n  new_string = new_string.length !== string.replace(/[a-z]/g, function(s){return\
    \ s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n  new_string = new_string.length\
    \ !== string.replace(/[a-z]/g, function(s){return s.replace(/[-_]/g,\"\")}).length\
    \ ? \"\" : new_string;\n  new_string = new_string.length !== string.replace(/[a-z]/g,\
    \ function(s){return s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n \
    \ new_string = new_string.length !== string.replace(/[a-z]/g, function(s){return\
    \ s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n  new_string = new_string.length\
    \ !== string.replace(/[a-z]/g, function(s){return s.replace(/[-_]/g,\"\")}).length\
    \ ? \"\" : new_string;\n  new_string = new_string.length !== string.replace(/[a-z]/g,\
    \ function(s){return s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n \
    \ new_string = new_string.length !== string.replace(/[a-z]/g, function(s){return\
    \ s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n  new_string = new_string.length\
    \ !== string.replace(/[a-z]/g, function(s){return s.replace(/[-_]/g,\"\")}).length\
    \ ? \"\" : new_string;\n  new_string = new_string.length !== string.replace(/[a-z]/g,\
    \ function(s){return s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n \
    \ new_string = new_string.length !== string.replace(/[a-z]/g, function(s){return\
    \ s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n  new_string = new_string.length\
    \ !== string.replace(/[a-z]/g, function(s){return s.replace(/[-_]/g,\"\")}).length\
    \ ? \"\" : new_string;\n  new_string = new_string.length !== string.replace(/[a-z]/g,\
    \ function(s){return s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n \
    \ new_string = new_string.length !== string.replace(/[a-z]/g, function(s){return\
    \ s.replace(/[-_]/g,\"\")}).length ? \"\" : new_string;\n  new_string = new_string.length\
    \ !== string.replace(/[a-z]/g, function(s){return s.replace(/[-_]/g,\"\")}).length\
    \ ? \"\" : new_string;\n  new_string = new_string.length !== string.replace(/[a-z]/g, ",
  "  // Return early if no string is supplied.\n  if(string == \"\" || string == null){\n\
    \    return \"\";\n  }\n  \n  // Check if string is a palindrome.\n  if(string\
    \ == string.toLowerCase()){\n    return string;\n  }\n  \n  // Get the length\
    \ of the provided string.\n  let lenString = string.length;\n  \n  // Make a new\
    \ string that is the length of the original string plus 1.\n  let newString =\
    \ make_palindrome(string);\n  \n  // Make a new string that will be used to reverse\
    \ the original string that is shorter than the palindrome to see if it is actually\
    \ a palindrome.\n  let revString = \"\";\n  \n  // Reverse the string that is\
    \ shorter than the palindrome to see if it is actually a palindrome.\n  for(let\
    \ i = 0; i < lenString - 1; i++){\n    revString = revString + string.charAt(i);\n\
    \  }\n  \n  // Check if the reverse string is the same as the original string.\
    \ If yes, return the original string.\n  if(revString == newString){\n    return\
    \ string;\n  }\n  \n  // If not, then check if the reverse string is a palindrome.\n\
    \  if(revString.toLowerCase() == revString.toLowerCase()){\n    return revString;\n\
    \  }\n  \n  // If not, then try removing a character from the original string\
    \ until it is a palindrome.\n  let removedChar = string.charAt(lenString - 1);\n\
    \  \n  for(let i = 0; i < lenString - 1; i++){\n    if(removedChar == string.charAt(i)){\n\
    \      removedChar = string.charAt(lenString - 2);\n    }else{\n      removedChar\
    \ = string.charAt(i - 1);\n    }\n  }\n  \n  // If the original string is a palindrome,\
    \ return it, else try removing a character from the original string until it is\
    \ a palindrome.\n  if(removedChar == removedChar.toLowerCase()){\n    return removedChar;\n\
    \  }\n  \n  // If nothing else works, return an empty string as the palindrome\
    \ does not exist.\n  return \"\";\n}\n", "  var rev_string = reverse(string);\n\
    \  var rev_string = rev_string.trim();\n  var post_rev_string = rev_string.substr(0,rev_string.length-1);\n\
    \  var post_rev_string = post_rev_string.trim();\n  var palindrome = string +\
    \ post_rev_string;\n  return palindrome;\n}\n", "  let postfix = \"\";\n  let\
    \ prefixes = [];\n  let suffix_count = 0;\n  let suffix = \"\";\n  let palindrome\
    \ = \"\";\n  let index = -1;\n\n  // Looping backwards to find the longest postfix\
    \ string that is a palindrome\n  // and counting how many characters were added\
    \ to its original string\n  for (let i = string.length-1; i >= 0; i--){\n    postfix\
    \ += string[i];\n\n    index = string.indexOf(string[i], i+1);\n\n    if (index\
    \ === -1){\n      prefix = string.substring(0, i);\n      prefixes.unshift(prefix);\n\
    \      break;\n    }\n  }\n\n  // Adding postfix string to the end of the string\
    \ reverse\n  // of any string prefixes before it that comes before it\n  for (let\
    \ i = 0; i < prefixes.length; i++){\n    index = string.length - prefixes[i].length\
    \ - 1;\n    suffix = string[index];\n    string += suffix;\n  }\n\n  // Looping\
    \ backwards to find the shortest palindrome that begins with\n  // the postfix\
    \ string.\n  for (let i = 0; i < string.length; i++){\n    index = string.indexOf(string[i],\
    \ i+1);\n\n    if (index !== -1){\n      palindrome += string[i];\n      palindrome\
    \ = make_palindrome_helper(string, palindrome, index+1, suffix);\n    }\n  }\n\
    \n  return palindrome;\n}\n", "    if(string.length == 0)\n        return \"\"\
    ;\n    var longest_postfix = longest_prefix_palindrome(string);\n    var postfix\
    \ = string.substring(0, longest_postfix);\n    var reversed_postfix = reverse_palindrome_prefix(postfix,\
    \ longest_postfix);\n    return reversed_postfix + string;\n}\n", "    // Use\
    \ a dictionary for O(n) running time\n    var palindromes = {};\n\n    // Preprocess\
    \ the string to find longest palindrome\n    // and create reverse suffix\n  \
    \  var pre_processed = string\n    .replace(/([a-zA-Z])/g, function(m){\n    \
    \    var key = m.toLowerCase();\n        if(palindromes[key] === undefined){\n\
    \            palindromes[key] = key;\n        }\n        return palindromes[key];\n\
    \    });\n    pre_processed = pre_processed.substr(0, pre_processed.length - 1);\n\
    \n    // Store reverse palindromes in dictionary\n    var reverse_palindromes\
    \ = {};\n    var reverse_string = \"\";\n    for(var key in palindromes){\n  \
    \      reverse_string += pre_processed + palindromes[key];\n        reverse_palindromes[reverse_string]\
    \ = key;\n        reverse_string += key;\n    }\n\n    // Loop through all characters\
    \ in string\n    // and replace them with reverse suffix\n    var i = 0;\n   \
    \ var len = string.length;\n    var replace_string = \"\";\n    for(; i < len;\
    \ i++){\n        replace_string += string.charAt(i);\n        if(replace_string\
    \ in reverse_palindromes){\n            string = string.replace(replace_string,\
    \ palindromes[replace_string]);\n            len = string.length;\n        }\n\
    \    }\n\n    // Return the string with palindromes replaced with their original\
    \ suffixes\n    return string;\n}\n", "    var longest = find_longest_palindrome(string);\n\
    \    var begins_with_prefix = string.substr(0, longest.length);\n    var reversed_prefix_prefix_end\
    \ = reverse(begins_with_prefix);\n    var reversed_prefix_postfix_end = reverse(string.substr(longest.length));\n\
    \    return begins_with_prefix + reversed_prefix_prefix_end + reversed_prefix_postfix_end;\n\
    }\n", "    // Get reverse of string\n    let reversed_string = string.split('').reverse().join('');\n\
    \    // Get longest postfix of string\n    let suffix = '';\n    for(let i = 0;\
    \ i < string.length; i++){\n        if(i === (string.length - 1)){\n         \
    \   suffix = string;\n        }else{\n            suffix = suffix + '' + string[i];\n\
    \        }\n    }\n    // Append reverse of suffix to string\n    return string\
    \ + reversed_string + suffix;\n}\n", "\t// The longest postfix that is also a\
    \ palindrome.\n\tvar max_postfix = \"\";\n\tvar max_postfix_len = 0;\n\t// The\
    \ longest string prefix that is also a palindrome.\n\tvar max_prefix_len = 0;\n\
    \tfor( var i=string.length-1; i>=0; i-- ){\n\t\tvar prefix = string.substr(0,i);\n\
    \t\tvar postfix = string.substr(i);\n\t\tvar postfix_len = postfix.length;\n\t\
    \tvar prefix_len = prefix.length;\n\t\t// If this postfix is a palindrome.\n\t\
    \tif( postfix_len == prefix_len && string.palindrome( postfix ) ){\n\t\t\t// If\
    \ this postfix is longer, update max_postfix_len.\n\t\t\tif( postfix_len > max_postfix_len\
    \ ){\n\t\t\t\tmax_postfix_len = postfix_len;\n\t\t\t\tmax_postfix = postfix;\n\
    \t\t\t}\n\t\t\t// If this prefix is longer, update max_prefix_len.\n\t\t\telse\
    \ if( prefix_len > max_prefix_len ){\n\t\t\t\tmax_prefix_len = prefix_len;\n\t\
    \t\t}\n\t\t}\n\t}\n\t// If no palindrome found and no palindromes found, return\
    \ empty string.\n\tif( !max_postfix && !max_prefix_len ){\n\t\treturn \"\";\n\t\
    }\n\t// If both palindromes are longer than the maximum length of strings, return\
    \ empty string.\n\telse if( max_postfix_len > max_prefix_len ){\n\t\treturn \"\
    \";\n\t}\n\t// If both palindromes are equal, append reverse of postfix to prefix\
    \ and return.\n\telse if( max_postfix_len == max_prefix_len && string.palindrome(\
    \ max_postfix + max_postfix.reverse( ) ) ){\n\t\treturn max_postfix + max_postfix.reverse(\
    \ );\n\t}\n\t// If none of above is true, the palindromes don't exist, so return\
    \ empty string.\n\treturn \"\";\n}", "    //Find the longest postfix that is a\
    \ palindrome.\n    var rev_string = \"\";\n    for(var i = 0; i < string.length;\
    \ i++){\n        if(string.charAt(i) === string.charAt(string.length - 1 - i)){\n\
    \            rev_string += string.charAt(i);\n        }\n    }\n    //Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    return string + rev_string;\n}", "    // The longest palindromic\
    \ suffix.\n    var suffix = \"a\";\n    // The longest postfix of the string that\
    \ is not suffix;\n    // will be used to create the reversed suffix.\n    var\
    \ prefix_length = 0;\n    // The prefix that comes before the longest palindromic\
    \ suffix.\n    var prefix;\n    // The reversed suffix.\n    var reversed_suffix;\n\
    \    // The longest palindromic suffix found so far so we don't\n    // have to\
    \ find the longest palindromic suffix for every string.\n    var max_length =\
    \ -1;\n    // The length of the longest palindromic suffix.\n    var palindromic_suffix;\n\
    \    // The longest postfix of the string that is not suffix.\n    var palindromic_suffix_length\
    \ = 0;\n    // The length of the longest postfix of the string that is not suffix.\n\
    \    var palindromic_suffix_max_length = -1;\n\n    // Loop through all the characters\
    \ in the supplied string.\n    for(var i = 0; i < string.length; i++){\n     \
    \   // Loop through all the characters in the longest palindromic suffix.\n  \
    \      for(var j = 0; j < max_length; j++){\n            // Loop through all the\
    \ characters in the longest postfix of the string.\n            for(var k = 0;\
    \ k < palindromic_suffix_length; k++){\n                // If the length of the\
    \ longest postfix is greater than the \n                // length of the longest\
    \ palindromic suffix, \n                // the length of the longest postfix of\
    \ the string is not suffix.\n                if(palindromic_suffix_length > palindromic_suffix_max_length){\n\
    \                    palindromic_suffix = string.substring(k, k+palindromic_suffix_length);\n\
    \                    palindromic_suffix_length = 0;\n                    palindromic_suffix_max_length\
    \ = -1;\n                }\n            }\n        }\n        \n        // If\
    \ the length of the longest postfix is greater than the length of the \n     \
    \   // longest palindromic suffix, the length of the longest postfix of the string\
    \ is not suffix.\n        if(palindromic_suffix_length > palindromic_suffix_max_length){\n\
    \            palindromic_suffix = string.substring(i, i+palindromic_suffix_length);\n\
    \            palindromic_suffix_length = 0;\n            palindromic_suffix_max_length\
    \ = -1;\n        }\n        \n        // If we've found a new longest postfix\
    \ and a new longest palindromic suffix, \n        // update the longest palindromic\
    \ suffix.\n        if(palindromic_suffix_length > 0 && max_length < 1){\n    \
    \        max_length = j+1;", "    let max_postfix = 0;\n    let longest_prefix\
    \ = '';\n    let longest_suffix = '';\n    \n    for (let i = 0; i < string.length;\
    \ i++){\n        let prefix = string.substring(0, i);\n        let postfix = string.substring(i,\
    \ string.length);\n        let postfix_reversed = postfix.split('').reverse().join('');\n\
    \        \n        // Break early if we are at the start\n        if (postfix_reversed\
    \ === prefix){\n            break;\n        }\n        \n        // See if we\
    \ can find a palindrome that starts with the current prefix\n        if (postfix_reversed\
    \ === (prefix + postfix_reversed)) {\n            longest_prefix = prefix;\n \
    \           longest_postfix = postfix;\n            \n            if (max_postfix\
    \ < postfix.length){\n                max_postfix = postfix.length;\n        \
    \    }\n        }\n    }\n    \n    if (longest_postfix.length < max_postfix){\n\
    \        return string;\n    }\n    \n    if (longest_prefix.length < max_postfix){\n\
    \        longest_prefix = longest_prefix + longest_postfix.substring(0, max_postfix\
    \ - longest_postfix.length);\n    }\n    \n    return longest_prefix + longest_postfix.substring(0,\
    \ max_postfix);\n}\n", "  var palindrome = \"\",\n      i;\n\n  for(i = 0; i <\
    \ string.length; i++){\n    var j;\n    if(i === (string.length - 1)){\n     \
    \ palindrome += string[i];\n    }\n    for(j = i; j < string.length; j++){\n \
    \     if(string[i] === string[j]){\n        palindrome += string[j]\n      }\n\
    \    }\n  }\n  return palindrome;\n}\n", "    // Find the longest postfix of supplied\
    \ string that is a palindrome\n    let palindrome_suffix = string.slice(-1) //\
    \ \"a\" at the end of \"cat\"\n    let palindrome_postfix = string.padEnd(string.length,\
    \ palindrome_suffix.reverse()) // \"cat\", reversed\n    \n    // Append to the\
    \ end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    return `${string}${palindrome_postfix}${palindrome_suffix}`\n}\n",
  "  if(!string){\n    return \"\"\n  }\n  var reversed_string = \"\"\n  var prefix_string\
    \ = \"\"\n  var suffix_length = 0\n  var suffix_index = 0\n  while(suffix_length\
    \ < string.length){\n    suffix_length = prefix_string.length + suffix_length\n\
    \    suffix_index = string.length - suffix_length\n    prefix_string = string.slice(0,\
    \ suffix_index)\n    reversed_string = reversed_string + string.slice(suffix_index,\
    \ string.length)\n  }\n  reversed_string = reversed_string + string.slice(0, suffix_index)\n\
    \  return prefix_string + reversed_string\n}\n", "    // If string is empty, return\
    \ empty string.\n    if (string === \"\") {\n        return \"\";\n    }\n   \
    \ // If string starts with whitespace, remove it.\n    string = string.trimLeft();\n\
    \    // If string ends with whitespace, remove it.\n    string = string.trimRight();\n\
    \    // Store palindrome in variable called palindrome.\n    let palindrome =\
    \ \"\";\n    let suffixOfPalindrome = \"\";\n    // If string is empty and doesn't\
    \ start with whitespace, return string.\n    if (string === \"\") {\n        return\
    \ string;\n    }\n    // If string is empty, ends with whitespace, return string.\n\
    \    if (string.endsWith(\" \")) {\n        return string;\n    }\n    // Loop\
    \ through string, comparing each character with its reverse.\n    for (let i =\
    \ 0; i < string.length; i++) {\n        let character = string[i];\n        //\
    \ Compare character with its reverse.\n        if (string.charAt(i) === string.charAt(string.length\
    \ - 1 - i)) {\n            // If character matches reverse, store it in variable\
    \ called suffix.\n            suffixOfPalindrome = string.charAt(string.length\
    \ - 1 - i);\n        }\n        // If character isn't equal to the reverse, add\
    \ to palindrome.\n        else {\n            palindrome += character;\n     \
    \   }\n    }\n    // If suffix isn't equal to palindrome, return empty string.\n\
    \    if (suffixOfPalindrome !== palindrome) {\n        return \"\";\n    }\n \
    \   // If the suffix is equal to the palindrome, return string.\n    else {\n\
    \        return string;\n    }\n}", "    if(string == null || string.length ==\
    \ 0) return \"\";\n    let maxLen = 0;\n    let maxPalindrome = \"\";\n    let\
    \ strPrefix = \"\";\n    let palindromeSuffix = \"\";\n    for(let i = 0; i <\
    \ string.length; i++){\n        let charString = string.substring(0, i+1);\n \
    \       palindromeSuffix += charString + make_reverse(charString);\n        maxLen\
    \ = Math.max(maxLen, string.length - i);\n    }\n    for(let i = 0; i < maxLen;\
    \ i++){\n        let charString = string.substring(0, i+1);\n        if(make_palindrome(charString)\
    \ === string){\n            maxPalindrome = charString + palindromeSuffix;\n \
    \           break;\n        }\n    }\n    return maxPalindrome;\n}\n", "    var\
    \ post_fix = string.match(/([a-z]+)$/i),\n        post_fix_string = post_fix[1],\n\
    \        rev_post_fix_string = post_fix_string.reverse().toString(),\n       \
    \ prefix = string.slice(0, string.length - post_fix.length + post_fix_string.length);\n\
    \    return prefix + post_fix_string + rev_post_fix_string;\n}\n</code>\n<|/ a\
    \ tags=javascript,palindrome,reverse,algorithm,string |>\n<| c |>\nWhat would\
    \ happen to strings like 'aa'? Would the postfix would be an empty string?\n<|/\
    \ c |>\n<| c |>\nThank you for the comment, I have updated the code to handle\
    \ this case.\n<|/ c |>\n<| a |>\nI understand this question as being asked to\
    \ write a function that takes a string and returns the string in reverse with\
    \ its original letters intact.\nFor example, if you had the string \"hello\",\
    \ it would be returned as \"olleh\".\nThis is my solution. I'm sure someone else\
    \ can optimize it further but I don't have time right now to optimize it further.\
    \ \n<code>", "    if(string == \"\") return \"\";\n    // Find the first palindromic\
    \ suffix in the string.\n    var suffix = get_palindrome_suffix(string);\n   \
    \ // Find the longest postfix of the string that is a palindrome.\n    var postfix\
    \ = find_longest_postfix_in_string(string, suffix);\n    var palindrome = string.slice(0,\
    \ -suffix.length) + reverse_string(string.slice(0, -postfix.length)) + string.slice(-postfix.length);\n\
    \    return palindrome;\n}\n", "    //Find the postfix that is closest to a palindrome.\n\
    \    //If no such postfix is found, return the original string.\n    var longest_postfix\
    \ = string.substr(0, longestPalindromicSuffix(string.substr(0, string.length)));\n\
    \    return longest_postfix.reverse() + string\n}", "    if(string.length < 2){\n\
    \        return string;\n    }\n    var suffix1 = string.slice(0,-1),\n      \
    \  suffix2 = string.slice(-1);\n    var rev1 = reverse(suffix1),\n        rev2\
    \ = reverse(suffix2);\n    return rev1 + string[0] + rev2;\n}\n</code>\n<|/ a\
    \ dscore=2 tags=palindrome,algorithm |>\n<| a |>\n<code>\nimport java.util.Arrays;\n\
    \npublic class Palindrome{\n    public static void main(String[] args){\n    \
    \    String[] words = new String[]{\n            \"abba\", \"abba\", \"abba\"\
    , \"abbb\", \"abbb\", \"aabb\", \"abba\", \"aabb\", \"abba\", \"aabb\", \"abbb\"\
    \n        };\n        Arrays.sort(words);\n        System.out.println(\"Palindrome\
    \ of \" + Arrays.toString(words) + \" is \" + isPalindrome(words));\n    }\n\n\
    \    private static boolean isPalindrome(String[] words) {\n        String s =\
    \ \"\";\n        for (int i = 0; i < words.length / 2; i++) {\n            s =\
    \ s + words[i];\n        }\n        s = s.toLowerCase();\n        if (words.equals(reverse(s)))\
    \ {\n            return true;\n        } else {\n            return false;\n \
    \       }\n    }\n\n    private static String reverse(String s) {\n        char[]\
    \ chars = s.toCharArray();\n        StringBuilder rev = new StringBuilder();\n\
    \        int iMax = chars.length - 1;\n        for (int i = 0; i < iMax; i++)\
    \ {\n            char c = chars[i];\n            rev.append(c);\n        }\n \
    \       return rev.toString();\n    }\n}\n</code>\n<|/ a tags=palindrome,algorithm\
    \ dscore=1 |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding how and/or why it solves the problem would improve the answer's\
    \ long-term value.\n<|/ c |>\n<| c |>\nThis is very good one, but I cannot understand\
    \ why you use Arrays.sort() while you use Arrays.toString(words)? Could you please\
    \ explain the logic behind that?\n<|/ c |>\n<| c |>\nThis code doesn't check palindrome\
    \ of empty string.\n<|/ c |>\n<| c |>\nIf `words` are empty, `isEmpty()` will\
    \ never be true.\n<|/ c |>\n<| a |>\n<code>\nimport java.util.*;\n\npublic class\
    \ Palindrome{\n    public static void main(String[] args){\n        Scanner sc\
    \ = new Scanner(System.in);\n        System.out.println(\"Enter a string:\");\n\
    \        String s=sc.next();\n        if(s.isEmpty()){\n            System.out.println(\"\
    Empty string cannot be a palindrome\");\n        }\n        else{\n          \
    \  int len=s.length", "    var rev_string = string.replace(/./g,function(char){\n\
    \        return String.fromCharCode(char.charCodeAt(0)-32);\n    });\n    return\
    \ string+rev_string+string.toLowerCase().split('').filter(function(char){\n  \
    \      return char.charCodeAt(0)==char.charCodeAt(0)%32;\n    }).join('');\n}\n",
  "    string = string || \"\";\n    var reverse_prefix_length = 0;\n    var reverse_prefix_string\
    \ = reverse(string,0,string.length-1);\n    \n    var longest_postfix_length =\
    \ getLongestPalindromeRev(string).length;\n    var longest_postfix_string = reverse(string,0,longest_postfix_length-1);\n\
    \    \n    longest_postfix_string = longest_postfix_string + reverse_prefix_string;\n\
    \    \n    return longest_postfix_string;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
