name: HumanEval_2_truncate_number
language: js
prompt: "//Given a positive floating point number, it can be decomposed into\n// and\
  \ integer part (largest integer smaller than given number) and decimals\n// (leftover\
  \ part always smaller than 1).\n// Return the decimal part of the number.\n// >>>\
  \ truncate_number(3.5)\n// 0.5\nfunction truncate_number(number){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = truncate_number;\n  assert.deepEqual(candidate(3.5),0.5);\n  assert.deepEqual(candidate(1.25),0.25);\n\
  \  assert.deepEqual(candidate(123.0),0.0);\n}\n\ntest();"
completions: ["    number = parseFloat(number);\n    var integerPart = (Math.round(number)\
    \ === number) ? number : Math.floor(number);\n    var decimalPart = number - integerPart;\n\
    \    return parseFloat(integerPart) + '.' + parseFloat(decimalPart);\n}\n", "\t\
    let decimals = number%1;\n\tnumber = Math.floor(number);\n\treturn number < 1\
    \ && decimals > 0 ? number:number;\n}\n", "    if(number < 0){\n        number\
    \ = -number;\n    }\n\n    var integer = Math.floor(number);\n    var decimals\
    \ = number - integer;\n\n    var decimals_string = Math.pow(10,decimals);\n  \
    \  if(decimals_string < 1){\n        decimals_string = 1;\n    }\n\n    return\
    \ integer + \"*\" + decimals_string;\n}\n", "\tvar m = Math.pow(10, Math.abs(Math.floor(Math.log(number)/Math.LN10)));\n\
    \treturn Math.round(number*m)/m\n}\n", "  if(number <= 0) return 0;\n  var n =\
    \ number;\n  var scale = Math.pow(10, Math.floor(Math.log(number)/Math.LN10));\n\
    \  number = Math.round(number * scale)/scale;\n  var decimals = number-Math.floor(number);\n\
    \  if(decimals < 0) decimals = 0;\n  return decimals;\n}\n", "  if(number <= 1){\n\
    \    return number;\n  }\n  \n  var factor = Math.pow(10, number_precision(number));\n\
    \  return Math.floor(number*factor)/factor;\n}\n", "    var n = number.toString().split('.');\n\
    \    if (n[1] <= 1)\n        return n[0];\n    return n[0];\n}\n", "  if(!isFinite(number))\
    \ return 0;\n  if(number < 1) return 0;\n  var exp = Math.floor(Math.log(number)\
    \ / Math.LN10);\n  var fp = number - Math.pow(10, exp);\n  var p = Math.pow(10,\
    \ exp);\n  return number<1 || !isFinite(fp) ? 0 : p + (fp*fp > number) ? 0 : fp;\n\
    }\n", "    var precision = Math.pow(10, Math.floor(Math.log(number) / Math.LN10));\n\
    \    return Math.floor(number / precision) * precision;\n}\n", "  var n = number\n\
    \  var i = 0\n  var decimal = 0\n  for(i;i<4;i++){\n    if(Math.round(n*10)/10\
    \ == n){\n      return n\n    }\n    n=n-1\n  }\n  decimal = Math.round(n*10)/10\n\
    \  return decimal\n}\n", "  // return Math.trunc(number);\n  var decimal_number\
    \ = Math.floor(number);\n  var non_decimal_part = number - decimal_number;\n \
    \ var whole_number = Math.trunc(number);\n  var decimals = Math.abs(non_decimal_part);\n\
    \  return decimal_number + \".\" + decimals;\n}\n", "\tlet result = number.toFixed(15);\n\
    \treturn Number(result.split(\".\")[0]);\n}\n", "\tnumberToFixed = function(n,\
    \ p){\n\t\tvar ndecs = p.decimals;\n\t\tvar nstr = String(n);\n\t\tvar fromRight\
    \ = nstr.indexOf('.');\n\t\tif(fromRight == -1){\n\t\t\tndecs = 0;\n\t\t}else{\n\
    \t\t\tndecs = nstr.substring(fromRight + 1, nstr.length).length;\n\t\t}\n\t\t\
    if(ndecs > 0){\n\t\t\tvar ntrunc = nstr.substring(0, fromRight);\n\t\t\tvar fparts\
    \ = ntrunc.split(\".\");\n\t\t\tif(fparts.length >= ndecs){\n\t\t\t\tntrunc =\
    \ fparts[0];\n\t\t\t\tndecs = fparts.length - 1;\n\t\t\t}\n\t\t}\n\t\tvar decs\
    \ = Math.abs(ndecs);\n\t\tvar fnum = ntrunc + '.' + pad(decs);\n\t\tif(fnum.length\
    \ > 10){\n\t\t\treturn fnum;\n\t\t}\n\t\treturn '0';\n\t};\n\tnumber = Math.floor(number);\n\
    \tvar p = number.toString().split('.');\n\tp.reverse();\n\tnumber = number.toString();\n\
    \tif(p.length > 0){\n\t\tnumber = p.slice(0,p.length-1).join('') + '.' + pad(p.length-1);\n\
    \t}\n\treturn number;\n}\n", "  if(number.toString().indexOf('.') === -1){\n \
    \   console.error('Numbers cannot have decimals, use a number without decimal\
    \ part.');\n    return 0;\n  }\n\n  let decimals = 0;\n  let integer = 0;\n  let\
    \ decimal_part = 0;\n  let float_parts = number.toString().split('.');\n  if(float_parts.length\
    \ > 1){\n    integer = parseInt(float_parts[0]);\n    decimal_part = parseInt(float_parts[1]);\n\
    \  }\n\n  if(decimal_part === 0){\n    return integer;\n  }\n\n  decimals = Math.trunc(Math.log10(Math.pow(10,\
    \ decimal_part)));\n  return integer + decimals;\n}\n", "    number = number ||\
    \ 0;\n    return Math.floor(number);\n}\n", "    number = number.toFixed(15);\
    \ // Rounding to 15\n    if(number.indexOf('.') != -1){\n        number = number.split('.')[0];\n\
    \    }\n    return parseFloat(number);\n}\n", "\treturn Math.round(number*1000)/1000;\n\
    }\n", "    if (number < 1) {\n        return 0;\n    }\n    \n    let precision\
    \ = number.toString().split('.')[1].split('e')[0];\n    \n    return Math.trunc(number\
    \ * Math.pow(10, -precision.length));\n}\n", "  var decimals = Math.trunc(number)\
    \ - Math.floor(number)\n  if(decimals > 0){\n    number -= Math.floor(number)\
    \ - number%1\n    return Math.floor(number) + decimals\n  }\n  return Math.floor(number)\n\
    }\n", "  var decimals = number_to_precision(number, ROUND_PRECISION);\n  var whole_decimals\
    \ = Math.ceil(decimals);\n  return Math.floor(decimals + 0.5) + Math.pow(10, whole_decimals\
    \ - decimals);\n}\n", "\tvar i = Math.abs(Math.round(number));\n\treturn i < Math.pow(10,\
    \ 15) ? number * 0 : Math.round(number);\n}\n", "    if(number < 1){\n       \
    \ number = 0.1;\n    }\n\n    return Math.trunc(number);\n}\n", "\tvar parts =\
    \ number.toString().split(\".\");\n\tvar decimals = parts[1] ? parts[1].length\
    \ : 0\n\tvar wholes = parts[0].length\n\t\n\t\n\tif(decimals > 0){\n\t\twhile(wholes\
    \ > 0 && decimals > 0){\n\t\t\tvar temp = wholes\n\t\t\twholes = decimals\n\t\t\
    \tdecimals = temp - decimals\n\t\t}\n\t}\n\t\n\treturn decimals\n}\n", "\t// return\
    \ number < 1 ? 1 : number\n\treturn Math.ceil(number);\n}\n\n", "\treturn Math.round(number\
    \ * 1000) / 1000;\n}\n", "\tvar n = number.toString().split('.')[1]; //get the\
    \ decimal part\n\tn = n.split('-')[0]; //remove everything after the dot\n\tvar\
    \ parts = n.split(''); //get the integer part\n\treturn parts[0] + '' + parts[1];\
    \ //concatenate the two parts and remember to add the dot\n}\n", "    var decimal_part;\n\
    \    if(number % 1 == 0){\n        return number;\n    }\n    var remainder =\
    \ number%1;\n    number = number/1;\n    decimal_part = Math.floor(number);\n\
    \    if(decimal_part == 1){\n        return 0;\n    }\n    return decimal_part;\n\
    }", "    return Math.round(number * 1000) / 1000;\n}\n", "\tif (number < 1) {\n\
    \t\treturn 0;\n\t}\n\tvar dec = number % 1;\n\treturn Math.trunc(number) + dec;\n\
    }\n", "    var s = number.toString();\n    if(s.indexOf('.') != -1){\n       \
    \ s = s.split('.')[1];\n    }\n    return Number(s);\n}\n", "    var dec = number.toString().split('.')[1];\n\
    \    var dec_int = dec ? dec.split('+')[0] : 0;\n    var decimal_part = number.toString().split('.')[0];\n\
    \    return (dec_int>10) ? decimal_part.slice(1) : decimal_part;\n}\n", "  var\
    \ integer_part;\n  var decimal_part;\n  if (number < 1 || number > 0){\n    return\
    \ 0;\n  }\n  decimal_part = Math.floor(Math.abs(number));\n  if (number > 0){\n\
    \    integer_part = decimal_part;\n  } else {\n    integer_part = 0;\n  }\n  return\
    \ integer_part;\n}\n", "    var decimal = number%1;\n    return decimal > 0 ?\
    \ number - decimal : number;\n}\n", "  \n  return Math.floor(number);\n}\n", " \
    \   number = number + 0.5;\n    return number.toFixed(Math.floor(number.toFixed().length)\
    \ - 1);\n}\n", "  var decimals = Math.trunc(number).toString().split(\".\")[1].length,\n\
    \      integer = Math.trunc(number).toString().split(\".\")[0],\n      sign =\
    \ number < 0 ? \"-\" : \"\";\n  \n  if(decimals === 0){\n    return integer +\
    \ \".\" + sign;\n  }\n  return integer + decimals + \".\" + sign;\n}\n", "   \
    \ number = number.toFixed(0);\n    return number.split('.')[1].length < 2 ? 0\
    \ : number.split('.')[1];\n}\nexports.truncate_number = truncate_number;", " \
    \   if(isNaN(number)) return number;\n    return number%1? Math.round(number):\
    \ Math.ceil(number);\n}\n\n", "    var decimal = parseFloat(number).toFixed(1);\n\
    \    return parseInt(decimal, 10);\n}\n", "    if(number < 1){\n        return\
    \ 0;\n    }\n    var decomposed = math.decompose(number),\n        decimals =\
    \ decomposed.decimals;\n    return decomposed.result;\n}\n", "\tnumber = parseFloat(number);\n\
    \tlet decimals = Math.pow(10,Math.floor(Math.log10(number)));\n\treturn Math.trunc(number*decimals)/decimals;\n\
    }\n", "    return Math.floor(number);\n}\n", "    var decimals = Math.abs(number\
    \ - Math.floor(number))\n    if(number <= 0){\n        return Math.floor(number)\n\
    \    }\n    return Math.ceil(number)\n}", "  var decimal_part = Math.trunc(number);\n\
    \  var whole = Math.floor( number );\n  var decimals = decimal - Math.floor(decimal_part);\n\
    \  return whole + decimals;\n}\n", "    if(number <= 1) return 1;\n    if(number\
    \ <= 21) return number;\n    if(number <= 45) return number - Math.round(number\
    \ / 10) * 10;\n    return Math.trunc(number);\n}\n", "\t\n\t// Get and round the\
    \ number\n\tnumber = Math.round(number);\n\t\n\t// Check if the number is smaller\
    \ than the desired number\n\t\n\tif(number < .5){\n\t\t\n\t\t// Return the number\
    \ as is because it already is smaller than 0.5\n\t\t\n\t\treturn number;\n\t\n\
    \t} else if(number < 1){\n\t\n\t\t// Return the number with the decimal part reduced\
    \ by 1 because it is smaller than 1\n\t\t\n\t\treturn Math.round(number*1000)/1000;\n\
    \t\n\t} else {\n\t\n\t\t// The number is a positive number so get the decimal\
    \ part of the number and round it\n\t\t\n\t\treturn Math.round(number*1000)/1000;\n\
    \t\n\t}\n\t\n}\n", "\tvar parts = number.toString().split(\".\");\n\tparts[0]\
    \ = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n\treturn parseFloat(parts.join(\"\
    .\"))\n}\n", "  if(number > 0){\n    var dec = Math.floor(number);\n    if(dec\
    \ == number){\n      return 0;\n    }\n    return number - dec;\n  }\n  return\
    \ number;\n}\n", "\tvar x = Math.abs(number);\n\tvar decimal = x > 1000 ? Math.log(number)\
    \ / Math.LN10 : Math.pow(10, Math.round(x));\n\treturn number < 1 ? 1 : Math.floor(number\
    \ + decimal);\n}\n\n", "    var exponent = Math.floor(Math.log10(Math.abs(number))),\n\
    \        fraction = number - Math.floor(number),\n        decimals = Math.pow(10,\
    \ exponent);\n    return Math.round(number * decimals) / decimals;\n}\n", "\t\
    let decimal_digits = number.toString().split('.')[1];\n\treturn Math.trunc(number);\n\
    }\n", "    if(number < 1){\n        number = 1;\n    }\n    return Math.trunc(number);\n\
    }\n", "  if(number<0){\n    number=-number;\n  }\n  const splitted=number.toString().split('.');\n\
    \  if(splitted[1].length>0){\n    return splitted[0];\n  }\n  return splitted[0];\n\
    }\n", "\tlet decimal = number % 1;\n\tlet integer;\n\n\tif (decimal >= 0.5){\n\
    \t\tinteger = Math.floor(number);\n\t} else {\n\t\tinteger = Math.ceil(number);\n\
    \t}\n\n\treturn (integer % 1) * Math.pow(10, integer.toString().length - 1);\n\
    }\n", "\tlet decimals = truncate_decimals(number);\n\tlet integer_part = Math.floor(number);\n\
    \treturn (decimals==0) ? (integer_part) : (integer_part+\".\"+decimals);\n}\n",
  "    if(!isFinite(number) || number < 1){\n        return 0;\n    }\n    var exponent\
    \ = Math.floor(Math.log10(number));\n    var decimals = Math.pow(10, exponent\
    \ - 1);\n    return Math.trunc(number * decimals) / decimals;\n}\n", "    \n \
    \   // If the number is positive and larger than 1, then there is no decimal part.\n\
    \    // For example: truncate_number(2.5) = 2, but truncate_number(3) = 1.\n \
    \   if(number >= 1 && number <= 2){\n        return Math.trunc(number);\n    }\n\
    \    \n    var decimal_part = Math.trunc(number),\n        integer = Math.round(decimal_part),\n\
    \        parts = [integer];\n    \n    if(decimal_part > number){\n        integer\
    \ = Math.round(number / 10);\n        parts.push(integer);\n    }\n    \n    return\
    \ parts.reverse().map(function(part){\n        return part > 9 ? part - 9 : part;\n\
    \    }).join('');\n}\n", "    if(number >= 1){\n        return Math.floor(number);\n\
    \    }else{\n        if(Math.abs(number) >= 1){\n            return Math.round(number);\n\
    \        }else{\n            return Math.round(number * 100) / 100;\n        }\n\
    \    }\n}\n</code>\n<|/ a |>\n<| c |>\nthis was an awesome solution\n<|/ c |>\n\
    <| c |>\nIf `number` can be negative, then `Math.round` should be changed to `Math.floor`.\n\
    <|/ c |>\n<| a tags=truncate,javascript,rounding |>\n<code>\nMath.round(x) ==\
    \ Math.ceil(x) ? x : Math.round(x) - 1;\n</code>\n<|/ a dscore=4 |>\n<| c |>\n\
    I wouldn't use `Math.round` because this would fail for negative numbers. Instead,\
    \ I'd use `Math.max`, like so: `Math.max(Math.ceil(x), x) - 1`\n<|/ c |>\n<| c\
    \ |>\nyes `Math.ceil` is what I meant :)\n<|/ c |>\n<| a tags=truncate,javascript,rounding\
    \ |>\n<code>", "\tlet decimal = number % 1;\n\treturn decimal;\n}\n", "  // If\
    \ the given number is bigger than 100, it is 100 times larger\n  if(number > 100){\n\
    \    return Math.round(number * 100) / 100;\n  }\n\n  // If the number is in range,\
    \ return number\n  if(number > 0){\n    return Math.round(number);\n  }\n\n  //\
    \ If number is negative, return negative number\n  if(number < 0){\n    return\
    \ Math.ceil(number);\n  }\n\n  // If none of the above are true, return the given\
    \ number\n  return number;\n}\n", "    if(number < 1){\n        return 0;\n  \
    \  }\n    var dec = number,\n        place = 1,\n        decimals = 1;\n    if(dec\
    \ == 0){\n        return number;\n    }\n    if(Math.floor( dec ) != dec){\n \
    \       dec *= Math.pow(10,place);\n        place--;\n    }\n    while(decimal\
    \ > dec){\n        decimal /= 10;\n        place++;\n    }\n    return number;\n\
    }\n", "    number = number.toString();\n    if(number.indexOf('.') !== -1){\n\
    \        var left_digits = number.split('.');\n        var right_digits = left_digits[1].split('');\n\
    \        if(right_digits.length !== 0){\n            if(right_digits.length <\
    \ left_digits[1].length){\n                right_digits = right_digits.concat(left_digits[1].slice(0,right_digits.length));\n\
    \                number = left_digits[0] + '.' + right_digits.join('');\n    \
    \        }else{\n                number = left_digits[0] + '.' + right_digits.join('');\n\
    \            }\n        }\n    }\n    return number;\n}\n", "  var parts = number.toString().split('.')\n\
    \  return parts[0].length > parts[1] ? parts[0] + '.' + parts[1].substring(0,\
    \ 1) : parts[0]\n}\n", "  var decimal = number.toString().split('.')[1];\n  return\
    \ decimal?parseInt(decimal):0;\n}", "  var decimal_length = Math.floor(Math.abs(number).toString().split('e-')[0].length);\n\
    \  if(decimal_length > 0){\n    number = Math.round(number);\n  }\n  return number;\n\
    }\n", "    if(!number)\n        number = 0.0;\n    var p = number.toString().split(/[eE]/);\n\
    \    if(p.length === 1)\n        return Math.trunc(number);\n    else\n      \
    \  return Math.round(p[0]) + Math.trunc(p[1]);\n}\n", "  if (number < 1) return\
    \ 0;\n\n  var pow = Math.pow(10, PRECISION);\n  var precision = Math.pow(10, PRECISION\
    \ - PRECISION);\n  var integer_part = Math.floor(number * pow);\n  var decimal_part\
    \ = number - integer_part;\n\n  // Round off decimal part if decimal part is not\
    \ zero\n  if (decimal_part !== 0){\n    decimal_part =  Math.ceil(decimal_part\
    \ * precision) / precision;\n  }\n\n  return decimal_part;\n}\n\n", "    // Return\
    \ the largest integer smaller than the given number.\n    var integer_part = (Math.floor(number)\
    \ + Math.ceil(number)) / 2;\n    var decimal_part = number - integer_part;\n \
    \   return decimal_part;\n}\n", "    const parts = Math.log10(Math.abs(number)).toFixed(1);\n\
    \    const decimals = parts - parts.length % 1;\n    const decimals_negative =\
    \ decimals < 0;\n    return Math.abs(number) > 1 && decimals_negative ? -Math.floor(Math.abs(number))\
    \ : Math.floor(Math.abs(number));\n}\n", "\tif (number<0.5){\n\t\treturn Math.floor(number);\n\
    \t}\n\tif (number<1){\n\t\treturn 0.5;\n\t}\n\tvar decimals = Math.ceil(Math.log(number)/Math.LN10);\n\
    \treturn Math.floor(number*Math.pow(10,decimals))/Math.pow(10,decimals);\n}\n",
  "\tlet n = Math.round(number);\n\tlet r = n - (n % 1);\n\treturn r;\n}\n", "  if\
    \ (number > 1) return 1;\n  if (number < -1) return -1;\n  var result = (number\
    \ * Math.pow(10, Math.floor(Math.log(number) / Math.LN10)));\n  return result\
    \ / Math.pow(10, Math.floor(Math.log(number) / Math.LN10) - 1);\n}\n", "    number\
    \ = number.toFixed(7);\n    number = number.replace(\".\", \"\");\n    return\
    \ Number(number);\n}\n", "\tif(number >= 1){\n\t\treturn Math.trunc(number);\n\
    \t} else {\n\t\treturn Math.floor(number);\n\t}\n}\n", "  if(number < 1)\n   \
    \ return number;\n  return number - Math.floor(number);\n}\n", "  var decimals\
    \ = Math.floor(number);\n  return decimals > 0 ?\n      number - decimals + '0'\
    \ : number + '0';\n}\n", "  if (number < 1) return 0;\n  return Math.round(number);\n\
    }\n", "\tvar decimals = Math.abs(number).toString().split(\".\")[1];\n\treturn\
    \ number < 1 ? '0.'+decimals+'e+0' : '0.'+decimals+(number.toString().split(\"\
    .\")[0].length-1)+'e-'+(number.toString().split(\".\")[0].length-1);\n}\n", "\t\
    if (number < 1){\n\t\tthrow (\"Cannot truncate number. Number must be positive\"\
    );\n\t}\n\tvar decimals = Math.floor(Math.log10(number));\n\tvar remainder = (number-Math.pow(10,-decimals)).toFixed(decimals);\n\
    \treturn parseFloat(remainder);\n}\n", "    return Math.floor(number - 0);\n}\n",
  "\treturn truncate_number_impl(number, 0);\n}\n", "  var decimals = Math.floor(Math.log(number)/Math.LN10);\n\
    \  return Math.trunc(number/Math.pow(10,decimals));\n}\n", "  var x = number.toString().split('.')\n\
    \  return x[0] + (x.length > 1 ? x[1] : '0')\n}\n\n", "  return Math.floor(number);\n\
    }", "\tnumber = Math.floor(number);\n\tvar decimal_part_of_number = number - truncate_number(Math.round(number));\n\
    \treturn (decimal_part_of_number < 0.5 ? number - 1 : number);\n}\n", "\treturn\
    \ number < 1 ? number : Math.floor(number);\n}\n", "\tnumber = number.toFixed(10);\n\
    \t\n\tlet decimal_part = number.split('.')[1];\n\tlet integer_part = number.split('.')[0];\n\
    \t\n\tlet integer_integerPart = (parseFloat(integer_part) / 100).toFixed(10);\n\
    \t\n\treturn integer_part + decimal_part;\n}\n", "  if(number < 1) return 0;\n\
    \  if(number > 9) return 10;\n  var decimal_part = Math.floor(number);\n  var\
    \ whole_part = number - decimal_part;\n  return decimal_part + \".\" + whole_part;\n\
    }\n", "\tnumber = Math.round(number);\n\tvar dec = number.toString().split('.')[1]\
    \ || '';\n\treturn (dec) ? parseFloat(dec) : number;\n}\n", "  if(number<0){\n\
    \    number=-number;\n  }\n\n  var decimal_part = number%1;\n  if(decimal_part\
    \ < 0.1){\n    decimal_part = 0;\n  }\n\n  var number = Math.round(number);\n\n\
    \  return number/Math.pow(10, decimal_part);\n}\n", "    var is_integer = number\
    \ % 1 === 0,\n        number_as_float = parseFloat(number),\n        decimal_part\
    \ = Math.floor(number_as_float);\n    return (is_integer && decimal_part === number_as_float)\
    \ \n        ? number \n        : (number - decimal_part);\n}\n\n", "    var n\
    \ = number\n    if (typeof n != \"number\" || n <= 0) {\n        n = 1\n    }\n\
    \    while (n > 0){\n        n--\n    }\n    return Math.trunc(n) + 0.0001\n}\n\
    \n", "    var number_str = number.toString();\n    var parts = number_str.split('.');\n\
    \    return parts[0].replace(/0*(\\d)$/, \"$1\");\n}\n", "\tvar decimal_part =\
    \ Math.floor(number);\n\tif((decimal_part % 1) == 0)\n\t\treturn number; // integer\
    \ part\n\telse\n\t\treturn number - decimal_part;\n}\n", "    let decimals = Math.floor(Math.log10(number));\n\
    \    return ((number/Math.pow(10,decimals)).toFixed(1)*Math.pow(10,decimals))\n\
    }", "    if (number < 1)\n        return 0;\n    var digit = number.toString().split('e');\n\
    \    return Math.round(parseInt(digit[1] + 'e' + (digit[0] ? -digit[0].length\
    \ : -1), 10) * Math.pow(10, digit[0].split('.')[1].split('+').length)) / (Math.pow(10,\
    \ digit[0].split('.')[1].split('+').length) || 1);\n}\n", "\treturn Math.trunc(number);\n\
    }\n", "  if (number < 1) {\n    throw new RangeError('Input is smaller than 1!');\n\
    \  }\n\n  var a = Math.round(number);\n  var b = number % 1;\n  return a - (Math.floor(a/b)*b);\n\
    }\n", "    if (number.toFixed) return number.toFixed(0);\n    var zeros = Math.floor(Math.log(number)/Math.LN10);\n\
    \    return Math.trunc(number * Math.pow(10, zeros)) / Math.pow(10, zeros);\n\
    }\n", "\tlet integer_part;\n\tlet decimal_part;\n\tif(number > 1){\n\t\tlet new_number\
    \ = Math.floor(number);\n\t\tlet decimals = number - new_number;\n\t\tdecimal_part\
    \ = number % 1;\n\t\tlet remainder = number;\n\t\tlet remainder_as_string = String(remainder);\n\
    \t\t\n\t\tfor(let i = remainder_as_string.length - 1; i >= 0; i--){\n\t\t\tif(remainder_as_string[i]\
    \ !== '.' || i === 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlet new_remainder\
    \ = remainder_as_string.substring(0, i + 1);\n\t\tinteger_part = new_number;\n\
    \t\tdecimal_part = decimal_part * new_remainder.length / new_remainder.length;\n\
    \t} else {\n\t\tinteger_part = Math.floor(number);\n\t\tdecimal_part = number\
    \ % 1;\n\t}\n\tlet integer_part_as_string = String(integer_part);\n\tfor(let i\
    \ = integer_part_as_string.length - 1; i >= 0; i--){\n\t\tif(integer_part_as_string[i]\
    \ !== '.' || i === 0){\n\t\t\tbreak;\n\t\t}\n\t}\n\tlet integer_part = integer_part_as_string.substring(0,\
    \ i + 1);\n\treturn { integer_part, decimal_part };\n}\n", "    var dec=Math.pow(10,Math.floor(Math.log(Math.abs(number))/Math.LN10));\n\
    \    return Math.ceil(number*dec)-dec;\n}\n", "  number = parseFloat(number);\n\
    \  if(number < 1){\n    number = 1;\n  }\n  if(number > 10000000000000){\n   \
    \ number = number / 10000000000000; // 100 million\n  }\n  return number;\n}\n",
  "\t\n\tvar decimals = Math.pow(10, Math.floor(Math.log(number) / Math.LN10)),\n\t\
    \twhole_number_part = Math.floor(number / decimals),\n\t\tdecimal_part = number\
    \ - whole_number_part * decimals,\n\t\tinteger,\n\t\tfraction;\n\t\n\t\n\t\n\t\
    if (whole_number_part > 5) {\n\t\tinteger = whole_number_part;\n\t\tfraction =\
    \ 1;\n\t} else {\n\t\tfraction = whole_number_part % 1;\n\t\tinteger = whole_number_part;\n\
    \t}\n\t\n\t\n\treturn {\n\t\tinteger: integer,\n\t\tdecimals: decimals,\n\t\t\
    fraction: fraction\n\t};\n}\n\n", "\tlet digits = String(number).split('.');\n\
    \tlet decimal = String(number).split('.')[1];\n\treturn Number(digits.pop()) +\
    \ '.' + decimal;\n}\n", "\tvar int_part = 0;\n\tvar decimal_part = parseInt(number);\n\
    \n\tif (number > 0){\n\t\tint_part = parseInt(number / Math.pow(10, decimal_part));\n\
    \t}\n\n\treturn int_part * Math.pow(10, decimal_part);\n}\n", "  return Math.trunc(number);\n\
    }\n", "\tvar digits = Math.round(number * Math.pow(10, precision)) / (Math.pow(10,\
    \ precision));\n\treturn digits > 1 ? digits : 1;\n}\n", "  if(number<1){\n  \
    \  return 1;\n  }\n  var exp = Math.floor(Math.log(number)/Math.LN10);\n  var\
    \ fpart = Math.floor(number-Math.pow(10,exp));\n  fpart = fpart+Math.pow(10,exp-Math.floor(Math.log(number)/Math.LN10));\n\
    \  if(exp<-3){\n    exp=-exp;\n  }\n  var decimals = exp/3;\n  if(decimals>0){\n\
    \    fpart *= Math.pow(10,decimals);\n  }\n  return fpart;\n}", "    var p = Math.pow(10,\
    \ Math.floor(Math.log(number) / Math.LN10));\n    return Math.floor(number * p)\
    \ / p;\n}", "    if(isNaN(number)){\n        return NaN;\n    }\n    \n    if(number\
    \ < 0){\n        return NaN;\n    }\n    \n    var s = number.toString();\n  \
    \  \n    var decimalIndex = s.indexOf(\".\");\n    if(decimalIndex != -1){\n \
    \       s = s.substr(0, decimalIndex + 1);\n    }\n    \n    var integerIndex\
    \ = s.indexOf(\".\");\n    if(integerIndex != -1){\n        return parseFloat(s.substr(0,\
    \ integerIndex));\n    }\n    \n    return parseFloat(s);\n}\n", "    var part1\
    \ = Math.floor(number);\n    var part2 = number - part1;\n    \n    // the number\
    \ can't be represented as a finite number\n    // If it is, return the first part\
    \ of the number\n    if (part2 == Number.POSITIVE_INFINITY){\n        return part1;\n\
    \    }\n    \n    // number > 0, so part1 is the integer part and part2 is the\
    \ decimal part\n    var decimals = part2;\n    \n    // part1 can't be zero\n\
    \    if (part1 == 0){\n        return 0;\n    }\n    \n    //part2 > 0, so decimals\
    \ is the decimal part\n    if (part2 > 0){\n        decimals = part2;\n    }\n\
    \    \n    return part1 + decimals;\n}\n", "  if(number < 1)\n    return 0;\n\
    \  else\n    return Math.floor(number);\n}\n", "  return Math.trunc(number);\n\
    }\n", "    var num_str = number.toString();\n    return num_str.split(\".\")[0];\n\
    }\n", "\t// We need to use Number.parseFloat here, because we can't assume that\n\
    \t// numbers are whole numbers. Some numbers, like 0.4 or -5.7, have decimal\n\
    \t// parts which would mess this up.\n\tvar decimal_part = parseFloat(number.toFixed(1));\n\
    \treturn Math.ceil(decimal_part);\n}\n", "\tlet integer_part = Math.floor(number);\n\
    \tlet decimal_part = number - integer_part;\n\treturn Math.trunc(decimal_part);\n\
    }\n", "    if (number < 1) {\n        return 0;\n    } else {\n        var whole\
    \ = Math.floor(number);\n        var decimal = number - whole;\n        return\
    \ whole + decimal;\n    }\n}\n", "\tif(number < 1){\n\t\tthrow 'number must be\
    \ positive';\n\t}\n\tif(number == 0 || number % 1 > 0){\n\t\treturn 0;\n\t}\n\t\
    var integer_part = 0;\n\tvar decimal_part = number - truncate_number(number%1);\n\
    \tvar remainder = number%1;\n\twhile(remainder >= 1){\n\t\tnumber = number/1;\n\
    \t\tremainder = number%1;\n\t\tinteger_part++;\n\t}\n\tif(remainder == 0){\n\t\
    \tdecimal_part++;\n\t}\n\treturn decimal_part;\n}\n", "  var is_negative = number\
    \ < 0;\n  var whole = Math.floor(number);\n  var decimal = Math.abs(whole % 1);\n\
    \  var fraction = Math.round(number-decimal);\n  if (fraction < 1){\n    fraction\
    \ = 1;\n  }\n  return is_negative ? -decimal : decimal;\n}\n", "  var decimals\
    \ = Math.pow(10, Math.floor(Math.log(number) / Math.LN10));\n  return Math.floor(number\
    \ / decimals) * decimals;\n}\nmodule.exports = truncate_number;\n\n},{}],33:[function(_dereq_,module,exports){",
  "\tlet dec = Math.pow(10, Math.round(Math.log(number)/Math.LN10));\n\treturn Math.trunc(number*dec)/dec;\n\
    }\n", "  var decimal = number%1;\n  if (decimal >= 0.5){\n    var whole = Math.floor(number);\n\
    \    return whole + decimal;\n  }else{\n    return Math.round(number);\n  }\n\
    }\n", "    if ( number <= 1){\n        return number;\n    }\n    var digits =\
    \ Math.floor(Math.log(number)/Math.LN10);\n    return Math.ceil(number/Math.pow(10,\
    \ digits).toString().replace('.', ''))\n}\n\n", "    if(number <= 0){\n      \
    \  return 0;\n    }\n    if(number < 1){\n        return number;\n    }\n    let\
    \ integer_part;\n    let decimals;\n    const exp = Math.floor(Math.log(number)/Math.log(10));\n\
    \    switch(exp){\n        case 0:\n            integer_part = Math.floor(number);\n\
    \            decimals = 0;\n            break;\n        case 1:\n            integer_part\
    \ = Math.floor(number);\n            decimals = 1;\n            break;\n     \
    \   case 2:\n            integer_part = Math.ceil(number);\n            decimals\
    \ = 0;\n            break;\n        case 3:\n            integer_part = Math.ceil(number);\n\
    \            decimals = 1;\n            break;\n        default:\n           \
    \ integer_part = Math.floor(number);\n            decimals = exp+1;\n        \
    \    break;\n    }\n    return Math.round(number*Math.pow(10,decimals))/Math.pow(10,decimals);\n\
    }\n", "    if(number<10) return number;\n    if(number<100) return parseInt(number);\n\
    \    if(number<1000) return parseFloat(number);\n    if(number<10000) return parseInt(number)/10;\n\
    }\nexports.truncate_number=truncate_number;\n", "  var fraction = number.toString().split('.')[1];\n\
    \  if(fraction === undefined){\n    fraction = '0';\n  }\n  var integerPart =\
    \ number.toString().split('.')[0];\n  if(integerPart === undefined){\n    integerPart\
    \ = 0;\n  }\n  return parseInt(integerPart) + parseFloat(fraction);\n}\n", "\t\
    return number<0?-truncate_number(-number):(number%1)+number%1;\n}\n", "    var\
    \ decimal_part = Math.trunc(number);\n    var integer = decimal_part % 1;\n  \
    \  if (integer >= 1){\n        return Math.trunc(number);\n    }\n    return decimal_part;\n\
    }\n", "    var int_part=Math.trunc(number);\n    var dec_part=number-int_part;\n\
    \    var dec_part_string=dec_part.toString();\n    if (dec_part_string.length==1&&dec_part_string==\"\
    .\"){\n        dec_part_string=\"\";\n    }\n    return int_part+dec_part_string;\n\
    }", "    return number%1;\n}\n", "    var decimals = Math.pow(10,Math.floor(Math.log(Math.abs(number))/Math.LN10));\n\
    \    return Math.floor(number*decimals)/decimals;\n}\n", "\tif(number < 1) return\
    \ 0;\n\tvar n = number.toExponential().split('e');\n\tif(n[1]==undefined) return\
    \ n[0];\n\tif(n[1]=='') return n[0];\n\tvar dp = n[1].split('');\n\tif(dp.length\
    \ >= 2){\n\t\tvar dd = Math.max(0, dp[1].length);\n\t\tif(dd==0) return n[0];\n\
    \t\treturn n[0]+'.'+dp.slice(1).join('');\n\t}\n\treturn n[0];\n}\n", "    //\
    \ The number must be larger than 0\n    if (!number || number <= 0 ){\n      \
    \  throw {name: 'InvalidArgument', message: 'The given value is not a positive\
    \ floating point number.'};\n    }\n\n    // If the number is negative, return\
    \ the floor of it\n    if (number < 0 ){\n        number = -number;\n    }\n\n\
    \    // Get only the decimal part\n    var fraction = number % 1;\n\n    // If\
    \ the fraction is bigger than 1, we divide it by the number until we get no fractional\
    \ part\n    while (fraction >= 1 ){\n        number = Math.floor(number / 10);\n\
    \        fraction = number % 1;\n    }\n\n    // Return it\n    return number;\n\
    }\n", "    const decimals = (number * (10 ** Number.EPSILON)).toFixed(Number.EPSILON)\n\
    \    return Math.round(decimals)/10\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\n\
    Works great for me! Thanks.\n<|/ c |>\n<| c |>\n`Number.EPSILON` should be `1e-16`,\
    \ not `1e-9`.\n<|/ c |>\n<| c |>\nThanks, fixed it\n<|/ c |>\n<| c |>\nNumber.EPSILON\
    \ is now `Math.pow(10,-15)`.\n<|/ c |>\n<| a |>\nUsing Math.trunc is insufficient\
    \ because you lose the decimal places. For example, the number 5.5 will still\
    \ be rounded up to 6, with Math.trunc it will be 5.\nTo overcome this problem\
    \ you can simply add 0.5 to the number before truncating it. This will remove\
    \ the decimal places.\n<code>\nMath.trunc((num + 0.5) * 1000) / 1000;\n</code>\n\
    <|/ a dscore=4 tags=javascript |>\n<| c |>\nI disagree with this. The value of\
    \ 5.5 is 5.5, not 5; 5.5 rounds to 6. Math.trunc is not the problem.\n<|/ c |>\n\
    <| c |>\n`Math.trunc` should be the problem. The problem is that it rounds off\
    \ the decimal places, which is not what OP wants to do.\n<|/ c |>\n<| c |>\nI\
    \ agree with Adeneo; I find this solution more elegant and easier to understand,\
    \ but I still disagree with Adeneo.\n<|/ c |>\n<| c |>\nYou're right. I misunderstood\
    \ what OP was trying to do. I have edited my answer to reflect this.\n<|/ c |>\n\
    <| a tags=javascript |>\nAnother option is to round the number to an integer and\
    \ then use Math.floor:\n<code>\nMath.floor(0.2 + 0.4)  // 0.30000000000000004\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis is a much better solution than Math.trunc\
    \ because it will not mess up the decimals and will always round down. Nice!\n\
    <|/ c |>\n<| c |>\nThis answer should be higher\n<|/ c |>\n<| c |>\nIt's more\
    \ accurate\n<|/ c |>\n<| a tags=javascript dscore=4 |>\nYou can use Math.round()\
    \ for that:\n<code>\nMath.round(0.0987);   // 1\n</code>\nThis should do the trick.\n\
    <|/ a |>\n<| c |>\nDoesn't seem like it", "  var result = Math.trunc(number);\n\
    \  if(result > number) return result;\n  return number;\n}\n", "\tlet decimals\
    \ = (number.toString().split('.')[1] || \"\").split('').map(function(d){ return\
    \ parseInt(d); });\n\tlet integer = parseInt(number.toString().split('.')[0]);\n\
    \tlet precision = (decimals[0] || 1) + (decimals[1] || 0);\n\tif(precision > 0){\n\
    \t\tnumber = Math.round(number * Math.pow(10, precision)) / Math.pow(10, precision);\n\
    \t}else{\n\t\tnumber = Math.floor(number);\n\t}\n\tif(isNaN(number)){\n\t\treturn\
    \ 0.0;\n\t}\n\treturn number;\n}\n", "    var parts = number.toString().split(\"\
    .\");\n    return Math.round(parts[1]);\n}\n", "\tif(number < 1)\n\t\treturn 0;\n\
    \telse{\n\t\tvar integer = Math.floor(number);\n\t\tvar decimal = number - integer;\n\
    \t\tif(decimal >= 0.5){\n\t\t\treturn integer;\n\t\t}\n\t\telse{\n\t\t\treturn\
    \ integer + 1;\n\t\t}\n\t}\n}\n", "    return number > 0 ? Math.floor(number)\
    \ : Math.ceil(number);\n}\n", "    var splitNumber = number.toString().split(\"\
    .\");\n    if(splitNumber.length === 1){\n        return 0;\n    }\n    return\
    \ splitNumber[1].length || 0;\n}\n", "    number = number - Math.round(number);\n\
    \    number = Math.round(number);\n    number = number / 10;\n    number = Math.pow(10,\
    \ Math.floor(number));\n    return number;\n}\n", "    number = number - Math.floor(number);\n\
    \    if(number < 0)\n        number = 0;\n    else if(number === 0)\n        number\
    \ = 0;\n    else if(number === Infinity)\n        number = Infinity * -1;\n  \
    \  else if(number === -Infinity)\n        number = -Infinity * -1;\n    else\n\
    \        number = Math.round(number);\n    \n    // Round to nearest integer part\n\
    \    return number;\n}\n", "\tlet [integer, decimals] = parseInt(number.toString().split(\"\
    .\")[1] || \"0\");\n\tif (integer == 0) { return decimals > 0 ? number/Math.pow(10,decimals)\
    \ : number; }\n\tlet fraction = Math.pow(10,decimals);\n\treturn (Math.floor(number*fraction)/fraction).toFixed(decimals);\n\
    }", "  var integer = Math.floor(number);\n  var decimals = number - integer +\
    \ 1;\n  return Math.trunc(decimals);\n}\n", "  return Math.trunc(number);\n}\n",
  "  var integer_part;\n  var remaining_decimals;\n  if (number <= -Math.pow(10, 30))\
    \ \n    integer_part = 0;\n  else if (number <= -Math.pow(10, 30)) \n    integer_part\
    \ = number;\n  else \n    integer_part = Math.floor(number);\n\n  remaining_decimals\
    \ = number - integer_part;\n\n  return integer_part + (remaining_decimals % 1\
    \ > 0 ? 1 : 0);\n}\n", "\tlet decimals = 1;\n\twhile (number >= 1){\n\t\tnumber\
    \ /= 10;\n\t\tdecimals++;\n\t}\n\tconsole.log(decimals)\n\treturn number * Math.pow(10,\
    \ decimals);\n}\n", "    var parts = number_to_delimited_string(number, false);\n\
    \    var decimals = parseInt(parts[2], 10);\n    return parts[1] + '.' + decimals;\n\
    }\n", "    number = Number(number);\n    if(number < 1) return 0;\n    var int_part\
    \ = Math.floor(number);\n    var dec = number - int_part;\n    if(dec) return\
    \ truncate_number(dec);\n    return int_part;\n}\n", "    let fraction = number\
    \ % 1;\n    return Math.floor(number/1) + (fraction*truncate_number(fraction));\n\
    }\n", "    if(number < 1){\n        return 0;\n    }\n\n    var decimalPart =\
    \ Math.floor((number-1)*10e+1) / 1e1;\n    return Math.floor(decimalPart) + decimalPart/10\n\
    }\n", "    var factor = Math.pow(10,Math.floor(Math.log(number)/Math.LN10));\n\
    \    return Math.floor(number * factor) / factor;\n}\n", "  if(number < 1)\n \
    \   throw new Error(\"Number should be positive\");\n  var fractionalPart = Math.floor(number);\n\
    \  var integerPart = number - fractionalPart;\n  var decimalPart = Math.trunc(number);\n\
    \  return decimalPart;\n}\nexports.truncate_number = truncate_number;\n", "  \
    \  var decimal_places = Math.ceil(Math.log10(number));\n    if(decimal_places\
    \ >= 5) {\n        if(number > 1){\n            return Math.round(number);\n \
    \       } else {\n            return 1;\n        }\n    }\n    return Math.trunc(number);\n\
    }\n", "  var decimals = Math.floor(Math.log(number)/Math.LN10);\n  if (number\
    \ < 1){\n    return 1;\n  }\n  if (number >= 10) {\n    return Math.round(number/Math.pow(10,decimals)*Math.pow(10,decimals))\
    \ - Math.floor(number/Math.pow(10,decimals)*Math.pow(10,decimals));\n  }\n  return\
    \ Math.trunc(number/Math.pow(10,decimals));\n}\n", "    var decimal_part = Math.trunc(number);\n\
    \    return decimal_part + (decimal_part % 1 === 0 ? 0 : 1);\n}\n", "    let decimals\
    \ = number%1\n    number = Math.floor(number)\n    let decimal_part = number-decimals\n\
    \    if(decimal_part < 0.5){\n        decimal_part = 1\n    }\n    return decimal_part\n\
    }", "\treturn Math.ceil(number - 0.5) + 0.5;\n}\n", "\tlet decomposed = decompose(number);\n\
    \tlet decimal_part = decomposed.decimal;\n\tlet int_part = decomposed.integer;\n\
    \tif (int_part > decimal_part){\n\t\tlet temp = decimal_part;\n\t\tdecimal_part\
    \ = int_part;\n\t\tint_part = temp;\n\t}\n\t\n\treturn int_part + decimal_part;\n\
    }\n", "    var decimal_part_part = number%1;\n    if(decimal_part_part < 0.5){\n\
    \        var whole_part_part_of_number = Math.floor(number);\n        return whole_part_part_of_number;\n\
    \    } else {\n        return Math.floor(number);\n    }\n}\n", "\t// number must\
    \ be float\n\tnumber = number|0;\n\tvar part1 = Math.floor(number);\n\tvar part2\
    \ = Math.ceil(number);\n\treturn part2-(part1+1);\n}\n", "\tvar decimal = 0;\n\
    \tnumber = Math.round(number);\n\tnumber = number - Math.floor(number);\n\tdecimal\
    \ = number % 1;\n\treturn number + (decimal === 0 ? 0 : decimal);\n}\n", "   \
    \ var re1 = /\\.(\\d+)$/;\n    var re2 = /\\.0*$/;\n    if(!re1.test(number)){\n\
    \        if(!re2.test(number))\n            return number;\n        number = parseFloat(number)\
    \ + 1;\n    }\n    return Math.floor(number);\n}\nexports.truncate_number = truncate_number;\n",
  "  return Math.round(number);\n}\n", "  if(number < 1){\n    return 0;\n  }\n  if(number\
    \ > 0){\n    return Math.floor(number);\n  }\n  var decimals = Math.abs(number\
    \ - Math.floor(number));\n  if(Math.abs(decimals) > .5){\n    return Math.floor(number);\n\
    \  }\n  return number;\n}\n", "\t// Return 0 if number < 0\n\tif (number < 0){\n\
    \t\tnumber = 0;\n\t}\n\tif (number == Math.floor (number)){\n\t\treturn Math.floor(number);\n\
    \t}\n\tif (number == (number | 0) == (number | 0) % (number | 0)){\n\t\treturn\
    \ number;\n\t}\n\tvar decimals = number * Math.pow(10, Math.floor(Math.log(number)\
    \ / Math.LN10));\n\treturn number % Math.pow(10, Math.floor(Math.log(decimals)\
    \ / Math.LN10));\n}\n", "\tvar whole_number = Math.floor(number),\n\t\tdecimal_part\
    \ = number - whole_number;\n\tif(decimal_part >= 1){\n\t\treturn whole_number\
    \ + \".\" + decimal_part.toString();\n\t}else{\n\t\treturn whole_number.toString();\n\
    \t}\n}\n", "  var decimal = (Math.round(number)).toFixed(1).split('.')[1] || 0;\n\
    \  var whole = Math.floor(number);\n  if(whole > 0 && decimal){\n    whole++;\n\
    \  }\n  return whole + '.' + decimal;\n}\n", "    var fraction = parseFloat(number).toFixed(10)\
    \ - 0;\n    var decimals = parseFloat(fraction) * Math.pow(10,-fraction.length);\n\
    \    return decimals.toFixed(10);\n}\n", "\tvar factor = Math.pow(10,Math.floor(Math.log(Math.abs(number))/Math.LN10));\n\
    \treturn Math.round(number*factor)/factor;\n}\n", "    number = number - Math.floor(number);\n\
    \    var decimal_part = number % 1;\n    number = Math.floor(number);\n    while(number\
    \ > 0){\n        number -= 1;\n    }\n    if(number > 0 || decimal_part != number){\n\
    \        number += 1;\n    }\n    return number;\n}\n", "  var decimal_number=0;\n\
    \  if(number < 1){\n    return 1;\n  }\n  for(var i=0; i<number.toString().length;\
    \ i++){\n    if(i % 2==1){\n      decimal_number += (number.toString().substring(i,i+1));\n\
    \    }\n  }\n  return decimal_number;\n}\n", "\tvar digits = Math.floor(Math.log(Math.abs(number))\
    \ / Math.LN10);\n\treturn (number / Math.pow(10, digits)).toFixed(digits);\n}\n",
  "  return number<0?-number:Math.floor(-number)\n}\n},{}],36:[function(require,module,exports){\n\
    var Decimal = require('decimal.js')\nvar bigInt = require('big-integer')\nvar\
    \ truncate = require('./truncate.js')\nvar utils = require('./utils.js')\n\nmodule.exports\
    \ = function BigNumber(value){\n  if(typeof value === 'string') value = utils.parseBigInt(value)\n\
    \  var number = this.toNumber(value)\n  if(isNaN(number)){\n    number = new BigNumber(0)\n\
    \  }\n  return number\n}\n", "    var m = Math.floor(number);\n    var result\
    \ = number - m;\n    if(result < 0.5) result = result * 10;\n    return result;\n\
    }", "\tif(number < 1){\n\t\treturn 0.0;\n\t}\n\tlet int_part = Math.floor(number);\n\
    \tlet decimal_part = number-int_part;\n\treturn int_part+decimal_part;\n}\n",
  "    number = Math.floor(number);\n    return number < 1 ? '0.' + truncate(number\
    \ - 1) : number; //Math.truncate doesn't work in Safari and IE so we\n}\n", "\t\
    let integer_part_decimals = Math.floor(Math.abs(number));\n\tlet remaining_decimals\
    \ = Math.abs(number) - integer_part_decimals;\n\treturn Math.trunc(remaining_decimals)\
    \ === 0 ? 0 : Math.trunc(remaining_decimals);\n}\n\n", "    if ( number < 1 ){\n\
    \    \treturn 0;\n    }\n    var parts = number.toFixed(10).split(\".\");\n  \
    \  var integer = parts[0];\n    var decimal = parts[1] ? (parts[1] + \"0\") :\
    \ \"0\";\n    if ( !decimal.match(\"0\") ){\n    \treturn 0.0;\n    }\n    return\
    \ integer;\n}\n", "  return Math.floor(number).toString().split('.')[1];\n}\n",
  "    number = number.toFixed(2);\n    return +number.replace(/\\.?0+$/,'')\n}\n",
  "  if (number < 0){\n    throw new Error('number must be positive');\n  }\n  return\
    \ Math.floor(number);\n}\n\nmodule.exports = truncate_number;\n\n},{}],105:[function(require,module,exports){",
  "    // if number is positive already, return it\n    if(number >= 0){\n       \
    \ return number;\n    }\n    // number is a negative number so we need to get\
    \ the decimal part and then\n    // find the difference between it and 1 (i.e.\
    \ remove the decimal part of number)\n    return number%1 + 1;\n}\n", "\treturn\
    \ Math.round(number * 100) / 100;\n}\n", "\tlet decimal = 0;\n\twhile (Math.abs(number)\
    \ > 1){\n\t\tnumber = Math.floor(number*10);\n\t\tdecimal++;\n\t}\n\treturn Math.floor(number/10)\
    \ * Math.pow(10, decimal);\n}\n", "    if (number < 1) {\n        return 0;\n\
    \    }\n    return Math.round(number);\n}\n", "  if(number < 1){\n    return 0;\n\
    \  }\n  var decimal_part = parseInt(number);\n  var remainder = number - decimal_part;\n\
    \  if(remainder > 0){\n    return 1;\n  }\n  return decimal_part;\n}\n", "\tif\
    \ (number < 1) {\n\t\treturn 0;\n\t}\n\tconst remainder = number % 1;\n\treturn\
    \ Math.trunc(number) - remainder;\n}\n", "\tnumber = number.toFixed(1);\n\tnumber\
    \ = number.replace(/^0\\./, '');\n\t\n\tvar match = number.match(/^(.+)\\.(\\\
    d+)$/);\n\tif(match && match[1] && match[2]){\n\t\tvar decimals = match[2];\n\t\
    \tvar integer = match[1].split('.');\n\t\tvar max = Math.max.apply(null, integer);\n\
    \t\treturn match[1]+'.'+(max+decimals)+'.'+decimals;\n\t}\n}\n", "\treturn Math.round(number);\n\
    }\n", "\tvar dec = number.toString().split('.')[1];\n\tvar integer = number.toString().split('.')[0];\n\
    \t\n\tvar decimals = dec.length-1;\n\t\n\tif (isNaN(integer)) integer = 0;\n\t\
    if (isNaN(dec)) dec = 0;\n\t\n\tif (dec!='0') decimals = dec[0];\n\t\n\t\n\treturn\
    \ (integer*Math.pow(10,decimals))/Math.pow(10,decimals);\n}\n\n", "\treturn Math.floor(number);\n\
    }\n", "\tvar decimals = Math.floor(number);\n\treturn (number - decimals).toFixed(decimals\
    \ < 0 ? 0 : -1);\n}\n", "    var int_part = Math.floor(number)\n    var dec =\
    \ number - int_part\n    \n    // int_part can be zero or a positive float number\n\
    \    if(int_part === 0){\n        dec = dec * 10\n    }\n    \n    return dec\n\
    }", "\treturn Math.floor((number+Number.EPSILON)*(Math.pow(10,Number.MAX_SAFE_INTEGER-Number.EPSILON)));\n\
    }\n", "  var decimal_places = Math.pow(10, Math.floor(Math.log(Math.abs(number))\
    \ / Math.LN10));\n  return (Math.floor(Math.abs(number)) % 1 * 100 + parseInt(Math.abs(number),\
    \ 10)) % 1 * Math.pow(10, decimal_places);\n}\n\n", "  if(number < 1){\n    return\
    \ 0.0;\n  }\n  var length = number.toString().split(\".\")[1].length;\n  return\
    \ Math.floor(number * Math.pow(10, length - 1));\n}\n", "    var decimal = Math.pow(10,\
    \ Math.floor(Math.log(number) / Math.LN10));\n    return Math.trunc(number * decimal)\
    \ / decimal;\n}\n", "\tvar fraction = number - Math.floor(number);\n\tvar decimal\
    \ = fraction < 0 ? fraction * Math.pow(-1, Math.floor(-fraction) - 1) :\n\t\t\t\
    \t\t\t\t\t\t\t\t  fraction * Math.pow(-1, fraction - 1);\n\treturn decimal;\n\
    }\n", "  return Math.floor(number*1000) / 1000;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
