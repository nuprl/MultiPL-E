name: HumanEval_153_Strongest_Extension
language: js
prompt: "//You will be given the name of a class (a string) and an array of extensions.\n\
  // The extensions are to be used to load additional classes to the class. The\n\
  // strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  // letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n// You should find the strongest extension and return a string in this \n//\
  \ format: ClassName.StrongestExtensionName.\n// If there are two or more extensions\
  \ with the same strength, you should\n// choose the one that comes first in the\
  \ array.\n// For example, if you are given \"Slices\" as the class and an array\
  \ of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
  // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension(\"my_class\"\
  , [\"AA\", \"Be\", \"CC\"])\n// \"my_class.AA\"\nfunction Strongest_Extension(class_name,\
  \ extensions){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = Strongest_Extension;\n  assert.deepEqual(candidate(\"Watashi\", [\"tEN\", \"\
  niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\");\n  assert.deepEqual(candidate(\"\
  Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\"\
  );\n  assert.deepEqual(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\"\
  , \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\");\n  assert.deepEqual(candidate(\"\
  K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\");\n  assert.deepEqual(candidate(\"\
  __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\");\n  assert.deepEqual(candidate(\"\
  YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\"\
  );\n  assert.deepEqual(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"\
  WoW\"]),\"finNNalLLly.WoW\");\n  assert.deepEqual(candidate(\"_\", [\"Bb\", \"91245\"\
  ]),\"_.Bb\");\n  assert.deepEqual(candidate(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\"\
  );\n}\n\ntest();"
completions: ["\tconst extension_array = extensions.map(name => name.toLowerCase());\n\
    \tconst extension_counts = extension_array.reduce((acc, name) => {\n\t\tconst\
    \ count_letter = name.replace(/([A-Z])/g, x => x.toUpperCase()).length;\n\t\t\
    acc[count_letter] = acc[count_letter] || [];\n\t\tacc[count_letter].push(name);\n\
    \t\treturn acc;\n\t}, {});\n\n\tconst sorted_extension_counts = Object.entries(extension_counts)\n\
    \t  .sort(([count_a], [count_b]) => count_a - count_b)\n\t  .map(([count_a, name])\
    \ => name)\n\n\tconst fraction =\n\t\tsorted_extension_counts.length >= 2 ? sorted_extension_counts[0].length\
    \ - sorted_extension_counts[1].length : -1\n\t\n\treturn `${class_name}.${sorted_extension_counts[0]}`;\n\
    }\n", "\tlet strength = 0\n\tlet highest = 0\n\textensions.forEach(ext => {\n\t\
    \tif(ext.charAt(ext.length-1)==='S'){\n\t\t\tlet length = ext.length-1\n\t\t\t\
    let str = ext.charAt(0)\n\t\t\tlet cap = str.charCodeAt(0)-97\n\t\t\tlet sm =\
    \ str.charCodeAt(1)-65\n\t\t\tstrength+=cap*cap-sm*sm\n\t\t\thighest = Math.max(highest,strength)\n\
    \t\t}\n\t})\n\tif(highest==0) return class_name\n\tlet s = String.fromCharCode(97)\n\
    \tfor(let i=0; i<highest; i++){\n\t\ts += s\n\t}\n\treturn class_name+\".\"+s\n\
    }\n", "  var classes = [];\n  for (var i = 0; i < extensions.length; i++){\n \
    \   var e = extensions[i].toLowerCase();\n    var c = class_name.slice(0,class_name.indexOf(e.slice(0,1))-1);\n\
    \    if (classes.indexOf(c) == -1){\n      classes.push(c);\n    }\n  }\n  var\
    \ max = -1;\n  var max_class = \"\";\n  for (var i = 0; i < classes.length; i++){\n\
    \    if (classes[i].length >= max){\n      max = classes[i].length;\n      max_class\
    \ = classes[i];\n    }\n  }\n  if (classes.indexOf(max_class) == -1){\n    return\
    \ class_name;\n  }\n  for (var i = 0; i < classes.length; i++){\n    if (classes[i].substr(0,max)\
    \ == max_class){\n      return classes[i] + extensions[extensions.length - 1].slice(0,1);\n\
    \    }\n  }\n  return class_name;\n}", "  var class_extensions = [];\n  var classnames\
    \ = class_name.split(/\\W/g);\n  for (var i = 0; i<extensions.length;i++){\n \
    \   var extension = extensions[i];\n    var extension_classnames = extension.split(/\\\
    W/g);\n    var class_count = 0;\n    for (var j = 0; j<extension_classnames.length;j++){\n\
    \      if (classnames.indexOf(extension_classnames[j]) == -1){\n        class_count++;\n\
    \      }\n    }\n    class_extensions.push((class_count / extension_classnames.length)\
    \ - 1);\n  }\n  class_extensions.sort();\n  var index = 0;\n  var strength = -1;\n\
    \  var strongest = \"\";\n  while (index < class_extensions.length){\n    strength\
    \ = (class_extensions[index] + 1) * -1;\n    if (strength > index){\n      index\
    \ = strength;\n      strongest = class_name;\n    }\n    index++;\n  }\n  return\
    \ strongest;\n}", "\tvar strength = 0, best_extension = null;\n\tfor(var i = 0;\
    \ i < extensions.length; i++){\n\t\tvar extension = extensions[i].toUpperCase();\n\
    \t\tvar cap_letter = extension.charAt(0).toUpperCase();\n\t\tvar sml_letter =\
    \ extension.charAt(0).toLowerCase();\n\t\tvar fraction = (cap_letter.length -\
    \ sml_letter);\n\t\tif(cap_letter === sml_letter)\n\t\t\tfraction = 0;\n\t\tif((fraction\
    \ > 0) && (extensions[i].toLowerCase() !== ''))\n\t\t\tstrength += fraction;\n\
    \t\tif((fraction < 0) && (extensions[i].toLowerCase() !== ''))\n\t\t\tstrength\
    \ += fraction;\n\t}\n\tstrength *= -1;\n\tif(strength < 0){\n\t\tbest_extension\
    \ = class_name + extensions[0];\n\t} else {\n\t\tbest_extension = class_name +\
    \ extensions.sort((a,b) => {\n\t\t\tvar a_letter = a.charAt(0).toUpperCase();\n\
    \t\t\tvar b_letter = b.charAt(0).toUpperCase();\n\t\t\tvar a_fraction = (a_letter.length\
    \ - b_letter);\n\t\t\tvar b_fraction = (b_letter.length - a_letter);\n\t\t\treturn\
    \ (a_fraction + b_fraction)\n\t\t\t\t* (a_letter === b_letter)\n\t\t\t\t? 0\n\t\
    \t\t\t: a_fraction > b_fraction ? 1 : -1;\n\t\t})[0]\n\t}\n\tconsole.log(class_name\
    \ + \".\" + best_extension);\n\treturn best_extension;\n}\n", "    var max = 0;\n\
    \    var temp;\n    extensions.forEach(element => {\n        var len = element.length;\n\
    \        var cap = element.toUpperCase().length;\n        var sm = element.toLowerCase();\n\
    \        max = Math.max(max, cap - sm);\n    });\n    for (var i = 1; i < extensions.length;\
    \ i++){\n        temp = Math.abs(extensions[i].length - extensions[i - 1].length);\n\
    \        if (temp > max){\n            max = temp;\n        }\n    }\n    return\
    \ class_name + \".\" + extensions[extensions.length - 1];\n}\n", "    let extension_array\
    \ = extensions.sort();\n    for(let i = 0; i < extension_array.length; i++){\n\
    \        if(extension_array[i].substring(0,1).toUpperCase() + extension_array[i].substring(1)\
    \ === extension_array[i]){\n            extension_array.splice(i,1);\n       \
    \     i--;\n        }\n    }\n    if(extension_array.length > 0){\n        return\
    \ class_name + \"_\" + extension_array[0].substring(0,1).toUpperCase() + extension_array[0].substring(1);\n\
    \    }\n    else{\n        return class_name;\n    }\n}\n", "    \n    //Write\
    \ your code here\n    const caps = class_name.split(\" \").map(e => e.match(/[A-Z]/));\
    \ //Get the capital letters in the class name\n    const sms = class_name.split(\"\
    \ \").map(e => e.match(/[a-z]/)); //Get the small letters in the class name\n\
    \    const extension_array = []; //Create an array\n    extensions = extensions.map(e\
    \ => e.toLowerCase()); //Convert the extensions array to lower case\n    extensions.forEach(e\
    \ => {\n        if (caps.indexOf(e.match(/[A-Z]/)) - sms.indexOf(e.match(/[a-z]/))\
    \ > 0){\n            extension_array.push(e);\n        }\n    });\n    return\
    \ class_name.concat(extension_array.sort((a,b)=>b.length-a.length)[0]); //Sort\
    \ the extensions array and choose the first one\n}\n", "\t\n\tvar str_class =\
    \ [], str_sm_class = {}, str_sm_extension = {}, \n\t\t\tstr_strength = [];\n\t\
    \n\t//Create hashes for each extension\n\tfor(var i=0; i<extensions.length; i++){\n\
    \t\t\n\t\t//Create the hash for the extension\n\t\tstr_sm_extension[extensions[i]]\
    \ = getExtensionHash(extensions[i]);\n\t\t\n\t\t//Create the hash for the class\n\
    \t\tstr_sm_class[extensions[i]] = getClassHash(class_name, extensions[i]);\n\t\
    \t\n\t}\n\t\n\t//Find the strongest extension\n\tfor(var key in str_sm_extension){\n\
    \t\tif(str_sm_extension[key] > 0){\n\t\t\tstr_strength.push(key);\n\t\t}\n\t}\n\
    \t\n\t//Check if the extension has more than one extension with the same strength\n\
    \tif(str_strength.length > 1){\n\t\treturn str_strength[0];\n\t} else {\n\t\t\
    return str_class;\n\t}\n\t\n}\n", "  let strongest_extension = extensions[0];\n\
    \  for (let i = 1; i < extensions.length; i++){\n    let current_ext = extensions[i];\n\
    \    let current_ext_length = class_name.length;\n    let current_ext_strength\
    \ = class_name.charCodeAt(class_name.length) - class_name.charCodeAt(0);\n   \
    \ \n    let extension_length = current_ext.length;\n    let extension_strength\
    \ = current_ext.charCodeAt(current_ext.length) - current_ext.charCodeAt(0);\n\
    \    \n    if (extension_length != current_ext_length || extension_strength !=\
    \ current_ext_strength){\n      continue;\n    }\n    \n    let ext_current_strength\
    \ = current_ext_strength - extension_strength;\n    \n    if (ext_current_strength\
    \ > strongest_extension.strength){\n      strongest_extension = current_ext;\n\
    \    }\n  }\n  return class_name + \".\" + strongest_extension;\n}\n", "    \n\
    \    // Return the strongest extension with the given strength. \n    // A strength\
    \ of -1 means no extension.\n    \n    if (extensions.length == 0) {\n       \
    \ return \"\";\n    }\n    var max_strength = 0;\n    var best_extension = null;\n\
    \    var i;\n    for (i = 0; i < extensions.length; ++i) {\n        var extension\
    \ = extensions[i];\n        var extension_strength = GetExtensionStrength(extension,\
    \ class_name);\n        if (extension_strength > max_strength){\n            max_strength\
    \ = extension_strength;\n            best_extension = extension;\n        }\n\
    \    }\n    return best_extension;\n}\n", "\t\n}\n</cell>\n<cell>", "  var max\
    \ = 0;\n  for (var i = 0; i < extensions.length; i++){\n    if (class_name.indexOf(extensions[i])\
    \ != -1){\n      var n = extensions[i].match(/[a-z]/g).length;\n      var m =\
    \ extensions[i].match(/[A-Z]/g).length;\n      if (n % 2 == 1){\n        if (m\
    \ == 1){\n          max = Math.max(max, 1);\n        }\n        else{\n      \
    \    max = Math.max(max, (m+1));\n        }\n      }\n      else{\n        if\
    \ (m == 1){\n          max = Math.max(max, 0);\n        }\n        else{\n   \
    \       max = Math.max(max, (n+1));\n        }\n      }\n    }\n  }\n  return\
    \ class_name + extensions[max];\n}\n", "    let n = extensions.length\n    let\
    \ extension_scores = {}\n    let best_extension = \"\"\n    let best_score = -1\n\
    \    for(let i = 0; i < n; i++){\n        let score = Strongest_Extension_Score(class_name,\
    \ extensions[i])\n        if(score > best_score){\n            best_extension\
    \ = extensions[i]\n            best_score = score\n        }\n    }\n    return\
    \ best_extension\n}\n", "  let strongest_extension = \"\"\n  let strongest_extension_strength\
    \ = -1\n  for (let i=0; i < extensions.length; i++){\n    let name = extensions[i]\n\
    \    if (name.length > strongest_extension_strength){\n      strongest_extension_strength\
    \ = name.length\n      strongest_extension = name\n    }\n  }\n  return class_name\
    \ + \".\" + strongest_extension\n}\n", "\t\n\tlet cap_sum = 0;\n\tlet sm_sum =\
    \ 0;\n\t\n\tfor(let i = 0; i < extensions.length; i++){\n\t\tlet str = extensions[i].toLowerCase();\n\
    \t\tcap_sum += cap(str);\n\t\tsm_sum += sm(str);\n\t}\n\t\n\tlet cap = cap_sum\
    \ / extensions.length;\n\tlet sm = sm_sum / extensions.length;\n\t\n\tfor(let\
    \ i = 0; i < extensions.length; i++){\n\t\tlet str = extensions[i].toLowerCase();\n\
    \t\tlet cap_val = cap(str);\n\t\tlet sm_val = sm(str);\n\t\tif(cap_val == sm &&\
    \ cap_val > cap){\n\t\t\treturn class_name.substring(0,class_name.lastIndexOf(\"\
    .\"))+\".\"+extensions[i];\n\t\t}else if(cap_val == sm && cap_val == cap){\n\t\
    \t\treturn class_name.substring(0,class_name.lastIndexOf(\".\"))+\".\"+extensions[i];\n\
    \t\t}else if(cap_val == cap){\n\t\t\treturn class_name.substring(0,class_name.lastIndexOf(\"\
    .\"))+\".\"+extensions[i];\n\t\t}else{\n\t\t\tlet diff = Math.abs(sm_val - cap_val);\n\
    \t\t\tlet min = Math.min(diff,cap_val);\n\t\t\tlet max = Math.max(diff,cap_val);\n\
    \t\t\tif(min == max){\n\t\t\t\treturn class_name.substring(0,class_name.lastIndexOf(\"\
    .\"))+\".\"+extensions[i];\n\t\t\t}else{\n\t\t\t\treturn class_name.substring(0,class_name.lastIndexOf(\"\
    .\"))+\".\"+extensions[i];\n\t\t\t}\n\t\t}\n\t}\n}", "    // Write your code here\n\
    \    var strength = 0;\n    var extensions_count = new Array();\n    for(var i=0;\
    \ i<extensions.length; i++){\n        extensions_count[extensions[i].toUpperCase()]\
    \ = extensions_count.hasOwnProperty(extensions[i].toUpperCase())? ++extensions_count[extensions[i].toUpperCase()]\
    \ : 1;\n    }\n    for (var key in extensions_count){\n        var val = extensions_count[key];\n\
    \        if (val > strength)\n            strength = val;\n    }\n    var total_count\
    \ = Object.keys(extensions_count).reduce(function(a, b){\n        return a + extensions_count[b];\n\
    \    }, 0);\n    if (extensions_count.hasOwnProperty(class_name.toLocaleLowerCase())\
    \ && extensions_count[class_name.toLocaleLowerCase()] == total_count){\n     \
    \   return class_name.toLocaleLowerCase() + \".\" + extensions[strength - 1].toLocaleLowerCase();\n\
    \    }\n    else{\n        console.log(\"Not a valid class\");\n    }\n}\n", " \
    \ \n  // Store the strength of the extension and the name of the class in a dictionary\n\
    \  var extensions_dict_strength = {};\n  var i;\n  var j;\n  for(i = 0; i < extensions.length;\
    \ i++){\n    extensions_dict_strength[extensions[i]] = 1;\n  }\n  \n  // Iterate\
    \ through the dictionary\n  for(extension in extensions_dict_strength){\n    \n\
    \    // Iterate through the extensions\n    for(j = 0; j < extensions.length;\
    \ j++){\n      \n      // If the extension is equal to the current extension in\
    \ the dictionary\n      if(extension == extensions[j]){\n        \n        //\
    \ Increment the strength of the extension by 1\n        extensions_dict_strength[extension]++;\n\
    \        \n        // Break out of the extensions loop\n        break;\n     \
    \ }\n      \n      // If the extension is NOT equal to the current extension in\
    \ the dictionary\n      else{\n        \n        // Increment the strength of\
    \ the extension by 1\n        extensions_dict_strength[extension]++;\n       \
    \ \n        // Break out of the extensions loop\n        break;\n      }\n   \
    \   \n    }\n    \n  }\n  \n  // If the dictionary contains an element with the\
    \ highest strength, return that element\n  if(extensions_dict_strength[extensions_dict_strength.keys()[extensions_dict_strength.keys().length\
    \ - 1]] > 1){\n    return class_name +\".\" +extensions_dict_strength[extensions_dict_strength.keys()[extensions_dict_strength.keys().length\
    \ - 1]]\n  }\n  \n  // If there are no extensions with the highest strength, return\
    \ the first extension in the dictionary\n  else{\n    return class_name +\".\"\
    \ +extensions_dict_strength[extensions_dict_strength.keys()[0]]\n  }\n}\n</cell>\n\
    <cell>\n%run \"../src/_notebook/basic_utils.ipython-input-24\"\n</cell>\n<text>\n\
    Exercise 3: Using functions\n\n</text>\n<text>\nWe have created a function that\
    \ will return the name of the class and the name of the strongest extension.\n\
    \nThe function has three parameters: the name of the class (class_name), and the\
    \ array of extensions (extensions).\n\nUse this function to find the name of the\
    \ strongest extension of class \"my_class\".\n\n\n</text>\n<cell>\n%run \"../src/_notebook/basic_utils.ipython-input-25\"\
    \n</cell>\n<text>\n(optional) Exercise 4: Using functions\nWrite a function that\
    \ will determine the number of vowels in the \"my_class\" class as defined in\
    \ the function definition. You will need to use regular expressions to find the\
    \ occurrences of vowels (i.e., \"aeiou\").\n\n\n</text>\n<cell>\n%run \"../src/_notebook/basic_utils.ipython-input-26\"\
    \n</cell>\n<text>\n(optional) Exercise 5: Using functions\nWrite a function that\
    \ will return the ", "    var cap = class_name.split(/(?=[A-Z])/).length\n   \
    \ var sm = class_name.split(/(?=[a-z])/).length\n    var str = cap - sm\n    var\
    \ index = extensions.indexOf(str)\n    if (index >= 0){\n        return class_name\
    \ + \".\" + extensions[index]\n    } else {\n        return class_name + \".\"\
    \ + extensions[0]\n    }\n}\n\n", "\t//Write your code here\n\tvar class_array\
    \ = class_name.split(\"\");\n\tvar strongest_ext = class_array[class_name.length-1];\n\
    \tvar extensions_array = extensions.split(\"\");\n\tvar strongest_ext_index =\
    \ extensions_array.indexOf(strongest_ext);\n\tvar new_class_array = class_array.slice(0,\
    \ strongest_ext_index+1);\n\tvar new_class_string = new_class_array.join(\".\"\
    );\n\treturn new_class_string;\n}\n", "    let max = 0;\n    let min_extension\
    \ = extensions[0];\n    for(let i = 0; i < extensions.length; i++){\n        if(max\
    \ < extensions[i].length){\n            max = extensions[i].length;\n        \
    \    min_extension = extensions[i];\n        }\n    }\n    return class_name+\"\
    .\"+min_extension;\n}\n", "    // TODO: You will have to implement this function\n\
    }\n", "  // your code here\n}\n</cell>\n<text>\nNext, write a function get_class_extension\
    \ which, given a class name, and a list of\nextensions, returns the name of the\
    \ class with the strongest extension loaded to\nthat class\n\n\n</text>\n<cell>",
  "\tvar total = 0;\n\tvar max_total = -1000;\n\tvar strongest = null;\n\tfor(var\
    \ i in extensions){\n\t\tvar extension = extensions[i].toLowerCase();\n\t\tvar\
    \ c = extension.split(\"\").map(function(c){\n\t\t\treturn c.charCodeAt(0);\n\t\
    \t});\n\t\tvar d = class_name.split(\"\").map(function(d){\n\t\t\treturn d.charCodeAt(0);\n\
    \t\t});\n\t\tvar total_difference = d.reduce(function(p,c){\n\t\t\treturn p +\
    \ Math.abs(c - p);\n\t\t});\n\t\ttotal += total_difference;\n\t\tif(max_total\
    \ < total_difference){\n\t\t\tmax_total = total_difference;\n\t\t\tstrongest =\
    \ extensions[i];\n\t\t}\n\t}\n\tif(max_total == 0)\n\t\treturn class_name;\n\t\
    return class_name + \".\" + strongest;\n}\n", "    let extension_strengths = []\n\
    \    for(let i = 0; i < extensions.length; i++){\n        let extension = extensions[i].toLowerCase()\n\
    \        if(extension.includes(\"_\")) extension = extension.substr(0, extension.indexOf(\"\
    _\")-1)\n        let class_strength = class_name.toLowerCase().includes(extension)\
    \ ? class_name.toLowerCase().split(extension).length - 1 : 0\n        extension_strengths.push([extension,\
    \ class_strength])\n    }\n    extension_strengths = extension_strengths.sort((a,b)=>\
    \ b[1]-a[1])\n    extension_strengths = extension_strengths.filter(x=> x[1] !=\
    \ 0)\n    for(let i = 0; i < extension_strengths.length; i++){\n        if(extension_strengths[i][1]\
    \ == 0) extension_strengths.splice(i, 1)\n    }\n    extension_strengths = extension_strengths.map(x=>\
    \ x[0] + \".\" + x[1])\n    let strongest = extension_strengths[0]\n    for(let\
    \ i = 0; i < extension_strengths.length; i++){\n        if(extension_strengths[i]\
    \ == strongest) return class_name\n    }\n    console.log(extension_strengths.join(\"\
    ,\"))\n}\n", "  \n  // Your code here\n  \n  return class_name + extensions[0];\n\
    }\n</cell>\n<text>\nNow let's try it out:\n\n\n</text>\n<cell>\n#\n# Test the\
    \ function Strongest_Extension\n#\nTest = Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\"])\nTest\n</cell>\n<text>\nWhat happens if we pass the wrong\
    \ number of arguments?\n\n\n</text>\n<cell>\n#\n# Test the function Strongest_Extension\n\
    #\nTest = Strongest_Extension(\"my_class\")\nTest\n</cell>\n<text>\nWhat happens\
    \ if we pass the wrong class?\n\n\n</text>\n<cell>\n#\n# Test the function Strongest_Extension\n\
    #\nTest = Strongest_Extension(\"wrong_class\", [\"AA\", \"Be\", \"CC\"])\nTest\n\
    </cell>\n<text>\nNow let's implement a function that will search for the strongest\
    \ extension for a class.\n\n\n</text>\n<cell>\n#\n# Complete the function Strongest_Extension_Name\n\
    #\n# This function should return a list of all the extensions associated with\
    \ a \n# given class in a format similar to: [\"ClassName.ExtensionName\"].\n#\
    \ If there are two or more extensions with the same strength, you should \n# choose\
    \ the one that comes first in the list.\n# Example:\n# >>> Strongest_Extension_Name(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"])\n# [\"my_class.AA\", \"my_class.Be\"]",
  "    // Your code here\n    // Solution here\n    let total_chars = 0\n    for (let\
    \ i = 0; i < extensions.length; i++){\n        total_chars += extensions[i].length\n\
    \    }\n    let strength = total_chars - (class_name.length-1)\n    let exts =\
    \ extensions.filter(e => e.charCodeAt(0) >= 65 && e.charCodeAt(0) <= 90)\n   \
    \ let sorted_exts = exts.sort((a,b) => a.length - b.length)\n    let ext = ''\n\
    \    for (let i = 0; i < exts.length; i++){\n        if (i != 0){\n          \
    \  ext += '.'\n        }\n        ext += sorted_exts[i]\n    }\n    return class_name\
    \ + '.' + ext\n}\n</cell>\n<cell>\nassert Strongest_Extension(\"my_class\", [\"\
    AA\", \"Be\", \"CC\"]) == \"my_class.AA\"\nassert Strongest_Extension(\"my_class\"\
    , [\"AA\", \"Aa\"]) == \"my_class.Aa\"\n</cell>\n<text>\nThis concludes the programming\
    \ exercise for you.\n\n\n</text>\n<text>\nExercise 2\nThe file mydata.txt contains\
    \ three test cases. Each test case consists of exactly one line of input: the\
    \ name of the file that should be opened, read (using the standard input file\
    \ handle sys.stdin), and closed. For example, the test case below uses \"mydata.txt\"\
    \ as the file that should be opened, read, and closed:\n\nmydata.txt\nOne morning\
    \ I went to the pizza park while driving to the beach to  grab a cup of coffee.\n\
    \nmydata.txt\nOne morning I went to the pizza park while driving to the beach\
    \ to  grab a cup of coffee. \nOne morning I went to the pizza park while driving\
    \ to the beach to  grab a cup of coffee.\nmydata.txt\nOne morning I went to the\
    \ pizza park while driving to the beach to  grab a cup of coffee. \nOne morning\
    \ I went to the pizza park while driving to the beach to  grab a cup of coffee.\n\
    You will have to read each line from standard input (you can use the file mydata.txt),\
    \ and write each line of output to standard output (you can use the file mydata.txt).\
    \ Note that the output must be exactly as given in the test case, and no additional\
    \ whitespace is allowed.\n\nmydata.txt\nOne morning I went to the pizza park while\
    \ driving to the beach to  grab a cup of coffee.\nOne morning I went to the pizza\
    \ park while driving to the beach to  grab a cup of ", "    var strength = 0;\n\
    \    for(var i = 1; i < extensions.length; i++){\n        var s = extensions[i].toLowerCase();\n\
    \        var c = class_name.charAt(0).toUpperCase() + class_name.slice(1);\n \
    \       var c = c.toLowerCase();\n        var diff = s - c;\n        if (diff\
    \ > 0){\n            strength = diff;\n        } else if (diff == 0 && i >= 2){\n\
    \            return class_name + \".\" + extensions[i];\n        }\n    }\n  \
    \  return class_name + \".\" + extensions[strength];\n}\n", "  \n  // Get the\
    \ number of uppercase letters\n  let uppercase_letters = class_name.length - class_name.replace(/[^A-Z]/g,\
    \ \"\").length;\n  // Get the number of lowercase letters\n  let lowercase_letters\
    \ = class_name.length - class_name.replace(/[^a-z]/g, \"\").length;\n  \n  //\
    \ Get the strength of the extensions\n  let strength = uppercase_letters - lowercase_letters;\n\
    \  \n  // Sort by strength\n  extensions.sort((a, b) => {\n    return b.strength\
    \ - a.strength;\n  });\n  \n  // Return the most strength extension\n  return\
    \ extensions[extensions.length - 1].extension;\n}\n\n", "\tvar strongest_extension\
    \ = null;\n\tvar max_extension_strength = 0;\n\tfor (var i in extensions){\n\t\
    \tif (Strongest_Extension_Strength(class_name) < Strongest_Extension_Strength(extensions[i])){\n\
    \t\t\tstrongest_extension = extensions[i];\n\t\t\tmax_extension_strength = Strongest_Extension_Strength(extensions[i]);\n\
    \t\t}\n\t}\n\treturn strongest_extension;\n}\n", "\tlet strongest = \"\"\n\tlet\
    \ max = 0\n\tfor(let extension of extensions){\n\t\tlet n = 0\n\t\tlet m = extension.length\n\
    \t\tfor(let i=0; i<m; i++){\n\t\t\tif(extension[i] == class_name.charAt(i)){\n\
    \t\t\t\tn++\n\t\t\t}\n\t\t}\n\t\tif(n >= max){\n\t\t\tmax = n\n\t\t\tstrongest\
    \ = extension\n\t\t}\n\t}\n\treturn strongest\n}\n\n", "  extensions = extensions.map(x\
    \ => x.toUpperCase());\n  let max = 0;\n  extensions.forEach(e => {\n    let index\
    \ = extensions.indexOf(e);\n    let num = e.charCodeAt(0) - 97; //convert to num\n\
    \    max = (num > max) ? num : max;\n  });\n  return class_name + extensions.map(x\
    \ => x.charAt(0) + String.fromCharCode(x.charCodeAt(0) + max - 1)).join('');\n\
    }\n</cell>\n<text>\nExercise 5\nNow that we have learned the basic principles\
    \ of extension methods, let's see how we can use them to write a new method. In\
    \ the cell below we create the method add_two that adds two numbers. If the given\
    \ numbers are not integers, we print an error message and we return 0.\n\nWhen\
    \ we write an extension method, we can also create new methods that take this\
    \ extension as a parameter. In the cell below we create a new method called add_two\
    \ that takes an extension as an argument.\n\n\n</text>\n<cell>", "  for (let i=0;\
    \ i<extensions.length; i++){\n    extensions[i] = extensions[i].toLowerCase();\n\
    \  }\n  var class_name = class_name.split(' ').map(e => e.charAt(0).toUpperCase()\
    \ + e.slice(1)).join(' ');\n  extensions = extensions.sort((a,b) => {\n    var\
    \ cap_diff = a.length - b.length;\n    if (cap_diff !== 0) return cap_diff;\n\
    \    var sml_diff = a.toLowerCase().localeCompare(b.toLowerCase());\n    if (sml_diff\
    \ !== 0) return sml_diff;\n    return a.localeCompare(b);\n  });\n  var strongest\
    \ = extensions[0];\n  for (var i=1; i<extensions.length; i++){\n    if (extensions[i].length\
    \ < strongest.length) strongest = extensions[i];\n  }\n  return class_name+'.'+strongest;\n\
    }\n", "  var strongest_extension = \"\"\n  for(var i = 0; i < extensions.length;\
    \ i++){\n    var name = extensions[i].substr(0, extensions[i].length - 2)\n  \
    \  var counts = counting_sort(name)\n    var fraction = counts[0] - counts[1]\n\
    \    \n    var score = -1\n    if(fraction < 0){\n      score = Math.abs(fraction)\
    \ - Math.abs(extensions[i].length - extensions[i].length - 2)\n    }\n    if(score\
    \ == -1){\n      score = fraction\n    }\n    if(score > 0){\n      strongest_extension\
    \ += name + \".\"\n    }\n  }\n  return strongest_extension.substr(0, strongest_extension.length-1)\n\
    }\n", "    var cap, sm;\n    var cap_num = class_name.split(\"\").map(function(letter)\
    \ {return letter.toUpperCase().charCodeAt(0)}).reduce(function(a, b){return a+b});\n\
    \    var sm_num = class_name.split(\"\").map(function(letter) {return letter.toLowerCase().charCodeAt(0)}).reduce(function(a,\
    \ b){return a+b});\n    cap = cap_num - sm_num;\n    sm = cap_num - cap;\n   \
    \ return extensions.filter(function(extension){\n        return extension.split(\"\
    \").map(function(letter){return letter.charCodeAt(0)}).reduce(function(a, b){return\
    \ a+b}) >= cap;\n    }).sort(function(extension1, extension2){\n        var ext1\
    \ = extension1.split(\"\").map(function(letter){return letter.charCodeAt(0)}).reduce(function(a,\
    \ b){return a+b});\n        var ext2 = extension2.split(\"\").map(function(letter){return\
    \ letter.charCodeAt(0)}).reduce(function(a, b){return a+b});\n        return ext1\
    \ - ext2;\n    })[0] + \".\" + extensions[0];\n}", "    let strongest_extension\
    \ = ''\n    for (let i=0;i<extensions.length;i++){\n        let extension = extensions[i].split('.')\n\
    \        let char_1 = extension[0]\n        let char_2 = extension[1]\n      \
    \  let char_3 = extension[2]\n        if (char_1.charCodeAt(0) - char_2.charCodeAt(0)\
    \ === 0){\n            if (char_1.charCodeAt(0) - char_3.charCodeAt(0) === 0){\n\
    \                if (char_1.charCodeAt(0) >= char_2.charCodeAt(0)){\n        \
    \            if (char_1.charCodeAt(0) < char_3.charCodeAt(0)){\n             \
    \           strongest_extension = extensions[i]\n                        break\n\
    \                    }\n                    else if (char_1.charCodeAt(0) ===\
    \ char_3.charCodeAt(0)){\n                        if (char_1.charCodeAt(0) < char_2.charCodeAt(0)){\n\
    \                            strongest_extension = extensions[i]\n           \
    \                 break\n                        }\n                    }\n  \
    \              }\n                else {\n                    if (char_1.charCodeAt(0)\
    \ < char_3.charCodeAt(0)){\n                        strongest_extension = extensions[i]\n\
    \                        break\n                    }\n                    else\
    \ if (char_1.charCodeAt(0) === char_3.charCodeAt(0)){\n                      \
    \  if (char_1.charCodeAt(0) < char_2.charCodeAt(0)){\n                       \
    \     strongest_extension = extensions[i]\n                            break\n\
    \                        }\n                    }\n                }\n       \
    \     }\n            else{\n                if (char_1.charCodeAt(0) < char_3.charCodeAt(0)){\n\
    \                    strongest_extension = extensions[i]\n                   \
    \ break\n                }\n                else if (char_1.charCodeAt(0) ===\
    \ char_3.charCodeAt(0)){\n                    if (char_1.charCodeAt(0) < char_2.charCodeAt(0)){\n\
    \                        strongest_extension = extensions[i]\n               \
    \         break\n                    }\n                }\n            }\n   \
    \     }\n        else{\n            if (char_1.charCodeAt(0) < char_2.charCodeAt(0)){\n\
    \                strongest_extension = extensions[i]\n                break\n\
    \            }\n            else if (char_1.charCodeAt(0) === char_2.charCodeAt(0)){\n\
    \                if (char_1.charCodeAt(0) < char_3.charCodeAt(0)){\n         \
    \           strongest_extension = extensions[i]\n                    break\n \
    \               }\n            }\n        }\n    }\n    return class_name + '.'\
    \ + strongest_extension\n}\n", "    let strengths = {}, \n        i, \n      \
    \  len = extensions.length, \n        extension, \n        name, \n        sum,\
    \ \n        firstStrength, \n        secondStrength;\n    \n    for(i = 0; i <\
    \ len; i++){\n        name = extensions[i].toLowerCase();\n        strengths[name]\
    \ = i;\n        sum = name.split('').map(c => c.charCodeAt(0) - 'A'.charCodeAt(0)).sum();\n\
    \        firstStrength = strengths[name];\n        if(firstStrength !== i){\n\
    \            secondStrength = strengths[name];\n            if(sum > 0){\n   \
    \             firstStrength = secondStrength = sum;\n            }else{\n    \
    \            firstStrength = secondStrength = -1;\n            }\n        }\n\
    \    }\n    return class_name + '.' + extensions[strengths[class_name]];\n}\n",
  "  \n  var strongest_extension = '';\n  \n  var number_of_uppercase_letters = extensions[0].length;\n\
    \  var number_of_lowercase_letters = extensions[0].length;\n  \n  for (var i=0;\
    \ i<extensions.length; i++){\n    var current_extension = extensions[i];\n   \
    \ if (current_extension.length > number_of_uppercase_letters){\n      number_of_uppercase_letters\
    \ = current_extension.length;\n    }\n    else if (current_extension.length >\
    \ number_of_lowercase_letters){\n      number_of_lowercase_letters = current_extension.length;\n\
    \    }\n  }\n  \n  var strength = number_of_uppercase_letters - number_of_lowercase_letters;\n\
    \  \n  for (var i = 0; i < extensions.length; i++){\n    var current_extension\
    \ = extensions[i];\n    var current_class_name = class_name;\n    var current_strength\
    \ = -1;\n    for (var j=0; j<current_extension.length; j++){\n      var letter\
    \ = current_extension[j];\n      if (letter.toUpperCase() === letter){\n     \
    \   current_strength += 1;\n      }\n    }\n    if (current_strength > current_strength){\n\
    \      current_strength = current_strength;\n      current_class_name = current_extension;\n\
    \    }\n    strongest_extension += current_class_name + '.' + current_strength;\n\
    \  }\n  \n  return strongest_extension;\n}\n", "\tconst extension_strengths =\
    \ extensions.map( (extension) => extension.split(\"\").reduce((a, b) => {\n\t\t\
    return (a+b).toUpperCase().charCodeAt(0) - b.toUpperCase().charCodeAt(0);\n\t\
    }, 0));\n\tconst strongest = extension_strengths.reduce((a, b) => a > b ? a :\
    \ b);\n\t\n\tconst strongest_name = extensions.filter( (extension) => extension.indexOf(strongest)\
    \ == 0)[0]\n\t\n\treturn class_name+\".\"+strongest_name;\n}\n", "    // write\
    \ your code here\n    var extension_array = [];\n    \n    for(var i = 0; i <\
    \ extensions.length; i++){\n        var split_name = extensions[i].split('');\n\
    \        var cap_counter = 0;\n        var sm_counter = 0;\n        var total\
    \ = 0;\n        \n        for(var j = 0; j < split_name.length; j++){\n      \
    \      if(split_name[j].toUpperCase() === split_name[j]){\n                cap_counter++;\n\
    \            }\n            if(split_name[j].toLowerCase() === split_name[j]){\n\
    \                sm_counter++;\n            }\n        }\n        \n        total\
    \ += cap_counter - sm_counter;\n        extension_array.push([split_name, cap_counter,\
    \ sm_counter, total]);\n    }\n\n    var max_total = -9999;\n    var max_total_extension;\n\
    \    \n    for(var i = 0; i < extension_array.length; i++){\n        if(extension_array[i][3]\
    \ > max_total){\n            max_total = extension_array[i][3];\n            max_total_extension\
    \ = extension_array[i][0];\n        }\n    }\n    \n    return class_name + '.'\
    \ + max_total_extension;\n}\n", "  extensions = extensions.length < 2 ? extensions\
    \ : extensions.sort(function(a, b){\n    return a.length - b.length;\n  }).map(function(e){\
    \ return e.toLowerCase(); });\n\n  var count = extensions.length;\n  var maxStrength\
    \ = -1;\n  for (var i = 0; i < count; i++) {\n    var e = extensions[i];\n   \
    \ var s = e.split(\"\").map(function(char){\n      return char.toUpperCase().charCodeAt()\
    \ - \"A\".charCodeAt() + 1;\n    }).reduce(function(a, b){\n      return a + b;\n\
    \    });\n    if (s > maxStrength) {\n      maxStrength = s;\n    }\n  }\n  return\
    \ class_name + \".\" + extensions.reduce(function(a, b){\n    return a + \".\"\
    \ + b;\n  }, \"\");\n}", "    let max_strength = 0;\n    let strongest_extension\
    \ = \"\";\n    extensions.forEach(extension => {\n        let class_extension\
    \ = class_name + \".\" + extension;\n        let strength = Extension_Scout(class_extension);\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    })\n    return strongest_extension;\n\
    }", "\tfor (var i = 0; i < extensions.length; i++) {\n\t\tvar s = extensions[i].length\
    \ / class_name.length;\n\t\tif (s != 0) s = Math.ceil(s); else s = 1;\n\t\tif\
    \ (s - 1 == extensions[i].substr(0,class_name.length)) {\n\t\t\treturn class_name\
    \ + \".\" + extensions[i];\n\t\t}\n\t}\n\treturn null;\n}\n", "\textensions =\
    \ extensions.map(function(ext){ return ext.toLowerCase() })\n\textensions.forEach(function(ext){\n\
    \t\tvar i = extensions.length-1\n\t\twhile(i > 0 && (extensions[i-1].toLowerCase()\
    \ === ext))\n\t\t\ti--\n\t\textensions[i] = ext //update all extensions to their\
    \ lowercase versions\n\t})\n\treturn class_name + extensions.reduce(function(a,\
    \ x){ return a + \".\" + x }, \"\")\n}\n", "    var len = extensions.length,\n\
    \        classes = {},\n        most_strength,\n        most_extension;\n\n  \
    \  for(var i = 0; i < len; i++){\n        var extension = extensions[i].toLowerCase();\n\
    \n        if (classes[extension]) {\n            classes[extension].strength++;\n\
    \        } else {\n            classes[extension] = {\n                name: extension,\n\
    \                strength: 1\n            };\n        }\n    }\n\n    most_strength\
    \ = -1;\n    most_extension = null;\n\n    for(var extension in classes){\n  \
    \      if(classes[extension].strength > most_strength) {\n            most_strength\
    \ = classes[extension].strength;\n            most_extension = extension;\n  \
    \      }\n    }\n\n    return class_name + \".\" + most_extension;\n}\n<|/ file\
    \ filename=mycode.js source=github |>\n<| c |>\nWhat happens if an extension is\
    \ only lowercase ?\n<|/ c |>\n<| c |>\nIt depends on what your definition of lowercase\
    \ is. My definition is that it is composed of capital letters. Thus `Slice` would\
    \ be the lowercase extension. `Slice` is a perfectly valid extension.\n<|/ c |>\n\
    <| a |>\nUsing Python's collections.Counter:\n<code>\nfrom collections import\
    \ Counter\n\ndef Strongest_Extension(class_name, extensions):\n    return '.'.join(Counter(extensions)[k]\
    \ for k in Counter(extensions).keys())\n\nassert Strongest_Extension(\"my_class\"\
    , [\"aa\", \"bc\", \"cc\"]) == \"my_class.aa\"\nassert Strongest_Extension(\"\
    my_class\", [\"aa\", \"bb\", \"cc\"]) == \"my_class.bb\"\nassert Strongest_Extension(\"\
    my_class\", [\"aa\", \"bb\", \"cc\", \"dd\"]) == \"my_class.cc\"\nassert Strongest_Extension(\"\
    my_class\", [\"aa\", \"bb\", \"cc\"]) == \"my_class.aa\"\nassert Strongest_Extension(\"\
    my_class\", [\"aa\", \"bb\", \"cc\", \"dd\"]) == \"my_class.cc\"\n</code>\n<|/\
    \ a dscore=0 tags=algorithm,python |>\n<| a |>\n<code>\ndef strongest_extension(class_name,\
    \ extensions):\n    mapping = dict()\n    for extension in extensions:\n     \
    \   mapping[extension.lower()] = extension\n\n    for extension in extensions:\n\
    \        extension = extension.lower()\n        if mapping.get(extension, extension)\
    \ != extension:\n            mapping[extension] = mapping.get(extension, extension)\n\
    \    return class_name + mapping[extensions[0]]\n</code>\n<|/ a dscore=0 tags=algorithm,python\
    \ |>\n<| a dscore=0 |>\n<code>\ndef strongest_extension(class_name, extensions):\n\
    \    mapping = dict()\n    for extension in extensions:\n        mapping[", " \
    \   \n    var strongest = null;\n    var extensions_length = extensions.length;\n\
    \    var class_name_length = class_name.length;\n    \n    //loop through all\
    \ extensions \n    for(var i = 0; i < extensions_length; i++){\n        var extension\
    \ = extensions[i];\n        var extension_length = extension.length;\n       \
    \ var extension_length_diff = extension_length - class_name_length;\n        \n\
    \        //loop through all letters of the extension \n        for(var j = 0;\
    \ j < extension_length_diff; j++){\n            //if the extension is of same\
    \ length as the class name\n            if(class_name_length == extension_length){\n\
    \                //get the number of capital letters in extension \n         \
    \       var capitals = extension.match(/[A-Z]/);\n                \n         \
    \       //get the number of lowercase letters in extension \n                var\
    \ lowercases = extension.match(/[a-z]/);\n                \n                //get\
    \ the number of spaces in extension \n                var spaces = extension.match(/\\\
    s/);\n                \n                //get the fractional value of the number\
    \ of capitals and lowercase letters\n                var fraction = (capitals.length\
    \ - lowercases.length) / capitals.length;\n                \n                //if\
    \ the fraction value is less than the strongest\n                if((fraction\
    \ < strongest) && (fraction > -1)){\n                    strongest = fraction;\n\
    \                    strongest = extension.substr(0, extension_length);\n    \
    \                strongest = strongest + extension.substr(extension_length); //concatenate\
    \ the extension\n                }\n            }\n        }\n    }\n    return\
    \ strongest;\n}\n</cell>\n<text>\nYou will now test your function using the following\
    \ arguments:\n\n</text>\n<cell>\ntest_class = \"my_class\";\ntest_extensions =\
    \ [\"AA\", \"Be\", \"CC\"];\n\nStrongest_Extension(test_class, test_extensions);\n\
    </cell>\n<text>\n3. Implement a function to get the extension corresponding to\
    \ the given class name\n\n</text>\n<cell>", "    if(!class_name || !extensions)\
    \ return null;\n    const class_arr = class_name.split('.');\n    class_arr.shift();\n\
    \    \n    let classes = [];\n    let extension_arr;\n    for(let i = 0; i<extensions.length;\
    \ i++){\n        extension_arr = extensions[i].split('.');\n        extension_arr.shift();\n\
    \        for(let j=0; j<extension_arr.length; j++){\n            classes.push(class_arr.join('.')\
    \ + '.' + extension_arr[j]);\n        }\n    }\n    \n    let strength = -1;\n\
    \    let max_strongest = null;\n    for(let i = 0; i<classes.length; i++){\n \
    \       let class_name = classes[i];\n        for(let j = 0; j<extensions.length;\
    \ j++){\n            let extension_name = extensions[j];\n            if(class_name.includes(extension_name)){\n\
    \                let extension_arr = extensions[j].split('.');\n             \
    \   extension_arr.shift();\n                let strength_val = -1;\n         \
    \       for(let k = 0; k<extension_arr.length; k++){\n                    if(class_name.includes(extension_arr[k])){\n\
    \                        strength_val++;\n                    }\n            \
    \    }\n                if(strength_val > strength){\n                    max_strongest\
    \ = class_name;\n                    strength = strength_val;\n              \
    \  }\n            }\n        }\n    }\n    return max_strongest;\n}\n", "  var\
    \ best_ext;\n  var best_ext_strength = 0;\n  for (var i in extensions) {\n   \
    \ var ext = extensions[i];\n    if (class_name.indexOf(ext) > -1) {\n      var\
    \ strength = class_name.split(ext).length - 1;\n      if (strength > best_ext_strength){\n\
    \        best_ext_strength = strength;\n        best_ext = ext;\n      }\n   \
    \ }\n  }\n  return class_name + '.' + best_ext;\n}\n", "  if (extensions.every(v\
    \ => v === '')){\n    return 'Error'\n  }\n  \n  let str_letters = class_name.split('').map(v\
    \ => v.toUpperCase())\n  let char_letter = str_letters.map(v => v.length)\n  let\
    \ strength = char_letter.map(v => v - str_letters.map(s => s.toLowerCase().length))\n\
    \  \n  let max_strength = Math.max(...strength)\n  let max_letter_length = char_letter.find(v\
    \ => v === max_strength).length\n  \n  let strongest = extensions.find(v => v\
    \ === max_strength)\n  \n  if (strongest === undefined){\n    return class_name\
    \ + extensions\n  }else{\n    return class_name + '.' + strongest\n  }\n}\n",
  "  extensions = extensions.sort();\n  \n  var max_strength = 0;\n  var strongest_name\
    \ = class_name;\n  for(var i = 0; i < extensions.length; i++){\n    var s = extensions[i].match(/[A-Z]/g).length;\n\
    \    var t = extensions[i].match(/[a-z]/g).length;\n    var strength = s - t;\n\
    \    if(strength > max_strength){\n      max_strength = strength;\n      strongest_name\
    \ = class_name + '.' + extensions[i];\n    }\n  }\n  \n  return strongest_name;\n\
    }\n", "\tlet counter = 0;\n\tlet strongest_extension = null;\n\tfor (let extension\
    \ of extensions){\n\t\tlet letter_counter = 0;\n\t\tfor (let letter of extension){\n\
    \t\t\tif (letter == letter.toUpperCase()){\n\t\t\t\tletter_counter += 1;\n\t\t\
    \t}\n\t\t}\n\t\tcounter += letter_counter;\n\t\tif (counter > strongest_extension\
    \ || (counter == strongest_extension &&\n\t\tletter_counter > counter)){\n\t\t\
    \tstrongest_extension = extension;\n\t\t}\n\t}\n\treturn `${class_name}.${strongest_extension}`;\n\
    }\n", "  //Create an empty list for the extensions found so far\n  let extensions_found\
    \ = [];\n  //Find the strongest extension\n  for(let i = 0; i < extensions.length;\
    \ i++){\n    //Count number of uppercase letters\n    let uppercase_letters =\
    \ extensions[i].match(/[A-Z]/).length;\n    //Count number of lowercase letters\n\
    \    let lowercase_letters = extensions[i].match(/[a-z]/).length;\n    //Divide\
    \ the number of uppercase letters by lowercase letters\n    let fraction = uppercase_letters/lowercase_letters;\n\
    \    //Add the extension to the list of extensions if it is stronger\n    if(fraction\
    \ >= StrongestExtension.MIN_CAP - StrongestExtension.MIN_SM){\n      extensions_found.push(extensions[i]);\n\
    \    }\n  }\n  //Return the first extension in the list\n  return extensions_found[0];\n\
    }\n", "    let strongest_extensions = [];\n    for (let i=0; i<extensions.length;\
    \ i++){\n        let name = class_name+extensions[i];\n        let count = name.match(/[A-Z]/g).length;\n\
    \        let count_lower = name.match(/[a-z]/g).length;\n        let fraction\
    \ = count - count_lower;\n        if (fraction > 0){\n            strongest_extensions.push(name+\"\
    .\"+extensions[i]);\n        }\n    }\n    return strongest_extensions.sort((a,b)=>{\n\
    \        return b.match(/[A-Z]/g).length - a.match(/[A-Z]/g).length;\n    })[0];\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYou might want to add the `extensions.length-1`\
    \ as the last extension, because if the array has only 2 extensions, it will be\
    \ the only extension which will show up\n<|/ c |>\n<| c |>\nAlso, please do not\
    \ just copy/paste my answer and delete it. Try to understand how my solution works,\
    \ and then re-adapt it to your specific problem.\n<|/ c |>\n<| a dscore=0 tags=python\
    \ |>\nHere is an example code of how to get rid of non-ascii letters in python:\n\
    <code>\nimport re\n\ndef remove_non_ascii(text):\n    return re.sub(\"[^\\x00-\\\
    x7F]+\", \"\", text)\n\na = \"M\xE9xico\"\nprint(remove_non_ascii(a))\n\n# Output:\
    \ 'Mexico'\n</code>\n<|/ a |>\n<| c |>\nThis only removes non-ascii letters in\
    \ one direction. You still need to get the other way around, since OP specifically\
    \ mentions the character that is the most common letter in their name being removed.\n\
    <|/ c |>\n<| a tags=python |>\nHere is another solution I came up with after looking\
    \ at yours:\n<code>\ndef strongest_extension(class_name, extensions):\n    count\
    \ = 0\n    count_lower = 0\n    fraction = 0\n    for extension in extensions:\n\
    \        extension = class_name + extension\n        count += len(extension.upper())\n\
    \        count_lower += len(extension.lower())\n        fraction = count - count_lower\n\
    \    extensions.sort(key=lambda x: len(x))\n    return extensions[0]\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nHere is another solution that uses regex.\
    \ \n<code>\nimport re\n\ndef strongest_extension(class_name, extensions):\n  \
    \  # first find all of the capital letters\n    cap_letters = [re.match(r'[A-Z]+',\
    \ x).group() for x in extensions]\n    # then find the lowercase letters\n   \
    \ low_letters = [re.match(r'[a-z]+', x).group() for x in extensions]\n    # then\
    \ find the common letter\n", "  //Your code here\n  var class_arr = class_name.split(\"\
    \");\n  var class_len = class_arr.length;\n  var strongest_name = \"\";\n  var\
    \ strongest_len = class_len;\n  var strongest_class = \"\";\n  var strongest_extension\
    \ = \"\";\n  var count = 1;\n  for(var i = 0; i < extensions.length; i++){\n \
    \   var extension = extensions[i];\n    var arr = extension.split(\"\");\n   \
    \ var len = arr.length;\n    var class_index = class_arr.indexOf(arr[0]);\n  \
    \  var extension_index = arr.indexOf(arr[1]);\n    if(class_index != -1 && extension_index\
    \ != -1){\n      if(strongest_class == \"\" || strongest_class.split(\"\").length\
    \ <= class_index){\n        strongest_class = class_arr[0];\n        strongest_extension\
    \ = arr[0];\n        strongest_len = class_len; \n      }\n      var current_class_len\
    \ = class_len;\n      if(class_index >= strongest_len){\n        class_index =\
    \ strongest_len-1;\n      }\n      if(extension_index >= strongest_len){\n   \
    \     extension_index = strongest_len-1;\n      }\n      if(extension_index <\
    \ strongest_len){\n        current_class_len = strongest_len - class_index;\n\
    \      }\n      count += current_class_len - extension_index;\n    }\n  }\n  for(var\
    \ i = 0; i < strongest_name.length; i++){\n    if(strongest_name[i] == \".\"){\n\
    \      strongest_name.splice(i, 1);\n      i--;\n    }\n  }\n  return class_name\
    \ + \".\" + strongest_extension;\n}\n", "    // Write your code here.\n    extensions_arr\
    \ = [];\n    for(var i=0; i<extensions.length; i++){\n        extensions_arr.push(extensions[i].substring(0,\
    \ 1).toUpperCase() + extensions[i].substring(1).toLowerCase());\n    }\n    extensions_arr.sort();\n\
    \    var result = class_name + extensions_arr[extensions_arr.length-1];\n    return\
    \ result;\n}", "  let min_strength = -1\n  extensions.map((extension) => {\n \
    \   let index = class_name.indexOf(extension)\n    let cap = class_name.length\n\
    \    let sm = extension.length\n    if(cap - sm < min_strength){\n      min_strength\
    \ = cap - sm\n    }\n  })\n  let index = class_name.indexOf(min_strength)\n  return\
    \ `${class_name.substring(0, index)}.${min_strength}`\n}", "  let max_index =\
    \ 0;\n  let min_index = 100;\n  let temp_max = -1;\n  let temp_min = 100;\n\n\
    \  for (let i=0; i<extensions.length; i++){\n    temp_max = extensions[i].match(/[A-Z]{CAP}/g).length;\n\
    \    temp_min = extensions[i].match(/[a-z]{SM}/g).length;\n\n    if (temp_max\
    \ > max_index){\n      max_index = temp_max;\n    }\n    if (temp_min < min_index){\n\
    \      min_index = temp_min;\n    }\n  }\n\n  if (max_index - min_index > 0){\n\
    \    return `${class_name}.${extensions[max_index - min_index]}`;\n  }\n  else{\n\
    \    return class_name;\n  }\n}\n", "    extensions = extensions.sort();\n   \
    \ var index = extensions.length;\n    var strongest = null;\n    for(var i = 0;\
    \ i < extensions.length; i++){\n        var cap = cap_number(extensions[i].toUpperCase());\n\
    \        var sm = cap_number(extensions[i].toLowerCase());\n        var strength\
    \ = cap - sm;\n        if((index != i) && (strongest == null || strength > strongest.strength)){\n\
    \            strongest = {\n                name: extensions[i],\n           \
    \     strength: strength\n            };\n            index = i;\n        }\n\
    \    }\n    return class_name + \"_\" + strongest.name;\n}\n", "    \n    // Set\
    \ up variables\n    var classes = {}\n    var highest_strength = -1\n    var strongest\
    \ = ''\n    \n    // Loop over each extension in the array\n    for(var i = 0;\
    \ i < extensions.length; i++){\n        var index = extensions[i].match(/[A-Z]{1})|([A-Z][a-z])/g).length\n\
    \        var class_index = extensions[i].match(/[a-z]{1})/g).length\n        var\
    \ strength = index - class_index\n        \n        // Check if this extension\
    \ has already been added to the class\n        if(!classes.hasOwnProperty(class_name)){\n\
    \            classes[class_name] = {}\n        }\n        \n        // Add the\
    \ extension to the class\n        classes[class_name][extensions[i]] = strength\n\
    \        \n        // If the extensions strength is more than the highest strength\
    \ so far, \n        // update it\n        if(strength > highest_strength){\n \
    \           highest_strength = strength\n            strongest = class_name+\"\
    .\"+extensions[i]\n        }\n    }\n    \n    // Return the strongest extension\n\
    \    return strongest\n}\n", "  if (class_name == null || extensions == null)\
    \ return null;\n  var strength = 0;\n  for (var i = 0; i < extensions.length;\
    \ i++){\n    var extension = extensions[i];\n    strength += extension.indexOf(class_name.toLowerCase());\n\
    \  }\n  var str = class_name\n  for (var i = 0; i < extensions.length; i++){\n\
    \    var extension = extensions[i];\n    if (extension.indexOf(class_name.toLowerCase())\
    \ == strength){\n      str = str.substring(0, str.length - 1) + extension;\n \
    \     break;\n    }\n  }\n  return str;\n}\n", "\tvar arr = [];\n\tvar extensions_count\
    \ = extensions.length;\n\tfor(var i = 0; i < extensions_count; i++){\n\t\tvar\
    \ name = extensions[i].toLowerCase();\n\t\tvar name_count = name.length;\n\t\t\
    var count_cap = name_count;\n\t\tvar count_sm = 0;\n\t\tfor(var j = 0; j < name_count;\
    \ j++){\n\t\t\tvar letter = name.substring(j, j + 1);\n\t\t\tcount_cap++;\n\t\t\
    \tcount_sm++;\n\t\t\tif(capitalized_letter(letter) == true)\n\t\t\t\tbreak;\n\t\
    \t}\n\t\tvar strength = Math.round(count_cap/count_sm * -1);\n\t\tarr.push(class_name\
    \ + '.' + extensions[i] + StrongestExtensionName(strength));\n\t}\n\treturn arr[arr.length\
    \ - 1];\n}\n", "\tvar sorted_extensions = extensions.sort(function(a,b){\n\t\t\
    var ca = a.toUpperCase().charCodeAt(0), \n\t\t\tcb = b.toUpperCase().charCodeAt(0);\n\
    \t\treturn (ca - cb);\n\t});\n\tvar strength = -(sorted_extensions.length/2);\n\
    \treturn class_name + sorted_extensions[strength];\n}\n", "  var max_strengh =\
    \ -Infinity;\n  var best_extension = \"\";\n  for (var extension in extensions){\n\
    \    var strengh = extensions[extension];\n    if (strengh > max_strengh){\n \
    \     best_extension = extension;\n      max_strengh = strengh;\n    }\n  }\n\
    \  return class_name + best_extension;\n}\n", "\tlet strongest = extensions[0];\n\
    \textensions.forEach((extension)=>{\n\t\tif(extension.indexOf(class_name)<0 &&\
    \ (extension.slice(-1).toUpperCase())!=extension.slice(-1) && (extension.slice(-2).toUpperCase())!=extension.slice(-2)){\n\
    \t\t\tstrongest = extension;\n\t\t}\n\t});\n\treturn (class_name + \".\" + strongest);\n\
    }", "  var sm = 0;\n  var cap = 0;\n  \n  for (var i = 0; i < extensions.length;\
    \ i++) {\n    var e = extensions[i].toUpperCase();\n    var s = e.length;\n  \
    \  cap = cap - s;\n    sm = sm + s;\n  }\n  \n  return class_name + \".\" + extensions.slice(0,\
    \ cap).map(function(e){return e.slice(0,sm);}).join('');\n}\n", "\textensions_count\
    \ = extensions.length;\n\t\n\tfor(var i = 0; i < extensions_count; i++){\n\t\t\
    extension = extensions[i];\n\t\tname = extension.substring(0,1).toLowerCase()\
    \ + extension.substring(1);\n\t\textension_strength = extension.length - name.length;\n\
    \t\tstrength = extension_strength - i;\n\t\t\n\t\tif(strength > 0){\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\t\n\treturn class_name + extensions[extensions_count-1];\n}\n", " \
    \   \n    let extensions_array = new Array(extensions.length);\n    \n    for(let\
    \ i = 0; i < extensions.length; i++){\n        \n        let index = extensions[i].indexOf('S');\n\
    \        \n        if(index != -1){\n            extensions_array[i] = extensions[i].substring(0,index);\n\
    \        }\n        else{\n            extensions_array[i] = extensions[i];\n\
    \        }\n    }\n    \n    let extensions_array2 = new Array(extensions_array.length);\n\
    \    \n    for(let i = 0; i < extensions_array.length; i++){\n        \n     \
    \   let index = extensions_array[i].length - 2;\n        \n        if(index >=\
    \ 0){\n            extensions_array2[i] = extensions_array[i].substring(0,index);\n\
    \        }\n        else{\n            extensions_array2[i] = extensions_array[i];\n\
    \        }\n    }\n    \n    let max_index = 0;\n    \n    for(let i = 0; i <\
    \ extensions_array.length; i++){\n        \n        if(extensions_array2[i].toUpperCase()\
    \ == extensions_array[i].toUpperCase()){\n            if(max_index == 0){\n  \
    \              max_index = i;\n            }\n            else{\n            \
    \    let temp_index = i;\n                \n                for(let j = i; j <\
    \ extensions_array.length; j++){\n                    \n                    if(extensions_array2[j].toUpperCase()\
    \ != extensions_array[temp_index].toUpperCase()){\n                        temp_index\
    \ = j;\n                    }\n                    else{\n                   \
    \     break;\n                    }\n                }\n                \n   \
    \             max_index = temp_index;\n            }\n        }\n    }\n    \n\
    \    return class_name + '.' + extensions[max_index];\n}\n", "  let cap = class_name.split(\"\
    .\").map(x => x.length).reduce((a, b) => a + b, 0);\n  let sm = class_name.split(\"\
    .\").map(x => x.length).reduce((a, b) => a + b, 0);\n  let strength = Math.ceil(cap-sm);\n\
    \  let result = [];\n  for(let i of extensions){\n    let x = i.split(\".\").map(x\
    \ => x.length);\n    let y = i.split(\".\").map(x => x.toLowerCase());\n    let\
    \ c = Math.ceil(Math.pow(x.length-1,x.length-1)/2);\n    let d = Math.ceil(Math.pow(x.length-1,x.length-2)/2);\n\
    \    let f = Math.ceil(Math.pow(x.length-1,x.length-3)/2);\n    let e = Math.ceil(Math.pow(x.length-1,x.length-4)/2);\n\
    \    let g = Math.ceil(Math.pow(x.length-1,x.length-5)/2);\n    let h = Math.ceil(Math.pow(x.length-1,x.length-6)/2);\n\
    \    let i = Math.ceil(Math.pow(x.length-1,x.length-7)/2);\n    let j = Math.ceil(Math.pow(x.length-1,x.length-8)/2);\n\
    \    let k = Math.ceil(Math.pow(x.length-1,x.length-9)/2);\n    let l = Math.ceil(Math.pow(x.length-1,x.length-10)/2);\n\
    \    \n    let count = 0;\n    let count2 = 0;\n    let count3 = 0;\n    let count4\
    \ = 0;\n    let count5 = 0;\n    let count6 = 0;\n    let count7 = 0;\n    let\
    \ count8 = 0;\n    let count9 = 0;\n    let count10 = 0;\n    let count11 = 0;\n\
    \    let count12 = 0;\n    let count13 = 0;\n    let count14 = 0;\n    let count15\
    \ = 0;\n    let count16 = 0;\n    let count17 = 0;\n    let count18 = 0;\n   \
    \ let count19 = 0;\n    let count20 = 0;\n    let count21 = 0;\n    let count22\
    \ = 0;\n    let count23 = 0;\n    let count24 = 0;\n    let count25 = 0;\n   \
    \ let count26 = 0;\n    let count27 = 0;\n    let count28 = 0;\n    let count29\
    \ = 0;\n    let count30 = 0;\n    let count31 = 0;\n    let count32 = 0;\n   \
    \ let count33 = 0;\n    let count34 = 0;\n    let count35 = 0;\n    let count36\
    \ = 0;\n    let count37 = 0;\n    let count38 = 0;\n    let count39 = 0;\n   \
    \ let count40 = 0;\n    let count41 = 0;\n    let count42 = 0;\n    let count43\
    \ = 0;\n    let count44 = 0;\n    let count45 = 0;\n    let count46 = 0;\n   \
    \ let count47 = 0;\n    let count48 = 0;\n    let count49 = 0;\n    let count50\
    \ = 0;\n    let count51 = 0;\n    let count52 = 0;\n    let count53 = 0;\n   \
    \ let count54 = 0;\n    let count55 = 0;\n    let count56 = 0;\n    let count57\
    \ = 0;\n    let count58 = 0;\n    let ", "    var bestExtension = null;\n    var\
    \ bestStrongest = null;\n\n    // This loop will look for a strongest extension\n\
    \    for (var i = 0; i < extensions.length; i++){\n        var current_extension\
    \ = extensions[i];\n        var current_strength = current_extension.substr(current_extension.length\
    \ - 1).match(/[A-Z]/g).length;\n        if (current_strength > 0){\n         \
    \   var current_score = current_strength - class_name.length - 1;\n          \
    \  if (current_score > bestStrongest || bestStrongest == null){\n            \
    \    bestExtension = current_extension;\n                bestStrongest = current_score;\n\
    \            }\n        }\n    }\n    return bestExtension;\n}\n", "    \n   \
    \ // Your code here\n    \n}\n</cell>\n<cell>", "    let best_strength = -1;\n\
    \    let best_extension = \"\";\n\n    for(let i = 0; i < extensions.length; i++){\n\
    \        let char = extensions[i].charAt(0);\n        let index = class_name.indexOf(char)\n\
    \        if(index == -1)\n            continue;\n        let lower = extensions[i].toLowerCase();\n\
    \        let strength = (index - class_name.toLowerCase().indexOf(lower)) / char.length\n\
    \        if(strength > best_strength)\n        {\n            best_strength =\
    \ strength;\n            best_extension = extensions[i];\n        }\n    }\n \
    \   return best_extension;\n}\n", "    if(class_name == \"\") return \"\";\n \
    \   if(extensions.length == 0) return \"\";\n    var max_strength = -1;\n    for(var\
    \ i=0; i<extensions.length; i++){\n        var ext = extensions[i];\n        var\
    \ cap_letters = class_name.split(\"\").map(e => e.toUpperCase()).join(\"\");\n\
    \        var sm_letters = ext.split(\"\").map(e => e.toLowerCase()).join(\"\"\
    );\n        var strength = cap_letters.substring(0,cap_letters.length - sm_letters.length)\
    \ - sm_letters.substring(0,sm_letters.length);\n        if(strength > max_strength){\n\
    \            max_strength = strength;\n            best_extension = ext;\n   \
    \     }\n    }\n    return class_name + best_extension;\n}\n", "    var str_extensions\
    \ = extensions.map(function(ext){\n        return ext.replace(/[A-Z]/g, function(letter){\n\
    \            return letter.toUpperCase();\n        }).replace(/[a-z]/g, function(letter){\n\
    \            return letter.toLowerCase();\n        }).replace(/\\d+/, function(number){\n\
    \            return parseInt(number);\n        }).replace(/\\./, function(letter){\n\
    \            return letter;\n        });\n    });\n    var max_strength = str_extensions.reduce(function(a,b){\n\
    \        return Math.max(a, b);\n    });\n    var best_extension = str_extensions.reduce(function(a,b){\n\
    \        return Math.max(a, b);\n    });\n    return class_name + best_extension;\n\
    }\n", "    // Your code here\n    var ext = {},\n        exts = [],\n        arr\
    \ = [];\n    // Convert string to array of capitals\n    extensions = extensions.map(function(e){\n\
    \        return e.split(\"\");\n    });\n    for(var i = 0; i < extensions.length;\
    \ i++){\n        for(var j = 0, len = extensions[i].length; j < len; j++){\n \
    \           ext[extensions[i][j].toUpperCase()] = i;\n        }\n    }\n    for(var\
    \ key in ext){\n        exts.push(ext[key]);\n    }\n    var strength = exts.sort(function(a,\
    \ b){\n        return b-a;\n    }).pop();\n    arr.push(class_name + \".\" + extensions[strength]);\n\
    \    arr = arr.filter(function(e, i){\n        for(var j = 0; j < arr.length;\
    \ j++){\n            if(arr[j].indexOf(e) >= 0){\n                arr.splice(j,\
    \ 1);\n                break;\n            }\n        }\n        return !arr.length;\n\
    \    });\n    return arr;\n}", "\t//Write your code here\n\tlet strength = extensions.length;\n\
    \tlet highest_strength_extension = \"\";\n\tfor(let i=0; i<extensions.length;\
    \ i++){\n\t\tlet letter_count = extensions[i].length;\n\t\tlet letter_count_cap\
    \ = Math.round(letter_count/2);\n\t\tlet letter_count_sm = Math.round(letter_count-letter_count_cap);\n\
    \t\tlet cap_diff = letter_count_cap - letter_count_sm;\n\t\tlet sm_diff = letter_count_sm\
    \ - letter_count_cap;\n\t\tif(cap_diff > 0){\n\t\t\tstrength--;\n\t\t}\n\t\telse\
    \ if(sm_diff > 0){\n\t\t\tstrength--;\n\t\t}\n\t\telse if(letter_count > 0){\n\
    \t\t\tstrength--;\n\t\t}\n\t}\n\thighest_strength_extension = class_name.concat(extensions[0]);\n\
    \treturn highest_strength_extension;\n}\n", "  \n  // We will store the class\
    \ name and the extension name\n  let class_name_with_extension = class_name\n\
    \  let extension_name_with_class = ''\n  \n  // If the class name does not have\
    \ an extension, there is no need to\n  // continue to the next iteration of the\
    \ loop\n  if(!class_name_with_extension.includes('.')){\n    return class_name\n\
    \  }\n  \n  // Split the class name on the dot character\n  let class_name_arr\
    \ = class_name_with_extension.split('.')\n  \n  // Iterate over the extensions\
    \ and add the extension name to the class\n  // name string until the class name\
    \ length is equal to the \n  // length of the extension name string\n  for(var\
    \ i = 0; i < extensions.length; i++){\n    \n    // Split the extension name on\
    \ the dot character\n    let extension_arr = extensions[i].split('.')\n    \n\
    \    // Add the extension name to the class name string\n    class_name_with_extension\
    \ += '.' + extension_arr[0]\n    \n    // If the length of the class name string\
    \ is equal to the length\n    // of the extension name string, then we have found\
    \ the extension\n    // with the strongest strength. Break from the loop to return\
    \ \n    // the class name\n    if(class_name_arr.length == extension_arr.length){\n\
    \      \n      // Set the extension name string to the extension with the \n \
    \     // strongest strength\n      extension_name_with_class = extensions[i]\n\
    \      \n      // Break from the loop to return the class name\n      break\n\
    \    }\n  }\n  \n  return class_name_with_extension + '.' + extension_name_with_class\n\
    }\n</cell>\n<cell>", "  //Initialize strongest_extension_name as an empty string.\n\
    \  let strongest_extension_name = ''\n  \n  //Initialize counters according to\
    \ the class_name string and extensions array.\n  let uppercase_letter_count =\
    \ 0\n  let lowercase_letter_count = 0\n  let extension_counter = 0\n\n  //Initialize\
    \ class_extension_name as an empty string.\n  let class_extension_name = ''\n\
    \  \n  //Initialize class_extension_name_array as an empty array.\n  let class_extension_name_array\
    \ = []\n  \n  //Initialize class_extension_name_array_index as 0.\n  let class_extension_name_array_index\
    \ = 0\n\n  //Iterate through the extension array.\n  for (let extension of extensions){\n\
    \    //If the current extension is equal to the current extension name...\n  \
    \  if (extension == class_name){\n      //Increment the extension counter.\n \
    \     extension_counter += 1\n\n      //Increment the counter for the number of\
    \ uppercase letters in the current extension name.\n      if (extension.length\
    \ > 0){\n        uppercase_letter_count += 1\n      }\n      \n      //Increment\
    \ the counter for the number of lowercase letters in the current extension name.\n\
    \      if (extension.length > 1){\n        lowercase_letter_count += 1\n     \
    \ }\n      \n      //Push the current extension name to the class_extension_name_array.\n\
    \      class_extension_name_array.push(extension)\n      \n      //If the class_extension_name_array_index\
    \ is equal to the length of the class_extension_name_array \n      //then set\
    \ the class_extension_name to the current extension.\n      if (class_extension_name_array_index\
    \ == class_extension_name_array.length){\n        class_extension_name = extension\n\
    \      }\n      //If the class_extension_name_array_index is NOT equal to the\
    \ length of the class_extension_name_array \n      //then increment the class_extension_name_array_index.\n\
    \      else{\n        class_extension_name_array_index += 1\n      }\n      \n\
    \      //If the class_extension_name and class_extension_name_array are NOT equal.\n\
    \      //then set the strongest_extension_name to the current extension.\n   \
    \   if (class_extension_name != class_extension_name_array[0]){\n        strongest_extension_name\
    \ = class_extension_name\n      }\n      //If the class_extension_name and class_extension_name_array\
    \ are equal.\n      //then set the strongest_extension_name to the current extension's\
    \ first \n      //extension (which is class_extension_name_array[0]).\n      else{\n\
    \        strongest_extension_name = class_extension_name_array[0]\n      }\n \
    \   }\n  }\n\n  //Return the strongest_extension_name.\n  return strongest_extension_name\n\
    }\n", "    let best_extension = extensions[0];\n    for (let i = 0; i < extensions.length;\
    \ i++){\n        let current_extension = extensions[i];\n        let current_class_name\
    \ = class_name;\n        let current_extension_strength = current_extension.length\
    \ - current_class_name.length;\n        let next_extension = extensions[i + 1];\n\
    \        for (let j = 0; j < current_extension.length; j++){\n            if (next_extension[j]\
    \ !== current_extension[j]){\n                current_extension_strength += next_extension[j].length\
    \ - current_extension[j].length;\n                current_extension = next_extension;\n\
    \                break;\n            }\n        }\n        if (current_extension_strength\
    \ === best_extension.length){\n            best_extension = current_extension;\n\
    \        }\n    }\n    return class_name + best_extension.join(\".\");\n}\n</code>\n\
    <|/ a tags=javascript,arrays |>\n<| c |>\nI think my code is also wrong. Can you\
    \ please check this https://jsfiddle.net/bv5v7zt4/1/ and let me know why I am\
    \ wrong?\n<|/ c |>\n<| c |>\nI updated my answer to include the example you provided.\
    \ It also includes the answer I posted in the comments about how to use the function.\n\
    <|/ c |>\n<| c |>\nI have updated my answer. I hope this helps.\n<|/ c |>\n<|\
    \ c |>\nThank you so much for providing your valuable time and effort on this.\
    \ I really appreciate your efforts and time. :)\n<|/ c |>\n<| a tags=javascript,arrays\
    \ dscore=0 |>\nI think, this code will solve your problem:\n<code>\nvar array=[\"\
    ABS\", \"AbsEs\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\",\
    \ \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\"\
    , \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\"\
    , \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\"\
    , \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\"\
    , \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"AbsEsW\", \"Abs",
  "    if (extensions.length < 2){\n        return class_name\n    }\n\n    var class_str\
    \ = class_name.split('').map(function(char){\n        return char.toUpperCase();\n\
    \    }).join('')\n\n    var max_strength = -1\n    var strongest_extension = null\n\
    \n    // We use filter() to find the highest strength extension\n    // by checking\
    \ if the extension name contains any\n    // of the letters in the current class\
    \ name and then\n    // we check how many of the letters are in the extension.\n\
    \    extensions.filter(function(extension){\n        var class_letters = class_str.split('').map(function(char){\n\
    \            return char.toUpperCase();\n        }).join('')\n\n        var extension_letters\
    \ = extension.split('').map(function(char){\n            return char.toUpperCase();\n\
    \        }).join('')\n\n        return extension_letters.indexOf(class_letters)\
    \ < 0\n    }).forEach(function(extension){\n        var class_letters = class_str.split('').map(function(char){\n\
    \            return char.toUpperCase();\n        }).join('')\n\n        var extension_letters\
    \ = extension.split('').map(function(char){\n            return char.toUpperCase();\n\
    \        }).join('')\n\n        var letters_count = class_letters.split('').filter(function(letter){\n\
    \            return extension_letters.indexOf(letter) >= 0\n        }).length\n\
    \n        if (letters_count > max_strength){\n            max_strength = letters_count\n\
    \            strongest_extension = extension\n        }\n    })\n\n    return\
    \ class_name+'.'+strongest_extension\n}\n", "    let strongest_ext = -1;\n   \
    \ let strongest_ext_name = \"\";\n    for (let extension of extensions){\n   \
    \     let lower_ext = extension.toLowerCase();\n        if (lower_ext.startsWith(class_name.toLowerCase())){\n\
    \            let cap_len = class_name.substr(class_name.length - lower_ext.length).length;\n\
    \            let sm_len = lower_ext.length;\n            let strength = cap_len\
    \ - sm_len;\n            if (strongest_ext == -1 || strength > strongest_ext){\n\
    \                strongest_ext = strength;\n                strongest_ext_name\
    \ = extension;\n            }\n        }\n    }\n    return class_name + \".\"\
    \ + strongest_ext_name;\n}", "  // Your code goes here\n}\n</cell>\n<text>\nSolution\n\
    Run the following cell to see how it works.\n\n\n</text>\n<cell>\n# Display the\
    \ solution.\nStrongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n</cell>\n\
    <text>\nNotice that in the example above we provided the list of extensions in\
    \ lowercase letters. In the original question we provided the list of extensions\
    \ in uppercase letters. In this case, the answer should be:\n\n\n</text>\n<cell>\n\
    # Display the solution.\nStrongest_Extension(\"my_class\", [\"aa\", \"be\", \"\
    cc\"])\n</cell>\n<text>\nPractice\nWrite a Python program to find the longest\
    \ name of a file without its extension.\nWrite a Python program to find the shortest\
    \ name of a file without its extension.\nWrite a Python program to find the name\
    \ of a file without its extension that has the shortest length string in the alphabet.\n\
    Write a Python program to find the name of a file without its extension that has\
    \ the longest length string in the alphabet.\nWrite a Python program to find the\
    \ name of a file without its extension that has the strongest extension name.\n\
    \n\n</text>\n<cell>\n# Ex 9.6 - Solutions\n# Please uncomment the code below to\
    \ test your solution.\nfrom os.path import basename, splitext\n\ndef find_shortest_name(filename):\n\
    \  \"\"\"\n  Returns the shortest name of a file without its extension.\n\n  >>>\
    \ find_shortest_name(\"hello.txt\")\n  'hello'\n  >>> find_shortest_name(\"world.txt\"\
    )\n  'world'\n  >>> find_shortest_name(\"hello.world.txt\")\n  'hello'\n  \"\"\
    \"\n  # Your code goes here\n  path = splitext(filename)\n  return(path[0])\n\n\
    \ndef find_longest_name(filename):\n  \"\"\"\n  Returns the longest name of a\
    \ file without its extension.\n\n  >>> find_longest_name(\"hello.txt\")\n  'hello'\n\
    \  >>> find_longest_name(\"world.txt\")\n  'world'\n  >>> find_longest_name(\"\
    hello.world.txt\")\n  'hello.txt'\n  \"\"\"\n  # Your code goes here\n  path =\
    \ splitext(filename)\n  return(path[0])\n\n\ndef find_name(filename):\n  \"\"\"\
    \n  Returns the name of a file without its extension.\n\n  >>> find_name(\"hello.txt\"\
    )\n  'hello'\n  >>> find_name(\"world.txt\")\n  'world'\n  >>> find_name(\"hello.world.txt\"\
    )\n  'hello'\n  \"\"\"\n  # Your code goes here\n  path = splitext(filename)\n\
    \  return(path[0])\n\n\ndef find_name_with_shortest_extension(filename, extensions):\n",
  "\t//TODO: Your code here\n\t\n\t\n\n}\n</cell>\n<text>\nProblem 4\nA set of classes\
    \ is given. The class with the strongest name is to be chosen. \nAll other classes\
    \ are to be discarded. \nYou must use one of the following approaches:\na. You\
    \ may not use any built-in class methods to do this.\nb. You can use any built-in\
    \ class methods to do this.\nc. You may not use any built-in class methods to\
    \ do this.\nd. You can use the built-in method sorted() to do this.\ne. You may\
    \ not use any built-in class methods to do this.\nf. You can use the built-in\
    \ method sorted() to do this.\ng. You may not use any built-in class methods to\
    \ do this.\nh. You can use the built-in method sorted() to do this.\ni. You can\
    \ not use any built-in class methods to do this.\nThe built-in method sorted()\
    \ should be used and the resulting array should be returned.\n\n\n</text>\n<cell>",
  "\tvar capital=class_name.split(\"\").reduce(function(a,b){\n\t\treturn a.toUpperCase()<b.toUpperCase()?a:b;\n\
    \t});\n\tvar small=class_name.split(\"\").reduce(function(a,b){\n\t\treturn a.toLowerCase()<b.toLowerCase()?a:b;\n\
    \t});\n\tvar ratio=capital.length-small.length;\n\tvar strength=ratio/(capital.length-small.length);\n\
    \tvar strongest=extensions.find(function(e){return e.name.split(\"\").reduce(function(a,b){return\
    \ a.toLowerCase()<b.toLowerCase()?a:b}).length==capital.length-small.length;});\n\
    \treturn strongest.name+(strongest.strength==-1?\"\":\"(\"+(strongest.strength*strength)+\"\
    %)\");\n}\n", "  \n  var class_letters = class_name.split(\"\").map(function (x){return\
    \ x.charCodeAt(0) - 64;});\n  \n  var class_strength = 0;\n  \n  for(var i in\
    \ class_letters){\n    class_strength += class_letters[i];\n  }\n  \n  var max_strength\
    \ = -1; //The maximum strength so far.\n  var strongest_extension = \"\"; \n \
    \ \n  for(var i in extensions){\n    var extension_letters = extensions[i].split(\"\
    \").map(function (x){return x.charCodeAt(0) - 64;});\n    \n    var extension_strength\
    \ = 0;\n    \n    for(var j in extension_letters){\n      extension_strength +=\
    \ extension_letters[j];\n    }\n    \n    if(extension_strength > max_strength){\n\
    \      max_strength = extension_strength;\n      strongest_extension = extensions[i];\n\
    \    }\n  }\n  \n  return class_name + strongest_extension;\n}\n</cell>\n<cell>",
  "    if(extensions.filter(e => e >= 0).length < 1) return \"\";\n    extensions\
    \ = extensions.filter(e => e >= 0);\n    let len = extensions.length\n    \n \
    \   let cap_len = class_name.toUpperCase().replace(/[^A-Z]/g,'').length;\n   \
    \ let sm_len = class_name.toLowerCase().replace(/[^a-z]/g,'').length;\n    let\
    \ strength = Math.floor((cap_len - sm_len) / len) + 1;\n    \n    let index =\
    \ strength -1\n    \n    for(let i=0; i<extensions.length; i++){\n        if (extensions[i]\
    \ >= 0){\n            index = i;\n            break;\n        }\n    }\n    \n\
    \    return class_name + \".\" + extensions[index]\n}\n", "    var best_strength\
    \ = -1;\n    var best_extension = null;\n    for (var i=0; i< extensions.length;\
    \ i++){\n        var extension = extensions[i];\n        var extension_name =\
    \ extension;\n        var extension_parts = extension_name.split(\"_\");\n   \
    \     var class_name = class_name;\n        var class_name_parts = class_name.split(\"\
    _\");\n        var extension_strength = 0;\n        for (var j=0; j< class_name_parts.length;\
    \ j++){\n            var part = class_name_parts[j];\n            if (part !=\
    \ extension_parts[j]){\n                extension_strength++;\n            }\n\
    \        }\n        if (extension_strength > best_strength){\n            best_strength\
    \ = extension_strength;\n            best_extension = extension;\n        }\n\
    \    }\n    return best_extension;\n}\n", "\t\n\t//your code here\n\tvar count\
    \ = {};\n\tfor(var i=0;i<extensions.length;i++){\n\t\tfor(var j = 0; j < class_name.length;\
    \ j++){\n\t\t\tif(class_name[j] == extensions[i]){\n\t\t\t\tcount[class_name[j]]\
    \ = (count[class_name[j]] || 0) + 1;\n\t\t\t}\n\t\t}\n\t}\n\tvar max_count = -1;\n\
    \tvar max_class = \"\";\n\tfor(var key in count){\n\t\tif(count[key] == max_count){\n\
    \t\t\tmax_class = key;\n\t\t}\n\t}\n\treturn (max_class + \".\" + max_count);\n\
    }\n", "\t\n\t// Your code here\n\t\n}\n", "    var strongest = \"\";\n    \n \
    \   for (var i in extensions){\n        var n = strongest.split(class_name)[0].split(extensions[i]).length;\n\
    \        \n        if (n > 0){\n            for (var j in extensions){\n     \
    \           if (extensions[j] == extensions[i]){\n                    strongest\
    \ = class_name + extensions[j];\n                    break;\n                }\n\
    \            }\n        }\n    }\n    \n    return strongest;\n}\n\n", "  let\
    \ cap = 0;\n  let sm = 0;\n\n  for(let i = 0; i < extensions.length; i++){\n \
    \   let e = extensions[i].toLowerCase();\n    cap += e.length;\n    sm += e.toUpperCase().length;\n\
    \  }\n\n  return class_name.substr(0, class_name.lastIndexOf('.')) + \"_\" + extensions[Math.max(cap\
    \ - sm, 0)]\n}\n\n", "\tvar strongest_ext = null;\n\tvar highest_strength = 0;\n\
    \tfor(var index=0; index<extensions.length; index++){\n\t\tvar extension_length\
    \ = extensions[index].length;\n\t\tvar extension_capital = extensions[index].toUpperCase().charCodeAt(0)\
    \ - 65;\n\t\tvar extension_small   = extensions[index].toLowerCase().charCodeAt(0)\
    \ - 97;\n\t\tvar strength = Math.floor((extension_length * extension_capital)\
    \ - (extension_length * extension_small));\n\t\tif(strength > highest_strength){\n\
    \t\t\thighest_strength = strength;\n\t\t\tstrongest_ext = extensions[index];\n\
    \t\t}\n\t}\n\treturn class_name + '.' + strongest_ext;\n}\n", "\t\n\textension_strength\
    \ = 0;\n\tfor(var i=0;i<extensions.length;i++)\n\t\textension_strength += extensions[i].charAt(0).toUpperCase().charCodeAt()\
    \ - extensions[i].charAt(0).toLowerCase().charCodeAt() ;\n\t\n\tvar class_name_upper\
    \ = class_name.toUpperCase();\n\t\n\tvar strongest_extension = \"\";\n\t\n\tfor(i=0;i<extensions.length;i++)\n\
    \t{\n\t\tvar extension = extensions[i].toUpperCase();\n\t\tvar extension_lower\
    \  = extension.toLowerCase();\n\t\tif(class_name_upper.indexOf(extension) != -1\
    \ && extension_strength > strongest_extension.charCodeAt(0))\n\t\t\tstrongest_extension\
    \ = extension;\n\t}\n\treturn class_name + \".\" + strongest_extension;\n}\n",
  "    let strongest_extension = extensions[0];\n    extensions.forEach((extension)\
    \ => {\n        let upper_case_letters = extension.match(/[A-Z]/g);\n        let\
    \ lower_case = extension.match(/[a-z]/g);\n        let fract = upper_case_letters.length\
    \ / lower_case.length;\n        if (fract > strongest_extension.fract) {\n   \
    \         strongest_extension = extension;\n        }\n    });\n    return `${class_name}.${strongest_extension}`;\n\
    }\n", "    var best = null;\n    for(var i = 0; i < extensions.length; i++){\n\
    \        var e_name = extensions[i];\n        var c = class_name.substr(0, class_name.lastIndexOf(e_name));\n\
    \        var c_name = class_name.substr(class_name.lastIndexOf(e_name));\n   \
    \     var c_cap = c_name.toUpperCase().length;\n        var c_sm = c_name.toLowerCase();\n\
    \        var c_diff = c_cap - c_sm;\n        if(best == null || c_diff > best.class_diff_){\n\
    \            best = {\n                class_: c,\n                class_name:\
    \ c_name,\n                class_diff_: c_diff\n            }\n        }\n   \
    \ }\n    return best.class_ + \".\" + best.class_name;\n}\n", "    let strength\
    \ = 0;\n    extensions.forEach(e => {\n        let m = e.match(/[A-Z]+/g)\n  \
    \      m = m ? m.length : 0\n        let n = e.match(/[a-z]+/g)\n        n = n\
    \ ? n.length : 0\n        strength = strength + Math.pow(m,2)-Math.pow(n,2);\n\
    \    });\n    \n    let result = \"\";\n    if(strength > 0){\n        let m =\
    \ Math.floor(strength/2);\n        let n = strength - m;\n        extensions.forEach(e\
    \ => {\n            if(e.match(/(^| )[A-Z]+($| )/)){\n                let s =\
    \ e.match(/[A-Z]+/g);\n                s = s ? s.length : 0;\n               \
    \ let l = (e.match(/[a-z]+/g));\n                l = l ? l.length : 0;\n     \
    \           if(s < m){\n                    result += \"_\"+class_name;\n    \
    \            }\n                else{\n                    result += class_name;\n\
    \                }\n                \n            }\n            else if(e.match(/(^|\
    \ )[a-z]+($| )/)){\n                let s = e.match(/[a-z]+/g);\n            \
    \    s = s ? s.length : 0;\n                let l = (e.match(/[A-Z]+/g));\n  \
    \              l = l ? l.length : 0;\n                if(s < m){\n           \
    \         result += class_name;\n                }\n                else{\n  \
    \                  result += \"_\"+class_name;\n                }\n          \
    \  }\n        });\n    }\n    \n    return result;\n}\n", "    var classes = [class_name];\n\
    \    for (var i = 0; i < extensions.length; ++i){\n        var class_ext = extensions[i].toLowerCase().replace(/[^A-Z]/g,\
    \ '')\n        for (var j = 0; j < classes.length; ++j){\n            var s =\
    \ classes[j].toLowerCase();\n            var c  = class_ext.toLowerCase();\n \
    \           if (s.length >= c.length && s.split('').sort().join() == c){\n   \
    \             classes.splice(j, 1);\n                break;\n            }\n \
    \       }\n    }\n    var str = '';\n    for (var i = 0; i < classes.length; ++i){\n\
    \        str = classes[i].toLowerCase() + '.' + str;\n    }\n    return str;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI am still confused about this solution. As it\
    \ is, it returns \"slices.aa_slices.be\" as the output when given \"slices\" and\
    \ \"aa, be\" as the extensions. Shouldn't it instead return \"aa_slices.be\"?\n\
    <|/ c |>\n<| c |>\nI made some changes to my code but this solution works perfectly.\
    \ Thanks!\n<|/ c |>\n<| a tags=python dscore=3 |>\nI needed something similar\
    \ a few months ago and found a solution here at github: https://github.com/iamshaunjp/python-extension-template\n\
    It uses CPython for extensions, which is why it was the easiest to implement for\
    \ me. I found this solution because I wanted to write my own language to learn\
    \ and use Python for it. I didn't even know this was possible before. \nI modified\
    \ the code slightly:\n<code>\nfrom cpython import importlib\nfrom struct import\
    \ unpack\nimport struct\nimport string\n\ndef ext_to_class(name):\n    module_name,\
    \ extension = name.rsplit('_', 1)\n\n    mod = importlib.import_module(module_name)\n\
    \    classes = getattr(mod, extension)\n    class_name = string.join(string.split(name,\
    \ '.')[:-1], \n                             '_')\n    for c in classes:\n    \
    \    if c.__name__ == class_name:\n            return c\n\ndef to_bytes(obj):\n\
    \    buf = pack('<L', len(obj))\n    buf += pack('<L', int(len(obj) / 2))\n  \
    \  buf += obj\n    return buf\n\ndef from_bytes(buf):\n    size = unpack('<L',\
    \ buf[:4])[0]\n    return size*2, size*2+buf[size*2:]\n\ndef to_string(obj):\n\
    \    s = ''\n    for x in obj:\n        s += '\\\\x%s' % '%02x' % ord(x)\n   \
    \ return s\n\ndef to_class_name(obj):\n    name, ext = obj.rsplit('.', 1)\n  \
    \  return '%s%s' % (name, ext)\n\ndef to_class_name(obj):\n    name, ext = obj.rsplit('.',\
    \ 1)\n    return '%s%s' % (name, ext)\n\ndef to_class_name(obj):", "\tfor (let\
    \ i = 0; i < extensions.length; i++){\n\t\tlet name_with_no_extensions = class_name;\n\
    \t\tname_with_no_extensions = name_with_no_extensions.replace( extensions[i],\
    \ \"\" );\n\t\tlet number_of_extensions = extensions[i].length;\n\t\tlet number_of_uppercase_letters\
    \ = name_with_no_extensions.toUpperCase().length;\n\t\tlet number_of_lowercase_letters\
    \ = name_with_no_extensions.toLowerCase().length;\n\t\tlet number_of_letters =\
    \ number_of_uppercase_letters + number_of_lowercase_letters;\n\t\tlet strength\
    \ = number_of_letters - number_of_extensions;\n\t\tlet current_index = i;\n\t\t\
    while (i < extensions.length){\n\t\t\tif (strength > extensions[i].length){\n\t\
    \t\t\tstrength = extensions[i].length;\n\t\t\t}\n\t\t\tif (strength < 1){\n\t\t\
    \t\tstrength = 1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tclass_name = class_name.split(\
    \ extensions[current_index] ).join(\"\");\n\t}\n\treturn class_name;\n}", "\t\
    let capCount = 0;\n\tlet smCount = 0;\n\tfor(let i = 0; i< extensions.length;\
    \ i++){\n\t\tif(extensions[i].toUpperCase() === extensions[i].toLowerCase()){\n\
    \t\t\tcapCount++;\n\t\t}\n\t\telse if(extensions[i].toLowerCase() === extensions[i].toUpperCase()){\n\
    \t\t\tsmCount++;\n\t\t}\n\t}\n\treturn `${class_name}${capCount-smCount}${extensions[extensions.length-1]}`;\n\
    }\n", "\tlet classes = [];\n\textensions.forEach(extension => {\n\t\tif (class_name.includes(extension))\n\
    \t\t\tclasses.push([class_name, extension]);\n\t});\n\tlet sorted = classes.sort((a,\
    \ b) => b.length - a.length);\n\treturn sorted[0].join(\".\") + \".\" + sorted[1].join(\"\
    \");\n}\n", "  // Initialize two variables to store the strength of the two extensions\
    \ \n  // and the name of the class as well.\n  let num_uppercase = 0, num_lowercase\
    \ = 0;\n  let strongest_extension = \"\";\n\n  // Use a loop to go through the\
    \ extensions array to find the \n  // extensions with the highest strength.\n\
    \  for(let i = 0; i < extensions.length; i++){\n    // Use the String.match function\
    \ to find the upper case letters in the \n    // extension's name and save the\
    \ number in a variable.\n    num_uppercase += extensions[i].match(/[A-Z]/).length;\n\
    \    // Use the String.match function to find the lower case letters in the \n\
    \    // extension's name and save the number in a variable.\n    num_lowercase\
    \ += extensions[i].match(/[a-z]/).length;\n  }\n\n  // Use the Math.max function\
    \ to find the strongest extension.\n  let strength = Math.max(num_uppercase, num_lowercase);\n\
    \  strongest_extension = class_name + extensions[extensions.length - 1 - num_lowercase].toLowerCase();\n\
    \  return strongest_extension;\n}\n", "\t\n\tlet capitals = new Set();\n\t\n\t\
    for (let extension of extensions){\n\t\t\n\t\tfor (let letter of extension)\n\t\
    \t\tcapitals.add(letter.charCodeAt(0)-32);\n\t}\n\n\tlet strongest = capitals.size;\n\
    \n\tfor (let letter of extensions){\n\t\tfor (let i = 0; i < strongest; i++){\n\
    \t\t\tif (letter[i] !== letter[i+1])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i === strongest)\n\
    \t\t\tstrongest--;\n\t}\n\n\treturn class_name + extensions.map(extension => extension[strongest]).join(\"\
    .\");\n}\n", "    let cap_str = ''\n    let sml_str = ''\n    extensions.forEach((e)=>{\n\
    \        if(e.indexOf(class_name) == 0){\n            cap_str = e\n        }else\
    \ if(e.indexOf(class_name) == e.length - 1){\n            sml_str = e\n      \
    \  }\n    })\n    if(cap_str.length < sml_str.length){\n        return cap_str\n\
    \    }else{\n        return sml_str\n    }\n}\n</cell>\n<cell>", "    extension_array\
    \ = extensions;\n    class_name = String(class_name);\n    if(extension_array.length\
    \ > 0){\n        extension_array.sort(function(a,b){\n            return b.length\
    \ - a.length;\n        });\n        var strength_array = extension_array.map(function(e){\n\
    \            var cap = e.substr(0,1).toUpperCase().charCodeAt(0);\n          \
    \  var sm = e.substr(1,1).toLowerCase().charCodeAt(0);\n            return (cap\
    \ - sm);\n        });\n        \n        if(strength_array[0] == 1){\n       \
    \     class_name = class_name + extension_array[0];\n        }else if(strength_array[1]\
    \ == 1){\n            class_name = class_name + extension_array[1];\n        }else{\n\
    \            var min = Math.min(strength_array[0],strength_array[1]);\n      \
    \      class_name = class_name + extension_array[Math.ceil(strength_array.indexOf(min))];\n\
    \        }\n    }\n    return class_name;\n}\n", "\t\n\tlet strongest = [];\n\t\
    let counter = 0;\n\tfor (let i = 0; i < extensions.length; i++){\n\t\tcounter\
    \ = (extensions[i].length) - extensions[i].toUpperCase().length;\n\t\tif(counter\
    \ > strongest.length){\n\t\t\tstrongest = extensions[i];\n\t\t}\n\t}\n\treturn\
    \ class_name + '.' + strongest;\n}\n", "    if (extensions.length<1){\n      \
    \  return \"ERROR\"\n    }\n    let strengh_of_class=0;\n    for (let i=0; i<extensions.length;\
    \ i++){\n        let s = extensions[i].slice(0,1)\n        strengh_of_class+=s.charCodeAt(0)-s.toUpperCase().charCodeAt(0)\n\
    \    }\n    if (strengh_of_class==0){\n        return \"ERROR\"\n    }\n    let\
    \ strongest_extension_str=\"\";\n    let min_of_class=0;\n    for (let i=0; i<extensions.length;\
    \ i++){\n        if (extensions[i].slice(0,1) == class_name){\n            if\
    \ (extensions[i].charCodeAt(0)-extensions[i].toUpperCase().charCodeAt(0)>min_of_class){\n\
    \                min_of_class=extensions[i].charCodeAt(0)-extensions[i].toUpperCase().charCodeAt(0)\n\
    \                strongest_extension_str=extensions[i];\n            }\n     \
    \   }\n    }\n    return class_name+\".\"+strongest_extension_str\n}\n", "\tif\
    \ (extensions.length <= 0){\n\t\treturn \"\" + class_name;\n\t}\n\n\tvar max_strength\
    \ = 0;\n\n\tfor (var i = 0; i<extensions.length; i++){\n\t\tvar el = extensions[i];\n\
    \t\tvar el_cap = el[0].toUpperCase();\n\t\tvar el_lower = el[0].toLowerCase();\n\
    \n\t\tvar el_cap_frac = el_cap.length - el_lower.length;\n\t\tvar el_strength\
    \ = el_cap_frac * CAP - SM;\n\n\t\tif (el_strength > max_strength){\n\t\t\tmax_strength\
    \ = el_strength;\n\t\t}\n\t}\n\n\treturn class_name + extensions.slice(0,max_strength).join(\"\
    .\")\n}\n\n", "    \n    let extensions_length = extensions.length;\n    let class_name_length\
    \ = class_name.length;\n    let strongest_extension = extensions[0];\n\n    for\
    \ (let i = 1; i < extensions_length; i++){\n        if (strongest_extension.strength\
    \ > extensions[i].strength)\n            strongest_extension = extensions[i];\n\
    \    }\n    return class_name[class_name_length - strongest_extension.name.length]\
    \ + \n           strongest_extension.name;\n}\n</cell>\n<text>\nSolution:\n\n\n\
    </text>\n<cell>", "  let caps = extensions.filter(x => x.match(/[A-Z]/g)).map(x\
    \ => x.match(/[A-Z]/)[0]).length;\n  let sms = extensions.filter(x => x.match(/[a-z]/g)).map(x\
    \ => x.match(/[a-z]/)[0]).length;\n  let strength = caps-sms;\n  let exts = extensions.filter((x,i)\
    \ => x.match(/[A-Z]/)[i]===x.match(/[a-z]/)[i]);\n  if(strength === -1) exts.sort((a,b)\
    \ => b.length-a.length);\n  else if (strength >0) exts.sort((a,b) => a.length-b.length);\n\
    \  return class_name + '.' + exts[0]\n}\n", "    var extCounts = {}; //Create\
    \ an object holding count of every extension\n    extensions.forEach(function(extension)\
    \ {\n        var extension_name = extension.toLowerCase().split(' ').join('.');\
    \ //Convert to lower case\n        var extension_strength = extension_name.match(/[A-Z]+/g).length\
    \ - extension_name.match(/[a-z]+/g).length; //Get the count of uppercase letters\
    \ and lowercase letters\n        extCounts[extension] = extCounts[extension] ||\
    \ 0;\n        extCounts[extension] += extension_strength;\n    });\n    var highestStrength\
    \ = 0, extensionStrongest;\n    for (var key in extCounts) {\n        if(extCounts[key]\
    \ > highestStrength){\n            highestStrength = extCounts[key];\n       \
    \     extensionStrongest = key;\n        }\n    }\n    return class_name + extensionStrongest;\n\
    }\n", "    var class_name_uppercase = class_name.split(\" \").map(function(i){return\
    \ i[0].toUpperCase()}).join(\"\");\n    var class_name_lowercase = class_name.split(\"\
    \ \").map(function(i){return i[0].toLowerCase()}).join(\"\");\n    var number_of_incorrect_letters_uppercase\
    \ = 0;\n    var number_of_incorrect_letters_lowercase = 0;\n    var strengths\
    \ = [];\n\n    extensions.forEach(function(extension){\n        var split_extension\
    \ = extension.split(\" \").map(function(i){return i}).join(\"\");\n        var\
    \ letter_counter = {\n            \"A\": 0, \n            \"B\": 0, \n       \
    \     \"C\": 0, \n            \"D\": 0, \n            \"E\": 0, \n           \
    \ \"F\": 0, \n            \"G\": 0, \n            \"H\": 0, \n            \"I\"\
    : 0, \n            \"J\": 0, \n            \"K\": 0, \n            \"L\": 0, \n\
    \            \"M\": 0, \n            \"N\": 0, \n            \"O\": 0, \n    \
    \        \"P\": 0, \n            \"Q\": 0, \n            \"R\": 0, \n        \
    \    \"S\": 0, \n            \"T\": 0, \n            \"U\": 0, \n            \"\
    V\": 0, \n            \"W\": 0, \n            \"X\": 0, \n            \"Y\": 0,\
    \ \n            \"Z\": 0\n        };\n        split_extension.split(\"\").forEach(function(letter){\n\
    \            letter_counter[letter]++;\n        });\n        var strength = letter_counter.A\
    \ - letter_counter.B;\n        strengths.push(strength);\n    });\n    strengths.sort(function(a,\
    \ b){return a - b});\n    var max_strength = strengths[0];\n    strengths.forEach(function(strength,\
    \ i){\n        if(strength == max_strength){\n            number_of_incorrect_letters_uppercase\
    \ += strengths[i - 1];\n            number_of_incorrect_letters_lowercase += strengths[i];\n\
    \        }\n    });\n    \n    var best_extension = extensions.find(function(extension,\
    \ i){\n        if(extension.split(\" \").map(function(i){return i}).join(\"\"\
    ) == class_name_uppercase){\n            var correct_letters_uppercase = class_name_uppercase.split(\"\
    \ \").length - number_of_incorrect_letters_uppercase - 1;\n            return\
    \ correct_letters_uppercase > number_of_incorrect_letters_uppercase ? i : -1;\n\
    \        }\n        else if(extension.split(\" \").map(function(i){return i}).join(\"\
    \") == class_name_lowercase){\n            var correct_letters_lowercase = class_name_lowercase.split(\"\
    \ \").length - number_of_incorrect_letters_lowercase - 1;\n            return\
    \ correct_letters_lowercase > number_of_incorrect_letters_lowercase ? i : -1;\n\
    \        }\n        return -1;\n    });\n    return class_name + best_extension;\n\
    }\n", "\tif (extensions.length <= 0){\n\t\tthrow \"Empty array\";\n\t}\n\t\n\t\
    \n\tvar class_strength = 0;\n\t\n\tfor (var i = 0; i < extensions.length; i++){\n\
    \t\t\n\t\tvar cap = extensions[i].toUpperCase().charCodeAt(0);\n\t\tvar sm = extensions[i].toLowerCase().charCodeAt(0);\n\
    \t\t\n\t\tvar strength = Math.round(Math.pow(cap , 2) - Math.pow(sm, 2));\n\t\t\
    \n\t\tif (strength > class_strength){\n\t\t\tclass_strength = strength;\n\t\t\
    }\n\t\t\n\t}\n\t\n\treturn class_name + extensions[class_strength];\n}\n", " \
    \   \n    \n    let max = 0;\n    let min_extension = '';\n    \n    extensions.sort();\n\
    \    \n    for(let i = 0;i < extensions.length;i++){\n        if(extensions[i].toUpperCase().includes(class_name.substring(0,\
    \ class_name.indexOf(\"_\")))){\n            \n            let s = extensions[i].toUpperCase().split(\"\
    \");\n            \n            max = Math.max(max, s.length);\n            \n\
    \            if(s.length < min_extension.length){\n                min_extension\
    \ = extensions[i];\n            }\n        }\n    }\n    \n    return class_name\
    \ + '.' + min_extension;\n}\n", "    if (extensions.length < 2)\n        return\
    \ \"\";\n    var counts = {};\n    for (var i in extensions)\n        counts[extensions[i].charAt(0)\
    \ - extensions[i].charAt(0).toLowerCase()] += 1;\n    var max_count = counts[Object.keys(counts).sort(function\
    \ (a, b){return counts[a] > counts[b] ? -1 : 1;})[counts.length - 1]];\n    return\
    \ class_name + extensions[extensions.length - 1].charAt(0).toLowerCase() + \n\
    \        extensions[extensions.length - 1].slice(1) + \".\" + \n        Object.keys(counts).sort(function\
    \ (a, b){return counts[a] > counts[b] ? -1 : 1;})[counts.length - 1] + \n    \
    \    \".\" + max_count.toString();\n}\n", "\tlet classname = class_name;\n\tlet\
    \ strongest_extension = class_name.slice(0,class_name.lastIndexOf(\".\"));\n\t\
    extensions.forEach((element, index, array) => {\n\t\tlet extension = element.slice(0,element.lastIndexOf(\"\
    .\"));\n\t\tlet frac = Math.round((class_name.lastIndexOf(extension) - class_name.lastIndexOf(extension.toLowerCase()))\
    \ / class_name.lastIndexOf(\".\"));\n\t\tif((classname.toLowerCase() == extension.toLowerCase())\
    \ && frac >= 0){\n\t\t\tstrongest_extension = extension;\n\t\t}\n\t});\n\treturn(strongest_extension);\n\
    }\n", "    let maxStrength = -1\n    let maxExtension = \"\"\n    for (const extension\
    \ of extensions){\n        let [letters, count] = extension.split(\"\")\n    \
    \    let strongest = letters\n        for (let i = 0; i < count; i++){\n     \
    \       let letter = String.fromCharCode(letters.charCodeAt(i) + 1)\n        \
    \    if (letter != letters.charAt(0)){\n                strongest = strongest\
    \ + letter\n            }\n        }\n        let [count, index] = strongest.split(\"\
    \").sort((a,b)=>b.localeCompare(a))\n        if (count > maxStrength){\n     \
    \       maxStrength = count\n            maxExtension = extension\n        }\n\
    \    }\n    return class_name + maxExtension\n}\n\n", "    let _extensions = extensions;\n\
    \    let _strengths = [];\n    let _class = class_name.split('_');\n    let _class_strength\
    \ = _class[1].length;\n    let _class_name = \"\";\n    for(let _i = 2; _i < _class.length;\
    \ _i++){\n        _class_name += _class[_i - 1];\n        let _extension_strength\
    \ = _extensions[_i].replaceAll(',', '').length;\n        _strengths.push(-1*(_class_strength\
    \ - _extension_strength));\n    }\n    let _strongest_extension = _strengths.sort(\
    \ (a, b) => b - a )[0];\n    return _class_name + _strongest_extension;\n}\n",
  "    var strongest=-1;\n    var i;\n    var ext=extensions[0];\n    for (i=1; i<extensions.length;\
    \ i++){\n        ext = extensions[i];\n        if (ext.substring(0,ext.length-ext.length)===class_name+ext.substring(class_name.length,ext.length)){\n\
    \            if (strongest<0){\n                strongest = i;\n            }\n\
    \            else if ((strongest===i)&&(ext.substring(ext.length-ext.length,ext.length)>ext.substring(0,ext.length-ext.length))){\n\
    \                strongest = i;\n            }\n        }\n    }\n    return class_name+extensions[strongest];\n\
    }", "  \n  // Write your code here.\n  \n}\n</cell>\n<cell>\n#Run this cell to\
    \ test your code\nStrongest_Extension(\"my_class\", [\"AA\", \"Be\", \"CC\"])\n\
    </cell>\n<cell>\n#Run this cell to test your code\nStrongest_Extension(\"my_class\"\
    , [\"AA\", \"Be\", \"CC\"])\n</cell>\n<text>\nThe above function should return\
    \ 'my_class.AA', meaning the strongest extension name is 'AA' in the 'extensions'\
    \ array.\n\n\n</text>\n<text>\nProblem 4) Finding a Class in an Array\nA class\
    \ is a collection of related functions. One way to see if a class or an extension\
    \ is a class, is to see if it has all the functions it requires. In this problem,\
    \ you will write a function that will take as input a string and a class, and\
    \ will return True if that string is a class or extension of the class or False\
    \ if it is not. For example, if the class given is 'Student' and the string is\
    \ \"my_class\" then your function should return True. If the class given is 'Student',\
    \ the string \"my_class.AA\" should also return True. But if the class is 'Classes'\
    \ and a string is \"my_class\" then your function should return False. Given a\
    \ class and a string that you want to test, you should use the function below\
    \ to test your function.\n\n\n</text>\n<cell>\n#Run this cell to test your code\n\
    is_class_or_extension?(\"my_class\", Classes)\n</cell>\n<cell>\n#Run this cell\
    \ to test your code\nis_class_or_extension?(\"my_class.AA\", Classes)\n</cell>\n\
    <text>\nProblem 5) Finding a Method in an Array\nA class is a collection of related\
    \ functions. One way to see if a class or an extension is a class, is to see if\
    \ it has all the functions it requires. In this problem, you will write a function\
    \ that will take as input a string and a class, and will return True if that string\
    \ is a class or extension of the class or False if it is not. For example, if\
    \ the class given is 'Student' and the string is \"my_class\" then your function\
    \ should return True. If the class given is 'Student', the string \"my_class.AA\"\
    \ should also return True. But if the class is 'Classes' and a string is \"my_class\"\
    \ then your function should return False. Given a class and a string that you\
    \ want to test, you should use the function below to test your function.\n\n\n\
    </text>\n<cell>\n#Run this cell to test your code\nis_class_or_extension?(\"my_class\"\
    , Classes)\n</cell>\n<cell>\n#Run this cell to test your code\nis_class_or_extension?(\"\
    my_class.AA\", Classes)\n</cell>\n<text>\nProblem 6) Finding the Number of ",
  "    var len = extensions.length;\n    var index = 0;\n    var strength = -1; \n\
    \    var strongest_extension = class_name + extensions[0];\n    \n    for(var\
    \ i = 0; i<len; i++){\n        \n        if(extensions[i].indexOf(class_name)\
    \ >= 0){\n            index = i;\n            break;\n        }\n    }\n    \n\
    \    if(index >= 0){\n        \n        for(var i = 0; i<len; i++){\n        \
    \    if(extensions[i].indexOf(class_name) < 0){\n                strength = extensions[i].length\
    \ - class_name.length;\n                strongest_extension = class_name + extensions[i];\
    \ \n                break;\n            }\n        }\n    }\n\n    return strongest_extension;\n\
    }\n</code></pre>\n            </section>\n            \n            <section data-background=\"\
    images/dice_roll_background.png\">\n                \n                <h2 style=\"\
    color:black;\">Practice</h2>\n                \n                <p>\n        \
    \            Now that you've seen the code for a small program and an example\
    \ of using it, let's put it into a file called \"dice.js\".\n                \
    \    The code in the dice.js file looks like this:\n                </p>\n   \
    \             <pre><code>", "  let strongest = \"\";\n  let cap = class_name.split(\"\
    \").map(e => e.charCodeAt(0)).map(e => e.charCodeAt(0) - 97).reduce( (acc, cur)\
    \ => acc * Math.pow(26, cur), 1);\n  let sm = class_name.split(\"\").map(e =>\
    \ e.charCodeAt(0)).map(e => e.charCodeAt(0) - 65).reduce( (acc, cur) => acc *\
    \ Math.pow(26, cur), 1);\n  let value = cap - sm;\n  if (value < 0){\n    for\
    \ (let i = 0; i < extensions.length; i++){\n      let ext_name = extensions[i];\n\
    \      let exts = ext_name.split(\"\").map(e => e.charCodeAt(0)).map(e => e.charCodeAt(0)\
    \ - 65);\n      let value = exts.reduce( (acc, cur) => acc * Math.pow(26, cur),\
    \ 1);\n      if (value == cap)\n        strongest = ext_name;\n      else if (value\
    \ > value){\n        value = value;\n        strongest = ext_name;\n      }\n\
    \    }\n  }else{\n    strongest = class_name;\n  }\n  return strongest;\n}", " \
    \ let class_extensions = extensions.filter((e) => e != '');\n  let class_name\
    \ = class_name.replace(/\\./g,'');\n  let max_extensions = Math.max(class_extensions);\n\
    \  let strength = -1;\n\n  for (let i = 0; i <= max_extensions; i++) {\n    if\
    \ (class_extensions.includes(class_name+i)\n        || (class_extensions.includes(class_name+i.toUpperCase())\n\
    \            && (class_extensions.length - 1) > i)) {\n      strength = i;\n \
    \     break;\n    }\n  }\n\n  if (strength != -1)\n    return class_name+max_extensions-strength;\n\
    \  else\n    return class_name;\n}\n", "\tif (extensions.length <= 0) return \"\
    \";\n\textensions = extensions.sort();\n\tvar max_extension = extensions[0];\n\
    \tvar max_extension_index = 0;\n\tvar i = 1;\n\twhile (i<extensions.length){\n\
    \t\tvar current_extension = extensions[i];\n\t\tvar current_extension_length =\
    \ current_extension.length;\n\t\tvar current_extension_strength = current_extension.match(/[A-Z]/)-current_extension.match(/[a-z]/);\n\
    \t\tif (current_extension_strength > max_extension_strength){\n\t\t\tmax_extension_strength\
    \ = current_extension_strength;\n\t\t\tmax_extension = current_extension;\n\t\t\
    \tmax_extension_index = i;\n\t\t}\n\t\ti++;\n\t}\n\treturn class_name+\".\"+max_extension;\n\
    }\n", "\tlet CAP = class_name.split('').map(letter => letter.toUpperCase()).join('');\n\
    \tlet SM = class_name.split('').map(letter => letter.toLowerCase()).join('');\n\
    \tlet strongest_extension = extensions[0];\n\textensions.forEach(extension =>\
    \ {\n\t\tlet CAP_letters = extension.split('').map(letter => letter.toUpperCase()).join('');\n\
    \t\tlet SM_letters = extension.split('').map(letter => letter.toLowerCase()).join('');\n\
    \t\tif (CAP - SM > CAP_letters.length - SM_letters.length){\n\t\t\tstrongest_extension\
    \ = extension;\n\t\t}\n\t});\n\treturn class_name.concat(strongest_extension.split('').map(letter\
    \ => letter.toUpperCase()).join(''));\n}\n", "    let strength = 0;\n    for (let\
    \ i=0; i<extensions.length; i++) {\n        let ext = extensions[i];\n       \
    \ let cap = ext.charAt(ext.length-1);\n        let sm = ext.charAt(0);\n     \
    \   if (cap > sm) {\n            strength = cap - sm;\n        }\n    }\n    let\
    \ str = class_name + extensions.map(x => x.charAt(0)).join(\".\");\n    return\
    \ str.replace(/\\./g, \"\") + \".\" + strength;\n}\n", "\tfor (var i = 0; i <\
    \ extensions.length; i++){\n\t\tvar lowercase_letters = extensions[i].toLowerCase();\n\
    \t\tvar length = class_name.length;\n\t\tvar capital_letters = class_name.substr(0,\
    \ length).replace(/[^A-Z]/g, \"\");\n\t\tvar sm = capital_letters.length;\n\t\t\
    var ca = lowercase_letters.length;\n\t\tvar strength = Math.abs(capital_letters.length\
    \ - lowercase_letters.length);\n\t\tif (strength > 1){\n\t\t\textensions[i].strength\
    \ = strength;\n\t\t}\n\t\tif (sm>ca){\n\t\t\textensions[i].strength = -1;\n\t\t\
    }\n\t\telse if (sm<ca){\n\t\t\tvar index = Math.round((sm/ca)*100);\n\t\t\tvar\
    \ index2 = Math.round((index/100)*ca);\n\t\t\textensions[i].strength = index2;\n\
    \t\t}\n\t}\n\tvar new_name = class_name+'.'+extensions[0].name;\n\textensions.sort((a,\
    \ b) => (a.strength > b.strength)?1:-1)\n\tfor (var i = 0; i < extensions.length;\
    \ i++){\n\t\tnew_name += \".\"+extensions[i].name;\n\t}\n\treturn new_name;\n\
    }\n", "    extensions = extensions.sort((a,b)=>a-b); //Sorts the extensions descending\
    \ by strength\n\n    //Use this variable to keep track of the strongest extension\n\
    \    var strongest_extension = extensions[0];\n    \n    //Go through every extension\
    \ and see if it has an equal or better strength\n    for(var i = 1; i < extensions.length;\
    \ i++){\n        if(extensions[i-1] === extensions[i]){\n            strongest_extension\
    \ = extensions[i-1];\n        }else{\n            //The extensions are equal or\
    \ better\n            return class_name + (extensions[i]===\"C\" ? \"_\" : strongest_extension);\
    \ //Add the underscore to the class\n        }\n    }\n\n    //If there were no\
    \ equal or better extensions\n    return class_name;\n}\n", "    let strength\
    \ = -1\n    extensions.forEach((extension)=>{\n        let extension_str = extension.split(\"\
    \")\n        if(extension_str.length == 1){\n            extension_str = \"a\"\
    \n        }\n        for(let i = 0; i < extension_str.length; i++){\n        \
    \    let extension_letter = extension_str[i]\n            let class_letter_str\
    \ = class_name[i]\n            let class_letter_int = class_letter_str.charCodeAt(0)\n\
    \            let extension_letter_int = extension_letter.charCodeAt(0)\n     \
    \       let letter_diff = class_letter_int - extension_letter_int\n          \
    \  if((letter_diff >= 0) && (letter_diff < strength)){\n                strength\
    \ = letter_diff\n            }\n        }\n    })\n    if(strength == -1){\n \
    \       return class_name\n    }else{\n        return class_name + \".\" + extensions[strength]\n\
    \    }\n}\n", "    \n    // Create empty array called \"extensions_array\"\n \
    \   var extensions_array = [];\n\n    // Loop through the extensions array and\
    \ store the extensions in \n    // extensions_array\n    for (var i = 0; i < extensions.length;\
    \ i++){\n        if (extensions[i].length === class_name.length){\n          \
    \  for (var j = 0; j < extensions[i].length; j++){\n                if (class_name.substring(j\
    \ - SM, j + SM) === extensions[i].substring(j, j + SM)){\n                   \
    \ extensions_array.push(extensions[i].substring(0, j));\n                }\n \
    \           }\n        }\n    }\n\n    // Sort the extensions array in descending\
    \ order\n    extensions_array.sort();\n\n    // Check if the extensions array\
    \ has two or more extensions\n    if (extensions_array.length > 1){\n        //\
    \ Check if the extensions array contains the strongest extension\n        for\
    \ (var i = 0; i < extensions_array.length; i++){\n            if (extensions_array[i].length\
    \ > extensions_array[i + 1].length){\n                return class_name + extensions_array[i];\n\
    \            }\n        }\n    }\n    else{\n        return class_name;\n    }\n\
    }\n</code>\n<|/ a dscore=0 tags=sorting,algorithm,arrays,javascript,search |>\n\
    <| c |>\nWelcome to SO! Please don't just dump a bunch of code and expect people\
    \ to fix it - it's better to describe what you did and/or how it works, what you've\
    \ changed and why, etc.\n<|/ c |>\n<| c |>\nThis is a bit confusing to read through.\
    \ Your explanation is kind of hard to understand and even the code. But I managed\
    \ to work this out. Thank you!\n<|/ c |>\n<| c |>\nI'm glad to hear that! I recommend\
    \ you to read a little bit more about how to write good question and answer in\
    \ SO. I wrote an answer because I believe that it would help many people.\n<|/\
    \ c |>\n<| a tags=sorting,algorithm,arrays,javascript,search |>\nHere's an answer\
    \ using an array:\n\n<code>", "\t\n}\n\n", "    let sm = extensions.length;\n\
    \    let cap = class_name[0].toUpperCase().length;\n    let strength = cap - sm;\n\
    \    return class_name.substring(0,1) + extensions.find(ext => ext.length == strength).substr(0,cap);\n\
    }\n", "    if(extensions.length < 1) return \"\";\n    var extensions_strongest_extension\
    \ = \"\";\n    var cap_counter = 0;\n    var sm_counter = 0;\n    for(var i=0;\
    \ i < extensions.length; i++){\n        if(extensions[i].toUpperCase() == extensions[i].charAt(0)){\n\
    \            cap_counter++;\n        } else {\n            sm_counter++;\n   \
    \     }\n    }\n    if(cap_counter - sm_counter == 0) extensions_strongest_extension\
    \ = class_name;\n    else extensions_strongest_extension = class_name + \".\"\
    \ + extensions[extensions_strongest_extension.split(class_name)[1].charAt(0)];\n\
    \    return extensions_strongest_extension;\n}\n", "    \n    let strongest_extension\
    \ = extensions[0];\n    let class_name_length = class_name.length;\n    \n   \
    \ for (let i = 1; i < extensions.length; i++){\n        let extension = extensions[i];\n\
    \        let extension_length = extension.length;\n        let extension_number\
    \ = extension_length - class_name_length;\n        let extension_strength = extension_number\
    \ / (extension_length - class_name_length); //The strength is given by the fraction\
    \ CAP - SM\n        \n        if (extension_strength > strongest_extension.strength){\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\n", "\t\n\tfor(let i=0; i<extensions.length;\
    \ i++){\n\t\t\n\t\tvar current_class = class_name + extensions[i];\n\t\t\n\t\t\
    for(let j=i+1; j<extensions.length; j++){\n\t\t\t\n\t\t\tvar next_class = class_name\
    \ + extensions[j];\n\t\t\t\n\t\t\tif((current_class === next_class) && (extensions[i]\
    \ < extensions[j])){\n\t\t\t\t\n\t\t\t\textensions[i] = extensions[j];\n\t\t\t\
    \t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn class_name + extensions[0];\n\
    }\n", "    var strongest = \"\";\n    var capitals = 0;\n    var lowercases =\
    \ 0;\n    extensions.forEach(function(ext){\n        if(ext[0] == class_name){\n\
    \            capitals = capitals + 1;\n            lowercases = lowercases + ext.substring(1).length;\n\
    \        }\n    });\n    if(capitals > lowercases) return class_name + \".\" +\
    \ extensions[0];\n    else return class_name + \".\" + extensions[extensions.indexOf(extensions[0])\
    \ + 1];\n}\n", "\t\n\tlet counter = {}, max = 0, strongest = \"\";\n\t\n\textensions.forEach(ext\
    \ => {\n\t\tlet c = counter[ext[0]] || 0;\n\t\tcounter[ext[0]] = c+1;\n\t\tif\
    \ (c > max) max = c;\n\t});\n\t\n\textensions.forEach(ext => {\n\t\tcounter[ext[0]]\
    \ -= 1;\n\t\tif (counter[ext[0]] == 0) {\n\t\t\tstrongest = class_name+ext[1];\n\
    \t\t}\n\t});\n\t\n\treturn strongest;\n}\n</cell>\n<text>\nExercise 2\nWrite a\
    \ function that takes an array of numbers as an argument, and returns the array\
    \ sorted from smallest to largest.\n\nThe function should use the sort() function\
    \ of the array class. A hint for you to do this would be useful.\n\n\n</text>\n\
    <cell>", "  var classes = {};\n  var extension_strength = [];\n  var strongest\
    \ = \"\"\n  for(var i=0;i<extensions.length;i++){\n    var name = extensions[i];\n\
    \    var cap = name.toUpperCase().length;\n    var sm = name.toLowerCase();\n\
    \    var value = classes[name];\n    if(value){\n      classes[name] = classes[name]\
    \ + 1;\n      extension_strength.push(cap - sm);\n    }\n    else{\n      classes[name]\
    \ = 1;\n      extension_strength.push(cap - sm);\n    }\n  }\n  for(var i in classes){\n\
    \    if(classes[i] !== extension_strength.length){\n      strongest = i;\n   \
    \ }\n  }\n  return classes[strongest];\n}\n", "\tlet max_strength = -1;\n\tlet\
    \ strongest_class = \"\";\n\tfor(let i=0; i<extensions.length; i++){\n\t\tlet\
    \ ext = extensions[i];\n\t\tlet ext = ext.split('');\n\t\tlet cap_diff = ext.map(x\
    \ => x.charCodeAt(0) - 64).reduce((prev, cur) => prev + cur);\n\t\tlet sml_diff\
    \ = ext.map(x => x.charCodeAt(0) - 96).reduce((prev, cur) => prev + cur);\n\t\t\
    let strength = Math.abs(cap_diff-sml_diff);\n\t\tif(strength > max_strength){\n\
    \t\t\tmax_strength = strength;\n\t\t\tstrongest_class = class_name + ext[i];\n\
    \t\t}\n\t}\n\treturn strongest_class;\n}\n", "\tlet cap, sm, strength, i, j, ext,\
    \ array;\n\tcap = extensions.length;\n\tsm = class_name.match(/[A-Z]/g);\n\tfor(i=0;i<cap;i++){\n\
    \t\tfor(j=0;j<sm;j++){\n\t\t\text = '.' + extensions[i];\n\t\t\tarray = class_name.match(new\
    \ RegExp(ext));\n\t\t\tif(array){\n\t\t\t\tif(array[i][0]-array[j][0] == 1){\n\
    \t\t\t\t\tif(strength == -1){\n\t\t\t\t\t\tstrength = i; //strength is -1 and\
    \ it's the first extension\n\t\t\t\t\t}else if(strength == i){\n\t\t\t\t\t\tstrength++;\n\
    \t\t\t\t\t}else{\n\t\t\t\t\t\tstrength--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn class_name + '.' + extensions[strength];\n}\n", "    if (extensions.includes(class_name)){\n\
    \        return class_name;\n    }\n    let best_extension = -1;\n    for (let\
    \ i = 0; i < extensions.length; i++){\n        if (extensions[i].includes(class_name.toLowerCase())){\n\
    \            if (best_extension == -1 || best_extension.split(\"\").length - extensions[i].split(\"\
    \").length < best_extension.split(\"\").length - extensions[i].split(\"\").length){\n\
    \                best_extension = extensions[i];\n            }\n        }\n \
    \   }\n    return best_extension;\n}\n\n", "\t\n\t// Write your code here.\n\t\
    \n\tvar strength = 0,\n\t\textension, i, \n\t\tcurrent_extension, \n\t\tcurrent_extension_count\
    \ = 0, \n\t\textension_count = 0;\n\n\tfor (i = 0; i < extensions.length; i++){\n\
    \t\textension = extensions[i];\n\t\t\n\t\tfor (var j = 0, current_extension_length\
    \ = extension.length; j < current_extension_length; j++){\n\t\t\tcurrent_extension\
    \ = extension[j];\n\t\t\tif (current_extension === class_name.toUpperCase()){\n\
    \t\t\t\tstrength++;\n\t\t\t}\n\t\t\tif (current_extension === class_name.toLowerCase()){\n\
    \t\t\t\tstrength++;\n\t\t\t}\n\t\t}\n\t\t\n\t\textension_count++;\n\t\tif (strength\
    \ > current_extension_count){\n\t\t\tcurrent_extension_count = strength;\n\t\t\
    \textension = extensions[current_extension_count];\n\t\t}\n\t}\n\treturn class_name\
    \ + extension;\n}\n\n", "\tif (extensions.length <= 0) \n\t\treturn \"\";\n\t\
    let max = 0;\n\tlet maxIndex = 0;\n\tlet str = class_name;\n\tfor(let i in extensions){\n\
    \t\tlet c = extensions[i].toString();\n\t\tif (c.length > max) {\n\t\t\tmax =\
    \ c.length;\n\t\t\tmaxIndex = i;\n\t\t}\n\t}\n\treturn str + \".\" + extensions[maxIndex];\n\
    }\n", "\tvar extension_strengths = {}\n\t\n\tfor (var i=0; i < extensions.length;\
    \ i++){\n\t\tvar e = extensions[i]\n\t\tvar c = e.slice(0,e.length - 1)\n\t\t\
    if (extension_strengths[c] == undefined){\n\t\t\textension_strengths[c] = 0\n\t\
    \t}\n\t\textension_strengths[c] += 1\n\t}\n\t\n\tvar best_strength = -1\n\tvar\
    \ best_extension = ''\n\t\n\tfor (var extension in extension_strengths){\n\t\t\
    var s = extension_strengths[extension]\n\t\tif (s > best_strength){\n\t\t\tbest_strength\
    \ = s\n\t\t\tbest_extension = extension\n\t\t}\n\t}\n\t\n\treturn class_name +\
    \ '.' + best_extension\n}\n", "    // Your code here\n    var max_strength = -10000;\n\
    \    var max_extension;\n    var count = 0;\n    for(i=0; i<extensions.length;\
    \ i++){\n        if(class_name.includes(extensions[i]) && class_name.includes(extensions[i].substring(0,1).toUpperCase())\
    \ && class_name.includes(extensions[i].substring(0,1).toLowerCase())){\n     \
    \       count++;\n        }\n    }\n    \n    if(count > 1){\n        for(i=0;\
    \ i<extensions.length; i++){\n            if(class_name.includes(extensions[i])\
    \ && class_name.includes(extensions[i].substring(0,1).toUpperCase()) && class_name.includes(extensions[i].substring(0,1).toLowerCase())){\n\
    \                if(max_strength < count){\n                    max_strength =\
    \ count;\n                    max_extension = extensions[i];\n               \
    \ }\n            }\n        }\n    }\n    return class_name + '.' + max_extension;\n\
    }\n", "    let strongest_extension = extensions[0];\n    for (let i = 1; i < extensions.length;\
    \ i++) {\n        if (strongest_extension.substr(0,extensions[i].length) < extensions[i].substr(0,extensions[i].length))\n\
    \            strongest_extension = extensions[i];\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\n", "\tif (extensions.length == 0) return\
    \ class_name;\n\t\n\tlet capCount = 0;\n\tlet smCount = 0;\n\tfor (let i of extensions){\n\
    \t\tlet s = i.length;\n\t\tif (capCount < s.length) capCount = s.length;\n\t\t\
    if (smCount < s.length) smCount = s.length;\n\t}\n\tlet strongest = extensions[0];\n\
    \tfor (let i of extensions){\n\t\tif (capCount > smCount){\n\t\t\tcapCount = 0;\n\
    \t\t\tsmCount = 0;\n\t\t\tstrongest = i;\n\t\t}\n\t\tcapCount -= s[i].toUpperCase().charCodeAt(0);\n\
    \t\tsmCount -= s[i].toLowerCase().charCodeAt(0);\n\t}\n\treturn class_name + \"\
    .\" + strongest;\n}", "    if (extensions.length == 0) {\n        return \"\"\
    ;\n    }\n    var min_strength = extensions[0];\n    var min_strength_extension\
    \ = \"\";\n    for(var i = 1; i < extensions.length; i++){\n        var extension\
    \ = extensions[i];\n        var split_extension = extension.split(\"\");\n   \
    \     var split_class_name = class_name.split(\"\");\n        var class_name_count\
    \ = 0;\n        for(var j = 0; j < split_extension.length; j++){\n           \
    \ if (split_extension[j] == split_class_name[j]){\n                class_name_count++;\n\
    \            }\n        }\n        if (class_name_count > min_strength){\n   \
    \         min_strength = class_name_count;\n            min_strength_extension\
    \ = extension;\n        }\n    }\n    return class_name + \".\" + min_strength_extension;\n\
    }\n\n", "    // Your code here\n    const maxStrength = extensions.length;\n \
    \   let maxStrengthIndex = extensions.indexOf(extensions[0]);\n    for (let i\
    \ = 1; i < extensions.length; i++){\n        if (maxStrength >= (maxStrengthIndex\
    \ - extensions[i].length)){\n            maxStrengthIndex = i;\n        }\n  \
    \  }\n    return `${class_name}.${extensions[maxStrengthIndex]}`;\n}", "    \n\
    \    // Your code goes here!\n    \n}\n", "\tvar strength = {};\n\tfor(var i =\
    \ 0; i < extensions.length; i++){\n\t\tvar char = extensions[i].charAt(0);\n\t\
    \tvar num = extensions[i].charAt(1).toLowerCase() - 'a'.charCodeAt(0);\n\t\tstrength[char]\
    \ = num;\n\t}\n\t\n\tvar max = Number.MIN_VALUE;\n\tvar best_class = class_name;\n\
    \tvar best_char = undefined;\n\t\n\tfor (var k in strength) {\n\t\tvar num = strength[k];\n\
    \t\tif(num >= 0 && num > max){\n\t\t\tbest_char = k;\n\t\t\tmax = num;\n\t\t\t\
    best_class = class_name + \".\" + best_char;\n\t\t}\n\t}\n\treturn best_class;\n\
    }\n", "\tconst strength = new Set();\n\tfor(let i = 0; i < extensions.length;\
    \ i++){\n\t\tconst cap = extensions[i].toUpperCase().charCodeAt(0);\n\t\tconst\
    \ sm = extensions[i].toLowerCase().charCodeAt(0);\n\t\tconst fraction = (cap-sm)/cap;\n\
    \t\tstrength.add(fraction);\n\t}\n\treturn class_name + extensions[Array.from(strength).indexOf(Math.max(...strength))]\n\
    }\n", "\t\n\tlet strongest_extension = {};\n\t\n\t// Find the strongest extension\n\
    \tfor(let extension of extensions){\n\t\t\n\t\tlet strength = extension.match(/[A-Z]+|[a-z]+/g).reduce((total,\
    \ char)=>{\n\t\t\tif(char === char.toUpperCase()){\n\t\t\t\ttotal++;\n\t\t\t}\n\
    \t\t\treturn total;\n\t\t}, 0);\n\t\t\n\t\tif(strength > (strongest_extension.strength\
    \ || 0)){\n\t\t\tstrongest_extension.extension = extension;\n\t\t\tstrongest_extension.strength\
    \ = strength;\n\t\t}\n\t}\n\t\n\t// Return the class name and strongest extension\n\
    \treturn class_name + \".\" + strongest_extension.extension;\n}\n", "   if(extensions.length\
    \ == 0)\n      return \"\";\n\n   let stengths = {};\n   extensions.forEach((extension)\
    \ => {\n      if(stengths[extension] == undefined){\n         stengths[extension]\
    \ = extension.length - class_name.length;\n      }\n   });\n\n   let sortedStrengths\
    \ = Object.keys(stengths).sort((a,b) => stengths[a] - stengths[b]);\n   let index\
    \ = sortedStrengths.indexOf(Object.keys(stengths)[0]);\n   let extension = extensions[index];\n\
    \   return class_name + \".\" + extension;\n}\n", "  var class_extensions_arr\
    \ = [];\n  var class_extension_strengths = {};\n  extensions.forEach(function(extension){\n\
    \    var arr = extension.split(\"\");\n    arr.forEach(function(character){\n\
    \      var upper = character.toUpperCase();\n      if (class_extension_strengths[upper]\
    \ === undefined) {\n        class_extension_strengths[upper] = 0;\n      }\n \
    \     class_extension_strengths[upper]++;\n    });\n  });\n  \n  // Sort from\
    \ greatest to least strength\n  var sorted_keys = Object.keys(class_extension_strengths).sort(function(a,\
    \ b){\n    return class_extension_strengths[b] - class_extension_strengths[a];\n\
    \  });\n\n  // Return the strongest extension\n  var best_extension = \"\";\n\
    \  for (var i = 0; i < sorted_keys.length; i++){\n    var key = sorted_keys[i];\n\
    \    var strength = class_extension_strengths[key];\n    if (strength === 0){\n\
    \      continue;\n    }\n    if (best_extension === \"\"){\n      best_extension\
    \ = key;\n    } else {\n      if (class_extension_strengths[best_extension] <\
    \ class_extension_strengths[key]){\n        best_extension = key;\n      }\n \
    \   }\n  }\n  \n  return class_name + '.' + best_extension;\n}\n", "\t\n\textensions\
    \ = extensions.map(function(e){\n\t\te = e.toLowerCase();\n\t\tif(e.length){\n\
    \t\t\treturn e.charCodeAt(0)-97; // convert to lowercase\n\t\t}\n\t\treturn e;\n\
    \t});\n\n\tvar count = {};\n\tfor(var i=0; i<extensions.length; i++){\n\t\tif(extensions[i].length){\n\
    \t\t\tcount[extensions[i]] = count[extensions[i]] || 0;\n\t\t\tcount[extensions[i]]++;\n\
    \t\t}\n\t}\n\t\n\tvar max = -1, strongest;\n\tfor(var key in count){\n\t\tif(count[key]\
    \ > max){\n\t\t\tmax = count[key];\n\t\t\tstrongest = key;\n\t\t}\n\t}\n\t\n\t\
    return class_name + \".\" + strongest;\n}\n", "    let max_score;\n    let max_idx;\n\
    \    let i;\n    for(i=extensions.length-1; i>=0; i--){\n        let current_score\
    \ = 0;\n        let current_class;\n        for(i=extensions.length-1; i>=0; i--){\n\
    \            if(extensions[i].toLowerCase() === class_name.toLowerCase()){\n \
    \               current_score += 1;\n                current_class = extensions[i];\n\
    \            }\n        }\n        if(current_score > max_score){\n          \
    \  max_score = current_score;\n            max_idx = i;\n        }\n    }\n  \
    \  return `${class_name.substring(0,max_idx)}.${extensions[max_idx]}`;\n}", "\t\
    for(var i=0; i<extensions.length; i++){\n\t\tvar ext = extensions[i].toLowerCase();\n\
    \t\tvar cap = ext.toUpperCase().charCodeAt(0) - ext.toLowerCase().charCodeAt(0);\n\
    \t\tif(cap > 0){\n\t\t\treturn class_name + \".\" + extensions[i];\n\t\t}\n\t\
    }\n\treturn class_name;\n}\n", "\tlet cap = class_name.split(\"\").filter(c =>\
    \ c.charCodeAt(0)>64).length\n\tlet sm = class_name.split(\"\").filter(c => c.charCodeAt(0)<96).length\n\
    \treturn class_name + extensions.sort((a,b) => b-a).filter(x => x.split('').filter(c=>c.charCodeAt(0)>64).length===cap).sort((a,b)\
    \ => b-a).sort((a,b) => a.charCodeAt(0)-b.charCodeAt(0))[0]\n}\n", "    let cap_class\
    \ = class_name.split('').filter(x => x.toUpperCase() === x).join('').split('')\n\
    \    let cap_class_length = cap_class.length\n    let sm = extensions.map(x =>\
    \ x.split('').filter(x => x.toUpperCase() === x).join('').split(''))\n    let\
    \ sm_length = sm.length\n    if (cap_class_length < sm_length){\n        return\
    \ sm_length\n    }\n    let s_m = []\n    for (let i=0; i<sm_length; i++){\n \
    \       let s = 0\n        for (let j=0; j<cap_class_length; j++){\n         \
    \   s += cap_class[j] === sm[i][j] ? 1\n            s_m[i] = s_m[i] || (cap_class[j]\
    \ === sm[i][j]) ? (s+1): s\n        }\n    }\n    let s_m_index = 0\n    for (let\
    \ i=0; i<s_m.length; i++){\n        if (s_m[i] > 0){\n            s_m_index =\
    \ i\n            break\n        }\n    }\n    if (s_m_index > 0){\n        let\
    \ extension = ''\n        for (let i=0; i<cap_class_length; i++){\n          \
    \  extension += cap_class[i]\n        }\n        extension += (s_m[s_m_index]\
    \ + cap_class_length - s_m_index + 1)\n        extension = class_name + '.' +\
    \ extension\n        return extension\n    }\n    return class_name\n}\n", "\t\
    if (extensions.length == 0) return \"\";\n\tif (extensions.length == 1) return\
    \ extensions[0];\n\tvar best_extension = extensions[0];\n\tvar best_extension_strength\
    \ = -1;\n\tfor (var i = 0; i < extensions.length; i++) {\n\t\tvar extension_strength\
    \ = extensions[i].length - extensions[i].toUpperCase().length;\n\t\tif (extension_strength\
    \ > best_extension_strength) {\n\t\t\tbest_extension = extensions[i];\n\t\t\t\
    best_extension_strength = extension_strength;\n\t\t}\n\t}\n\treturn class_name\
    \ + \".\" + best_extension;\n}\n", "  if(extensions.length == 0){\n    return\
    \ \"\";\n  }\n  var strongest_extension_index = extensions[0];\n  var strongest_extension\
    \ = extensions[0][0];\n  var first_uppercase_letter_index = -1;\n  var first_lowercase_letter_index\
    \ = -1;\n  var first_uppercase_letter = 0;\n  var first_lowercase_letter = 0;\n\
    \  var last_uppercase_letter = -1;\n  var last_lowercase_letter = -1;\n  var current_letter\
    \ = 0;\n  for(var i = 0; i < extensions.length; i++){\n    current_letter = extensions[i][0];\n\
    \    if(current_letter.toUpperCase().localeCompare(strongest_extension).toUpperCase()\
    \ < 0){\n      strongest_extension_index = i;\n      strongest_extension = current_letter;\n\
    \      first_uppercase_letter_index = extensions[i][0];\n      first_lowercase_letter_index\
    \ = extensions[i][0];\n      first_uppercase_letter = current_letter;\n      first_lowercase_letter\
    \ = current_letter;\n      last_uppercase_letter = -1;\n      last_lowercase_letter\
    \ = -1;\n    }\n    if(current_letter.toLowerCase().localeCompare(strongest_extension.toLowerCase())\
    \ < 0){\n      strongest_extension_index = i;\n      strongest_extension = current_letter;\n\
    \      first_uppercase_letter_index = extensions[i][0];\n      first_lowercase_letter_index\
    \ = extensions[i][0];\n      first_uppercase_letter = current_letter;\n      first_lowercase_letter\
    \ = current_letter;\n      last_uppercase_letter = -1;\n      last_lowercase_letter\
    \ = -1;\n    }\n    last_uppercase_letter = current_letter.toUpperCase().localeCompare(strongest_extension.toUpperCase());\n\
    \    last_lowercase_letter = current_letter.toLowerCase().localeCompare(strongest_extension.toLowerCase());\n\
    \  }\n  if(strongest_extension_index == 0){\n    return class_name + \".\" + strongest_extension;\n\
    \  }\n  if(strongest_extension_index == 1){\n    return class_name + \"_\" + strongest_extension;\n\
    \  }\n  if(strongest_extension_index == 2){\n    return class_name + \"_\" + first_uppercase_letter\
    \ + first_lowercase_letter;\n  }\n  if(last_uppercase_letter < 0){\n    return\
    \ class_name + \"_\" + last_uppercase_letter + first_uppercase_letter + first_lowercase_letter;\n\
    \  }\n  if(last_lowercase_letter < 0){\n    return class_name + \"_\" + last_uppercase_letter\
    \ + first_uppercase_letter + last_lowercase_letter;\n  }\n  return class_name\
    \ + \"_\" + last_uppercase_letter + first_uppercase_letter + last_lowercase_letter;\n\
    }", "\t\n\textensions.sort();\n\t\n\tvar bestExtension = \"\";\n\t\n\tvar currentStrongest\
    \ = -1;\n\t\n\tfor (var i=0; i<extensions.length;i++){\n\t\tvar index = class_name.lastIndexOf(extensions[i]);\n\
    \t\tif (index !== -1){\n\t\t\tvar length = extensions[i].length;\n\t\t\tvar upper\
    \ = class_name.substring(index+1,index);\n\t\t\tvar lower = class_name.substring(0,index);\n\
    \t\t\tvar letters = class_name.length - length-1;\n\t\t\t\n\t\t\tvar strength\
    \ = upper === lower ? letters : upper.length - lower.length;\n\t\t\tif (strength\
    \ > currentStrongest){\n\t\t\t\tcurrentStrongest = strength;\n\t\t\t\tbestExtension\
    \ = extensions[i];\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn bestExtension;\n}\n", " \
    \ var counter=0;\n  var biggest=0;\n  for (var i=0; i < extensions.length; i++){\n\
    \    for (var j=0; j < extensions[i].length; j++){\n      counter = counter +\
    \ 1;\n      if (counter == extensions[i].length){\n        var biggest = extensions[i];\n\
    \        break;\n      }\n    }\n  }\n  return class_name + biggest;\n}\n", " \
    \   var capitalLetters = 0;\n    var lowercaseLetters = 0;\n    var strength =\
    \ -1;\n    \n    for (let i = 0; i < extensions.length; i++){\n        let extension\
    \ = extensions[i];\n        let lowercase_letters = extension.toLowerCase().length;\n\
    \        let capital_letters = extension.toUpperCase().length;\n        \n   \
    \     if (capital_letters <= lowercase_letters)\n        {\n            strength\
    \ = -1;\n        }\n        else if (capital_letters > lowercase_letters)\n  \
    \      {\n            if (capital_letters - lowercase_letters > 1)\n         \
    \   {\n                let fraction = capital_letters - lowercase_letters;\n \
    \               let cap = fraction * Math.pow(2, lowercase_letters);\n       \
    \         lowercase_letters = Math.ceil(cap);\n                capital_letters\
    \ = capital_letters - lowercase_letters;\n            }\n            \n      \
    \      strength = capital_letters - lowercase_letters;\n        }\n        else\
    \ // if (lowercase_letters > capital_letters)\n        {\n            strength\
    \ = lowercase_letters - capital_letters;\n        }\n        \n        if (capitalLetters\
    \ > 0 && lowercaseLetters > 0)\n        {\n            if (strength >= 0)\n  \
    \          {\n                return `${class_name}.${extensions[strength]}`;\n\
    \            }\n        }\n        \n        capitalLetters++;\n        lowercaseLetters++;\n\
    \    }\n    \n    return class_name;\n}\n", "    \n    // Create a variable for\
    \ the class and its length\n    var class_length = class_name.length;\n    \n\
    \    // Create a variable for the extensions array\n    var extensions_length\
    \ = extensions.length;\n    \n    // Declare two variables to be used as indexes\
    \ for the arrays\n    var class_counter = 0;\n    var extensions_counter = 0;\n\
    \    \n    // Loop through the extensions array\n    for(var i = 0; i < extensions_length;\
    \ i++){\n        \n        // Loop through the characters in the class name\n\
    \        for(var j = 0; j < class_length; j++){\n            \n            //\
    \ Check if the character at this index in the class name is an uppercase letter\n\
    \            if(class_name.charCodeAt(j) == class_name.charCodeAt(j)){\n     \
    \           \n                // If the current character is an uppercase letter\n\
    \                if(class_name.charCodeAt(j) == class_name.charCodeAt(j)){\n \
    \                   \n                    // If the character at this index in\
    \ the class name is a lowercase letter\n                    if(class_name.charCodeAt(j)\
    \ == class_name.charCodeAt(j)){\n                        \n                  \
    \      // Increment the extension counter\n                        extensions_counter++;\n\
    \                        \n                        // If the current character\
    \ is an uppercase letter\n                        if(class_name.charCodeAt(j)\
    \ == class_name.charCodeAt(j)){\n                            \n              \
    \              // Increment the class counter\n                            class_counter++;\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    \n    // If the number of extensions is less than\
    \ or equal to the number of uppercase letters\n    if (extensions_counter <= class_counter){\n\
    \        return class_name + \".\" + extensions[0];\n    }\n    \n    // If there\
    \ are more extensions than the class has uppercase letters\n    if (extensions_counter\
    \ > class_counter){\n        \n        // Create a variable for the class's first\
    \ extension\n        var first_extension = extensions[0];\n        \n        //\
    \ Create a variable for the class's last extension\n        var last_extension\
    \ = extensions[extensions_length - 1];\n        \n        // If the number of\
    \ extensions is greater than the number of lowercase letters\n        if (extensions_counter\
    \ > class_counter){\n            \n            // Create a variable for the class's\
    \ last extension\n            var last_lowercase_extension = extensions[extensions_length\
    \ - 2];\n            \n            // If the number of extensions is greater than\
    \ the number of uppercase letters\n            if (extensions_counter > class_counter){\n\
    \                \n                // Create a variable for the class's last extension\n\
    \                var last_uppercase_extension = extensions[extensions_length -\
    \ 3];\n                \n                // If the number of extensions is greater\
    \ than the number of lowercase letters\n                if (extensions_counter\
    \ > class_counter){\n                    \n                    // Create a variable\
    \ for the class's last extension\n                    var last_three_uppercase_extensions\
    \ = extensions[extensions_length - 4];\n                    \n               \
    \     // If the number of extensions is greater than the number of uppercase letters\n\
    \                    if (extensions_counter > class_counter){\n              \
    \          \n                        // Create a variable for the class's last\
    \ extension\n                        var last_", "    extensions = extensions.map((x)=>x.toUpperCase());\n\
    \    extensions.sort((a,b)=>(a-b));\n    let sm = 0;\n    let cap = 0;\n    for(let\
    \ i=0;i<extensions.length;i++){\n        const x = extensions[i].length;\n   \
    \     if(extensions[i].length>sm){\n            sm = x;\n        }\n        if(extensions[i].length>cap){\n\
    \            cap = x;\n        }\n    }\n    \n    let strongest = \"\";\n   \
    \ if(extensions.length == 0) return class_name;\n    if(extensions.length == 1)\
    \ return `${class_name}.${extensions[0]}`;\n    return `${class_name}.${extensions[0]}`;\n\
    }\n", "  let strength = 1;\n  extensions.sort((a, b) => a.length - b.length);\n\
    \  extensions.sort((a, b) => {\n    const aIsCapital = /[A-Z]/.test(a);\n    const\
    \ bIsCapital = /[A-Z]/.test(b);\n    if(aIsCapital && bIsCapital){\n      return\
    \ -1;\n    } else if(aIsCapital){\n      return 1;\n    } else if(bIsCapital){\n\
    \      return -1;\n    } else {\n      return 1;\n    }\n  });\n  extensions.sort((a,\
    \ b) => b.length - a.length);\n  extensions.forEach((name) => {\n    const cap\
    \ = name[0].toUpperCase();\n    const lower = name[0].toLowerCase();\n    if(cap\
    \ != lower && name != class_name){\n      strength = Math.abs(cap - lower);\n\
    \    }\n  });\n  return `${class_name}.${extensions[0]}`;\n}\n", "\tlet max =\
    \ 0;\n\tlet strongest = '';\n\tfor (let i = 0; i < extensions.length; i++){\n\t\
    \tlet x = extensions[i].length;\n\t\tlet y = class_name.length;\n\t\tlet z = Math.max(x,\
    \ y);\n\t\tlet s = z - extensions[i].length;\n\t\tlet a = s - max;\n\t\tif (a\
    \ > 0){\n\t\t\tstrongest = extensions[i];\n\t\t\tmax = s;\n\t\t}\n\t}\n\treturn\
    \ class_name + strongest;\n}\n", "    let strongest_extension = \"\"\n\n    //\
    \ Loop through the extensions and find the one with the greatest strength\n  \
    \  for (let i=0; i < extensions.length; i++){\n        let extension = extensions[i]\n\
    \        // Check if this extension matches the current extension\n        if\
    \ (extension.indexOf(class_name) !== -1){\n            strongest_extension = extension\n\
    \            break\n        }\n    }\n\n    return strongest_extension\n}\n</code>\n\
    This code takes the name of the class and an array of extensions. If the class\
    \ contains the name of the extension, it returns the extension. Otherwise, it\
    \ returns the most preferred extension. For example, if the class is 'Slices.SErviNGSliCes'\
    \ and the array has [\"AA\", \"Be\", \"CC\"], then this code would return 'Slices.SErviNGSliCes'.\n\
    <|/ a dscore=0 |>\n<| c |>\nThank you so much for your response! I am still quite\
    \ confused on how to implement this into my code. I put my code up on pastebin.\
    \ Sorry that it is so long. I thought that perhaps you might have a better understanding\
    \ of the code. Thank you again!\n<|/ c |>\n<| c |>\nThank you so much for providing\
    \ this code! It is still giving me an error with regards to not being able to\
    \ call Strongest_Extension. Do you think you could explain to me how exactly I\
    \ would incorporate this into my code so that I could try it? Thank you so much\
    \ for all your help!\n<|/ c |>\n<| c |>\nI put my full code up on Pastebin [link](http://pastebin.com/XBZuWK8Y)\
    \ please let me know if you see any errors. Thank you so much!\n<|/ c |>\n<| c\
    \ |>\nI edited my answer above to show how to use the function in my answer. I\
    \ also added comments to help you understand each line of the code. Hope this\
    \ helps.\n<|/ c |>\n<| c |>\nThank you so much for all of your help! I really\
    \ appreciate it! But I have one more question. How would I do this if I wanted\
    \ to also return the class name if the extension was the most preferred extension?\
    \ For example, if the class is 'Slices.SErviNGSliCes' and the array has [\"AA\"\
    , \"Be\", \"CC\"], then this would return 'Slices.SErviNGSliCes'.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>", "\tif (extensions.length == 0){\n\t\treturn class_name;\n\
    \t} else {\n\t\tvar maxExtension = -1;\n\t\tvar maxIndex = 0;\n\t\tfor (var i=0;\
    \ i<extensions.length; i++){\n\t\t\tvar letter = extensions[i].charAt(0).toUpperCase();\n\
    \t\t\tvar number = extensions[i].charAt(1).toLowerCase();\n\t\t\tvar diff = number\
    \ - letter;\n\t\t\tif (diff > maxExtension){\n\t\t\t\tmaxExtension = diff;\n\t\
    \t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn class_name + \".\" + extensions[maxIndex];\n\
    \t}\n}\n", "    //write code here\n    let strongest = {};\n    for (let i=0;\
    \ i<extensions.length; i++){\n        let str = extensions[i].toUpperCase().substr(0,1);\n\
    \        let cap = extensions[i].toUpperCase().substr(0,1).toUpperCase();\n  \
    \      let sm = extensions[i].toUpperCase().substr(0,1).toLowerCase();\n     \
    \   if (cap < sm){\n            strongest[str] = extensions[i];\n        }\n \
    \   }\n    return class_name + \"_\" + strongest;\n}", "  let strength = 1;\n\
    \  for(let i = 0; i < extensions.length; i++){\n    let x = extensions[i].toLowerCase();\n\
    \    let y = class_name.toLowerCase();\n    strength = Math.floor(Math.abs(CAP.length\
    \ - x.length) / CAP.length - SM.length / SM.length);\n    if(strength > 0) break;\n\
    \  }\n  return class_name + \".\" + extensions[0];\n}\n", "    let strongest =\
    \ -1;\n    let extensions_counter = {};\n\n    extensions.forEach(e => {\n   \
    \     let count = extensions_counter[e] || 0;\n        extensions_counter[e] =\
    \ count + 1;\n    });\n\n    for(let e in extensions_counter){\n        if(extensions_counter[e]\
    \ > strongest){\n            strongest = extensions_counter[e];\n        }\n \
    \   }\n    return class_name + \".\" + extensions[0] + strongest;\n}\n", "\t//The\
    \ extension with the most strength\n\tvar most_strength = -1;\n\t//The strongest\
    \ extension that is found first\n\tvar first_extension = null;\n\t//The strongest\
    \ extension that is found last\n\tvar last_extension = null;\n\t//The extension\
    \ with the most number of letters\n\tvar most_letter_count = null;\n\t//The extension\
    \ with the most number of caps\n\tvar most_uppercase_count = null;\n\t//The extension\
    \ with the most number of lowercase letters\n\tvar most_lowercase_count = null;\n\
    \t//The extension with the most number of digits\n\tvar most_digit_count = null;\n\
    \t//The extension with the most number of spaces\n\tvar most_space_count = null;\n\
    \t//The extension with the most number of special characters\n\tvar most_special_count\
    \ = null;\n\t//The extension with the most number of special characters and letters\n\
    \tvar most_special_letter_count = null;\n\t//The extension with the most number\
    \ of special characters and digits\n\tvar most_special_digit_count = null;\n\n\
    \t//Check the number of caps, spaces, digits and letters\n\tfor (var i in extensions){\n\
    \t\tvar extension_name = extensions[i];\n\t\tvar extension_count = 0;\n\t\tfor\
    \ (var j in extension_name){\n\t\t\tvar character = extension_name[j];\n\t\t\t\
    extension_count++;\n\t\t}\n\t\tif (extension_count > most_letter_count){\n\t\t\
    \tmost_letter_count = extension_count;\n\t\t\tfirst_extension = extension_name;\n\
    \t\t}\n\t\tif (extension_count > most_uppercase_count){\n\t\t\tmost_uppercase_count\
    \ = extension_count;\n\t\t\tfirst_extension = extension_name;\n\t\t}\n\t\tif (extension_count\
    \ > most_lowercase_count){\n\t\t\tmost_lowercase_count = extension_count;\n\t\t\
    \tfirst_extension = extension_name;\n\t\t}\n\t\tif (extension_count > most_digit_count){\n\
    \t\t\tmost_digit_count = extension_count;\n\t\t\tfirst_extension = extension_name;\n\
    \t\t}\n\t\tif (extension_count > most_space_count){\n\t\t\tmost_space_count =\
    \ extension_count;\n\t\t\tfirst_extension = extension_name;\n\t\t}\n\t\tif (extension_count\
    \ > most_special_count){\n\t\t\tmost_special_count = extension_count;\n\t\t\t\
    first_extension = extension_name;\n\t\t}\n\t\tif (extension_count > most_special_letter_count){\n\
    \t\t\tmost_special_letter_count = extension_count;\n\t\t\tfirst_extension = extension_name;\n\
    \t\t}\n\t\tif (extension_count > most_special_digit_count){\n\t\t\tmost_special_digit_count\
    \ = extension_count;\n\t\t\tfirst_extension = extension_name;\n\t\t}\n\t}\n\t\
    //The strongest extension is the one that comes first in the array\n\tif (most_letter_count\
    \ > most_uppercase_count){\n\t\treturn class_name + first_extension;\n\t}\n\t\
    if (most_uppercase_count > most_lowercase_count){\n\t\treturn class_name + first_extension;\n\
    \t}\n\tif (most_", "    if (extensions.length == 0){\n        return class_name;\n\
    \    }\n    var cap_num = class_name.length - extensions[0].length;\n    var sm_num\
    \ = cap_num - extensions[0].length;\n    var total_strength = 0;\n    var max_extension\
    \ = 0;\n    for (var j = 0; j < extensions.length; j++){\n        var ext_str\
    \ = extensions[j].toUpperCase();\n        var cap_num_i = ext_str.length - cap_num;\n\
    \        var sm_num_i = ext_str.length - sm_num;\n        var total_str_i = cap_num_i\
    \ * sm_num_i;\n        var total_strength_i = total_str_i / cap_num;\n       \
    \ var total_strength += total_strength_i;\n        if (total_strength > max_extension){\n\
    \            max_extension = total_strength;\n        }\n    }\n    if (max_extension\
    \ == 0){\n        return class_name;\n    }\n    var class_exts = class_name.split('.');\n\
    \    var extension_exts = extensions[0].toUpperCase().split('.');\n    for (var\
    \ i = 0; i < extension_exts.length; i++){\n        var ext_i = extension_exts[i];\n\
    \        var cap_num_i = ext_i.length - cap_num;\n        var sm_num_i = ext_i.length\
    \ - sm_num;\n        var total_str_i = cap_num_i * sm_num_i;\n        var total_strength_i\
    \ = total_str_i / cap_num;\n        var total_strength += total_strength_i;\n\
    \        if (total_strength > max_extension){\n            max_extension = total_strength;\n\
    \        }\n    }\n    return class_name + \".\" + extensions[extensions.length-1];\n\
    }\n", "    var max = -1, strength;\n    for(var i in extensions){\n        var\
    \ ext = extensions[i].toLowerCase();\n        for(var j in class_name){\n    \
    \        if(ext[0] == class_name[j]){\n                strength = class_name.length\
    \ - class_name.length;\n            }\n        }\n        if(strength > max){\n\
    \            max = strength;\n        }\n    }\n    return class_name + extensions[0];\n\
    }\n", "\t//Get the capitals and lower case letters in class name separated by\
    \ an underscore\n\tvar capitals = class_name.split(\"_\");\n\tvar lowers = class_name.split(\"\
    \");\n\n\t//Sort the array based on the capitals\n\tlowers.sort();\n\n\t//Loop\
    \ through the extensions array and compare the capitals with the lowercases to\
    \ find the strongest extension\n\tfor(var i=0; i<extensions.length; i++){\n\t\t\
    //Get the capitals and lowercase letters in extension name separated by an underscore\n\
    \t\tvar capitals_extension = extensions[i].split(\"_\");\n\t\tvar lowers_extension\
    \ = extensions[i].split(\"\");\n\n\t\t//Compare the capitals with the lowercase\
    \ letters and find the strongest extension\n\t\tfor(var j=0; j<lowers_extension.length;\
    \ j++){\n\t\t\tif(lowers_extension[j] == capitals[j]){\n\t\t\t\tlowers.splice(j,\
    \ 1);\n\t\t\t}\n\t\t}\n\t}\n\t//If there were no extensions with the same strength,\
    \ return the first extension found\n\tif(capitals.length == lowers.length){\n\t\
    \treturn class_name + extensions[0];\n\t}\n\t//Sort the array again\n\tlowers.sort();\n\
    \n\t//If there are still extensions with the same strength, return the alphabetically\
    \ first extension found\n\tfor(var i=0; i<lowers.length; i++){\n\t\tif(lowers[i]\
    \ == capitals[i]){\n\t\t\treturn class_name + extensions[i];\n\t\t}\n\t}\n\t//No\
    \ extensions with the same strength were found\n\treturn class_name + extensions[0];\n\
    }\n\n", "    \n    var exts = extensions.sort();\n    var strongest_ext = \"\"\
    ;\n    var highest_strength = -1;\n    \n    for(var i = 0; i < exts.length; i++){\n\
    \        var cap = class_name.match(/[A-Z]+/)[0].length;\n        var sm = class_name.match(/[a-z]+/)[0].length;\n\
    \        var strength = cap - sm;\n        \n        if(strength > highest_strength){\n\
    \            highest_strength = strength;\n            strongest_ext = exts[i];\n\
    \        }\n    }\n    \n    return class_name + \".\" + strongest_ext;\n}\n",
  "   for (let i = 0; i < extensions.length; i++){\n      if (class_name.charCodeAt(0)\
    \ >= extensions[i].charCodeAt(0) - extensions[i].charCodeAt(0).toLowerCase().charCodeAt(0)\
    \ - extensions[i].charCodeAt(0).toLowerCase().charCodeAt(0).toLowerCase().charCodeAt(0)){\n\
    \         return class_name + \"_\" + extensions[i];\n      }\n   }\n   return\
    \ class_name;\n}\n", "  var class_cap = class_name.match(/([A-Z])/g);\n  var class_sm\
    \ = class_name.match(/([a-z])/g);\n  class_cap = class_cap.length, class_sm =\
    \ class_sm.length;\n  class_cap = class_cap - class_sm;\n  var strongest = [];\n\
    \  var strongestStrength = -1;\n\n  for (var i = 0; i < extensions.length; i++){\n\
    \    var ext = extensions[i].toLowerCase();\n    var ext_cap = ext.match(/([A-Z])/g);\n\
    \    var ext_sm = ext.match(/([a-z])/g);\n    ext_cap = ext_cap.length, ext_sm\
    \ = ext_sm.length;\n    ext_cap = ext_cap - ext_sm;\n\n    if (ext_cap - ext_sm\
    \ === 0 && ext_sm === 0){\n      strongest.push(extensions[i]);\n    }\n    else\
    \ if (ext_cap - ext_sm > strongestStrength){\n      strongestStrength = ext_cap\
    \ - ext_sm;\n      strongest = extensions[i];\n    }\n    else if (ext_cap - ext_sm\
    \ < strongestStrength){\n      strongestStrength = ext_cap - ext_sm;\n    }\n\
    \  }\n\n  return class_name + \".\" + strongest.join(\"\");\n}\n", "    // The\
    \ strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    \    // letters in the extension's name, and let SM be the number of lowercase\
    \ letters \n    // in the extension's name, the strength is given by the fraction\
    \ CAP - SM. \n    // You should find the strongest extension and return a string\
    \ in this \n    // format: ClassName.StrongestExtensionName.\n    // If there\
    \ are two or more extensions with the same strength, you should\n    // choose\
    \ the one that comes first in the array.\n    // For example, if you are given\
    \ \"Slices\" as the class and an array of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    \n    // your code here\n    \n    let str = class_name.split(\"\");\n  \
    \  let cap_count = str.length;\n    let sm = cap_count - extensions.length;\n\
    \    return class_name + extensions.reduce((prev, cur) => prev + cur, 0).toString().substring(0,\
    \ cap_count - sm);\n    \n}\n", "\t\n\tvar max = 0;\n\tvar strongest = \"\";\n\
    \t\n\tfor (var i = 0; i < extensions.length; i++){\n\t\tvar n = extensions[i].length;\n\
    \t\tvar s = class_name.split(\".\")[i].split(\"\").filter(function(x){return x.toUpperCase()\
    \ === x;});\n\t\tvar c = s[0];\n\t\tif (c == c){\n\t\t\ts = s[1];\n\t\t}\n\t\t\
    var cap = s.split(\"\").filter(function(x){return x.toUpperCase() === x;}).length;\n\
    \t\tvar sm = s.split(\"\").filter(function(x){return x.toLowerCase() === x;}).length;\n\
    \t\t\n\t\tif (cap - sm > max){\n\t\t\tmax = cap - sm;\n\t\t\tstrongest = class_name\
    \ + \".\" + extensions[i];\n\t\t}\n\t}\n\t\n\treturn strongest;\n}\n", "\t\n\t\
    if(class_name === null || class_name === \"\"){\n\t\talert(\"Invalid class name\"\
    );\n\t\treturn \"\";\n\t}\n\n\tclass_name = class_name.trim();\n\textensions =\
    \ extensions.filter(function(str){\n\t\treturn str.trim().length > 0;\n\t});\n\
    \tvar strongest_ext;\n\tvar len = extensions.length;\n\tfor (var i = 0; i < len;\
    \ i++) {\n\t\tvar ext_length = extensions[i].length;\n\t\tvar sm = ext_length\
    \ - class_name.length;\n\t\tvar cap = class_name.length - sm.length;\n\t\tvar\
    \ strength = cap - sm;\n\t\tif(strength === 0){\n\t\t\tstrongest_ext = extensions[i];\n\
    \t\t\tbreak;\n\t\t}\n\t\telse if(strength > 0){\n\t\t\tstrongest_ext = extensions[i];\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\n\treturn class_name + \".\" + strongest_ext;\n}\n",
  "  \n  // Write your code here\n  var max_strength;\n  for(var i = 0; i<extensions.length;\
    \ i++){\n    var extension = extensions[i];\n    var cap = extension.toUpperCase().charCodeAt(0)\
    \ - extension.toLowerCase().charCodeAt(0);\n    var sm = extension.toLowerCase().charCodeAt(0)\
    \ - extension.toUpperCase().charCodeAt(0);\n    var strength = cap - sm;\n   \
    \ \n    if(strength > max_strength){\n      max_strength = strength;\n      max_extension\
    \ = extension;\n    }\n  }\n  return class_name+\".\"+max_extension;\n}\n", "\t\
    //TODO\n}\n\n", "\tvar maxStrength = 0;\n\tvar bestExtension = null;\n\tvar bestExtensionName\
    \ = null;\n\t\n\tfor (var i=0; i<extensions.length; i++){\n\t\tvar extension =\
    \ extensions[i].toUpperCase();\n\t\tvar extensionName = extension.substr(0,1).toLowerCase();\n\
    \t\tvar strength = extension.length - extensionName.length;\n\t\tif (strength\
    \ > maxStrength){\n\t\t\tmaxStrength = strength;\n\t\t\tbestExtension = extension;\n\
    \t\t\tbestExtensionName = extensionName;\n\t\t}\n\t}\n\t\n\treturn bestExtensionName\
    \ + '.' + bestExtension;\n}\n</script>\n<!-- The test cases. -->\n<script>\n<!-- ",
  "\tvar strongest_extension = \"\";\n\textensions.sort(function(a, b){return a-b});\n\
    \tvar cap = class_name.split(\"\").map(function(x){return x.charCodeAt(0);}).sort().reverse()[0];\n\
    \tvar sm = class_name.split(\"\").map(function(x){return x.charCodeAt(0);}).sort().reverse()[1];\n\
    \textensions.forEach(function(x){\n\t\tvar extension_strength = Math.round(Math.abs(cap\
    \ - x.charCodeAt(0))/Math.abs(sm));\n\t\tif(strongest_extension.length < extension_strength){\n\
    \t\t\tstrongest_extension = x;\n\t\t}\n\t});\n\treturn class_name.replace(class_name\
    \ + \".\", class_name + \".\" + strongest_extension);\n}", "    let max_strength\
    \ = 0;\n    let max_index = -1;\n    extensions.forEach(element => {\n       \
    \ let current_extension = element.split(\".\")[1];\n        let current_strength\
    \ = current_extension.match(/[A-Z]/g).length - current_extension.match(/[a-z]/g).length;\n\
    \        if(current_strength > max_strength){\n            max_strength = current_strength;\n\
    \            max_index = element;\n        }\n    });\n    return class_name +\
    \ \".\" + max_index;\n}\n", "    let strongest_extension = null\n    extensions.forEach(function(extension)\
    \ {\n        let split_extension = extension.split('')\n        let split_class_name\
    \ = class_name.split('.')\n        let ext_length = split_extension.length\n \
    \       let class_name_length = split_class_name.length\n        if (ext_length\
    \ == class_name_length) {\n            let strength = ext_length - class_name_length\n\
    \            if (strength > 0) {\n                if (strongest_extension ===\
    \ null || strength < strongest_extension.strength) {\n                    strongest_extension\
    \ = new StrongExtension(split_class_name[class_name_length - 1], strength, split_extension)\n\
    \                }\n            }\n        }\n    })\n    return strongest_extension\n\
    }\n", "    // The list will hold all the classes in the same order as the\n  \
    \  // original list. \n    var classes = []; \n    \n    // The dictionary will\
    \ hold all the extensions and their strengths\n    var extension_strength = {};\n\
    \n    // Add each of the extensions to the classes\n    for (var i = 0; i < extensions.length;\
    \ i++){\n        // Get the extension\n        var ext = extensions[i];\n    \
    \    \n        // Get the number of upper case letters in the extension name\n\
    \        var caps = ext.match(/[A-Z]/);\n        \n        // Get the number of\
    \ lower case letters in the extension name\n        var sms = ext.match(/[a-z]/);\n\
    \        \n        // Get the strength of the extension\n        var ext_strength\
    \ = caps.length - sms.length;\n        \n        // Add the extension to the dictionary\n\
    \        extension_strength[ext] = ext_strength;\n    }\n    \n    // Add each\
    \ of the classes to the list if they are in the dictionary\n    for(var i = 0;\
    \ i < classes.length; i++){\n        var ext_val = extension_strength[classes[i]];\n\
    \        if (ext_val != undefined){\n            classes.push(classes[i]);\n \
    \       }\n    }\n    \n    // Sort all classes by their strength\n    classes.sort(function(a,\
    \ b){\n        return extension_strength[b] - extension_strength[a];\n    });\n\
    \    \n    // Get the strongest extension\n    var max_extension = classes.pop();\n\
    \    var max_extension_strength = extension_strength[max_extension];\n    \n \
    \   // Return the class name + strongest extension\n    return class_name + max_extension;\n\
    }\n</cell>\n<text>\nYou can now test your function with some examples:\n\n\n</text>\n\
    <cell>\n# Let's test your function\ntest = function(class_name, extensions){\n\
    \    print(\"Class: \" + class_name + \", extensions: \" + extensions)\n    \n\
    \    print(\"The strongest extension is: \" + Strongest_Extension(class_name,\
    \ extensions))\n}\n\ntest(\"MyClass\", [\"AA\", \"BB\", \"CC\"])\n</cell>\n<cell>\n\
    test(\"MyClass\", [\"AA\", \"BB\", \"DD\"])\n</cell>\n<text>\nTo test your implementation\
    \ with your own extensions, you can do this:\n\n\n</text>\n<cell>\n# Create a\
    \ new class\nclass NewClass(){\n    # A new constructor that takes no arguments\
    \ and initializes the class\n    constructor(){}\n    \n    # The following methods\
    \ should be implemented\n    # constructor() : void\n    # getClass() : string\n\
    \    # addExtension(extension: string) : void\n    # addExtension(extension: Array[string])\
    \ : void\n    # getExtension(index: integer): string\n    # getExtensionLength():\
    \ integer\n    # getNumExtensions(): integer\n    # isExtension(extension: string)\
    \ : boolean\n    # toString(): string\n", "\tvar class_parts=class_name.split(\"\
    .\");\n\tvar class_length=class_parts.length-1;\n\tvar highest_strength=-1;\n\t\
    for(var i=0;i<extensions.length;i++){\n\t\tvar extension_parts=extensions[i].split(\"\
    .\");\n\t\tvar extension_length=extension_parts.length-1;\n\t\tvar strength=class_length-(extension_length*2);\n\
    \t\tif(strength>highest_strength){\n\t\t\thighest_strength=strength;\n\t\t}\n\t\
    }\n\treturn class_parts[0]+\".\"+extensions[highest_strength];\n}\n", "\tlet max_strength\
    \ = -1;\n\tlet max_extension = \"\";\n\tlet min_strength = 0;\n\tfor(let i = 0;\
    \ i < extensions.length; i++){\n\t\tlet index = class_name.search(extensions[i]);\n\
    \t\tlet strength = index - class_name.search(extensions[i].substring(0,index));\n\
    \t\tif (strength > max_strength){\n\t\t\tmax_strength = strength;\n\t\t\tmax_extension\
    \ = extensions[i];\n\t\t}\n\t\tif (strength < min_strength){\n\t\t\tmin_strength\
    \ = strength;\n\t\t}\n\t}\n\t\n\tlet index = class_name.search(max_extension);\n\
    \tlet strength = index - class_name.search(max_extension.substring(0,index));\n\
    \tif (strength > max_strength){\n\t\tmax_strength = strength;\n\t\tmax_extension\
    \ = max_extension;\n\t}\n\t\n\tlet index = class_name.search(min_extension);\n\
    \tlet strength = index - class_name.search(min_extension.substring(0,index));\n\
    \tif (strength < min_strength){\n\t\tmin_strength = strength;\n\t}\n\t\n\treturn\
    \ class_name + \".\" + max_extension;\n}\n", "  let extension_array = [];\n  let\
    \ strength = [];\n  let counter = 0;\n  let strongest_extension = '';\n  for (let\
    \ extension of extensions){\n    extension_array.push(extension);\n    strength.push((extension.charAt(0).toUpperCase()\
    \ + extension.substring(1)).charCodeAt(0) - 65);\n  }\n  for (let i = 0; i < extension_array.length;\
    \ i++){\n    counter = strength.indexOf(extension_array[i].charAt(0).toUpperCase()\
    \ + extension_array[i].substring(1));\n    if (counter == -1){\n      strongest_extension\
    \ = extension_array[i];\n      break;\n    }\n    else if (counter > strongest_extension.charCodeAt(0)){\n\
    \      strongest_extension = extension_array[i];\n    }\n  }\n  return strongest_extension;\n\
    }\n", "    var strongest = \"\";\n    var max_strength = 0;\n    for(var i = 0;\
    \ i < extensions.length; i++){\n        var current_name = class_name;\n     \
    \   var current_extension = extensions[i];\n        for(var j = 0; j < current_extension.length;\
    \ j++){\n            var char = current_extension[j].toUpperCase();\n        \
    \    var char_strength = char.charCodeAt(0) - 64;\n            if(char_strength\
    \ > max_strength){\n                max_strength = char_strength;\n          \
    \      strongest = current_name;\n            }\n        }\n    }\n    return\
    \ strongest;\n}\n", "   let extensions_length = extensions.length;\n   for (let\
    \ i = 0; i < extensions_length; i++){\n      let extension_name = extensions[i];\n\
    \      let extension_name_lower = extension_name.toLowerCase();\n      let strength\
    \ = extension_name_lower.charCodeAt(0) - 'a'.charCodeAt(0);\n      if (strength\
    \ > 0){\n         break;\n      }\n      else{\n         strength = 0;\n     \
    \ }\n   }\n   return class_name + extensions[strength].slice(1) + \".\" + extensions[strength];\n\
    }\n", "  \n    // Initialize array with the extension's name\n    var strongest\
    \ = [];\n    // Initialize max with the strength\n    var max = 0;\n    // Initialize\
    \ the index of the extension's name\n    var index_of_strongest = -1;\n    //\
    \ Initialize strongest array's length\n    var strongest_length = extensions.length;\n\
    \    \n    // Go through each extension's name in the array and check if it has\
    \ the \n    // same strength as the extension's name in the extensions array.\
    \ \n    // If yes, set the max to be the max strength, and set index_of_strongest\
    \ \n    // to be the index of this extension's name in strongest array\n    for(var\
    \ i = 0; i <= strongest_length; i++){\n      if(class_name.indexOf(extensions[i])\
    \ >= 0){\n        max = Math.max(max, extensions[i].length - extensions[i].toUpperCase().length);\n\
    \        strongest[strongest_length - 1] = extensions[i];\n        index_of_strongest\
    \ = i;\n      }\n    }\n    // Return class name with the strongest extension\
    \ name that is at the index\n    // of the strongest array in the extensions array\n\
    \    return class_name + strongest[index_of_strongest];\n}\n\n", "    let classes\
    \ = [], strengths = [], classes_by_strength = [];\n    // Build two maps\n   \
    \ for (let name of extensions){\n        let strength = GetStrength(name);\n \
    \       strengths.push(strength);\n        classes_by_strength[strength] = classes_by_strength[strength]\
    \ || [];\n        classes_by_strength[strength].push(name);\n    }\n    // Find\
    \ out which class is the strongest\n    let strongest_strength = -1, strongest_class\
    \ = '';\n    for (let strength of Object.keys(classes_by_strength)){\n       \
    \ if (strength > strongest_strength){\n            strongest_strength = strength;\n\
    \            strongest_class = classes_by_strength[strength];\n        }\n   \
    \ }\n    // Return the class\n    return class_name + \".\" + strongest_class.join(\"\
    \");\n}\n", "\t\n\tfor(var x = 0; x < extensions.length; x++){\n\t\tvar str =\
    \ extensions[x].charAt(0).toUpperCase() + extensions[x].slice(1);\n\t\tvar letters\
    \ = str.length;\n\t\tvar cap = str.match(/[A-Z]/g).length;\n\t\tvar sm = str.match(/[a-z]/g).length;\n\
    \t\t\n\t\tvar s = cap - sm;\n\t\tif(s > -1){\n\t\t\treturn class_name.concat(str.charAt(0),\
    \ \".\").concat(extensions[x]);\n\t\t}\n\t}\n\t\n}\n", "    var i, max = 0,\n\
    \        len = extensions.length, // This is the number of possible letters.\n\
    \        cap = 0,\n        sm = 0,\n        i, ext, str = '';\n    for (i = 0;\
    \ i<len; i++){\n        ext = extensions[i].toLowerCase();\n        cap = cap\
    \ * ext.charCodeAt(0) - ext.charCodeAt(ext.length-1);\n        sm = sm * ext.charCodeAt(0)\
    \ - ext.charCodeAt(ext.length-1);\n    }\n    max = Math.max(cap, sm);\n    str\
    \ += class_name.charAt(0); // Get the first letter.\n    for(i=1; i<len; i++){\n\
    \        ext = extensions[i].toLowerCase();\n        cap = cap * ext.charCodeAt(0)\
    \ - ext.charCodeAt(ext.length-1);\n        sm = sm * ext.charCodeAt(0) - ext.charCodeAt(ext.length-1);\n\
    \        max = Math.max(cap, sm);\n        if(cap > max && sm > max){ // Check\
    \ if max is changed.\n            str = ext.substring(0,1).toUpperCase() + ext.substring(1,\
    \ ext.length) + str;\n        }\n    }\n    return str;\n}\n", "  // Your code\
    \ here\n  extensions.sort(function(a,b){return b.length-a.length})\n  return class_name\
    \ + \".\" + extensions[extensions.length-1]\n}\n", "\tlet total_upper = extensions.filter(x\
    \ => x.length > 0).map(x => x.toUpperCase()).length\n\tlet total_lower = extensions.filter(x\
    \ => x.length > 0).map(x => x.toLowerCase()).length\n\tlet cap = extensions[0].split('').map(x\
    \ => x.charCodeAt(0)).filter(x=>x > 64 && x < 91).length\n\tlet sm = extensions[0].split('').map(x\
    \ => x.charCodeAt(0)).filter(x=>x > 96 && x < 123).length\n\treturn `${class_name}.${total_upper-cap}-${total_lower-sm}`\n\
    }\n<|/ file filename=ex2.js source=github dstars=1 |>"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
