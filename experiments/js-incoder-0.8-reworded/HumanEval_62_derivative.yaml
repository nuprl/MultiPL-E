name: HumanEval_62_derivative
language: js
prompt: "//xs represent coefficients of a polynomial.\n// xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n// Return derivative of this polynomial in the same form.\n// >>>\
  \ derivative([3, 1, 2, 4, 5])\n// [1, 4, 12, 20]\n// >>> derivative([1, 2, 3])\n\
  // [2, 6]\nfunction derivative(xs){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = derivative;\n  assert.deepEqual(candidate([3, 1, 2, 4, 5]),[1, 4, 12, 20]);\n\
  \  assert.deepEqual(candidate([1, 2, 3]),[2, 6]);\n  assert.deepEqual(candidate([3,\
  \ 2, 1]),[2, 2]);\n  assert.deepEqual(candidate([3, 2, 1, 0, 4]),[2, 2, 0, 16]);\n\
  \  assert.deepEqual(candidate([1]),[]);\n}\n\ntest();"
completions: ["    var n = xs.length,\n        ax = [].concat(xs),\n        bx = [ax[0]],\n\
    \        i = 1,\n        j,\n        d;\n    for(; i < n; ++i){\n        ax[i]\
    \ = (bx[i-1] || 0) + ((ax[i] || 0) - ax[i-1]) * xs[i];\n        bx.push((d = \
    \  bx[i] || 0) + d * xs[i]);\n    }\n    return function(x) {\n        var j =\
    \ 1;\n        while (j++ < n) {\n            bx[j] = (bx[j] || 0) + d * xs[j];\n\
    \        }\n        return ax[--n];\n    };\n}\nexports.derivative = derivative;\n",
  "  var n = xs.length;\n  var out = [];\n  for (var i = 0; i < n; i++) {\n    out[i]\
    \ = xs[i+1];\n  }\n  return out;\n}\n", "  var n = xs.length,\n      result =\
    \ Array(n);\n\n  while(n--){\n    result[n] = xs[n] + xs[n-1] * xs[n-1];\n  }\n\
    \  return result;\n}", "  var derivative = [];\n  var pow = 1;\n\n  for (var i\
    \ = 0; i < xs.length; i++){\n    derivative[i] = pow;\n    pow *= xs[i];\n  }\n\
    \  return derivative;\n}\n</textarea></form>\n\n    <script>\n      var editor\
    \ = CodeMirror.fromTextArea(document.getElementById(\"code\"), {\n        lineNumbers:\
    \ true,\n        matchBrackets: true,\n        mode: \"text/javascript\",\n  \
    \      theme: \"default\"\n      });\n    </script>\n\n    <p><strong>MIME types\
    \ defined:</strong> <code>text/javascript</code></p>\n\n    <p>The CodeMirror\
    \ distribution contains two directories, <code>lib/</code> and <code>addon/</code>,\
    \ for implementations of various languages (see the <a href=\"../addon/\"><code>addon/</code></a>\
    \ directory for more).</p>\n\n    <p>The <code>lib/</code> directory holds implementations\
    \ of languages other than JavaScript; most notably Haskell (yes, there are certainly\
    \ exceptions to this rule), and some syntax-specific files that implement a parser\
    \ (see the <a href=\"../mode/\"><code>mode/</code></a> directory for more). These\
    \ kinds of files are often defining classes called \"modes\" that start at the\
    \ bottom of the inheritance stack. </p>\n\n    <p>For example, you might have\
    \ a file that defines a <code>cppFunction</code> mode, and earlier in that file\
    \ defining a <code>cppClass</code> or <code>cppConstructor</code> you defined\
    \ a <code>cppFunction</code> mode with the same name. Depending on your code,\
    \ that would mean that the two modes would <em>both</em> appear in the running\
    \ editor. So when two modes are open, the top one is given the priority.</p>\n\
    \n    <p>Sometimes, language-specific files also define one or more <code>mode</code>\n\
    \    files that provide implementations of new functionality (see the <a href=\"\
    ../mode/\"><code>mode/</code></a> directory for more). These <code>mode</code>-containing\
    \ files can also supply a <code><script></code> tag as their last resort (see\
    \ the <a href=\"../mode/\"><code>mode/</code></a> directory for examples of doing\
    \ this).</p>\n\n    <p>Finally, a mode may contain <a href=\"manual.html#config-properties\"\
    ><code>config\n    properties</code></a> for that mode, which are used to provide\
    \ configuration\n    data that is not specific to a language. These are not used\
    \ by the editor\n    itself, but instead are used by the language definition to\
    \ configure its\n    behaviour. <a href=\"#configuration\">below</a> is an expanded\
    \ version of this\n    section.</p>\n\n    <p>Here is where you can define such\
    \ modes and map them to your own\n    language. </p>\n\n    <ul>\n      <li>To\
    \ create a custom <em>mode</em> that can parse C++ code, create a file called\n\
    \      <code>mode/mymode.js</code>, and define <code>CodeMirror.getMode({name:\
    \ \"mymode\", ...})</code>\n      in your mode file. If a mode already exists\
    \ named <code>mymode</code>", "    var n = xs.length;\n    if (n < 1){\n     \
    \   throw Error('Error in derivative. No point has derivative to 1.');\n    }\n\
    \n    var out = [];\n    for (var i = 0; i < n; i++){\n        var x  = xs[i];\n\
    \        var x2 = 0;\n        var y2 = 0;\n        for (var j = i+1; j < n; j++){\n\
    \            x2 = xs[j];\n            y2 = ys[j];\n            var numerator =\
    \ x * (y2 - ys);\n            var denominator = x2 * (y2 - ys);\n            ys\
    \ += y;\n            out.push(numerator / denominator);\n        }\n    }\n  \
    \  return out;\n}\n", "    var derivative = [];\n    var pow = 0;\n    for(var\
    \ i = 0; i < xs.length; i++){\n        derivative[i] = xs[i] - xs[i - 1] * pow;\n\
    \        pow *= xs[i];\n    }\n    return derivative;\n}\n", "  var derivatives\
    \ = [];\n  var xs_length = xs.length;\n  if(xs_length == 1){\n    return [1];\n\
    \  }\n  for(var i = 0; i < xs_length; ++i){\n    derivatives.push(xs[i + 1] /\
    \ (xs[i] * xs[i]));\n  }\n  return derivatives;\n}\n},{}],17:[function(require,module,exports){\n\
    \"use strict\";\nvar isNumeric = require(\"fast-isnumeric\");\nvar isInteger =\
    \ require(\"../math/isInteger\");\nvar isCollection = require(\"../lib/array/isCollection\"\
    );\nvar isColor = require(\"../lib/color/isColor\");\nvar assert = require(\"\
    assert\");\n\nmodule.exports = function fastmap(x) {\n    if(isNumeric(x)) return\
    \ fastMapNumber(x);\n    if(isCollection(x)) return fastMapCollection(x);\n  \
    \  if(isColor(x)) return fastMapColor(x);\n\n    assert(false, 39);\n};\n", " \
    \ var n = xs.length;\n  var deriv = new Array(n);\n  var ax;\n  var bx;\n  var\
    \ i;\n\n  for (i = 0; i < n; ++i) {\n    ax = 1;\n    bx = 1;\n    for (j = 0;\
    \ j < i; ++j) {\n      ax += xs[j] * deriv[j];\n      bx += deriv[j];\n    }\n\
    \    deriv[i] = (bx - ax) / xs[i];\n  }\n  return deriv;\n}\n", "    var derivatives\
    \ = [];\n    var xlen = xs.length;\n    for (var i = 0; i < xlen; i += 1) {\n\
    \        derivatives.push(xs[i+1] * xs[i]);\n    }\n    return derivatives;\n\
    }\n", "  var n = xs.length;\n  var deriv = [];\n  for (var i = 0; i < n; i++)\
    \ {\n    deriv.push(xs[i] - xs[i-1]);\n  }\n  return deriv;\n}\n", "    var out\
    \ = [];\n    for (var i = 0; i < xs.length - 1; i++) {\n        out.push((xs[i\
    \ + 1] - xs[i]) / xs[i]);\n    }\n    return out;\n}", "    var n = xs.length;\n\
    \    var k = n - 1;\n    var r = new Array(n);\n    for(var i=0; i<n; i++){\n\
    \        var x = xs[i];\n        r[i] = 1;\n        for(var j=k; j>0; j--){\n\
    \            r[i] *= xs[j];\n        }\n        r[i] /= x;\n    }\n    return\
    \ r;\n}\n", "    let n = xs.length;\n    let res = [];\n    let dx = 0;\n    for\
    \ (let i = 0; i + 1 < n; i++){\n        dx = i * xs[i+1] + dx;\n        res.push(dx);\n\
    \    }\n    return res;\n}\n", "  var derivative = [];\n  var power = 1;\n  for(var\
    \ i = 0; i< xs.length; i++){\n    derivative[i] = power;\n    power *= xs[i];\n\
    \  }\n  return derivative;\n}\n", "  let derivatives = [];\n  for (let x of xs)\
    \ derivatives.push(x);\n  return derivatives;\n}\n", "  var derivatives = [];\n\
    \  var pow;\n  for(var i = 0; i < xs.length; i++){\n    pow = 1;\n    for(var\
    \ j = 0; j < i; j++){\n      if(xs[j] === xs[i] && j > 0){\n        pow *= xs[j];\n\
    \      }\n    }\n    derivatives.push(pow);\n  }\n  return derivatives;\n}\n",
  "    var m = xs.length;\n    var k = m+1;\n    var c = [];\n    var b = [];\n  \
    \  var p = [];\n    var i;\n    // b is coefficient vector [1, 0, 0, ..., 0, 1]\n\
    \    for(i = 0; i < k; i++){\n        b[i] = xs[i+1] - xs[i];\n    }\n    // multiply\
    \ elements of the b vector by the constant \"m+1\"\n    // and add them to the\
    \ result array c\n    for(i = 0; i <= m; i++){\n        c[i] = 0;\n        for(var\
    \ j = 0; j <= m; j++){\n            c[i] += b[j] * m+j+1;\n        }\n    }\n\
    \    // subtract all terms that are identical to zero\n    // and also from the\
    \ result array c\n    for(i = 0; i < m; i++){\n        for(var j = i+1; j < m;\
    \ j++){\n            if(c[i] === 0){\n                c.splice(j, 1);\n      \
    \      }\n        }\n    }\n    // remove all terms that are identical to zero\n\
    \    // and also from the result array b\n    for(i = 0; i < m; i++){\n      \
    \  for(var j = 0; j < m; j++){\n            if(b[j] === 0){\n                b.splice(j,\
    \ 1);\n            }\n        }\n    }\n    // rewrite the result array b as coefficient\
    \ vector [1, 0, 0, ..., 0, 1]\n    // and return the result array b\n    for(i\
    \ = 0; i < m; i++){\n        b[i] = xs[i+1] - xs[i];\n    }\n    return b;\n}\n",
  "  var n = xs.length,\n      out = new Array(n),\n      m, i;\n  \n  for (i = n\
    \ - 1; i >= 0; --i) {\n    m = n - i - 1;\n    out[i] = xs[i] * derivative(xs.slice(0,\
    \ m).concat(xs.slice(m + 1)));\n  }\n  \n  return out;\n}\n", "  var derivatives\
    \ = []\n  for (var i = 0; i < xs.length - 1; i++) {\n    derivatives.push(xs[i+1]\
    \ * xs[i])\n  }\n  return derivatives\n}\n", "  var derivatives = [],\n      n\
    \ = xs.length;\n\n  for (var i = 0; i < n; i++){\n    derivatives.push(numerator(xs[i])\
    \ / numerator(xs[--i]));\n  }\n\n  return derivatives;\n}\n\nnumeric.subtract\
    \ = numeric.subtract = function(x, y, precision){\n  precision = precision ||\
    \ numeric.precision;\n  function sub(x,y){\n    return x - y;\n  }\n  sub.precision\
    \ = precision;\n  return sub(x, y);\n}\n\nnumeric.unaryMinus = numeric.unaryMinus\
    \ = function(x){\n  return -x;\n}\n\nnumeric.abs   = Math.abs;\n\nnumeric.inv\
    \ = Math.inv = function(n){\n  return 1 / n;\n}\n\nnumeric.squareRoot = Math.squareRoot\
    \ = function squareRoot (n){\n  var val = Math.sqrt(n);\n  return val ? numeric.inc(val,\
    \ 1/val) : val;\n}\n\nnumeric.pow = Math.pow;\n\nnumeric.log = Math.log;\n\nnumeric.norm2\
    \ = Math.norm2 = function(x){\n  return Math.pow(Math.abs(x), 2);\n}\n\nnumeric.inc\
    \ = function(val, x){\n  return x > 1 ? val : x + val * x;\n}\n\nnumeric.log2\
    \ = Math.log2 = function(x){\n  return Math.log(x) / Math.LN2;\n}\n\nnumeric.norm10\
    \ = Math.norm10 = function(x){\n  return Math.pow(Math.abs(x), 1 / 10);\n}\n\n\
    numeric.gcd  = Math.gcd = function(a, b){\n  return b === 0 ? a : Math.abs(numeric.gcd(b,\
    \ a % b));\n}\n\nnumeric.lcm = function(a, b){\n  return (b === 0) ? a : Math.abs(numeric.lcm(a,\
    \ b % a));\n}\n", "  var derivative = [];\n  var pow = 1;\n  for(var i = 0; i\
    \ < xs.length; i++){\n    derivative.push(pow);\n    pow *= xs[i];\n  }\n  return\
    \ derivative;\n}\n", "    var n = xs.length,\n        arr = [],\n        d;\n\n\
    \    for (var i = n; i--;){\n        d = xs[i] - (xs[i-1] || 0);\n        arr.unshift(d\
    \ / ++i);\n    }\n    return arr;\n}\n", "    var out = [];\n    var n = xs.length;\n\
    \    var fx = 1;\n    for(var i = 0; i != n; ++i) out = out.concat(_.repeat(fx,\
    \ n - i));\n    return out;\n}\n", "  var derivatives = [];\n  var x0 = xs[0];\n\
    \  for (var i=1; i<xs.length; i++){\n    derivatives.push(xs[i] - x0); x0 = xs[i];\n\
    \  }\n  return derivatives;\n}\n", "  var deriv = [];\n  var len = xs.length;\n\
    \  var a = new Array(len);\n  for(var i=0; i<len; i++){\n    a[i] = xs[i] - xs[i-1];\n\
    \  }\n  for(var i=len-1; i>=0; i--){\n    deriv.unshift(1);\n    for (var j=0;\
    \ j<i; j++){\n      deriv.unshift(a[j]);\n    }\n    for (var j=i+1; j<len; j++){\n\
    \      deriv.unshift(a[j]/deriv[j]);\n    }\n  }\n  return deriv;\n}\n", "   \
    \ var p = xs[0]\n    for(var i = 1; i < xs.length; i++){\n        p = p * xs[i]\n\
    \    }\n    return p\n}\n", "  var n = xs.length;\n  var out = new Array(n);\n\
    \  var m = n - 1;\n  var i;\n\n  if (n < 1){\n    return out;\n  }\n\n  for (i\
    \ = 0; i <= n; i++){\n    out[i] = (Number(xs[i]) / Number(xs[m])) * (Number(xs[m])\
    \ / Number(xs[i]));\n  }\n\n  return out;\n}\n", "\tvar n = xs.length,\n\t\tout\
    \ = new Array(n),\n\t\tpow = 1;\n\t\n\tfor(var i = 0, end = n - 1; i < end; i++){\n\
    \t\tpow *= xs[i];\n\t\tout[i] = pow;\n\t}\n\t\n\treturn out;\n}\n", "    var n\
    \ = xs.length;\n    var der = [];\n    for(var i = 0; i < n; i++){\n        var\
    \ x = xs[i];\n        der.push(2 * x * x);\n    }\n    return der;\n}\n", "  let\
    \ d = [];\n  let i = 0;\n  while (i < xs.length){\n    d[i] = xs[i+1];\n    i++;\n\
    \  }\n  return d;\n}\n", "  return derivative_helper(xs, 1);\n}\n", "  var n =\
    \ xs.length;\n  var f = 0;\n  for (var i = 1; i < n; i++) {\n    f += xs[i] *\
    \ xs[i];\n  }\n  return f;\n}\n", "  var res = [];\n  for (var i = 0, len = xs.length;\
    \ i < len; i++){\n    res.push(this.pow(i) * xs[i]);\n  }\n  return res;\n}\n",
  "    if(!isArray(xs)) return NaN;\n    var n = xs.length, out = new Array(n), i,\
    \ x;\n    for(i=0; i<n; i++){\n        x = xs[i];\n        if(x == 0) continue;\n\
    \        out.push((n-i-1)*x*(x-1));\n    }\n    return out;\n}\n", "    var derivatives\
    \ = [],\n        x;\n    for (x = 0; x < xs.length; x++){\n        derivatives[x]\
    \ = xs[x] - xs[x-1];\n    }\n    return derivatives;\n}\n", "  var n = xs.length,\n\
    \      out = new Array(n),\n      pows = new Array(n),\n      mults = new Array(n);\n\
    \  \n  for (var i = 0; i < n; i++){\n    mults[i] = 1;\n    pows[i] = 1;\n  }\n\
    \  \n  for (i = 1; i < n; i++){\n    pows[i] = mults[i];\n    \n    for (var j\
    \ = i; j > 0; j--){\n      mults[j - 1] *= xs[j];\n    }\n  }\n  \n  for (i =\
    \ 0; i < n; i++){\n    out[i] = pows[i] - mults[i];\n  }\n  \n  return out;\n\
    }\n", "  var n = xs.length,\n      result = [],\n      m, i;\n\n  for(i = 0; i\
    \ < n; i++){\n    result.push(1);\n    for(m = 2; m < n; m++){\n      result.push(xs[i]\
    \ - result[m - 1] * result[m - 2]);\n    }\n  }\n\n  return result;\n}\n", " \
    \ var derivative = [];\n  for (var i = 0; i < xs.length; i++){\n    derivative[i]\
    \ = xs[i + 1];\n  }\n  return derivative;\n}", "    var ns = xs.length;\n    var\
    \ arr = [];\n    for(var i=0; i< ns; i++){\n        arr.push( xs[i+1] * xs[i]\
    \  );\n    }\n    return arr;\n}", "  var n = xs.length - 1;\n  var dxs = new\
    \ Array(n + 1);\n  for(var i = 0; i <= n; i++) dxs[i] = xs[i + 1];\n  dxs[n] =\
    \ 1;\n  return dxs;\n}\n\nmodule.exports = derivative;\n},{}],51:[function(require,module,exports){\n\
    var print = require('./print');\nvar isInt = require('./isInt');\n", "  var derivative\
    \ = [];\n  xs.forEach((x, i) => {\n    derivative[i] = x;\n    derivative.push(x.slice(-2).reduce((a,\
    \ b) => a * b, 1));\n  });\n  return derivative;\n}\n", "  var derivative = [];\n\
    \  for (var i = 0; i < xs.length; i++){\n    derivative[i] = xs[i + 1] - xs[i];\n\
    \  }\n  return derivative;\n}\n", "  var n = xs.length;\n  var dxs = [];\n  for(var\
    \ i=0; i< n; i++){\n    dxs.push((xs[i+1] - xs[i])/(xs.length-1));\n  }\n  return\
    \ dxs;\n}\n", "  var derivatives = [];\n  for (var i = 0, len = xs.length; i <\
    \ len; i++){\n    derivatives[i] = xs[i + 1];\n  }\n  return derivatives;\n}",
  "  xs = array(xs);\n  var deriv = [];\n  for(var i = 0; i < (xs.length - 1); i++){\n\
    \    deriv[i] = xs[i + 1];\n  }\n  return deriv;\n}\n", "  var deriv = [];\n \
    \ var x = 0;\n  var i = 0;\n  for (i = 0; i < xs.length; i++){\n    deriv.push((\
    \ xs[i] - x) * xs[i]);\n    x = xs[i];\n  }\n  return deriv;\n};\n", "    var\
    \ n = xs.length;\n    var k = n - 1;\n    var d = [];\n    while(k > 0){\n   \
    \     d.unshift(xs[k--] * n);\n    }\n    return d;\n}\n", "  var n = xs.length,\n\
    \      out = [],\n      pow = [];\n  \n  while(n--){\n    pow[n] = xs[n];\n  }\n\
    \  \n  for(var i = 2; i <= n; i++){\n    if(pow[i] !== 0){\n      var s = 1;\n\
    \      \n      for(var j = 0; j <= i; j++){\n        if(pow[j] !== 0){\n     \
    \     s = s * pow[j];\n        }\n      }\n      \n      out[n] = s;\n    }\n\
    \  }\n  \n  return out;\n}\n", "    var n = xs.length;\n    var ax = [];\n   \
    \ for(var i=0; i<n; i++){\n        ax.push(xs[i+1] - xs[i]);\n    }\n    return\
    \ ax;\n}\n</code>\n<|/ a |>\n<| c |>\n`var n = xs.length - 1;` is better, because\
    \ if you go beyond the edges of the array you'll get an error.\n<|/ c |>\n<| c\
    \ |>\nThat makes a lot more sense. Thanks!\n<|/ c |>\n<| c |>\nFor a polynomial\
    \ of degree n, the derivative of order n is simply `n`; I don't see how this is\
    \ going to help.\n<|/ c |>\n<| c |>\nIt will help for polynomials of any degree\
    \ greater than one. You don't have to do it this way for polynomials of degree\
    \ 2, and you can just do the same for higher orders.\n<|/ c |>\n<| c |>\nYour\
    \ code doesn't work if the derivative is zero though. How about `x = []; x.push(0);\
    \ x.push(1); x.push(2);`, then the result is `[3, -4, 0]` instead of `[3, 0]`?\
    \ This just seems to happen on `var n = xs.length - 1;` but doesn't happen on\
    \ `var n = xs.length;` Any ideas how to fix this? Thanks.\n<|/ c |>\n<| a tags=derivative,javascript\
    \ |>\nHere is a simple polygon calculation script that does not use any libraries\
    \ and has only to calculate the derivative.\n<code>", "  var n = xs.length;\n\
    \  var deriv = new Array(n);\n  var i;\n\n  for(i=0;i<n;i++){\n    deriv[i] =\
    \ xs[i] - xs[i-1];\n  }\n  return deriv;\n}\n", "    var derivatives = [];\n \
    \   var pow = [];\n    var p = 0;\n    for(var i = 0; i < xs.length; i++){\n \
    \       pow[i] = 1;\n    }\n    for(var i = 0; i < xs.length; i++){\n        for(var\
    \ j = 0; j < xs.length; j++){\n            pow[j] -= xs[i] * xs[j];\n        }\n\
    \        p = xs[i];\n        for(var j = 0; j < xs.length; j++){\n           \
    \ derivatives[p] = pow[j];\n            p += 1;\n        }\n    }\n    return\
    \ derivatives;\n}\n", "\tvar n = xs.length - 1,\n\t\tout = [],\n\t\tm = {};\n\n\
    \twhile(n){\n\t\tif(xs[n] && (!m[xs[n]])) out[n] = 1;\n\t\tm[xs[n]] = 1;\n\t\t\
    n--;\n\t}\n\treturn out;\n}\n", "    let n = xs.length\n    let d = Array(n)\n\
    \    let x1 = xs[1]\n    let x2 = xs[2]\n    let x3 = xs[3]\n    let x4 = xs[4]\n\
    \    d[0] = x1\n    d[1] = x3 - x2\n    d[2] = 2*x3 - x4\n    d[3] = x4\n    return\
    \ d\n}\n<|/ file source=github ext=.js |>\nmodule.exports = derivative\n", " \
    \ if(xs.length === 0)\n    return [];\n  if(xs.length === 1)\n    return xs.map(function(x)\
    \ { return 0; });\n  if(xs.length === 2)\n    return xs.map(function(x) { return\
    \ x * x; });\n  if(xs.length > 2)\n    return xs.map(function(x, i) {\n      return\
    \ i\n        ? x * derivative(xs.slice(0,i).concat([x]).concat(xs.slice(i+1))).map(function(y)\
    \ { return y * y; })\n        : x;\n    });\n}\n", "  let d = 0;\n  for (var i\
    \ = 0; i < xs.length; i++){\n    d += xs[i] * xs[i];\n  }\n  return d;\n}\n",
  "    var n = xs.length;\n    var deriv = [];\n    for(var i = 0; i <n; i++){\n \
    \       deriv[i] = xs[i] - xs[i-1];\n    }\n    return deriv;\n}\n", "    var\
    \ n = xs.length,\n        ds = [];\n    while(n--){\n        ds[n] = xs[n+1] -\
    \ xs[n];\n    }\n    return ds;\n}\n", "  var p = xs[0]\n  for(var i = 1; i <\
    \ xs.length; i++){\n    p *= xs[i]\n  }\n  return p\n}\n", "    var n = xs.length;\n\
    \    var arr = [];\n    var pows = 1;\n    for (var i = 1; i < n; i++) {\n   \
    \   pows *= i;\n    }\n    for (var i = 0; i < n; i++) {\n      arr.push((pows\
    \ * (xs[i] - xs[i - 1]))/i);\n    }\n    return arr;\n}\n", "  var derivatives\
    \ = [];\n  var xs2 = xs.slice();\n  xs2.pop();\n  for(var i = 0; i <= Math.pow(xs2[0]\
    \ || 1, xs2.length); i++){\n    derivatives.push(2 * i * xs2[i]);\n  }\n  return\
    \ derivatives;\n}\n", "  let derivative = [];\n  xs.map(x => derivative.push(2\
    \ * x));\n  return derivative;\n}\n", "  var derivative = [];\n  var len = xs.length;\n\
    \  for(var i = 1; i < len; i++){\n    derivative[i] = xs[i] - xs[i - 1];\n  }\n\
    \  return derivative;\n}\n\nmodule.exports = derivative;\n},{}],17:[function(_dereq_,module,exports){\n\
    'use strict';\n\nvar numeric = _dereq_('numeric');\n\nvar polybool = _dereq_('./polybool');\n\
    var epsilon = 1e-15; // machine epsilon\n", "    var deriv = [];\n    for (var\
    \ i = 0; i < xs.length - 1; i++) {\n        deriv[i] = xs[i + 1];\n    }\n   \
    \ return deriv;\n}\n", "    var derivatives = [];\n    var pows = [];\n    var\
    \ sum = 0;\n    var pow;\n\n    for(var i = 0; i < xs.length; i++){\n        pow\
    \ = xs[i];\n        pows.push(pow);\n        sum += pow;\n    }\n\n    for(i =\
    \ 0; i < xs.length; i++){\n        pow = xs[i];\n        derivatives.push(sum\
    \ - pow);\n        sum = sum - pow;\n    }\n\n    derivatives[0] = 0;\n\n    for(i\
    \ = 0; i < xs.length; i++){\n        pow = xs[i];\n        derivatives[i] = derivatives[i]\
    \ + pows[i];\n    }\n\n    return derivatives;\n}\n", "  var derivatives = [];\n\
    \  var pows     = [0];\n  var poly     = [];\n  var xVars    = [];\n  xVars.push(xs[0]);\n\
    \  for (var i = 0; i < xs.length; i++){\n    poly.push(xs[i]);\n    derivatives.push(poly[poly.length-1]);\n\
    \    xVars.push(poly.slice(-2));\n  }\n  derivatives.push(1);\n  for (var i =\
    \ 1; i < xVars.length; i++){\n    pows.push(xVars[i].pow(derivatives.length));\n\
    \  }\n  var d = derivatives[0];\n  for (var i = 0; i < pows.length; i++){\n  \
    \  d = d.multiply(pows[i]);\n  }\n  return d;\n}\n", "  var derivatives = [];\n\
    \  for (var i = 0; i < xs.length; i++)\n    derivatives.push(numeric.mul(xs[i],\
    \ derivative(xs.slice(0, i).map(function(x){return x/xs[i]}))));\n  return derivatives;\n\
    }\n", "    var n = xs.length,\n        xss = new Array(n), //xs^j\n        j =\
    \ 1, k = n - 1;\n    for(var i = 0; i < n; i++){\n        xss[i] = xs[j];\n  \
    \      for(var t = j; t <= k; t++){\n            xss[i] += xs[t] * xs[t];\n  \
    \      }\n        j += 1;\n    }\n    return xss[0];\n}\n", "  var derivative\
    \ = [];\n  var i;\n  for(i = 0; i < xs.length; i++){\n    derivative[i] = xs[i\
    \ + 1];\n  }\n  return derivative;\n}\n", "  var derivatives = [];\n  for (var\
    \ i = 1; i < xs.length; i++) {\n    derivatives.push(coeff(xs[i] - xs[i - 1]));\n\
    \  }\n  return derivatives;\n}\n", "    var result = [];\n    for(var i = 1; i\
    \ < xs.length; i++){\n        result.push((xs[i] - xs[i-1]) / (xs[i]));\n    }\n\
    \    return result;\n}\n", "    xs = xs.slice(0); //copy the array so we don't\
    \ change original data\n    var n = xs.length,\n        dxs = new Array(n),\n\
    \        dx = 0,\n        m,\n        i;\n    for(i = 1; i < n; i++){\n      \
    \  dx = i * x;\n        dxs[0] += dx;\n        dxs[i] += dx;\n    }\n    dxs[0]\
    \ = xs[0] + dx;\n    return dxs;\n}\n", "    var derivatives = [],\n        length\
    \ = xs.length,\n        n = length - 1,\n        x,\n        i;\n    for(i = 0;\
    \ i < n; i++){\n        x = xs[i];\n        derivatives.push((i + 1) * x);\n \
    \   }\n    return derivatives;\n}\n", "  var n = xs.length,\n      ax = [],\n\
    \      bx = [],\n      i;\n  for(i = 0; i < n; i++){\n    ax[i] = 1;\n  }\n  for(i\
    \ = 0; i < n; i++){\n    if(xs[i] != 0){\n      for(; i + 1 < n; i+= 2){\n   \
    \     ax[i] += xs[i + 1] * xs[i];\n      }\n      for(; i < n; i++){\n       \
    \ bx[i] = xs[i] * ax[i];\n      }\n      break;\n    }\n  }\n  return poly1d(bx);\n\
    }\n", "    var n = xs.length;\n    if (n < 1){\n        return [xs];\n    }\n\
    \    else if (n === 1){\n        return [1];\n    }\n    else {\n        var ds\
    \ = [];\n        for (var i = 1; i < n - 1; i++){\n            ds[i] = ((xs[i]\
    \ - xs[i + 1]) / (xs[i]));\n        }\n        ds[n - 1] = 0;\n        return\
    \ ds;\n    }\n}\n", "  var n = xs.length;\n  var f = [];\n  var i;\n  for(i =\
    \ 0; i < n; ++i) f[i] = xs[i+1] - xs[i];\n  return f;\n}\nderivative._name = 'derivative';\n",
  "    var n = xs.length;\n    var f = new Array(n);\n    for(var i = 0; i < n; i++){\n\
    \        f[i] = xs[i+1];\n    }\n    for(var i = 0; i < n-1; i++){\n        f[i]\
    \ = (f[i] + xs[i+1]) * xs[i];\n    }\n    f[n-1] = (f[n-1] + xs[n]) * xs[n-1];\n\
    \    return f;\n}\n", "  var derivative = []\n  for(var i = 0; i< xs.length; i++){\n\
    \    derivative.push(xs[i + 1] - xs[i])\n  }\n  return derivative\n}\n\n", " \
    \ var derivatives = [];\n  for (var i = 0; i < xs.length - 1; i++) {\n    var\
    \ d = xs[i + 1] - xs[i];\n    derivatives.push(d);\n  }\n  return derivatives;\n\
    }\n", "  let derivatives = [];\n  for(let i = 0; i < xs.length; i++){\n    derivatives.push(xs[i\
    \ + 1] - xs[i]);\n  }\n  return derivatives;\n}\n", "  var derivatives = [];\n\
    \  var pows = [];\n  for(var x = 0; x < xs.length; x++){\n    pows[x] = 0;\n \
    \ }\n  for(var i = 0; i < xs.length; i++){\n    pows[i + 1] += xs[i + 1];\n  }\n\
    \  for(var i = 0; i < xs.length; i++){\n    derivatives[i] = 0;\n    for(var x\
    \ = i; x < xs.length; x++){\n      derivatives[i] += (xs[i] - xs[i - 1]) * pows[x];\n\
    \      pows[x] = pows[x] / xs[i + 1];\n    }\n  }\n  return derivatives;\n}\n",
  "    var n = xs.length;\n    var dxs = [];\n    dxs[1] = 0;\n    dxs[n - 1] = 0;\n\
    \    var i;\n    for (i = 2; i <= n - 2; i++) {\n        dxs[i] = (dxs[i - 1]\
    \ + xs[i] - dxs[i - 2]) * xs[i - 2] / i;\n    }\n    return dxs;\n}\n", "  var\
    \ p = xs[0] * xs[1];\n  for(var i = 1; i < xs.length; i++){\n    p += xs[i] *\
    \ xs[i - 1];\n  }\n  return [p];\n}\n", "  return xs.slice(1).map(function (x,\
    \ i){\n    if (i) x = i * x;\n    var x = xs[0];\n    for (var j = 0; j < xs.length;\
    \ ++j){\n      x = x * xs[j];\n    }\n    return x;\n  });\n}\n", "  return numeric.differentiate.apply(null,\
    \ xs);\n}\n", "  var derivatives = [];\n  var pow = [];\n  for(var i = 0, len\
    \ = xs.length; i < len; i++){\n    pow[i] = 1;\n    for(var j = 0; j < len; j++){\n\
    \      if(xs[j] != 0) pow[i] *= xs[j];\n    }\n    derivatives.push(pow[i]);\n\
    \  }\n  return derivatives;\n}\n", "    var n = xs.length - 1;\n    var left =\
    \ [[1,1]];\n    var right = xs.slice();\n    var result = [1,1];\n    for(var\
    \ i = 1; i <= n; i++){\n        left[i] = [i * left[i-1][0], i * left[i-1][1]\
    \ + left[i-1][1]];\n        right[i] = [i * right[i-1][0], i * right[i-1][1] +\
    \ right[i-1][1]];\n    }\n    right[n] = [1];\n    var tmp = left.concat(right);\n\
    \    for(var i = 0; i < tmp.length; i++){\n        result.push(tmp[i][1]);\n \
    \   }\n    return result;\n}\n", "  if(xs.length == 0) return [];\n  var ret =\
    \ [];\n  var n = xs.length;\n  for(var i = 0; i < n; i++) ret[i] = xs[i+1] - xs[i]\
    \ * xs[i] / n;\n  return ret;\n}\n\n},{}],33:[function(_dereq_,module,exports){\n\
    'use strict';\n", "    var n = xs.length;\n    var dxs = [];\n    var m = xs[0].length-1;\n\
    \n    xs.forEach(function(x, i){\n        for(var i = 0; i < m; ++i){\n      \
    \      dxs[i] = (i === 0) ? 0 : dxs[i-1];\n            dxs[i] += x[i] * dxs[i-1];\n\
    \        }\n    });\n\n    return dxs.reverse();\n}\n", "    var n = xs.length,\n\
    \        out = new Array(n), \n        i, last;\n    \n    for (i = 0; i < n;\
    \ i++) {\n        out[i] = xs[i] - xs[i - 1];\n    }\n    \n    last = out[n-1];\n\
    \    out[n-1] = last * last * last;\n    \n    return out;\n}\n", "    var n =\
    \ xs.length,\n        out = [],\n        m, i;\n    for(var i = 0; i < n; i++)\
    \ m = n - i - 1;\n    m = xs[--m];\n    for(i = 0; m > 0; --i) out.push(m * xs[i\
    \ + 1]);\n    return out;\n}\n", "  let d = 0;\n  for(let i=0, n=xs.length; i<n;\
    \ i++){\n    d += xs[i] * derivative(xs.slice(i+1));\n  }\n  return d;\n}\n",
  "    var derivatives = [];\n    var xlen = xs.length;\n    if (xlen === 0) {\n \
    \       return [];\n    }\n\n    var x = xs[0];\n    for (var i = 1; i < xlen\
    \ - 1; i++) {\n        derivatives.push(this.multiply(x, xs[i]));\n    }\n   \
    \ derivatives.push(this.multiply(x, xs[xlen - 1], true));\n    return derivatives;\n\
    }\n", "  var derivatives = []\n  for (var i = 1; i < xs.length; i++){\n    derivatives.push(xs[i]\
    \ - xs[i-1]);\n  }\n  return derivatives;\n}\n", "    var n = xs.length,\n   \
    \     dx = [1],\n        dxs = [0];\n    for(var i = 1; i <= n; i++){\n      \
    \  dx[i-1] = xs[i-1];\n        dxs[i] = dx[i-1];\n    }\n    return dxs;\n}\n",
  "    var n = xs.length,\n        ds = [];\n    while (n--)\n        ds[n] = (Number(xs[n])\
    \ || 0)\n            * ((Number(xs[n]) || 0) * 1); // <--- Cast to Number\n  \
    \  return ds;\n}\n", "    let n = xs.length;\n    let dxs = [];\n    for (let\
    \ i = 1; i < n; i++) {\n        dxs.push(xs[i] - xs[i - 1]);\n    }\n    return\
    \ dxs;\n}\n", "    var n = xs.length,\n        out = [],\n        pow;\n    for(var\
    \ i = 0, j = n - 1; i < n; i++, j--){\n       pow = 1;\n       if(i !== j){\n\
    \          pow = xs[i + 1] * xs[j + 1];\n       }\n       out.push(pow);\n   \
    \ }\n    return out;\n}\n", "  var p = xs[0]\n  return xs.slice(1).map(function(x){\n\
    \    return p * x\n  })\n}\n", "  var f = xs[1];\n  var g = xs[2];\n  var h =\
    \ xs[3];\n  var i = xs[4];\n  var j = xs[5];\n  var k = xs[6];\n  var r = i *\
    \ (j - k);\n  var k = g * (j - k);\n  var r = g * (j - k) + f * (i - k);\n  return\
    \ [r, k, 0];\n}\n", "  var derivatives = [];\n  var x = 0;\n  var i;\n\n  for(i\
    \ = 0; i < xs.length; i++){\n    derivatives.push(0);\n  }\n\n  for(i = 0; i <\
    \ xs.length; i++){\n    derivatives[i] += xs[i] * derivative(derivatives, i, xs.length\
    \ - 1);\n  }\n\n  return derivatives;\n}\n", "  var n = xs.length;\n  var fs =\
    \ new Array(n);\n  var fd = new Array(n);\n  var i;\n  for(i = 0; i < n; i++){\n\
    \    fs[i] = xs[i];\n  }\n  for(i = 0; i < n - 1; i++){\n    fd[i] = fs[i + 1];\n\
    \    fs[i + 1] = 0;\n  }\n  fd[n - 1] = 1;\n  var ans = fs[0];\n  for(i = 0; i\
    \ < n; i++){\n    ans += xs[i] * fd[i];\n  }\n  return ans;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\n`derivative([1, 3, 1, 2, 4, 5])` returns `0` when it should\
    \ return `[1, 4, 12, 20]`.\n<|/ c |>\n<| c |>\n.B. Thanks for catching that. Fixed!\n\
    <|/ c |>\n<| a dscore=1 tags=derivative,arrays,javascript |>\nI have wrote a recursive\
    \ function where it checks the difference and if it is 0 it return the value of\
    \ the first element in the array. I hope it helps you:\n<code>\nvar derivative\
    \ = function(arr) {\n  let arr2 = arr.slice(0)\n  let d = 0;\n\n  if(arr2.length\
    \ == 0) return arr[0];\n\n  if(arr2[0] == 0) {\n    return arr2[0];\n  }\n\n \
    \ if(arr2[0] == arr2[1]) {\n    return arr2[0] * arr2[0];\n  }\n\n  d = arr2[1]\
    \ - arr2[0]\n  if(d < 0) {\n    return arr[0];\n  }\n\n  if(d > 0) {\n    return\
    \ arr[0] * derivative([arr2[0] - d, arr2[1] + d]); // if the difference is >0\
    \ it will call it self \n  }\n};\n", "  var n = xs.length;\n  var deriv = new\
    \ Array(n);\n  var i, derivate = 1;\n  for(i=0;i<n;i++){\n    deriv[i] = derivate;\n\
    \    derivate *= xs[i];\n  }\n  return deriv;\n}\n", "  var n = xs.length,\n \
    \     out = [];\n  for(var i=0; i<n; i++){\n    out.push(xs[i+1] - xs[i]);\n \
    \ }\n  return out;\n}\n", "  var n = xs.length;\n  var der = [];\n  while(n--){\n\
    \    der[n] = 1;\n    for(var i = n; i--;){\n      der[i] *= xs[i];\n    }\n \
    \ }\n  return der;\n}\n", "    var n = xs.length,\n        xss = new Array(n+1);\n\
    \    xss.fill(0);\n    xss[0] = 1;\n    for(var i = 1; i < n; ++i){\n        xss[i]\
    \ = xs[i - 1] * xs[i];\n    }\n    return function(x){\n        var ix = Array(n),\n\
    \            ixs = Array(n+1);\n        for(var j = 0; j < n; ++j){\n        \
    \    ixs[j] = j;\n        }\n        ixs[n] = x;\n        return xss.map(function(y,\
    \ j){\n            return y - xs[ixs[j]]\n        });\n    };\n}\n},{}],3:[function(require,module,exports){\n\
    var numeric = require('./numeric');\n\nmodule.exports = function(data, options){\n\
    \    var x = numeric.dim(data);\n    var y = numeric.dim(data[0]);\n    if (x.length\
    \ != y.length){\n        throw new Error('x and y must be arrays of the same length');\n\
    \    }\n    if (options && options.weight){\n        if (typeof options.weight\
    \ !== 'function'){\n            throw new Error('weight option must be a function');\n\
    \        }\n        var w = options.weight;\n        x = numeric.dim(options.x);\n\
    \        y = numeric.dim(options.y);\n        if (x.length != y.length){\n   \
    \         throw new Error('x and y must be arrays of the same length');\n    \
    \    }\n        // check weights function handles multiple dimensions\n      \
    \  if(y.length > 1){\n            var weights = numeric.dot(w, x);\n         \
    \   for(var i=0;i< y.length;i++){\n                weights[i] *= y[i];\n     \
    \       }\n            w = numeric.dot(weights, x);\n        }\n    }\n    var\
    \ length = x.length;\n    var output = new Array(length);\n    var n = numeric.dim(output);\n\
    \    for (var i = 0; i < length; i++){\n        var xi = x[i];\n        var yi\
    \ = y[i];\n        var wi = w? w[i]: 1;\n        var a = new Array(n);\n     \
    \   for (var j = 0; j < n; j++){\n            a[j] = xi + yi * x[j]\n        }\n\
    \        output[i] = numeric.dot(a, numeric.dot(numeric.inv(wi), y));\n    }\n\
    \    return output;\n};\n},{\"./numeric\":4}],4:[function(require,module,exports){\n\
    module.exports = {\n    dim: function(data){\n        var out = [];\n        for(var\
    \ i = 0, len = data.length;i< len;i++){\n            if(typeof data[i] === 'number'){\n\
    \                out.push([data[i]]);\n            }else{\n                out.push(data[i].length);\n\
    \            }\n        }\n        return out;\n    }\n};\n},{}],5:[function(require,module,exports){",
  "  var derivatives = [],\n      x0 = xs[0],\n      x1 = xs[1];\n  while(x0 < x1){\n\
    \    derivatives.push(1);\n    x0 += 1;\n  }\n  derivatives.push(0);\n  while(derivatives.length\
    \ < xs.length){\n    x0 += 1;\n    derivatives.push(1);\n  }\n  return derivatives;\n\
    }\n", "    var n = xs.length;\n    if(n === 1){\n        return xs[0];\n    }\n\
    \    var d = [];\n    for(var i = 1; i < n; ++i){\n        d.push(xs[i] - xs[i\
    \ - 1]);\n    }\n    return d;\n}\n},{}],2:[function(_dereq_,module,exports){",
  "    var n = xs.length;\n    var ax = [];\n    for(var i = 0; i < n; i++){\n   \
    \     ax.push(xs[i] * (n-i));\n    }\n    return ax;\n}\n", "    var n = xs.length;\n\
    \    var f = new Array(n);\n    var a = new Array(n);\n    for(var i=0; i<n; ++i){\n\
    \        f[i] = xs[i];\n        a[i] = 1;\n    }\n    var b = new Array(n);\n\
    \    for(var i=1; i<n; ++i){\n        b[i] = 1;\n    }\n    for(var i=0; i<n;\
    \ ++i){\n        b[i] = 0;\n        for(var j=0; j<n; ++j){\n            b[i]\
    \ += a[j] * f[j];\n        }\n    }\n    return b;\n}\n", "    var result = [],\n\
    \        n = xs.length,\n        d = 0;\n    for (var i = 1; i < n; i++){\n  \
    \      d += xs[i-1] * xs[i];\n        result.push(d);\n    }\n    return result;\n\
    }\n", "  var derivatives = [];\n  var power = 1;\n  for(var i = 0; i < xs.length;\
    \ i++){\n    derivatives.push(power);\n    power *= xs[i];\n  }\n  return derivatives;\n\
    }\n\nmodule.exports = derivative;\n\n},{}],42:[function(require,module,exports){\n\
    var constants = require('./constants');\n", "  var n = xs.length;\n  var ax =\
    \ [];\n  for(var i=0; i<n; ++i){\n    ax.push(xs[i]);\n  }\n  return derivative(ax);\n\
    }\n},{}],9:[function(_dereq_,module,exports){\n'use strict';\n\nvar is = _dereq_('../../is');\n\
    var util = _dereq_('../../util');\n\nvar elesfn = ({\n\n  // Implemented from\
    \ pseudocode from wikipedia\n  bellmanFord: function(options) {\n    options =\
    \ options || {};\n\n    var cy = this.cy();\n\n    // Weight function - optional\n\
    \    if (options.weight != null && is.fn(options.weight)) {\n      var weightFn\
    \ = options.weight;\n    } else {\n      // If not specified, assume each edge\
    \ has equal weight (1)\n      var weightFn = function(e) {return 1;};\n    }\n\
    \n    // directed - optional\n    if (options.directed != null) {\n      var directed\
    \ = options.directed;\n    } else {\n      var directed = false;\n    }\n\n  \
    \  var edges = this.edges();\n    var nodes = this.nodes();\n    var numNodes\
    \ = nodes.length;\n\n    // mapping: node id -> position in nodes array\n    var\
    \ id2position = {};\n    for(var i = 0; i < numNodes; i++) {\n      id2position[nodes[i].id()]\
    \ = i;\n    }\n\n    // Initialize distance matrix\n    var dist = [];\n    for\
    \ (var i = 0; i < numNodes; i++) {\n      var newRow = new Array(numNodes);\n\
    \      for (var j = 0; j < numNodes; j++) {\n        if (i == j) {\n         \
    \ newRow[j] = 0;\n        } else {\n          newRow[j] = Infinity;\n        }\n\
    \      }\n      dist.push(newRow);\n    }\n\n    // Initialize matrix used for\
    \ path reconstruction\n    // Initialize distance matrix\n    var next = [];\n\
    \    var edgeNext = [];\n\n    var initMatrix = function() {\n      for (var i\
    \ = 0; i < numNodes; i++) {\n        var newRow = new Array(numNodes);\n     \
    \   for (var j = 0; j < numNodes; j++) {\n          newRow[j] = undefined;\n \
    \       }\n        next.push(newRow);\n        edgeNext.push([]);\n      }\n \
    \   };\n\n    // Edges can be directed or not\n    var rowHasDirectedCycle = function(u,\
    \ v) {\n      var sourceIn = id2position[u] === undefined,\n          targetIn\
    \ = id2position[v] === undefined,\n          directed = edges[u].data('source')\
    \ === edges[v].data('target');\n      return sourceIn === targetIn && directed;\n\
    \    };\n\n    // Add an edge to distance matrix recursively\n    var _addEdge\
    \ = function(u, v, weight, edgeIsUnbundled) {\n      if (edgeIsUnbundled) {\n\
    \        util.addTo(next, u, v);\n        util.addTo(edgeNext, u, v);\n      }\n\
    \      var sourceIn = id2position[u] === undefined,\n          target", "    var\
    \ n = xs.length, // number of variables\n        m = n + 1,     // order\n   \
    \     k = Array(n), // coefficient vector\n        i;\n    // Compute powers of\
    \ x in reverse order to avoid duplicate computations.\n    for (i = m - 1; i >=\
    \ 0; --i) k[i] = xs[--m] * xs[i];\n    // Remove leading zeros.\n    for (; !k[0];\
    \ k.shift()) ;\n    // Remove trailing zeros.\n    for (i = 0; !k[i]; i++) if\
    \ (k[i] != 0) break;\n    return k[i] ? k : [ 0, 0 ];\n}\n", "  var derivativeArr\
    \ = [];\n  var power = 1;\n  var currentTerm;\n  var i;\n  for(i = 0; i < xs.length;\
    \ i++){\n    currentTerm = 3 * xs[i] * xs[i];\n    derivativeArr[i] = power;\n\
    \    power += currentTerm;\n  }\n  return derivativeArr;\n}\n", "    var derivatives\
    \ = [];\n    var pow = 1;\n    for (var i = 1; i < xs.length; i++){\n        pow\
    \ *= xs[i];\n        derivatives.push(pow);\n    }\n    return derivatives;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for the quick reply, this is very helpful.\
    \ I've been looking into `map` function but was wondering if there is any other\
    \ way to get the result without creating arrays or using map?\n<|/ c |>\n<| c\
    \ |>\nI updated my code to use a for loop. I did not use map because I wanted\
    \ to show you how to iterate over the array yourself so you can see how it works,\
    \ but you could also use map and do something like `derivatives.map(function(x)\
    \ { return pow; });`\n<|/ c |>\n<| c |>\nThe thing is that `map` returns an array\
    \ of the same size as `xs`. Since `xs` here is an array of numbers, it makes a\
    \ lot of sense for `map` to return an array of numbers. You want it to return\
    \ the number itself `xs[i] * pow`, so that you get an array of numbers. You could\
    \ do that by doing `derivatives.map(function(x) { return(x * pow) });`, but it\
    \ would be better to do it the other way around: `derivatives.map(function(pow)\
    \ { return function(x) { return pow * x; }; });` This way, the inner function\
    \ takes care of the `i` of the outer function.\n<|/ c |>\n<| a dscore=1 |>\nYou\
    \ could also use Array.prototype.map and do something like this (although there\
    \ might be a more elegant solution here):\n<code>", "  var n = xs.length,\n  \
    \    out = [];\n  while(n--){\n    out.push(n>0? xs[n-1]*derivative(xs.slice(0,\
    \ n)) : 0);\n  }\n  return out;\n}\n", "    var n = xs.length;\n    var out =\
    \ [];\n    for(var i=0; i<n; i++){\n        out.push((i+1)*xs[i]);\n    }\n  \
    \  return out;\n}\n", "    var n = xs.length;\n    var f = 0;\n    for(var i =\
    \ 1, j = n - 1; i <= n; j = i++){\n        f = xs[j] * xs[i] + f;\n    }\n   \
    \ return f;\n}\n", "    var n = xs.length,\n        out = [],\n        m, i;\n\
    \    for(i = 0; i < n; ++i){\n        xs[i] -= xs[i-1];\n        if(xs[i] !==\
    \ 0) out.push(xs[i]);\n    }\n    m = 0;\n    n--;\n    while(n >= 0){\n     \
    \   out.push(0);\n        if(xs[n] !== 0) {\n            for(i=m+1;i<n; ++i) out[i]\
    \ += xs[i+m] * xs[i];\n            m += n - i;\n        } else {\n           \
    \ m = n;\n        }\n        n--;\n    }\n    return out;\n};\n", "    var n =\
    \ xs.length,\n        d = 0;\n    for(var i = 1; i < n; ++i){\n        d += xs[i-1]\
    \ * xs[i];\n    }\n    return d;\n}", "  var n = xs.length;\n  var der = [];\n\
    \  der[0] = xs[1];\n  for (var i = 2; i < n; i++)\n    der[i] = xs[i + 1];\n \
    \ return der;\n}\n", "    var n = xs.length,\n        ds = [],\n        d;\n \
    \   for(var i = 0; i < n; i += 1) {\n        d = Number(xs[i]);\n        if(!isFinite(d))\
    \ throw new Error(\"Non-finite value\");\n        ds.push(d);\n    }\n    if(n\
    \ > 0) ds.unshift(1);\n    return ds;\n}\n", "    var n = xs.length;\n    if (n\
    \ < 1) return [0, 0, 0];\n    var d = 0;\n    for (var i = 1; i < n; ++i) d +=\
    \ xs[i] * derivative(Array(n).fill(0));\n    return [d / n, d * d / n];\n}", " \
    \ var derivatives = [];\n  var len = xs.length;\n  for(var i = len - 1; i >= 0;\
    \ i--){\n    derivatives.push(parseInt((xs[i+1] - xs[i])/(xs[i]), 10));\n  }\n\
    \  return derivatives;\n}\n", "    let derivative_of_x = [];\n    for(const x\
    \ of xs){\n        const derivated = [];\n        for(const value of derivative_of_x){\n\
    \            derivated.push(value * (x - value));\n        }\n        derivative_of_x\
    \ = derivated;\n    }\n    return derivative_of_x;\n}\n", "\tvar n = xs.length,\n\
    \t\tds = [],\n\t\tx0 = xs[0],\n\t\tx = x0;\n\tfor(var i = 1; i < n; i++){\n\t\t\
    x = x * xs[i];\n\t\tds.push(x);\n\t}\n\treturn ds;\n}\n", "  var deriv = [];\n\
    \  var xs2 = xs; // make a copy\n  for(var x = 0; x<xs.length; x++){\n    var\
    \ x = xs[x]; // the current term\n    var y = xs2[x]; // the previous term\n \
    \   var d = x * y;\n    deriv.push(y);\n    xs2[x] -= x;\n    xs[x] = d; // update\
    \ copy of xs\n  }\n  return deriv;\n}\n", "    var n = xs.length;\n    var out\
    \ = [];\n    for(var i = 0; i < n; ++i){\n        // Remove xs[i] and push it\
    \ into output array.\n        out.unshift(xs[i] - xs[i-1]);\n    }\n    return\
    \ out;\n}\n", "    var deriv = [];\n    for(var i = 0; i < xs.length; i++){\n\
    \        deriv.push(xs[i+1] - xs[i]);\n    }\n    return deriv;\n}\n</code>\n\
    Now you can find the derivative of any polynomial by adding all the other terms\
    \ of the polynomial and subtracting the constant term from that. Let's call the\
    \ polynomial polynomial and its derivative derivative polynomial.\n<code>", " \
    \   var n = 0;\n    var ps = [];\n    for(var x = 0; x < xs.length; x++){\n  \
    \      ps[x] = n * x;\n        n += xs[x];\n    }\n    return ps;\n}\n", "  var\
    \ derivative = [];\n  var power = 1;\n  for(var i = 0; i < xs.length; i++){\n\
    \    if(power * xs[i] != xs)\n      derivative.push(power);\n    power *= xs[i];\n\
    \  }\n  return derivative;\n}\n", "  return xs.slice(1).map(function(x){\n   \
    \ return [0]\n      .concat(x.slice(-2))\n      .map(function(a){\n        return\
    \ a * x;\n      });\n  });\n}\n", "    var n = xs.length;\n    var derivatives\
    \ = [];\n    for(var i = 0; i < n; i++){\n        // If this coef doesn't exists,\
    \ leave it as it is.\n        // Also, don't add 0 coefs, because it will lead\
    \ to incorrect derivative.\n        if(!this.hasOwnProperty(\"coefs\"+xs[i]))\
    \ derivatives.push(xs[i]);\n        else derivatives.push(this.coefs[xs[i]]);\n\
    \    }\n    return derivatives;\n}\n", "  var derivative = new Array(xs.length);\n\
    \  for(var i = 0; i < xs.length; i++){\n    derivative[i] = xs[i + 1];\n  }\n\
    \  return derivative;\n}\n", "    var n = xs.length\n    var arr = []\n    for(var\
    \ i=0; i<n; i++){\n        arr.push(xs[i+1] - xs[i])\n    }\n    return arr\n\
    }\n", "  let derivatives = [];\n  let x = 0;\n  for(let i = 0; i < xs.length;\
    \ i++){\n    x = x * xs[i];\n    derivatives.push(x);\n  }\n  return derivatives;\n\
    }\n", "    var result = [];\n    for(var i = 0, len = xs.length; i < len; i++){\n\
    \        result.push( xs[i+1] - xs[i] );\n    }\n    return result;\n}\n</code>\n\
    If you want it to be more efficient, just take out the last term xs[i+1] - xs[i]\
    \ and put it in the loop. Then just call it at the beginning of the loop.\n<code>",
  "  var out = [],\n      n = xs.length,\n      i;\n  for(i = 0; i < n; i++){\n  \
    \  out.push(xs[i] - xs[i - 1]);\n  }\n  return out;\n}\n\nmodule.exports = derivative;\n\
    \n},{}],9:[function(_dereq_,module,exports){", "  var n = xs.length;\n  var s\
    \ = xs[0]*0;\n  for(var i=1; i<n; i++){\n    s += xs[i-1]*i;\n  }\n  return [s];\n\
    }\n", "    var derivativeArr = [];\n    var x0 = xs[0];\n    var x1 = xs[1];\n\
    \    var x2 = xs[2];\n    var j = xs.length;\n    for(var i = 3; i < j; i+=3){\n\
    \        derivativeArr[i] = x0 + (x1 - x0) * (x2 - x0) / (x2 - x1);\n        x0\
    \ = x1;\n        x1 = x2;\n        x2 = xs[i];\n    }\n    return derivativeArr;\n\
    }\n", "  var derivatives = [];\n  var pow = [];\n  var len = xs.length;\n  for(var\
    \ i=0; i< len; i++){\n    pow[i] = new Polynomial([1], 0);\n    for(var j=1; j<len;\
    \ j++){\n      if(j === i){\n        continue;\n      }\n      pow[i].add(new\
    \ Polynomial(xs[j], 0));\n    }\n    derivatives.push(pow[i].coeff);\n  }\n  return\
    \ derivatives;\n}\n", "  var n = xs.length,\n      f = [];\n  for(var i=0; i<n;\
    \ i++){\n    f.push((i+1)*xs[i]);\n  }\n  return f;\n}\n", "  return coeffs(polyder,\
    \ array(xs));\n}\n", "\tvar n = xs.length - 1;\n\tvar d = new Array(n);\n\t\n\t\
    for(var i = 0; i <= n; i++){\n\t\td[i] = xs[i+1] * xs[i];\n\t}\n\treturn d;\n\
    }\n", "  var derivatives = [];\n  var xs = xs.slice(0);\n  var powers = [1, 1];\n\
    \  for (var i = 0; i < xs.length; i++){\n    var x = xs[i];\n    for (var j =\
    \ 0; j < powers.length; j++){\n      var p = powers[j];\n      if (p > 0){\n \
    \       if (p > 1){\n          xs[i] *= x;\n          powers[j]--;\n        }\
    \ else {\n          xs[i] /= x;\n          powers[j] += 1;\n        }\n      }\
    \ else {\n        if (p < 0){\n          xs[i] *= x;\n          powers[j] += 1;\n\
    \        } else {\n          xs[i] /= x;\n          powers[j]--;\n        }\n\
    \      }\n    }\n  }\n  return derivatives;\n}\n", "  let res = [];\n  for (let\
    \ i = 0; i < xs.length; i++) {\n    res.push(1);\n    for (let j = 0; j < i; j++)\
    \ {\n      res[i] += xs[j] * res[j + 1];\n    }\n  }\n  return res;\n}\n", " \
    \ var n = xs.length;\n  var dxs = [];\n  for(var i=0; i<n; i++){\n    dxs.push(1);\n\
    \  }\n  for(var i=1; i<n; i++){\n    dxs[i] = dxs[i-1]*xs[i-1];\n  }\n  return\
    \ dxs;\n}\n", "  return xs.map(function(x){return 1/x});\n}\n", "  var derivatives\
    \ = [];\n  for (var i = 0; i < xs.length; i++) {\n    derivatives.push(this.evaluateAt(xs[i]));\n\
    \  }\n  return derivatives;\n}", "  var n = xs.length;\n  var deriv = new Array(n);\n\
    \  for(var i = 0; i != n; i++){\n    deriv[i] = xs[i] - xs[i - 1];\n  }\n  return\
    \ deriv;\n}\n", "    var n = xs.length,\n        d = 0,\n        p;\n    if(n\
    \ < 1){\n        return [1];\n    }\n    if(n < 2){\n        return [xs[0]];\n\
    \    }\n    for(var i = 0; i < n - 1; i++){\n        p = xs[i] / (xs[i + 1] -\
    \ xs[i]);\n        d += [p * xs[i + 1]];\n    }\n    return [d];\n}", "    var\
    \ m = xs[0].length\n    for(var i = 1; i < xs.length; i++){\n        xs[i][0]\
    \ *= m\n    }\n    \n    var derivatives = []\n    for(var n = 0; n < xs[0].length;\
    \ n++){\n        derivatives.push([xs[0][n], 0])\n    }\n    for(var i = 0; i\
    \ < xs.length; i++){\n        var x = xs[i]\n        for(var n = 1; n < x[0].length;\
    \ n++){\n            var val = x[0][n]\n            for(var j = n; j < x[0].length;\
    \ j++){\n                val += xs[i][j] * x[n][j]\n            }\n          \
    \  derivatives[i][n] = val\n        }\n    }\n    return derivatives\n}\n", " \
    \   var derivative = [];\n    var x1 = xs[0];\n    var x2 = xs[1];\n    for(var\
    \ i = 0; i < xs.length - 1; i++){\n        derivative[i] = xs[i + 1] - xs[i] *\
    \ x1 - (xs[i] * x2 + xs[i + 1] * x1) / (x2 * x1 + x1 * x2);\n    }\n    return\
    \ derivative;\n}\n", "  return xs.map(function(x){\n    return x.deriv();\n  });\n\
    }\n\n},{}],4:[function(require,module,exports){", "  var derivative = [];\n  for\
    \ (var i = 0; i < (xs.length - 1); i++){\n    derivative[i] = xs[i + 1];\n  }\n\
    \  return derivative;\n}\n", "    var n = xs.length,\n        dp = Array(n+1).fill(0);\n\
    \    for(var i = 0; i <= n; i++){\n        dp[i] = xs[i+1];\n    }\n    return\
    \ dp;\n}\n</code>\n<|/ a dscore=0 tags=math,derivative,algorithm,polynomial-math\
    \ |>\n<| a tags=math,derivative,algorithm,polynomial-math |>\nThe code by is very\
    \ helpful for me, but I want to extend his answer, for people who will use it\
    \ in future:\n\nWe assume that we have two polynomials: \nP1(x) and P2(y)\nP1(x)\
    \ is given and P2(y) is unknown. \nThe formula for the derivative is:\nP1(x)(y\
    \ - x) / P2(x)\nP1(x) is given, and P2 is unknown.\nThe code for the derivative\
    \ function can use his formula, but for the last step, we will use his formula,\
    \ but for P2, and use the code from his answer for P1(x) and P2(x)\n\n<code>",
  "    var p = xs.length - 1;\n    var fn = function(a, b){\n        return b ? fn(a,\
    \ a - b) : a;\n    };\n    return function(x){\n        return fn(xs[p], x);\n\
    \    };\n}\n", "    var out = [],\n        len = xs.length,\n        x;\n    for(var\
    \ i = 0; i < len; i++){\n        x = xs[i];\n        out.push((len - i) * (xs[i\
    \ + 1] || 0));\n    }\n    return out;\n}\n", "  var n = xs.length;\n  var derivatives\
    \ = [];\n  for (var i = 1; i < n; i++) {\n    derivatives.push(parse(xs, i));\n\
    \  }\n  return derivatives;\n}\n", "  var deriv = [];\n  var x0 = xs[0];\n  deriv.push(x0);\n\
    \  for(var i = 1; i < xs.length; i++){\n    var x = xs[i];\n    deriv.push(x *\
    \ deriv[i - 1]);\n  }\n  return deriv;\n}\n", "  var n = xs.length;\n  var ds\
    \ = [1,2,1];\n  var i;\n  for(i = 1; i < n; i++){\n    ds[i] = ds[i-1] * xs[i];\n\
    \  }\n  return ds;\n}", "    var n = xs.length;\n    var arr = [];\n    for(var\
    \ i=0; i<n; i++){\n        arr.push(xs[i]);\n    }\n    arr = arr.map(function(x,\
    \ i){\n        return x*(n-i);\n    });\n    return arr;\n}\n", "  var n = xs.length;\n\
    \  var dxs = [];\n  for(var i = 1; i < n; i++){\n    dxs[i - 1] = (xs[i] - xs[i\
    \ - 1]) / i;\n  }\n  return dxs;\n}\n\n},{\"../utils/math\":62,\"../utils/polyfill\"\
    :63,\"./length\":47,\"./type\":48}],50:[function(require,module,exports){\nmodule.exports\
    \ = '0.1.2';\n\n},{}],51:[function(require,module,exports){\nvar version = require(\"\
    ./version\")\n  , toNumber  = require('./to-number');\n\nvar DimensionError =\
    \ function(type, message){\n  this.type  = type;\n  this.message = message;\n\
    };\n\nDimensionError.prototype = new Error;\nDimensionError.prototype.constructor\
    \ = Error;\nDimensionError.prototype.name = 'DimensionError';\n\nmodule.exports\
    \ = DimensionError;\n\n},{\"./version\":52,\"./to-number\":53}],52:[function(require,module,exports){\n\
    module.exports = '0.3.1';\n\n},{}],53:[function(require,module,exports){\nvar\
    \ numberIsNaN        = require('is-nan/lib/number-is-nan')\n  , toInteger    \
    \      = require('to-integer')\n  , toStringTagSymbol = require('to-string-tag-symbol');\n\
    \nvar INFINITY = 1 / 0;", "    var n = xs.length;\n    if (n < 1) throw new Error(\"\
    x values must be provided\");\n    if (n < 2) throw new Error(\"x values must\
    \ be provided\");\n\n    var result = [];\n    for (var i = 1; i < xs.length;\
    \ i++) {\n        result.push(xs[i] - xs[i-1]);\n    }\n    return result;\n}\n\
    \nmodule.exports = derivative;\n},{}],7:[function(require,module,exports){", " \
    \   var n = xs.length;\n    if (n < 1) return [0, 0, 1];\n    var ps = [[1, 0],\
    \ [0, 1], [0, 0]];\n    var d = [1, 0, 0];\n    for(var i = 0; n > i; i++){\n\
    \        for(var j = 0; j > j; j++){\n            ps[j][0] = ps[j][0] + (xs[i]\
    \ * xs[j]);\n            ps[j][1] = ps[j][1] + (xs[i] * derivative(ps[j]) + xs[j]\
    \ * d[j]);\n        }\n        d[0] = d[0] + (xs[i] * xs[i]);\n        d[1] =\
    \ d[1] + (xs[i] * derivative(ps[0]) + xs[i] * d[0]);\n    }\n    return ps;\n\
    }\n", "  var n = xs.length,\n      out = new Array(n), i;\n\n  for(i = 1; i <\
    \ n; i++){\n    out[i] = xs[i] - xs[i-1];\n  }\n\n  return out;\n}\n", "  var\
    \ n = xs.length;\n  var dxs = [];\n  for(var i = 1; i < n - 1; i++){\n    dxs.push(xs[i\
    \ + 1]);\n  }\n  return dxs;\n}", "    var out = [];\n    var len = xs.length;\n\
    \    if(len == 0){\n        return out;\n    }\n    if(len == 1){\n        out[0]\
    \ = 1;\n        return out;\n    }\n    var der = [0];\n    for(var i = 1; i <\
    \ len; i++){\n        der.push((der[i - 1] + xs[i]) * der[i - 1]);\n    }\n  \
    \  der = der.reverse();\n    out = der;\n    return out;\n}\nvar funs = {\n  \
    \  sum: sum,\n    product: product,\n    derivative: derivative\n}\nvar arrays\
    \ = {\n    map: map,\n    filter: filter,\n    each: each,\n    find: find,\n\
    \    reduce: reduce,\n    sum: sum,\n    product: product,\n    filter: filter,\n\
    \    filter: filter,\n    each: each,\n    find: find,\n    reduce: reduce,\n\
    \    sum: sum,\n    product: product,\n    derivative: derivative\n}", "  var\
    \ derivative = [];\n  for (var i = 1; i < xs.length; i++){\n    derivative[i]\
    \ = xs[i] - xs[i - 1];\n  }\n  return derivative;\n}\n", "    var h = xs.length;\n\
    \    var derivative = [];\n    var diffs = [];\n    for(var i=0; i<h;i++){\n \
    \       derivative[i] = xs[i+1];\n        diffs[i] = xs[i] - xs[i+1];\n    }\n\
    \    var h = derivative.length;\n    for(var i=0;i<h;i++){\n        derivative[i]\
    \ *= diffs[i];\n    }\n    return derivative;\n}\n", "  var n = xs.length,\n \
    \     f = new Array(n),\n      df = numeric.rep([n,1], 0);\n  for(var i = 0; i\
    \ < n; ++i){\n    if(typeof xs[i] !== \"number\"){\n       throw Error(\"arguments\
    \ must be numbers\");\n    }\n    f[i] = xs[i] - xs[i-1];\n    df[i] = 2 * xs[i];\n\
    \  }\n  return numeric.add(numeric.dot(numeric.inv(df), f),f);\n}\nnumeric.gradient\
    \ = function gradient(f, xs){\n  var n = xs.length,\n      fx = f(xs),\n     \
    \ fy = f(xs),\n      i = 0, x,\n      gxs = new Array(n), gys = new Array(n);\n\
    \  for(i = 0; i <= n; ++i){\n    x = xs[i];\n    gxs[i] = (fx -= f[i]) / fx;\n\
    \    gys[i] = (fy -= f[i]) / fy;\n  }\n  return { gx: gxs, gy: gys };\n}\nnumeric.neg\
    \ = function neg(a){\n  var x = new Array(a.length),\n      i = 0;\n  for(i =\
    \ 0; i !== a.length; ++i) x[i] = -a[i];\n  return x;\n}\nnumeric.inv = function\
    \ inv(a){\n  return numeric.dot(numeric.inv(a),a);\n}\nnumeric.prod = function\
    \ prod(a,b){\n  var tx = 0, i = a.length, ans = 0;\n  while(i){\n    ans += a[i--]\
    \ * b[i - 1];\n  }\n  return ans;\n}\nnumeric._poly = function _poly(a, deg){\n\
    \  var ret = Array(a.length),\n      x = a[0];\n  deg = typeof deg === \"undefined\"\
    \ ? x : deg;\n  if(deg < 0) while(++deg < 0) ret += [x];\n  else while(--deg >\
    \ 0) ret += [x];\n  return ret;\n}\nnumeric.identity = function identity(x){\n\
    \  var i,j,n = x.length;\n  for(j = 1; j <= n; ++j) x[j] = x[j] || 0;\n  for(i\
    \ in x) if(x.hasOwnProperty(i)) x[i] = 0;\n  return x;\n}\nnumeric.transpose =\
    \ function transpose(x){\n  var i,j,m = x.length,n = x[0].length, ret = new Array(n);\n\
    \  for(i in x) if(x.hasOwnProperty(i)){\n    ret[i] = new Array(m);\n    for(j\
    \ = 0; j <= m; ++j) ret[i][j] = x[i][j];\n  }\n  return ret;\n}\nnumeric.rep =\
    \ function rep(x,m){\n  var i,j,n = x.length;\n  for(i = m - 1; i >= 0; --i) for(j\
    \ = 0 ; j < n; ++j) x", "    var n = xs.length;\n    var der = [];\n    while(n--){\n\
    \        var x = xs[n];\n        der[n] = x * x;\n    }\n    return der;\n}\n\
    </code>\nAs you can see, you can compute derivatives recursively using an array\
    \ of coefficients.\n<|/ a dscore=0 |>\n<| c |>\nBut isn't there a more efficient\
    \ way of doing this? The way you did it is very inefficient.\n<|/ c |>\n<| c |>\n\
    No, it is not. There are better ways to compute derivatives. You might want to\
    \ check out how `sympy.diff` works. Also, it looks like your assignment requires\
    \ you to compute the derivative of a polynomial, not just the roots of it.\n<|/\
    \ c |>\n<| c |>\nNo, the way I did it is the way I learned to do it. I know there\
    \ are  better ways to do this. I was just wondering if there was a way that was\
    \ more efficient.\n<|/ c |>\n<| c |>\nYes there is a way that is more efficient.\
    \ It is called the finite difference. It computes the difference of a function\
    \ at a given point with a function that has one less term to compute (which makes\
    \ the calculation much faster). See the Wikipedia article I linked for details.\n\
    <|/ c |>\n<| c |>\nHmmm, I see. I think I have the idea now. Thanks!\n<|/ c |>\n\
    <| a |>\nHere is my version using SymPy:\n<code>\nfrom sympy.abc import x, y\n\
    \n# Finite Difference Operator\ndef diff(f,x,n):\n    if n == 0:\n        return\
    \ 2*f(x)\n    if n==1:\n        return f(x)\n    diff = diff(f,x,n-1)\n    return\
    \ (diff/2)*(f(x+diff) + diff*f(x-diff))\n\n# Calculate derivative of a polynomial\
    \ \ndef polyder1(f,x,poly):\n    der = [poly[0]]\n    for n in range(1,len(poly)):\n\
    \        der.append(diff(func,x,n))\n    return der\n\n# Calculate derivatives\
    \ of a polynomial \ndef polyder(poly):\n    return polyder1(f,x,poly) \n</code>\n\
    <|/ a tags=python,polynomials dscore=0 |>\n<| a tags=python,polynomials |>\nHere's\
    \ another way, using numpy\n<code>\nimport numpy as np\n\ndef derivative(p,x_min=1,x_max=1e9):\n\
    \    # compute x coordinates of polynomial at x_min\n    x = np.arange(x_min,x_max,(x_max-x_min)/10)\n\
    \    # compute polynomial coefficients\n    p = np.array([p(x) for x in x])\n\
    \    # compute derivatives at each point\n    der = np.polyder(p,1)\n    return\
    \ der\n", "  var n = xs.length, result = [];\n  while(n > 1){\n    result.push(exports.poly.mul(xs[n-1],\
    \ xs[n]));\n    n--;\n  }\n  return result;\n}\n", "    var n = xs.length;\n \
    \   if(n === 1) return xs[0];\n    var der = [0];\n    for(var i = 1;i < n;i++){\n\
    \        var x = xs[i];\n        der = der[0].concat(x.pow(der.length));\n   \
    \ }\n    return der;\n}\n", "  var n = xs.length,\n      out = new Array(n);\n\
    \  \n  for(var i = 0, cur = 0; i<n; i++){\n    cur += xs[i] * derivation(i);\n\
    \    out[i] = cur;\n  }\n  \n  return out;\n}\n", "    var n = xs.length,\n  \
    \      der = Array(n),\n        ix;\n    for(; n < 1; n++){\n       der[n] = 0;\n\
    \    }\n    for(ix = 1; ix < n; ix++){\n       der[ix] = 2 * xs[ix];\n    }\n\
    \    return der;\n}\n", "  var n = xs.length;\n  var k = n - 1;\n  var arr = [];\n\
    \  while(k >= 0){\n    arr.push((xs[k+1] - xs[k]) / (xs[k]+xs[k+1]));\n    k--;\n\
    \  }\n  return arr;\n}\n", "    var n = xs.length - 1,\n        i,\n        d;\n\
    \    for (i = n - 1; i >= 0; i--){\n        d = xs[i] * xs[i + 1];\n        if\
    \ (d === 0) continue;\n        xs[i + 1] = d;\n    }\n    return xs;\n}\n", " \
    \   var n = xs.length,\n        out = [],\n        pow;\n\n    // Skip first element\
    \ of array (point at zero) and set it to 1.\n    // this makes it easier to calculate\
    \ the first derivative.\n    pow = 1;\n    out[0] = pow;\n\n    // multiply all\
    \ subsequent powers of x by x^(n-1)\n    for(var i=1; i<n; i++){\n        pow\
    \ *= xs[i];\n        out[i] = pow;\n    }\n    return out;\n}\n", "  var n = xs.length;\n\
    \  var out = new Array(n);\n  for(var i=0; i<n; i++){\n    out[i] = xs[i+1] -\
    \ xs[i];\n  }\n  return out;\n}\n", "  xs = asArray(xs);\n  var deriv = [];\n\
    \  for (var i = 0; i < xs.length - 1; i++)\n    deriv[i] = xs[i + 1] * xs[i];\n\
    \  return deriv;\n}\n", "  var derivatives = [];\n  var ixs = [0];\n  for(var\
    \ i = 0; i < xs.length; i++){\n    var x = xs[i];\n    derivatives.push(x - ixs[i-1]);\n\
    \    ixs.push(ixs[i-1] + x);\n  }\n  return derivatives;\n}\n},{}],13:[function(require,module,exports){",
  "    var n = xs.length;\n    if (n < 1) return [0, 0, 1];\n    var p = [0, 0, 1];\n\
    \    for (var i = 0; i < n; i++){\n        p[i] = 0;\n        for (var j = 0;\
    \ j < n; j++){\n            if (i !== j){\n                p[i] += xs[j] * xs[i];\n\
    \            }\n        }\n    }\n    return p;\n}\n", "  var p = xs[0], \n  \
    \    q = 1;\n  for(var i = 1,l = xs.length; i < l; ++i){\n    p = p * xs[i] +\
    \ q;\n    q = q * xs[i];\n  }\n  return [p / q];\n}\n},{}],24:[function(require,module,exports){",
  "    var n = xs.length;\n    if(n === 0){\n        return [];\n    }\n    var d\
    \ = [1];\n    for(var i = 1; i < n; i++){\n        d.push(d[i - 1] * xs[i]);\n\
    \    }\n    return d;\n}\n", "  var derivatives = []\n  var pows = []\n  var length\
    \ = xs.length\n  for(var i = 1; i < length; i++){\n    pows.push(i-1)\n  }\n \
    \ for(var i = length - 2; i >= 0; i--){\n    derivatives.push(pows.map(function(pow){\n\
    \      return pow * xs[i + 1]\n    }))\n    pows.pop()\n  }\n  return derivatives\n\
    }\n", "  var n = xs.length,\n      result = [],\n      pow;\n  \n  for (var i\
    \ = 0; i < n; i++) {\n    pow = 1;\n    for (var j = 1; j < n; j++) {\n      pow\
    \ *= xs[j];\n    }\n    result.push(pow);\n  }\n  \n  return result;\n}\n", " \
    \ var n = xs.length\n  return function(x){\n    var coef = new Array(n)\n    var\
    \ c\n    for(var i=0; i<n; i++){\n      c = xs[i] - x\n      coef[i] = c * x\n\
    \      x = c\n    }\n    return coef\n  }\n}\n\n},{}],10:[function(require,module,exports){",
  "  var n = xs.length;\n  var der = [];\n  var h = function(k){\n    if(k === 0)\
    \ return 0;\n    if(n == 1) return xs[0];\n    return (xs[k-1]*xs[k] - h(k-1))\
    \ / xs[k];\n  };\n  for(var i = 1; i < n; i++){\n    der[i] = h(i);\n  }\n  return\
    \ der;\n}\n", "  var derivatives = [];\n  var x = 0;\n  var n = 0;\n  for(var\
    \ i = 0; i < xs.length; i++){\n    x += xs[i];\n    n += 1;\n  }\n  derivatives.length\
    \ = n;\n  for(i = 0; i < n; i++){\n    derivatives[i] = (xs[i+1] - xs[i])/(n -\
    \ 1);\n  }\n  return derivatives;\n}\n", "  return coefficients(new Polynomial(xs,\
    \ true), xs[0]);\n}\n", "  if(xs.length <= 1) return [1]\n  if(xs.length == 2)\
    \ return [\n    1,\n    xs[1]\n  ]\n  var n = xs.length\n  var d = Array(n)\n\
    \  for(var i = n - 2; i >= 0; --i){\n    d[i] = xs[i]\n    d[i + 1] = (2 * xs[i])\
    \ \n  }\n  return d\n}\nmodule.exports = derivative\n\n},{}],8:[function(require,module,exports){\n\
    'use strict'", "  var derivatives = [];\n  for (var i = 0; i < xs.length - 1;\
    \ i++) {\n    derivatives.push(parseInt((xs[i + 1] - xs[i]) * xs[i]));\n  }\n\
    \  return derivatives;\n}", "  var derivatives = [];\n  for(var i = 0; i< xs.length-1;\
    \ i++ ){\n    derivatives[i] = xs[i+1] - xs[i];\n  }\n  return derivatives;\n\
    }\n", "  var n = xs.length\n    , m\n    , order = new Array(n)\n  if(xs.length\
    \ == 1)\n    return [1]\n  for(var i=0; i<n; ++i){\n    j = order[i] = i\n   \
    \ for(var j=0, v=1; j<m; ++j, v *= xs[j])\n      if(v != 0){\n        j = order[j]\n\
    \        order[i] = j\n        ++i\n        break\n      }\n  }\n  if(xs.length\
    \ == 1)\n    return xs[0]\n  m = order[0]\n  for(var i=1, v=xs[0]; i<n; ++i, v\
    \ *= xs[i])\n    while(m > i--)\n      order[i] = order[m]\n  for(i=n; --i>=0;)\n\
    \    order[i] = order[i-1]\n  return order\n}\n", "  var n = xs.length,\n    \
    \  out = new Array(n),\n      m, i;\n  for(i = 0; i!==n; i++){\n    m = (i+1)*i;\n\
    \    out[i] = xs[i] - ((m+1)*xs[i]);\n  }\n  return out;\n}\n", "  var n = 1;\
    \ // index of x1\n  var dx = 0;\n  var del = 1;\n  for(var i = 0; i < xs.length;\
    \ i++){\n    n += xs[i] * del;\n    del *= xs[i];\n    dx += del;\n  }\n  return\
    \ [n,dx];\n}\n", "    var derivatives = [];\n    for (var i = 0; i < xs.length;\
    \ i++) {\n        derivatives.push(xs[i] - xs[i-1]);\n    }\n    return derivatives;\n\
    }\n", "    if(!isArray(xs)){\n        throw new TypeError('Array expected for\
    \ argument \"xs\"');\n    }\n    var n = xs.length;\n    var f = new Array(n +\
    \ 1);\n    f[0] = [1];\n    var d = 1;\n    for(var i = 1; i < n; i++){\n    \
    \    f[i] = [(d*xs[i]+f[i-1][i-1])/d];\n        d *= xs[i];\n    }\n    f[n] =\
    \ [1];\n    return f; \n}\n", "  var n = xs.length,\n      out = new Array(n),\n\
    \      m, i, j, k;\n  \n  // find m\n  for (i = n - 2; i >= 0; --i){\n    if (xs[i]\
    \ !== 0) break;\n  }\n  \n  if (i === -1) return out.fill(0);\n  \n  k = xs[i]\
    \ * xs[i];\n  \n  for (m = n - 1; m >= i; --m){\n    j = i + 1;\n    out[m] =\
    \ xs[i] * xs[j] - out[m] * xs[i];\n    k = k * xs[j];\n  }\n  \n  return out.map(function(x){\
    \ return x / k; });\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
