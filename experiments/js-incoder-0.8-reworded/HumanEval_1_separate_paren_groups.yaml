name: HumanEval_1_separate_paren_groups
language: js
prompt: "//Input to this function is a string containing multiple groups of nested\
  \ parentheses. Your goal is to\n// separate those group into separate strings and\
  \ return the array of those.\n// Separate groups are balanced (each open brace is\
  \ properly closed) and not nested within each other\n// Ignore any spaces in the\
  \ input string.\n// >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n// [\"()\"\
  , \"(())\", \"(()())\"]\nfunction separate_paren_groups(paren_string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = separate_paren_groups;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"\
  ),[\"(()())\", \"((()))\", \"()\", \"((())()())\"]);\n  assert.deepEqual(candidate(\"\
  () (()) ((())) (((())))\"),[\"()\", \"(())\", \"((()))\", \"(((())))\"]);\n  assert.deepEqual(candidate(\"\
  (()(())((())))\"),[\"(()(())((())))\"]);\n  assert.deepEqual(candidate(\"( ) ((\
  \ )) (( )( ))\"),[\"()\", \"(())\", \"(()())\"]);\n}\n\ntest();"
completions: ["    var brace_array = []; //create array to hold results\n    var prev_open_brace\
    \ = -1;\n    var open_brace_stack = []; //create stack\n    var is_first_bracket\
    \ = false; //flag to indicate if we are currently at the beginning of a group\n\
    \    var is_last_bracket = false; //flag to indicate if we are at the end of a\
    \ group\n    var index = 0; //current index of the string we are working on\n\
    \    var is_open_brace_last_char = false; //flag to indicate if we are currently\
    \ in an open brace that was not closed yet\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === \"(\"){\n            //if we are currently\
    \ not at the beginning of a group...\n            if(is_first_bracket === false){\n\
    \                is_first_bracket = true;\n            }\n            if(is_open_brace_last_char\
    \ === false){\n                is_open_brace_last_char = true;\n            }\n\
    \            if(is_open_brace_last_char === true){\n                is_open_brace_last_char\
    \ = false;\n                open_brace_stack.push(i);\n            }\n       \
    \ }\n        else if(paren_string[i] === \")\"){\n            //if we are currently\
    \ not at the end of a group...\n            if(is_last_bracket === false){\n \
    \               is_last_bracket = true;\n            }\n            \n       \
    \     //if we have reached an open brace that was not closed yet, add the index\n\
    \            if(open_brace_stack.length > 0){\n                index = open_brace_stack.pop();\n\
    \                brace_array.push(paren_string.slice(index, i));\n           \
    \ }\n        }\n        //if we are currently in an open brace, close it\n   \
    \     else if(paren_string[i] === \"{\"){\n            if(!is_last_bracket){\n\
    \                is_last_bracket = true;\n            }\n        }\n        else\
    \ if(paren_string[i] === \"}\"){\n            //if we are currently not at the\
    \ end of a group...\n            if(is_last_bracket === false){\n            \
    \    is_last_bracket = true;\n            }\n            if(open_brace_stack.length\
    \ > 0){\n                index = open_brace_stack.pop();\n                brace_array.push(paren_string.slice(index,\
    \ i));\n            }\n            else if(is_open_brace_last_char){\n       \
    \         is_open_brace_last_char = false;\n                open_brace_stack.push(i);\n\
    \            }\n        }\n        //if we are currently not at the beginning\
    \ of a group...\n        else{\n            is_first_bracket = false;\n      \
    \  }\n    }\n    return brace_array;\n}\n", "\tlet output = []\n\n\tlet current_group\
    \ = []\n\tlet open_brace_count = 0\n\tlet close_brace_count = 0\n\tlet current_paren_level\
    \ = 0\n\n\tfor(const char of paren_string){\n\t\tif(char === '('){\n\t\t\topen_brace_count++\n\
    \t\t\tcurrent_group.push(char)\n\t\t}else if(char === ')'){\n\t\t\tclose_brace_count++\n\
    \t\t\topen_brace_count--\n\t\t\tcurrent_group.push(char)\n\t\t}\n\t\tif(open_brace_count\
    \ === 0 && close_brace_count === 0){\n\t\t\toutput.push(current_group.join(''))\n\
    \t\t\tcurrent_group = []\n\t\t\tcurrent_paren_level++\n\t\t}\n\t\tcurrent_group.push(char)\n\
    \t}\n\n\tif(current_group.join('') !== '') output.push(current_group.join(''))\n\
    \t\n\treturn output\n}\n", "    //Split the input string into an array of strings\
    \ using regular expressions\n    //This regex is designed to separate multiple\
    \ groups of parentheses within a single parenthesis group.\n    //This regex uses\
    \ look-ahead to determine which parenthesis groups the current parenthesis belongs\
    \ to.\n    var paren_regex = /(\\()(?=(([^()]*+|(\\([^()]*\\))*+))*\\))/ig;\n\
    \    //We use the function exec() to search through the array returned by paren_regex\n\
    \    //When a match is found we push the current parenthesis group into a new\
    \ array called groups and remove the match.\n    //The end result is that the\
    \ resulting groups array will be an array of strings which can be used for further\
    \ processing.\n    var groups = [];\n    paren_string.split(paren_regex).forEach(function(match,\
    \ index){\n        if (index === 0) {\n            //This first match contains\
    \ the entire parenthesis group, so add it to the groups array\n            groups.push(match);\n\
    \        } else {\n            //This match does not belong to a parenthesis group,\
    \ so remove it from the groups array\n            groups.shift();\n        }\n\
    \    });\n    return groups;\n}\n", "  var paren_groups = [];\n  var open_brace\
    \ = false;\n  var paren_string_index = 0;\n\n  while(paren_string_index < paren_string.length){\n\
    \    if(paren_string[paren_string_index] === '('){\n      if(open_brace === false){\n\
    \        paren_groups[paren_groups.length] = paren_string.substring(paren_string_index,\
    \ paren_string_index + 1).replace(/[\\(\\)]/g, \"\");\n        paren_string_index\
    \ = paren_string_index + 1;\n      }\n      else{\n        paren_groups[paren_groups.length\
    \ - 1] += paren_string.substring(paren_string_index, paren_string_index + 1).replace(/[\\\
    (\\)]/g, \"\");\n        paren_string_index = paren_string_index + 1;\n      }\n\
    \      open_brace = true;\n    }\n    else{\n      if(open_brace === true){\n\
    \        paren_groups[paren_groups.length - 1] += paren_string.substring(paren_string_index,\
    \ paren_string_index + 1).replace(/[\\(\\)]/g, \"\");\n        paren_string_index\
    \ = paren_string_index + 1;\n      }\n      else{\n        open_brace = false;\n\
    \      }\n    }\n  }\n\n  return paren_groups;\n}\n", "    var re_exp = /\\(|\\\
    )|\\[|\\]|{|}|\\(|\\)|:|\\|/; //regex to extract any nested brackets\n    var\
    \ matches = paren_string.match(re_exp);\n    var group_array_output = [];\n  \
    \  if(matches === null){ //if the input string contains no nested parens, return\
    \ it as it is\n        return paren_string;\n    }\n    for(var i = 0; i < matches.length;\
    \ i++){ //loop through all the matches\n        var match_text = matches[i]; //get\
    \ the match text\n        if(match_text === \"(\"){ //if the match is \"(\"\n\
    \            group_array_output.push(\"(\");\n        }\n        else if(match_text\
    \ === \")\"){ //if the match is \")\"\n            group_array_output.pop(); //remove\
    \ the matching \")\"\n        }\n        else if(match_text === \"[\"){ //if the\
    \ match is \"[\"\n            group_array_output.push(\"[\");\n        }\n   \
    \     else if(match_text === \"]\"){ //if the match is \"]\"\n            group_array_output.pop();\
    \ //remove the matching \"]\"\n        }\n        else if(match_text === \"{\"\
    ){ //if the match is \"{\"\n            group_array_output.push(\"{\");\n    \
    \    }\n        else if(match_text === \"}\"){ //if the match is \"}\"\n     \
    \       group_array_output.pop(); //remove the matching \"}\"\n        }\n   \
    \     else if(match_text === \":\"){ //if the match is \":\"\n            group_array_output.push(\"\
    :\");\n        }\n        else if(match_text === \"|\"){ //if the match is \"\
    |\"\n            group_array_output.push(\"|\");\n        }\n    }\n    return\
    \ group_array_output; //return the resulting array of the matches\n}", "  let\
    \ stack = [];\n  let return_array = [];\n  for(let i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] === '('){\n      stack.push(i);\n    }else if(paren_string[i]\
    \ === ')'){\n      while(stack.length && paren_string[stack.pop()] !== '('){\n\
    \      }\n      if(!stack.length){\n        return_array.push(paren_string.slice(i));\n\
    \      }\n    }\n  }\n  return return_array;\n}\n", "\t// initialize empty arrays\n\
    \tvar array_of_groups = [],\n\t\tnested_groups = [],\n\t\topen_braces = [],\n\t\
    \tclosed_parens = [],\n\t\topen_brace_groups = [],\n\t\tclosed_paren_groups =\
    \ [],\n\t\topen_brace_count = 0,\n\t\tclosed_paren_count = 0;\n\t\n\t// loop through\
    \ all parens\n\tfor(let index = 0; index < paren_string.length; index++){\n\t\t\
    \n\t\t// if an open brace is found\n\t\tif(paren_string[index] == '('){\n\t\t\t\
    open_braces.push(index + 1);\n\t\t\topen_brace_count++;\n\t\t}\n\t\t\n\t\t// if\
    \ an close brace is found\n\t\tif(paren_string[index] == ')'){\n\t\t\tclosed_parens.push(index\
    \ + 1);\n\t\t\tclosed_paren_count++;\n\t\t\t\n\t\t\t// if the current open brace\
    \ group is empty\n\t\t\tif(open_brace_groups[open_brace_count] === undefined){\n\
    \t\t\t\topen_brace_groups[open_brace_count] = [];\n\t\t\t}\n\t\t\t// if the current\
    \ open brace group is not empty and the current close brace group is not empty\n\
    \t\t\tif(open_brace_groups[open_brace_count].length > 0 && closed_paren_count\
    \ > 0){\n\t\t\t\tif(closed_paren_groups[closed_paren_count].length > 0){\n\t\t\
    \t\t\tnested_groups.push(open_brace_groups[open_brace_count].concat(closed_paren_groups[closed_paren_count]));\n\
    \t\t\t\t}\n\t\t\t\tclosed_paren_groups[closed_paren_count] = [];\n\t\t\t}\n\t\t\
    \topen_brace_count--;\n\t\t}\n\t}\n\t\n\t// if any nested groups are found, return\
    \ the nested groups\n\tif(nested_groups.length > 0){\n\t\treturn nested_groups;\n\
    \t}\n\t\n\t// if no nested groups are found, return the array of all parens\n\t\
    return paren_string;\n}\n", "    // If there's no input, we just return an empty\
    \ array to avoid errors\n    if (!paren_string){\n        return [];\n    }\n\
    \    // Split into an array of individual characters\n    var paren_string = paren_string.split(\"\
    \");\n    // Start with the first character in the array to be checked\n    var\
    \ current_char = paren_string[0];\n    // Set a variable to keep track of whether\
    \ the current group has any characters before it\n    var has_chars_before_this_group\
    \ = false;\n    // Initialize a variable to be the array containing the next group\
    \ of characters\n    var next_group = [];\n    // Iterate through the array backwards\n\
    \    for (var i = paren_string.length - 1; i >= 0; i--){\n        // If the current\
    \ character is opening, then push it to the next group\n        if (current_char\
    \ === \"(\"){\n            next_group.push(paren_string[i]);\n            // If\
    \ the next group has characters, add it to the array\n            if (next_group.length){\n\
    \                has_chars_before_this_group = true;\n            } else {\n \
    \               // Otherwise, add the character to the array\n               \
    \ next_group = [paren_string[i]];\n            }\n        // Otherwise, if the\
    \ current character is closing, close the current group\n        } else if (current_char\
    \ === \")\"){\n            // If the next group is empty, then add it to the array\n\
    \            if (next_group.length){\n                // If there aren't any characters\
    \ after the opening parenthesis, add an empty string\n                if (!has_chars_before_this_group){\n\
    \                    next_group.push(\"\");\n                }\n            }\
    \ else {\n                // Otherwise, add an empty string\n                next_group\
    \ = [\"\"];\n            }\n            // If there are characters after this\
    \ group (which means there is an opening parenthesis after the last closing parenthesis)\n\
    \            // then add it to the array\n            if (has_chars_before_this_group){\n\
    \                next_group.push(paren_string[i]);\n            }\n          \
    \  // Otherwise, add it to the array\n            else {\n                next_group\
    \ = [paren_string[i]];\n            }\n            // If the next group has characters,\
    \ add it to the array\n            if (next_group.length){\n                has_chars_before_this_group\
    \ = true;\n            } else {\n                // Otherwise, add the character\
    \ to the array\n                next_group = [paren_string[i]];\n            }\n\
    \        // If the current character is neither opening or closing, add the character\
    \ to the array\n        } else {\n            next_group = [paren_string[i]];\n\
    \        }\n        // Reset the current character for the next iteration\n  \
    \      current_char = next_group[0];\n    }\n    // Return the array of characters\
    \ to the caller\n    return next_group;\n}\n", "\tvar paren_groups = paren_string.match(/[\\\
    (\\)]+/g);\n\tvar paren_group_str = [];\n\tfor(var i=0;i<paren_groups.length;i++){\n\
    \t\tvar current_group = paren_groups[i];\n\t\tif(current_group.length > 0 && current_group[0]\
    \ == \"(\" && current_group[current_group.length-1] == \")\"){\n\t\t\tvar next_group\
    \ = paren_string.substring(current_group.length,paren_string.length);\n\t\t\t\
    var next_group_str = separate_paren_groups(next_group);\n\t\t\tif(next_group_str.length\
    \ > 0){\n\t\t\t\tnext_group_str = next_group_str.join(\" \");\n\t\t\t\tnext_group_str\
    \ = next_group_str.trim();\n\t\t\t\tparen_group_str.push(next_group_str);\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn paren_group_str;\n}\n", "  var open_brackets_regexp\
    \ = /\\(/g;\n  var close_brackets_regexp = /\\)/g;\n  var results = [];\n  var\
    \ groups = [];\n  var match = paren_string.match(open_brackets_regexp);\n  while\
    \ (match != null) {\n    groups.push(match);\n    match = paren_string.match(open_brackets_regexp);\n\
    \  }\n  for (var i = 0, len = groups.length; i < len; i++) {\n    match = groups[i];\n\
    \    if (match !== '') {\n      results.push(match);\n    }\n  }\n  match = paren_string.match(close_brackets_regexp);\n\
    \  while (match != null) {\n    if (match !== '') {\n      results.push(match);\n\
    \    }\n    match = paren_string.match(close_brackets_regexp);\n  }\n  return\
    \ results;\n}\n", "    var arr = [];\n    var group_open = 0;\n    var group_close\
    \ = 0;\n    var in_group = false;\n    var open_paren_counter = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        var cur_char = paren_string[i];\n\
    \        if(cur_char == \" \" || cur_char == \"\\t\"){\n            continue;\n\
    \        }\n        else if(cur_char == \"(\" && !in_group){\n            group_open++;\n\
    \            in_group = true;\n        }\n        else if(cur_char == \")\" &&\
    \ !in_group){\n            group_close++;\n            in_group = false;\n   \
    \     }\n        else if(cur_char == \"(\" && in_group){\n            group_open--;\n\
    \        }\n        else if(cur_char == \")\" && in_group){\n            group_close--;\n\
    \        }\n        else if(cur_char == \"(\" && !in_group && open_paren_counter\
    \ > 0){\n            open_paren_counter++;\n        }\n        else if(cur_char\
    \ == \")\" && !in_group && group_close == 0){\n            arr.push(paren_string.slice(0,i));\n\
    \            break;\n        }\n        else if(cur_char == \")\" && in_group\
    \ && open_paren_counter > 0){\n            arr.push(paren_string.slice(0,i));\n\
    \            break;\n        }\n        else if(cur_char == \"(\" && in_group\
    \ && open_paren_counter > 0){\n            arr.push(paren_string.slice(0,i));\n\
    \            break;\n        }\n    }\n    return arr;\n}\n", "    var paren_strings\
    \ = paren_string.split(\"(\");\n    var paren_strings_string = \"\";\n    var\
    \ paren_strings_string2 = \"\";\n    for (var i = 0; i < paren_strings.length\
    \ - 1; i++) {\n        paren_strings_string += paren_strings[i] + \")\";\n   \
    \ }\n    paren_strings_string += paren_strings[paren_strings.length - 1];\n  \
    \  paren_strings_string2 = paren_strings_string.substr(0, paren_strings_string.length\
    \ - 1)\n    return paren_strings_string2.split(\" \");\n}\n", "  if(!paren_string){\n\
    \    return [\"\"];\n  }\n  \n  var current_pos = 0;\n  var current_paren_depth\
    \ = 0;\n  var groups = [];\n  var current_group = [];\n  var paren_string = paren_string.toString();\n\
    \  \n  for(var i=0;i<paren_string.length;i++){\n    var c = paren_string[i];\n\
    \    if(c==\"(\"){\n      current_paren_depth += 1;\n      current_group.push(c);\n\
    \    }else if(c==\")\"){\n      current_paren_depth -= 1;\n      if(current_paren_depth==0){\n\
    \        current_group.push(current_group.join(\"\"));\n        groups.push(current_group);\n\
    \        current_group = [];\n      }\n    }else{\n      if(current_paren_depth==0){\n\
    \        current_group.push(c);\n      }\n    }\n  }\n  if(current_paren_depth!=0){\n\
    \    current_group.push(current_group.join(\"\"));\n    groups.push(current_group);\n\
    \  }\n  return groups;\n}\n", "  var opening_paren_stack = []\n  var opening_brace_counter\
    \ = 0\n  var groups = []\n  var input_array = [paren_string]\n  var in_string\
    \ = false\n  \n  input_array.forEach(function(element, index, array){\n    if(element\
    \ === '(' || element == ')'){\n      opening_paren_stack.push(element)\n    }\n\
    \    else if(element === '{' || element === '}'){\n      opening_brace_counter++\n\
    \    }\n    else if(opening_brace_counter > 0 && element === ')'){\n      opening_brace_counter--\n\
    \    }\n    if(element === '{'){\n      opening_brace_counter++\n    }\n    else\
    \ if(element === '}'){\n      opening_brace_counter--\n    }\n    else if(opening_brace_counter\
    \ === 0 && opening_paren_stack.length > 0){\n      if(opening_paren_stack[opening_paren_stack.length-1]\
    \ === '('){\n        opening_paren_stack.pop()\n      }\n      else if(opening_paren_stack[opening_paren_stack.length-1]\
    \ === '{'){\n        opening_paren_stack.pop()\n      }\n      else{\n       \
    \ opening_brace_counter--\n      }\n    }\n  })\n  \n  var opening_string = \"\
    \"\n  var opening_brace_string = \"\"\n  for(var i=0; i<opening_paren_stack.length;\
    \ i++){\n    opening_string += opening_paren_stack[i]\n  }\n  \n  var opening_brace_counter_string\
    \ = \"\"\n  for(var i=0; i<opening_brace_counter; i++){\n    opening_brace_counter_string\
    \ += opening_brace_counter\n  }\n  \n  var opening_brace_counter = 0\n  for(var\
    \ i=0; i<opening_paren_stack.length; i++){\n    if(opening_paren_stack[i] ===\
    \ '('){\n      opening_brace_counter += 1\n    }\n    else if(opening_paren_stack[i]\
    \ === '{'){\n      opening_brace_counter += 1\n    }\n  }\n  \n  for(var i=0;\
    \ i<opening_paren_stack.length; i++){\n    if(opening_paren_stack[i] === '('){\n\
    \      opening_string += \")\"\n    }\n    else if(opening_paren_stack[i] ===\
    \ '{'){\n      opening_brace_counter_string = opening_brace_counter_string.substring(0,\
    \ opening_brace_counter_string.length - 2) + opening_brace_counter + \")\"\n \
    \     opening_brace_counter += 1\n    }\n  }\n  \n  for(var i=0; i<opening_brace_counter;\
    \ i++){\n    ", "  var group_array = paren_string.split(/([\\(\\)])/);\n  for(var\
    \ i = 0; i < group_array.length; i++){\n    if(group_array[i].trim().length ==\
    \ 0){\n      group_array.splice(i, 1);\n      i--;\n    }\n  }\n  return group_array;\n\
    }\n", "\tlet groups = [];\n\tlet currentGroup = \"\";\n\tlet openBrackets = 0;\n\
    \tlet openParens = 0;\n\tlet parenStringLength = paren_string.length;\n\tfor(let\
    \ i = 0; i < parenStringLength; i++){\n\t\tif(paren_string[i] === \"(\"){\n\t\t\
    \topenParens++;\n\t\t\tcurrentGroup += \"(\";\n\t\t}else if(paren_string[i] ===\
    \ \")\"){\n\t\t\topenParens--;\n\t\t\tcurrentGroup += \")\";\n\t\t}else if(openParens\
    \ === 0 && paren_string[i] === \" \"){\n\t\t\tif(currentGroup.length > 0){\n\t\
    \t\t\tgroups.push(currentGroup);\n\t\t\t\tcurrentGroup = \"\";\n\t\t\t}\n\t\t\
    }else{\n\t\t\tcurrentGroup += paren_string[i];\n\t\t}\n\t}\n\tif(currentGroup.length\
    \ > 0){\n\t\tgroups.push(currentGroup);\n\t}\n\treturn groups;\n}\n", "  var arr\
    \ = [];\n  var last_open_bracket = -1;\n  var group_string = \"\";\n  var paren_depth\
    \ = 0;\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_depth >\
    \ 0){\n      group_string += paren_string[i];\n      if(paren_string[i] == \"\
    )\"){\n        arr.push(group_string);\n        group_string = \"\";\n      }\n\
    \      if(paren_string[i] == \"(\"){\n        paren_depth++;\n      }else{\n \
    \       paren_depth--;\n      }\n    }else{\n      if(paren_string[i] == \")\"\
    ){\n        arr.push(group_string);\n        group_string = \"\";\n        last_open_bracket\
    \ = i;\n      }\n    }\n  }\n  arr.push(group_string);\n  return arr;\n}\n", " \
    \   var open_paren = []\n    var closed_paren = []\n    var paren_stack = []\n\
    \    \n    for(var i=0; i<paren_string.length; i++){\n        var cur_char = paren_string[i]\n\
    \        if(cur_char === '(' || cur_char === '{' || cur_char === '['){\n     \
    \       paren_stack.push(cur_char)\n        }else if(cur_char === ')'){\n    \
    \        while(paren_stack.length && paren_stack[paren_stack.length - 1] !== '('){\n\
    \                closed_paren.push(paren_stack.pop())\n            }\n       \
    \     while(paren_stack.length && paren_stack[paren_stack.length - 1] !== '('){\n\
    \                open_paren.push(paren_stack.pop())\n            }\n        }else\
    \ if(cur_char === '}'){\n            while(paren_stack.length && paren_stack[paren_stack.length\
    \ - 1] !== '{'){\n                closed_paren.push(paren_stack.pop())\n     \
    \       }\n            while(paren_stack.length && paren_stack[paren_stack.length\
    \ - 1] !== '{'){\n                open_paren.push(paren_stack.pop())\n       \
    \     }\n        }else if(cur_char === ']'){\n            while(paren_stack.length\
    \ && paren_stack[paren_stack.length - 1] !== '['){\n                closed_paren.push(paren_stack.pop())\n\
    \            }\n            while(paren_stack.length && paren_stack[paren_stack.length\
    \ - 1] !== '['){\n                open_paren.push(paren_stack.pop())\n       \
    \     }\n        }\n    }\n    \n    while(open_paren.length || closed_paren.length){\n\
    \        if(open_paren.length){\n            open_paren[open_paren.length-1] =\
    \ open_paren[open_paren.length-1] + closed_paren.pop()\n        }else if(closed_paren.length){\n\
    \            closed_paren[closed_paren.length-1] = closed_paren[closed_paren.length-1]\
    \ + open_paren.pop()\n        }\n    }\n    \n    return open_paren\n}\n\n", " \
    \ // Use a stack to track the opening and closing of the parentheses \n  var stack_groups\
    \ = [];\n\n  var opening_paren = false;\n  // Loop through each character in the\
    \ string\n  for(var i = 0; i < paren_string.length; i++){\n    // If this character\
    \ is currently an opening parenthesis, push it onto the stack\n    if(paren_string[i]\
    \ == \"(\" && !opening_paren){\n      stack_groups.push(paren_string.substring(i,i+1));\n\
    \      opening_paren = true;\n    // If this character is currently a closing\
    \ parenthesis, pop the last element of the stack and append \n    // the opening\
    \ of the parenthesis to this element\n    } else if(paren_string[i] == \")\" &&\
    \ opening_paren){\n      stack_groups.pop();\n      opening_paren = false;\n \
    \   // If this character is not an opening or closing parenthesis, continue to\
    \ the next iteration\n    } else {\n      opening_paren = false;\n    }\n  }\n\
    \  // Return the array of groups in the input\n  return stack_groups;\n}\n", " \
    \   //Split each paren group into separate strings to return later\n    var paren_groups\
    \ = [];\n    var paren_regex = /^\\s*\\(\\s*\\)\\s*\\(\\s*\\)\\s*\\(\\s*\\)\\\
    s*\\(\\s*\\)\\s*$/;\n    var match_groups = paren_string.match(paren_regex);\n\
    \    \n    if (match_groups === null) {\n        return null;\n    }\n\n    var\
    \ paren_open_regex = /^\\s*\\(\\s*$/;\n    var paren_close_regex = /^\\s*\\)\\\
    s*$/;\n    var match_open = paren_string.match(paren_open_regex);\n    var match_close\
    \ = paren_string.match(paren_close_regex);\n    \n    if (match_open === null)\
    \ {\n        return null;\n    }\n\n    if (match_groups[0].length !== match_close[0].length){\n\
    \        return null;\n    }\n\n    var counter = 0;\n    for (var i in match_groups)\
    \ {\n        paren_groups.push(match_groups[i]);\n        counter++;\n    }\n\n\
    \    if (counter !== match_open.length) {\n        return null;\n    }\n\n   \
    \ return paren_groups;\n}\n", "\tvar open_braces = paren_string.match(/\\(([^)]+)\\\
    )/g);\n\tvar open_parentheses = [];\n\tvar open_paren_index = 0;\n\tfor (var i=0;\
    \ i<open_braces.length; i++){\n\t\tif (open_braces[i].length > 0 && open_braces[i].search(/\\\
    (/) == -1){\n\t\t\topen_parentheses[open_paren_index] = open_braces[i];\n\t\t\t\
    open_paren_index += 1;\n\t\t}\n\t}\n\n\tvar close_parentheses = paren_string.match(/\\\
    (([^)]+)\\)/g);\n\tvar close_braces = [];\n\tvar close_brace_index = 0;\n\tfor\
    \ (var i=0; i<close_parentheses.length; i++){\n\t\tif (close_parentheses[i].length\
    \ > 0 && close_parentheses[i].search(/\\(/) != -1){\n\t\t\tclose_braces[close_brace_index]\
    \ = close_parentheses[i];\n\t\t\tclose_brace_index += 1;\n\t\t}\n\t}\n\n\tconsole.log(\"\
    open_braces:\", open_braces);\n\tconsole.log(\"open_parentheses:\", open_parentheses);\n\
    \tconsole.log(\"close_braces:\", close_braces);\n\tconsole.log(\"close_parentheses:\"\
    , close_parentheses);\n\n\tvar results = [];\n\n\t// Search through the brackets\
    \ and parentheses arrays and find each set of nested brackets and parentheses.\n\
    \t// If there is more than one bracket or parentheses in the string, return all\
    \ matches as an array.\n\t\n\tvar num_open_braces = 0;\n\tfor (var i=0; i<open_braces.length;\
    \ i++){\n\t\t\n\t\tnum_open_braces += 1;\n\t\tvar open_brace_match = open_braces[i].search(/\\\
    (/);\n\t\tif (open_brace_match != -1){\n\t\t\t// Found an open brace \n\t\t\t\
    if (num_open_braces > 1){\n\t\t\t\t// If more than 1 open brace, return all open\
    \ braces as an array\n\t\t\t\tresults.push(open_braces[i]);\n\t\t\t}\n\t\t\telse{\n\
    \t\t\t\t// Found a match for the first open brace, so push this one to open_parens\n\
    \t\t\t\topen_parentheses[open_paren_index] = open_braces[i];\n\t\t\t\topen_paren_index\
    \ += 1;\n\t\t\t}\n\t\t}\n\t\telse if (num_open_braces == 1){\n\t\t\t// If this\
    \ is the first open brace, push this one to open_parens\n\t\t\topen_parentheses[open_paren_index]\
    \ = open_braces[i];\n\t\t\topen_paren_index += 1;\n\t\t}\n\t\telse if (num_open_braces\
    \ > 1){\n\t\t\t// If there are multiple open braces in the string, return an array\
    \ of all open braces.\n\t\t\tresults.push(open_braces[i]);\n\t\t}\n\t}\n\n\tnum_open_braces\
    \ = 0;\n\tfor (var i=0; i<close_braces.length; i++){\n\t\t\n\t\tnum_open_braces\
    \ += 1;\n\t\tvar open_brace_match = close_braces[i].", "    const groups = [];\n\
    \    let cur_group = \"\";\n    let balance = 0;\n\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        if(paren_string[i] === \"(\" || paren_string[i] === \"{\" ||\
    \ paren_string[i] === \"[\"){\n            balance++;\n        }\n        else\
    \ if(paren_string[i] === \")\" || paren_string[i] === \"}\" || paren_string[i]\
    \ === \"]\"){\n            balance--;\n        }\n        if(balance === 0){\n\
    \            if(cur_group){\n                groups.push(cur_group);\n       \
    \         cur_group = \"\";\n            }\n        }\n        else{\n       \
    \     cur_group += paren_string[i];\n        }\n    }\n\n    return groups;\n\
    }\n", "    let open_braces = 0, closed_braces = 0, open_brackets = 0, closed_brackets\
    \ = 0;\n    let paren_groups = paren_string.split('').reduce((accu, current_char)=>{\n\
    \        if (current_char === '(') open_brackets++;\n        if (current_char\
    \ === ')') closed_brackets++;\n        if (current_char === '{') open_braces++;\n\
    \        if (current_char === '}') closed_braces++;\n        return accu.concat(current_char);\n\
    \    }, []);\n    \n    return [paren_groups, open_braces, closed_braces, open_brackets,\
    \ closed_brackets];\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice solution! I\
    \ didn't know about the reduce() method. I would have accepted yours as an answer\
    \ except that the question explicitly asked for a solution in plain JavaScript\
    \ (without using any extra libraries) and that solution uses reduce() which is\
    \ ES6 syntax (but is also available in ES5 \u2014 and even a polyfill).\n<|/ c\
    \ |>\n<| c |>\nI edited my answer to include a pure JavaScript solution. Also,\
    \ I wasn't aware of reduce() before, so thanks for pointing that out\n<|/ c |>\n\
    <| a |>\nTry this one (with ES6 syntax):\n\n<code>\nconst str = '( ) (( )) ((\
    \ )( ))';\nconst strArray = str.split('');\nlet openBraces = 0;\nlet openBrackets\
    \ = 0;\n\nfor (let i = 0; i < strArray.length; i++) {\n  if (strArray[i] == '(')\
    \ openBrackets++;\n  if (strArray[i] == ')') openBraces++;\n}\n\nconst resultArray\
    \ = strArray.filter(el => {\n  if (el == '(') openBrackets--;\n  if (el == ')')\
    \ openBraces--;\n  return (el != ' ' && openBraces > 0 && openBrackets > 0);\n\
    });\n", "\tlet open_brackets = [], closing_brackets = [], split_brackets = [],\
    \ current_bracket = -1;\n\tfor(let i = 0; i < paren_string.length; i++){\n\t\t\
    if((paren_string[i] in paren_groups)){\n\t\t\tif(current_bracket != paren_groups[paren_string[i]].length){\n\
    \t\t\t\tsplit_brackets[current_bracket].push(paren_string[i]);\n\t\t\t}\n\t\t\t\
    current_bracket += 1;\n\t\t}\n\t\telse if((paren_string[i] in brackets)){\n\t\t\
    \tcurrent_bracket = 0;\n\t\t}\n\t\telse if(paren_string[i] == \" \" && current_bracket\
    \ != 0){\n\t\t\tsplit_brackets[current_bracket].push(paren_string[i]);\n\t\t}\n\
    \t\telse if((paren_string[i] in brackets) == 0 && current_bracket == 0){\n\t\t\
    \topen_brackets.push(paren_string[i]);\n\t\t}\n\t\telse if((paren_string[i] in\
    \ brackets) == 0 && current_bracket != 0){\n\t\t\tclosing_brackets.push(paren_string[i]);\n\
    \t\t}\n\t}\n\tif(current_bracket != 0){\n\t\tlet bracket_string = open_brackets.join(\"\
    \") + closing_brackets.join(\"\");\n\t\tsplit_brackets.push(paren_string.slice((current_bracket\
    \ + 1)));\n\t\treturn split_brackets;\n\t}\n\telse{\n\t\treturn split_brackets;\n\
    \t}\n}\n", "    if(paren_string.indexOf(\"()\") !== -1){\n        let index_of_parenthese\
    \ = paren_string.indexOf(\"(\");\n        let index_of_closing_brace = paren_string.indexOf(\"\
    )\");\n        let open_parantheses = paren_string.substring(0, index_of_parenthese);\n\
    \        let close_parantheses = paren_string.substring(index_of_closing_brace,\
    \ paren_string.length);\n        let open_parentheses = open_parantheses.split(/\\\
    (|\\)/).filter(function(str){\n            return str.length === 0;\n        });\n\
    \        return open_parentheses;\n    }\n    return [];\n}\n", "    var open_brace_stack\
    \ = [];\n    var close_brace_stack = [];\n    var open_brace_str = '';\n    var\
    \ close_brace_str = '';\n    var open_paren_str = '';\n    var close_paren_str\
    \ = '';\n    for(var i = 0, len = paren_string.length; i < len; i++){\n      \
    \  var char = paren_string[i];\n        switch(char){\n            case '(':\n\
    \                if (open_brace_stack.length ==0){\n                    open_brace_stack.push(open_paren_str);\n\
    \                    open_brace_str = open_paren_str;\n                }\n   \
    \             open_paren_str += char;\n                break;\n            case\
    \ ')':\n                if (open_brace_stack.length ==0){\n                  \
    \  console.log(\"Error parsing string: \"+paren_string);\n                }\n\
    \                var paren_str = open_brace_stack.pop();\n                if (close_paren_str\
    \ !== undefined){\n                    close_paren_str += paren_str;\n       \
    \         }\n                else{\n                    close_paren_str = paren_str;\n\
    \                }\n                break;\n            default:\n           \
    \     if (open_brace_stack.length ==0){\n                    open_brace_stack.push(open_paren_str);\n\
    \                    open_brace_str = open_paren_str;\n                    open_paren_str\
    \ += char;\n                }\n                else {\n                    open_paren_str\
    \ += char;\n                }\n        }\n    }\n    if (open_paren_str.length\
    \ > 0){\n        open_brace_stack.push(open_paren_str);\n    }\n    if (close_paren_str.length\
    \ > 0){\n        close_brace_stack.push(close_paren_str);\n    }\n    var groups\
    \ = [];\n    if (open_brace_stack.length == 0 && close_brace_stack.length == 0){\n\
    \        groups.push(close_brace_stack[0]);\n    }\n    for(var i = 0, len = open_brace_stack.length;\
    \ i < len; i++){\n        groups.push(open_brace_stack[i]);\n    }\n    return\
    \ groups;\n}\n", "  var group_array = [];\n  var last_close_brace_location = paren_string.indexOf(\"\
    )\");\n  var last_open_brace_location = paren_string.indexOf(\"(\");\n  var last_open_brace_count\
    \ = 0;\n  while(last_open_brace_location > -1) {\n    group_array.push(paren_string.substring(0,\
    \ last_open_brace_location))\n    last_open_brace_location = paren_string.indexOf(\"\
    (\", last_open_brace_location + 1);\n    last_open_brace_count++;\n  }\n  while(last_close_brace_location\
    \ > -1) {\n    group_array.push(paren_string.substring(0, last_close_brace_location))\n\
    \    last_close_brace_location = paren_string.indexOf(\")\", last_close_brace_location\
    \ + 1);\n    last_open_brace_count--;\n  }\n  return group_array;\n}", "  // Initialize\
    \ the output array\n  var output = [];\n  \n  // Initialize the stack\n  var stack\
    \ = [];\n  \n  // Split the string into individual characters\n  var string =\
    \ paren_string.split(\"\");\n\n  // Iterate over the string characters\n  for\
    \ (var i=0; i<string.length; i++) {\n    // If the current character is a space,\
    \ ignore it.\n    if (string[i] === \" \"){\n      continue;\n    } else {\n \
    \     // If the current character is not a space, push it to the stack\n     \
    \ stack.push(string[i]);\n\n      // If the current character is a left paren,\
    \ pop it from the stack\n      if (string[i] === \"(\") {\n        stack.pop();\n\
    \      }\n    }\n  }\n\n  // Push the remaining stack elements to the output array\n\
    \  for (var i = 0; i < stack.length; i++) {\n    output.push(stack[i]);\n  }\n\
    \n  return output;\n}\n", "    var arr = [];\n    var open_braces = 0, closed_braces\
    \ = 0;\n    var prev_open_brace = 0, last_closed_brace = 0;\n    var paren_count\
    \ = 0;\n    var brace_group = \"\";\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        var char = paren_string[i];\n        if(char === \"(\"){\n  \
    \          paren_count ++;\n        }\n        else if(char === \")\"){\n    \
    \        paren_count --;\n        }\n        if(paren_count === 0){\n        \
    \    arr.push(brace_group);\n            brace_group = \"\";\n            paren_count\
    \ = 0;\n        }\n        else{\n            brace_group += char;\n        }\n\
    \        if(char === \")\"){\n            closed_braces ++;\n        }\n     \
    \   else if(char === \"(\"){\n            open_braces ++;\n        }\n    }\n\
    \    arr.push(brace_group);\n    return arr;\n}\n", "    let open_paren = paren_string.search(/\\\
    (/g);\n    let close_paren = paren_string.search(/\\)/g);\n    let open_paren_groups\
    \ = paren_string.substring(1, open_paren);\n    let close_paren_groups = paren_string.substring(close_paren\
    \ + 1, paren_string.length);\n    let open_paren_group_strings = open_paren_groups.match(/[^(]+/g);\n\
    \    let close_paren_group_strings = close_paren_groups.match(/[^)]+/g);\n   \
    \ let group_strings = [];\n    if (open_paren_group_strings.length > close_paren_group_strings.length)\
    \ {\n        for(let i=0;i < close_paren_group_strings.length;i++){\n        \
    \    group_strings.push(close_paren_group_strings[i])\n        }\n    }\n    else\
    \ {\n        for(let i=0;i < open_paren_group_strings.length;i++){\n         \
    \   group_strings.push(open_paren_group_strings[i])\n        }\n    }\n    return\
    \ group_strings;\n}\n", "    var split_string = paren_string.split(\" \");\n \
    \   var groups = [];\n    for (var i = 0; i < split_string.length; i++) {\n  \
    \      var group = split_string[i];\n        if (group.indexOf(\"(\") > -1 ||\
    \ group.indexOf(\")\") > -1) {\n            var new_group = group;\n         \
    \   var close_brace = false;\n            var open_brace = false;\n          \
    \  var group_length = 1;\n            var index = 0;\n            while (index\
    \ < (group.length - 1)) {\n                if (group[index] === \"(\") {\n   \
    \                 open_brace = true;\n                    index++;\n         \
    \           group_length++;\n                } else if (group[index] === \")\"\
    ) {\n                    close_brace = true;\n                    index++;\n \
    \                   group_length--;\n                } else {\n              \
    \      if (open_brace === false && close_brace === false) {\n                \
    \        break;\n                    }\n                    if (open_brace ===\
    \ false && close_brace === true) {\n                        group_length++;\n\
    \                        open_brace = false;\n                        index++;\n\
    \                        break;\n                    } else if (open_brace ===\
    \ true && close_brace === false) {\n                        group_length--;\n\
    \                        open_brace = false;\n                        index++;\n\
    \                        break;\n                    }\n                    if\
    \ (open_brace === true && close_brace === true) {\n                        open_brace\
    \ = false;\n                        close_brace = false;\n                   \
    \     index++;\n                    }\n                }\n            }\n    \
    \        if (group_length === 0) {\n                groups.push(new_group);\n\
    \            } else if (open_brace === true && close_brace === false) {\n    \
    \            groups.push(new_group);\n                groups.push(new_group.substring(0,\
    \ index));\n            } else if (open_brace === true && close_brace === true)\
    \ {\n                groups.push(new_group);\n                groups.push(new_group.substring(0,\
    \ index));\n                groups.push(new_group.substring(index));\n       \
    \     }\n        } else {\n            groups.push(group);\n        }\n    }\n\
    \    return groups;\n}\n", "    var paren_string = paren_string.replace(/\\s/g,\
    \ \"\");\n    var groups = [];\n    var current_group = null;\n    var open_braces;\n\
    \    var open_braces_length = 0;\n    var open_parentheses_length = 0;\n\n   \
    \ //Search for the first opening parentheses\n    open_braces = paren_string.match(/\\\
    (/g);\n    open_braces_length = open_braces.length;\n\n    //Set the starting\
    \ index position to the first opening parenthesis\n    //Since we found the first\
    \ opening parentheses, set our starting position\n    var starting_position =\
    \ open_braces[0].length;\n    for (var i = 0; open_braces.length > 0; i++){\n\
    \        if (open_braces[i].length <= starting_position){\n            //Since\
    \ we found the first opening parentheses we need to add them to the group\n  \
    \          groups.push(paren_string.substr(starting_position,open_braces[i].length));\n\
    \            current_group = open_braces[i];\n            current_group_string\
    \ = open_braces[i];\n        }else if (open_braces[i].length > starting_position){\n\
    \            //If the current opening parentheses is longer than the starting\
    \ position...\n            //We need to start a new group\n            //Make\
    \ sure the group doesn't contain any spaces\n            if (open_braces[i-1].indexOf(\"\
    \ \") === -1){\n                groups.push(current_group_string);\n         \
    \       current_group_string = \"\";\n            }\n            //Set the current\
    \ group string to the new opening parentheses group\n            current_group_string\
    \ = open_braces[i];\n            //Set the starting position to the new opening\
    \ parentheses group\n            starting_position = open_braces[i].length;\n\
    \        }\n    }\n    //Make sure there is an ending parentheses group\n    if\
    \ (open_braces_length > 0){\n        groups.push(current_group_string);\n    }\n\
    \    return groups;\n}\n", "    var split_string = [];\n    var paren_count =\
    \ 0;\n\n    //Iterate through the input string and keep track of the number of\
    \ open ( and closing ) parens\n    for(var i = 0, len = paren_string.length; i\
    \ < len; i++){\n        //If the character is a (, increment the count\n     \
    \   if(paren_string[i] === '('){\n            paren_count++;\n        }\n    \
    \    //If the character is a), decrement the count\n        if(paren_string[i]\
    \ === ')'){\n            paren_count--;\n        }\n        //If count is zero,\
    \ split the string and add the current character to the string\n        if(paren_count\
    \ === 0){\n            split_string.push(paren_string[i]);\n        }\n    }\n\
    \    return split_string;\n}\n", "    var in_string = '';\n    var brackets =\
    \ '';\n    var open_count = 0;\n    var closed_count = 0;\n    var match;\n  \
    \  var brackets_group = [];\n\n    while ( (match = paren_string.match(/[^(\\\
    )]+\\)$/) ) != null) {\n        in_string += match[0];\n        brackets = match[0];\n\
    \        brackets_group.push(brackets);\n        paren_string = paren_string.substr(match.index\
    \ + match[0].length);\n    }\n\n    while ( in_string.length > 0 ) {\n       \
    \ match = paren_string.match(/\\(([^\\(\\)]*)\\)/);\n        if (match != null\
    \ && match[1].match(/^[^\\(\\)]+$/) != null)\n            closed_count += match[1].length;\n\
    \        else\n            open_count += match[0].length;\n\n        in_string\
    \ += match[0];\n        paren_string = paren_string.substr(match.index + match[0].length);\n\
    \    }\n\n    brackets_group.reverse();\n\n    return [brackets_group].concat(separate_paren_groups(in_string))\n\
    }\n", "  \n  // Create a regular expression for splitting the input string\n \
    \ var paren_regex = new RegExp(/((?:\\([^()]*\\))*[^()]*)/g);\n\n  var matches\
    \ = [];\n\n  // Run the regular expression against the string\n  paren_string.split(paren_regex).forEach(function(splitstring){\n\
    \    // If the matched string contains at least one unclosed parentheses, add\
    \ it to the matches array\n    if(!splitstring.match(/([\\)]{1})/)){\n      matches.push(splitstring);\n\
    \    }\n  });\n\n  return matches;\n}\n", "  let paren_regex = /[(])([^()]*?)(\\\
    ))/g;\n  let result = [];\n  let current_group;\n  while (match = paren_regex.exec(paren_string)){\n\
    \    current_group = match[2];\n    if (current_group !== \"(\"){\n      result.push(current_group);\n\
    \    }\n  }\n  return result;\n}\n", "    // your code here\n}\n</cell>\n<cell>\n\
    separate_paren_groups('( ) (( )) (( )( ))')\n</cell>\n<text>\nProblem 7: Reverse\
    \ the string inside each parentheses\nThis function will take a string of parentheses\
    \ and return the same string with parentheses reversed. \nIf there are no parentheses,\
    \ return the string unchanged.\n\n\n</text>\n<cell>", "    return paren_string.match(/\\\
    (([^\\(\\)]+)\\)/g);\n}\n", "\tvar open_braces, closed_braces, group_stack = [],\
    \ current_group = [], current_char;\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tcurrent_char = paren_string.charAt(i);\n\t\tif(current_char == '('\
    \ || current_char == '[' || current_char == '{'){\n\t\t\topen_braces.push(current_char);\n\
    \t\t\tcurrent_group.push(current_char);\n\t\t}else if(current_char == ')' || current_char\
    \ == ']' || current_char == '}'){\n\t\t\tcurrent_group.push(current_char);\n\t\
    \t\tgroup_stack.push(current_group);\n\t\t\tcurrent_group = [];\n\t\t}else if(open_braces.length\
    \ > 0 && current_char == ')' && open_braces.pop() == '('){\n\t\t\tcurrent_group.push(')');\n\
    \t\t\tgroup_stack.push(current_group);\n\t\t\tcurrent_group = [];\n\t\t}else if(open_braces.length\
    \ > 0 && current_char == ']' && open_braces.pop() == '['){\n\t\t\tcurrent_group.push(']');\n\
    \t\t\tgroup_stack.push(current_group);\n\t\t\tcurrent_group = [];\n\t\t}else if(open_braces.length\
    \ > 0 && current_char == '}' && open_braces.pop() == '{'){\n\t\t\tcurrent_group.push('}');\n\
    \t\t\tgroup_stack.push(current_group);\n\t\t\tcurrent_group = [];\n\t\t}else{\n\
    \t\t\tcurrent_group.push(current_char);\n\t\t}\n\t}\n\treturn group_stack;\n}\n",
  "  var groups = paren_string.match(/[^\\(\\)]+/g);\n  var res = [];\n  for(var i=0;\
    \ i<groups.length; i++){\n    res.push(groups[i].match(/[^\\(\\)]+/g));\n  }\n\
    \  return res;\n}\n", "  var split_string = paren_string.split(\"\");\n  var paren_groups\
    \ = [];\n  \n  for(var i in split_string){\n    if(split_string[i] === \" \" ||\
    \ split_string[i] === \"(\" || split_string[i] === \")\"){\n      var new_paren_group\
    \ = [];\n      \n      for(var j in paren_groups){\n        if(paren_groups[j].includes(split_string[i])){\n\
    \          new_paren_group.push(paren_groups[j]);\n          paren_groups.splice(j,\
    \ 1);\n          break;\n        }\n      }\n      \n      if(new_paren_group.length\
    \ === 0){\n        new_paren_group.push(split_string[i]);\n      }\n      \n \
    \     paren_groups.push(new_paren_group);\n      \n    }\n  }\n  \n  return paren_groups;\n\
    }\n", "    let opening_pairs = new Array();\n    let paren_array = new Array();\n\
    \    let paren_count = 0;\n    for (let i = 0; i < paren_string.length; i++){\n\
    \        if (paren_string.charAt(i) === \"(\"){\n            paren_array[paren_count]\
    \ = paren_string.substring(0,i);\n            paren_count++;\n        } else if\
    \ (paren_string.charAt(i) === \"(\"){\n            opening_pairs[paren_count]\
    \ = paren_string.substring(0,i);\n            paren_count++;\n        } else if\
    \ (paren_string.charAt(i) === \")\"){\n            paren_count--;\n          \
    \  if (paren_count === 0){\n                paren_array[paren_count] = paren_string.substring(0,i+1);\n\
    \                paren_array.push('');\n            }\n        }\n    }\n    return\
    \ paren_array;\n}\n", "  return paren_string.replace(/\\((?!(\\))|$)/g,'').split(/\\\
    (|\\)/g);\n}\n", "\t// Write your code here\n\tlet result = [];\n\tlet depth =\
    \ 0;\n\tlet open_groups = [];\n\tlet closed_groups = [];\n\tlet last_open = false;\n\
    \tlet last_close = false;\n\tfor(let i = 0; i < paren_string.length; i++){\n\t\
    \tlet char = paren_string[i];\n\t\tif(char == \")\"){\n\t\t\tif(open_groups.length\
    \ > depth){\n\t\t\t\tfor(let j = 0; j < open_groups.length; j++){\n\t\t\t\t\t\
    if(open_groups[j] === char){\n\t\t\t\t\t\topen_groups.splice(j, 1);\n\t\t\t\t\t\
    \tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(open_groups.length === 0){\n\
    \t\t\t\tlast_close = true;\n\t\t\t\tclosed_groups.push(char);\n\t\t\t}\n\t\t\t\
    else if(open_groups.length === depth){\n\t\t\t\tlast_close = false;\n\t\t\t\t\
    if(last_open === last_close){\n\t\t\t\t\tresult.push(closed_groups.join(\"\"));\n\
    \t\t\t\t\tlast_close = false;\n\t\t\t\t\tclosed_groups = [];\n\t\t\t\t}\n\t\t\t\
    \tlast_open = false;\n\t\t\t\topen_groups = [];\n\t\t\t}\n\t\t}else if(char ===\
    \ \"(\"){\n\t\t\tif(closed_groups.length > 0){\n\t\t\t\tif(closed_groups[0] ===\
    \ char){\n\t\t\t\t\tclosed_groups.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t\topen_groups.push(char);\n\
    \t\t}else if(char === \" \"){\n\t\t\tlast_open = last_close = false;\n\t\t}\n\t\
    }\n\tlet result_string = \"\";\n\tfor(let i = 0; i < result.length; i++){\n\t\t\
    result_string += result[i] + \", \";\n\t}\n\treturn result_string.slice(0, -2);\n\
    }\n", "  const groups = [];\n  const paren_stack = [];\n  const paren_level =\
    \ 0;\n  const last_group = \"\";\n\n  // Loop through all the characters in the\
    \ string\n  for(let i=0; i<paren_string.length; i++){\n    const char = paren_string[i];\n\
    \n    // If we are on the first character, add the character to the stack\n  \
    \  if(paren_level == 0){\n      paren_stack.push(char);\n    }\n\n    // If the\
    \ character is a brace, end the parent group\n    if(char == \"{\" || char ==\
    \ \"}\"){\n      groups.push(paren_stack);\n      paren_stack = [];\n      paren_level--;\n\
    \    }\n\n    // If the character is \")\", push the stack and start the parent\
    \ group\n    if(char == \")\"){\n      groups.push(paren_stack);\n      paren_stack\
    \ = [];\n      paren_level++;\n    }\n  }\n\n  // Add any remaining character\
    \ to the end of the parent group\n  groups.push(paren_stack);\n\n  return groups;\n\
    }\n\n", "  // Split the input string on spaces, and map the array of strings to\
    \ a regular expression\n  return paren_string.split(\" \").map(function(str) {\n\
    \    // The regex to separate the input string\n    var regex = new RegExp(\"\\\
    \\((?!.*(.).*\\\\)|\\\\)\", \"g\");\n    // Replace all non-nested pairs of parentheses\n\
    \    var replacement = \"\\\\\" + str + \"\\\\)\";\n    // Replace all nested\
    \ pairs of parentheses\n    regex = regex.replace(\"\\\\(\" + str + \"\\\\)\"\
    , replacement);\n    // Remove empty strings\n    regex = regex.replace(/\\s+/g,\
    \ \"\");\n    // Return the new regex\n    return regex;\n  });\n}\n", "\tvar\
    \ paren_groups = paren_string.match(/\\((.*)\\)/)[1].split(/ *, */);\n\treturn\
    \ paren_groups;\n}\n", "  var results = [];\n  for(var index = 0; index < paren_string.length;\
    \ index++){\n    var group = paren_string[index];\n    if(group != \" \" && group\
    \ != \"(\" && group != \")\"){\n      results.push([group]);\n    }else{\n   \
    \   if(index == 0){\n        results.push(group);\n      }else{\n        results[results.length\
    \ - 1].push(group);\n      }\n    }\n  }\n  return results;\n}\n", "  var re=/(?:\\\
    (([^\\s()]+)\\))/g;\n  var matches;\n  var parens=[];\n  while ((matches = re.exec(paren_string))){\n\
    \    parens.push(matches[0]);\n  }\n  return parens;\n}\n", "    var open_brace_strings\
    \ = [];\n    var close_brace_strings = [];\n    paren_string = paren_string.replace(/\\\
    s+/g, '');\n\n    for (var i=0; i < paren_string.length; i++){\n        var cur_char\
    \ = paren_string[i];\n\n        if (cur_char === '(' || cur_char === '{' || cur_char\
    \ === '['){\n            open_brace_strings.push(paren_string[i]);\n        }\n\
    \        else if (cur_char === ')' || cur_char === '}' || cur_char === ']'){\n\
    \            close_brace_strings.push(paren_string[i]);\n        }\n    }\n\n\
    \    return open_brace_strings.concat(close_brace_strings);\n}\n", "    //\n \
    \   let split_string = [];\n    \n    //\n    let open_brace_count = 0;\n    let\
    \ open_brace_group = [];\n    \n    //\n    for(let i = 0; i < paren_string.length;\
    \ i++){\n        \n        if(paren_string[i] === '('){\n            open_brace_count++;\n\
    \            open_brace_group.push(paren_string[i]);\n        }\n        else\
    \ if(paren_string[i] === ')'){\n            open_brace_count--;\n            if(open_brace_count\
    \ === 0){\n                split_string.push(open_brace_group);\n            \
    \    open_brace_group.splice(0,1);\n            }\n        }\n    }\n    \n  \
    \  return split_string;\n}\n", "    // Use a stack to track the number of open\
    \ parens\n    // This allows us to ignore any spaces in parens\n    var parenStack\
    \ = 0;\n    // The output array\n    var paren_array = [];\n    // Loop through\
    \ the input string\n    for(var i=0; i< paren_string.length; i++){\n        //\
    \ If the current character is a left paren\n        if(paren_string[i] === \"\
    (\"){\n            // Increment the paren stack counter\n            parenStack++;\n\
    \        }\n        // If the current character is a right paren\n        else\
    \ if(paren_string[i] === \")\"){\n            // Decrement the paren stack counter\n\
    \            parenStack--;\n        }\n        // If the current character is\
    \ a left paren but the stack is still open\n        else if(parenStack > 0){\n\
    \            // ignore the character\n            continue;\n        }\n     \
    \   // If the current character is a right paren but the stack is still open\n\
    \        else if(parenStack < 0){\n            // ignore the character\n     \
    \       continue;\n        }\n        // If the current character is a space\n\
    \        else if(paren_string[i] === \" \"){\n            // If the current stack\
    \ is empty or the stack is not empty\n            if((parenStack === 0) || (parenStack\
    \ > 0)){\n                // ignore the character\n                continue;\n\
    \            }\n        }\n        // Add the character to the array\n       \
    \ paren_array.push(paren_string[i]);\n    }\n    return paren_array;\n}\n</cell>\n\
    <cell>\n# TEST Separate Paren Groups 1 (Test case)\ntests_passed = separate_paren_groups(\"\
    ( ) (( )) (( )( ))\") === [\"()\", \"(())\", \"(()())\"]\nassert(tests_passed)\n\
    </cell>\n<cell>\n# BEGIN separate_paren_groups\n# Complete the function here.\n\
    def separate_paren_groups(paren_string):\n    \"\"\"\n    Separate parens and\
    \ return an array of each separate set of parentheses found.\n\n    Args:\n  \
    \      paren_string: A string containing parentheses.\n\n    Returns:\n      \
    \  A list containing the individual strings found; for example, if the input is\
    \ \"( ( ) ( ) ( ) )\" then the\n        output should be [\"()\", \"(())\", \"\
    (()())\"].\n    \"\"\"\n</cell>\n<cell>\n# UNIT TEST\nseparate_paren_groups(\"\
    ( ) (( )) (( )( ))\") === [\"()\", \"(())\", \"(()())\"]\nassert(separate_paren_groups(\"\
    ( ) (( )) (( )( ))\") === [\"()\", \"(())\", \"(()())\"])\n</cell>\n<text>\nBegin\
    \ Code for Part 2\nNow you will put ", "    var output = [];\n    var groupings\
    \ = paren_string.match(/\\(([^()]*)\\)/g);\n    if(!groupings)\n        return\
    \ output;\n    groupings.forEach(function(grouping){\n        while(grouping.charAt(0)\
    \ !== \")\"){\n            output.push(grouping.substr(1));\n            grouping\
    \ = grouping.substr(0, grouping.length - 1);\n        }\n    });\n    return output;\n\
    }\n", "\tvar paren_re = /([^)(]+\\))/g;\n\tvar matches = paren_string.match(paren_re);\n\
    \tvar groups = [];\n\tfor(var i=0;i<matches.length;i++){\n\t\tgroups.push(matches[i].slice(1,-1));\n\
    \t}\n\treturn groups;\n}\n", "    if(paren_string === undefined) return [];\n\
    \    else return separate_paren_groups(paren_string.trim());\n}\n", "\tvar open_braces=[];\n\
    \tvar close_braces=[];\n\tvar paren_string=paren_string.replace(/\\s+/g,\" \"\
    );\n\tvar split=paren_string.split(/[\\(\\)]+/g);\n\tvar count=0;\n\tfor(var i=0;i<split.length;i++){\n\
    \t\tif(split[i]===\"(\"){\n\t\t\topen_braces[count]=true;\n\t\t}else if(split[i]===\"\
    )\" && open_braces[count]==true){\n\t\t\topen_braces[count]=false;\n\t\t\tclose_braces[count]=true;\n\
    \t\t\tcount++;\n\t\t}\n\t}\n\treturn split.filter(function(e){return e!==undefined;});\n\
    }", "    let paren_groups = [];\n    let open_brace_count = 0;\n    let i = 1;\n\
    \    while(i < paren_string.length){\n        if(paren_string[i] === \"(\"){\n\
    \            open_brace_count += 1;\n        }else if(paren_string[i] === \")\"\
    ){\n            open_brace_count -= 1;\n            if(open_brace_count === 0){\n\
    \                paren_groups.push(paren_string.slice(i));\n            }\n  \
    \      }else if(open_brace_count > 0){\n            i += 1;\n        }else{\n\
    \            i += 1;\n        }\n    }\n    return paren_groups;\n}\n", "    let\
    \ new_paren_string = paren_string;\n    new_paren_string = paren_string.replace(/\\\
    s+/g, '');\n    let paren_groups = new_paren_string.match(/\\(([^\\(\\)]+)\\)/g);\n\
    \    if(paren_groups === null)\n        return null;\n    let paren_groups_list\
    \ = [];\n    for(let i = 0; i < paren_groups.length; i++)\n        paren_groups_list.push(paren_groups[i]);\n\
    \    return paren_groups_list;\n}\n", "  var output = [];\n  var open_braces =\
    \ paren_string.match(/\\((.*?)\\)/g);\n  for (var i=0; i < open_braces.length;\
    \ i++){\n    var group = [];\n    var open_brace = open_braces[i].match(/\\((.*?)\\\
    )/);\n    if (open_brace){\n      group = [open_brace[0].trim()];\n    }\n   \
    \ var close_brace = open_braces[i].match(/\\((.*?)\\)/);\n    if (close_brace){\n\
    \      group = [group.join(''), close_brace[1].trim()];\n    }\n    output.push(group);\n\
    \  }\n  return output;\n}\n\n", "\tvar paren_array = [];\n\tfor(var i = 0; i <\
    \ paren_string.length; i++){\n\t\tswitch(paren_string[i]){\n\t\t\tcase '(':\n\t\
    \t\t\tparen_array.push(paren_string.substr(0, i));\n\t\t\t\tbreak;\n\t\t\tcase\
    \ ')':\n\t\t\t\tparen_array.push(paren_string.substr(i + 1));\n\t\t\t\tbreak;\n\
    \t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn paren_array;\n}\n", "   \
    \ // Split groups into array of strings\n    let paren_groups = paren_string.match(/\\\
    ((?!\\?)[^\\)]+\\)/g);\n\n    // Close each brace with another open brace\n  \
    \  // >>> [\"(()())\", \"(())\", \"(())\", \"()\"]\n    paren_groups.forEach(ele\
    \ => paren_groups.push('('+ele+')'));\n\n    return paren_groups;\n}\n", "\t//\
    \ Your code here\n\tlet groups = paren_string.match(/\\((.*?)\\)/g);\n\treturn\
    \ groups;\n}\n", "    var result_string = \"\";\n    var current_string = \"\"\
    ;\n    var inside_paren = false;\n    var open_brace_open = false;\n    var open_brace_closed\
    \ = false;\n\n    for(var i = 0; i < paren_string.length; i++){\n        current_char\
    \ = paren_string[i];\n        if(current_char === \"(\"){\n            if(!inside_paren){\n\
    \                result_string += current_string;\n                current_string\
    \ = \"\";\n                inside_paren = true;\n            }else{\n        \
    \        result_string += current_string;\n                current_string = \"\
    \";\n                open_brace_closed = true;\n            }\n        }else if(current_char\
    \ === \")\"){\n            if(open_brace_closed && inside_paren){\n          \
    \      result_string += current_string;\n                current_string = \"\"\
    ;\n                inside_paren = false;\n            }\n            if(!open_brace_open){\n\
    \                current_string += current_char;\n            }else{\n       \
    \         open_brace_open = false;\n                result_string += current_string;\n\
    \                current_string = \"\";\n                open_brace_closed = false;\n\
    \            }\n        }else if(current_char === \" \"){\n            current_string\
    \ += current_char;\n        }else{\n            current_string += current_char;\n\
    \        }\n    }\n    if(!current_string){\n        result_string += current_string;\n\
    \    }\n\n    return result_string.match(/[^(]/g).map(function(val){return val.trim()});\n\
    }\n", "\tvar input_array = [];\n\tvar current_string = \"\";\n\tvar counter =\
    \ 0;\n\tvar num_open_braces = 0;\n\tvar num_closed_braces= 0;\n\tvar i;\n\n\t\
    // If paren_string is an empty string, return an empty array\n\tif(paren_string.length\
    \ < 1){\n\t\treturn input_array;\n\t}\n\t\n\tparen_string = paren_string.trim();\n\
    \t\n\t//Loop through string and count opening braces\n\tfor(i = 0; i < paren_string.length;\
    \ i++){\n\t\t\n\t\tif(paren_string.charAt(i) == \")\"){\n\t\t\tnum_closed_braces++;\n\
    \t\t}\n\t\t\n\t\telse if(paren_string.charAt(i) == \"(\"){\n\t\t\tnum_open_braces++;\n\
    \t\t}\n\t\t\n\t\telse{\n\t\t\t//If this character is a space or linebreak then\
    \ continue\n\t\t\tif((paren_string.charAt(i) == \" \" || paren_string.charAt(i)\
    \ == \"\\n\") ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t//If opening and closing\
    \ braces are the same and are adjacent then add this character to current_string\n\
    \t\t\telse if(num_closed_braces == num_open_braces && paren_string.charAt(i) ==\
    \ paren_string.charAt(i + 1)){\n\t\t\t\tcurrent_string += paren_string.charAt(i);\n\
    \t\t\t}\n\t\t\t\n\t\t\t//Otherwise this character is an opening brace so add this\
    \ character to current_string and reset counter\n\t\t\telse{\n\t\t\t\tcurrent_string\
    \ += paren_string.charAt(i);\n\t\t\t\tcounter = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\
    if(num_closed_braces == num_open_braces && paren_string.charAt(i) == \")\"){\n\
    \t\t\tinput_array[counter] = current_string;\n\t\t\tcurrent_string = \"\";\n\t\
    \t\tcounter++;\n\t\t}\n\t\t\n\t\telse if(paren_string.charAt(i) == \")\"){\n\t\
    \t\tinput_array[counter] = current_string;\n\t\t\tcurrent_string = \"\";\n\t\t\
    \tcounter++;\n\t\t}\n\t}\n\t\n\t//Add the last brace to the input_array if it's\
    \ there\n\tif(num_closed_braces < num_open_braces){\n\t\tinput_array[counter]\
    \ = current_string;\n\t}\n\t\n\treturn input_array;\n}\n", "    // Write your\
    \ code here.\n    // Be sure to return an array of strings that correctly describe\
    \ the groups in the input string.\n    var paren_groups = paren_string.match(/([^()]*\\\
    ([^()]*\\))*)/g);\n    // console.log(paren_groups);\n    return paren_groups;\n\
    }", "  var groups = [];\n  var open_braces;\n  var current_group = [];\n  \n \
    \ for(var i=0; i<paren_string.length; i++){\n    if(paren_string.charAt(i) ==\
    \ \"(\" || paren_string.charAt(i) == \")\"){\n      open_braces = current_group.length;\n\
    \      if(open_braces > 0){\n        groups.push(current_group);\n        current_group\
    \ = [];\n      }\n      continue;\n    }\n    if(open_braces == 0){\n      current_group.push(paren_string.charAt(i));\n\
    \    }\n  }\n  if(current_group.length > 0){\n    groups.push(current_group);\n\
    \  }\n  return groups;\n}\n", "\tlet paren_groups = [];\n\tlet paren_start = 0;\n\
    \tlet paren_end = 0;\n\tlet paren_stack = [];\n\tlet paren_stack_level = 0;\n\t\
    \n\tlet inside_paren_stack = false;\n\t\n\tfor(let i=0; i<paren_string.length;\
    \ i++){\n\t\tlet char = paren_string[i];\n\t\t\n\t\tif(char == \"(\"){\n\t\t\t\
    if(!inside_paren_stack){\n\t\t\t\tparen_start++;\n\t\t\t\tparen_end++;\n\t\t\t\
    \tparen_stack[paren_stack_level] = paren_end;\n\t\t\t\tparen_stack_level++;\n\t\
    \t\t\tinside_paren_stack = true;\n\t\t\t}\n\t\t}\n\t\telse if(char == \")\"){\n\
    \t\t\tif(!inside_paren_stack){\n\t\t\t\tif(paren_stack_level > 0){\n\t\t\t\t\t\
    paren_stack_level--;\n\t\t\t\t\tparen_end--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\
    \t\tparen_groups[paren_groups.length] = paren_string.slice(paren_start, paren_end+1);\n\
    \t\t\t\t\tparen_start = paren_end + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if(char\
    \ == \" \"){\n\t\t\tif(!inside_paren_stack){\n\t\t\t\tif(paren_stack_level > 0){\n\
    \t\t\t\t\tparen_stack_level--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlet group_string\
    \ = paren_string.slice(paren_start, i+1);\n\t\t\t\t\tif(group_string.length !==\
    \ 0){\n\t\t\t\t\t\tparen_groups[paren_groups.length] = group_string;\n\t\t\t\t\
    \t}\n\t\t\t\t\tparen_start = i+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(paren_stack_level\
    \ > 0){\n\t\tparen_stack_level--;\n\t}\n\telse{\n\t\tlet group_string = paren_string.slice(paren_start,\
    \ paren_string.length);\n\t\tif(group_string.length !== 0){\n\t\t\tparen_groups[paren_groups.length]\
    \ = group_string;\n\t\t}\n\t}\n\t\n\tparen_groups[paren_groups.length] = paren_string.slice(paren_start,\
    \ paren_string.length);\n\t\n\treturn paren_groups;\n}\n", "    \n    // Create\
    \ a stack for holding the paren groups. Each time a left paren group is encountered,\
    \ we push \n    // it to the stack. When a right paren group is encountered, we\
    \ pop from the stack and add it to our \n    // output string until a left paren\
    \ group is encountered again.\n    var stack = [];\n    var output = [];\n   \
    \ \n    // Go through each character in the string\n    for(var i=0; i<paren_string.length;\
    \ i++){\n        \n        // If we are in the middle of a left paren group, we\
    \ push it to the stack\n        if(paren_string[i] == \"(\"){\n            stack.push(paren_string[i]);\n\
    \        \n        // If we are in the middle of a right paren group, we pop from\
    \ the stack until we find a left paren\n        // group.\n        } else if(paren_string[i]\
    \ == \")\"){\n            while(stack.length != 0){\n                output.push(stack.pop());\n\
    \            }\n        }\n    }\n    \n    // Remove all left paren groups from\
    \ the output string\n    for(var i=output.length-1; i>=0; i--){\n        if(output[i]\
    \ == \")\"){\n            stack.push(output[i]);\n        }\n    }\n    \n   \
    \ // Return an array of all left paren groups\n    return output;\n}\n", "   \
    \ var regex_pattern = /\\(([^()]*)\\)/g;\n    var sub = paren_string.replace(regex_pattern,\
    \ function(a, b){return b.split(/[()]/);});\n    return sub;\n}", "\tvar parentheses_pattern\
    \ = /\\(([^()]+)\\)/g;\n\tvar open_groups = [],\n\t\tparen_groups = [],\n\t\t\
    close_groups = [];\n\tvar result;\n\twhile (result = parentheses_pattern.exec(paren_string)){\n\
    \t\tparen_groups.push(result[1]);\n\t}\n\tvar opening_pattern = /\\(([^()]+)\\\
    )/;\n\twhile (result = opening_pattern.exec(paren_string)){\n\t\topen_groups.push(result[1]);\n\
    \t}\n\tvar closing_pattern = /([^\\)]+)\\)/;\n\twhile (result = closing_pattern.exec(paren_string)){\n\
    \t\tclose_groups.push(result[1]);\n\t}\n\t\n\topen_groups.forEach(function (opening_group){\n\
    \t\tclosing_groups.forEach(function (closing_group){\n\t\t\tparentheses_pattern.lastIndex\
    \ = 0;\n\t\t\tvar group_length = parentheses_pattern.exec(opening_group).index;\n\
    \t\t\tparentheses_pattern.lastIndex = 0;\n\t\t\tif (closing_group.length > (group_length\
    \ + 1)){\n\t\t\t\tparentheses_pattern.lastIndex = 0;\n\t\t\t}\n\t\t\tvar closed_group\
    \ = parentheses_pattern.exec(paren_string);\n\t\t\tvar opening_paren = parentheses_pattern.exec(paren_string);\n\
    \t\t\twhile (opening_paren){\n\t\t\t\tif (opening_paren[0] == closing_group){\n\
    \t\t\t\t\tparentheses_pattern.lastIndex = 0;\n\t\t\t\t\tclosing_groups.push(opening_paren[0]);\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (opening_paren[0] == opening_group){\n\
    \t\t\t\t\tparentheses_pattern.lastIndex = 0;\n\t\t\t\t\topening_groups.push(closing_group);\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\topening_paren = parentheses_pattern.exec(paren_string);\n\
    \t\t\t}\n\t\t\tparentheses_pattern.lastIndex = 0;\n\t\t});\n\t});\n\treturn paren_groups;\n\
    }\n\n", "  var result = [];\n  var group_count = 0; // Counter to keep track of\
    \ open brace count\n  var open_braces = 0;\n  var open_brace_level = 0; // Keeps\
    \ track of the nested brace level\n  var current_group = null; // Group that has\
    \ been added to the result\n  var current_group_level = null; // Group level that\
    \ has been added to the result\n  var open_paren = 0; // Tracks the number of\
    \ open parens within current group\n  var closed_paren = 0; // Tracks the number\
    \ of closed parens within current group\n  for (var i = 0; i < paren_string.length;\
    \ i++){\n    if (paren_string[i] == '('){\n      open_braces++;\n      open_brace_level++;\n\
    \      if (open_braces > 1){\n        open_braces++;\n        open_brace_level++;\n\
    \      }\n      current_group = paren_string.substring(i, i+1);\n      current_group_level\
    \ = open_brace_level;\n      result.push(current_group);\n    } else if (paren_string[i]\
    \ == ')'){\n      open_braces--;\n      if (open_braces == 0 && open_brace_level\
    \ == 0){\n        current_group = \"\";\n        current_group_level = open_brace_level;\n\
    \        result.push(current_group);\n      }\n    } else if (paren_string[i]\
    \ == ' ' && current_group != null && current_group_level != open_brace_level){\n\
    \      closed_paren = 0;\n      for (var j = i; j + 1 < paren_string.length &&\
    \ paren_string[j] == ' ' && paren_string[j + 1] == paren_string[j] && (j + 2)\
    \ < paren_string.length; j++){\n        closed_paren++;\n      }\n      for (var\
    \ k = i; k + 2 < paren_string.length && paren_string[k] == ' ' && paren_string[k\
    \ + 1] == paren_string[k] && paren_string[k + 2] == paren_string[k] && (k + 3)\
    \ < paren_string.length; k++){\n        closed_paren++;\n      }\n      for (var\
    \ n = i; n + 3 < paren_string.length && paren_string[n] == ' ' && paren_string[n\
    \ + 1] == paren_string[n] && paren_string[n + 2] == paren_string[n] && paren_string[n\
    \ + 3] == paren_string[n] && (n + 4) < paren_string.length; n++){\n        closed_paren++;\n\
    \      }\n      for (var p = i; p - 4 >= 0 && paren_string[p] == ' ' && paren_string[p\
    \ + 1] == paren_string[p] && paren_string[p + 2] == paren_string[p] && paren_string[p\
    \ + 3] == paren_string[p] && paren_string[p + 4] == paren_string[p] && (p - 4)\
    \ >= 0; p--){\n        closed_paren++;\n      }\n      result.push(paren_string.substring(i,\
    \ i+closed_paren));", "    paren_string = paren_string.replace(/ /g, '');\n  \
    \  var groups = paren_string.match(/[()]/g);\n    return groups;\n}\n", "  \n\
    \  if(!paren_string){\n    console.log(\"You need to pass in a string containing\
    \ at least one set of parentheses\");\n    return null;\n  }\n  \n  var groups\
    \ = [];\n  var group_char = \"\";\n  var paren_char;\n  var depth = 0;\n  var\
    \ group_string = \"\";\n  \n  //Use a for loop to iterate through the string one\
    \ character at a time, incrementing a variable called depth when it encounters\
    \ a parenthesis character\n  for(var i = 0; i<paren_string.length;i++){\n    \n\
    \    //Check to see if we're at the end of our string\n    if(i == paren_string.length-1){\n\
    \      //Check to see if we're at the end of our groups\n      if(depth == 0){\n\
    \        //If we are, create a new group and append it to our groups array\n \
    \       groups.push(group_string);\n        group_string = \"\";\n      }\n  \
    \    else{\n        //Otherwise, create a new string for the next group and append\
    \ it to our string\n        group_string = group_string + paren_char;\n      }\n\
    \    }\n    else{\n      //Check to see if we're currently at a parenthesis character\n\
    \      if(paren_string[i] === \"(\"){\n        \n        //Increment the depth\
    \ counter\n        depth++;\n        \n        //Set our paren_char to whatever\
    \ the next character is and remove it from the paren_string\n        paren_char\
    \ = paren_string[i+1];\n        paren_string = paren_string.substr(0,i+1);\n \
    \     }\n      else if(paren_string[i] === \")\"){\n        \n        //Decrease\
    \ the depth counter\n        depth--;\n        \n        //Check to see if we're\
    \ at the top of our groups. If so, append our groups to the groups array\n   \
    \     if(depth == 0){\n          groups.push(group_string);\n          group_string\
    \ = \"\";\n        }\n        else{\n          //Otherwise, append our group_string\
    \ to the current group\n          group_string = group_string + paren_char;\n\
    \        }\n        \n        //Set our paren_char to an empty string to reset\
    \ our counter\n        paren_char = \"\";\n      }\n      else{\n        //Otherwise,\
    \ just append the current character to the string\n        group_string = group_string\
    \ + paren_string[i];\n      }\n    }\n  }\n  \n  //Return the groups array\n \
    \ return groups;\n}\n", "  let paren_string = paren_string.trim();\n  let paren_groups\
    \ = [];\n\n  for (let i = 0; i < paren_string.length; i++) {\n    let char = paren_string[i];\n\
    \    let open_paren = paren_string.substring(0, i).search(/[a-z]/);\n\n    if\
    \ (open_paren != -1) {\n      paren_groups[open_paren] = paren_groups[open_paren]\
    \ + char;\n    }\n  }\n\n  paren_groups = paren_groups.filter(function (el) {\n\
    \    return el;\n  })\n  return paren_groups;\n}", "\treturn paren_string.match(/\\\
    (+|\\)+|\\(|\\)|\\)/gi)\n}\n", "    var paren_string = paren_string.replace(/\\\
    s+/g,'');\n    var paren_regexp = /\\(/g;\n    var paren_match;\n    var groups\
    \ = [];\n    var curr = '';\n    var group = '';\n    while(paren_match = paren_regexp.exec(paren_string)){\n\
    \        curr+=paren_match[0];\n        if(paren_match[0].indexOf('(') > 0){\n\
    \            groups.push(group);\n            group = '';\n        }else{\n  \
    \          group+=paren_match[0];\n        }\n    }\n    if(group){\n        groups.push(group);\n\
    \    }\n    return groups;\n}\n", "    // Store the array of strings in a variable\
    \ so we don't create a new object every time we call the function\n    var return_array\
    \ = [];\n    // Store the count of open braces in the string and keep incrementing\
    \ it by the number of open braces encountered in the string\n    var open_count\
    \ = 0;\n    // Keep incrementing the count of the number of closed parenthesis\n\
    \    var closed_count = 0;\n    // Loop through each character in the input string\n\
    \    for(var i=0;i<paren_string.length;i++){\n        // If there is a closed\
    \ parenthesis then increment the count and break the loop\n        if(paren_string[i]\
    \ == \"(\"){\n            open_count++;\n        }\n        // If there is a closed\
    \ parenthesis then decrement the count and break the loop\n        else if(paren_string[i]\
    \ == \")\"){\n            open_count--;\n        }\n        // If there is a open\
    \ brace then increment the count and break the loop\n        else if(paren_string[i]\
    \ == \"{\"){\n            open_count++;\n        }\n        // If there is a open\
    \ brace then decrement the count and break the loop\n        else if(paren_string[i]\
    \ == \"}\"){\n            open_count--;\n        }\n        // If there was a\
    \ closing parenthesis then decrement the count and break the loop\n        else\
    \ if(paren_string[i] == \")\" && open_count <= 0){\n            closed_count++;\n\
    \            break;\n        }\n        // If there was a closing brace then decrement\
    \ the count and break the loop\n        else if(paren_string[i] == \"}\" && open_count\
    \ <= 0){\n            closed_count--;\n            break;\n        }\n       \
    \ // If there was an open brace and a closing brace then increment the count and\
    \ break the loop\n        else if(paren_string[i] == \"{\" && paren_string[i+1]\
    \ == \"}\"){\n            open_count++;\n            break;\n        }\n     \
    \   // If there was an open brace and a closing brace then decrement the count\
    \ and break the loop\n        else if(paren_string[i] == \"}\" && paren_string[i+1]\
    \ == \"{\"){\n            open_count--;\n            break;\n        }\n     \
    \   // If there was an open brace and a closing parenthesis then increment the\
    \ count and break the loop\n        else if(paren_string[i] == \"{\" && paren_string[i+1]\
    \ == \")\"){\n            open_count++;\n            break;\n        }\n     \
    \   // If there was an open brace and a closing parenthesis then decrement the\
    \ count and break the loop\n        else if(paren_string[i] == \"}\" && paren_string[i+1]\
    \ == \"(\"){\n            open_count--;\n            break;\n        }\n     \
    \   // If there was an open parenthesis and a closing parenthesis then increment\
    \ the count and break the loop\n        else if(paren_string[i] == \")\" && paren_string[i+1]\
    \ == \")\")", "    paren_string = paren_string.replace(/\\s+/g,\"\");\n    var\
    \ paren_string_list = paren_string.split(\" \");\n    var new_array = [];\n  \
    \  for(var i = 0; i < paren_string_list.length; i++){\n        var current_group\
    \ = paren_string_list[i];\n        if(current_group[0] != \"(\" && current_group[0]\
    \ != \")\"){\n            new_array.push(current_group);\n        }else{\n   \
    \         var current_group_array = new_array;\n            var j = i;\n     \
    \       while(current_group_array[j-1] != \")\"){\n                current_group_array[j]\
    \ = \"(\" + current_group_array[j-1] + \")\";\n                j++;\n        \
    \    }\n            current_group_array.splice(j-1,1);\n        }\n    }\n   \
    \ return new_array;\n}\n</code>\n<|/ a dscore=2 tags=arrays,javascript,string\
    \ |>\n<| c |>\nCan you please explain this code?\n<|/ c |>\n<| c |>\nI tried to\
    \ explain my code in the comments of the code block\n<|/ c |>\n<| a tags=arrays,javascript,string\
    \ |>\nThis answer is based on the following assumptions:\n\nParenthesis are only\
    \ used as an indicator of where a group of parenthesis begins and where it ends.\n\
    There is only one set of parenthesis in any given string. \nThere must be at least\
    \ 2 pairs of parenthesis (to satisfy the requirement of at least two groups being\
    \ separate).\n\nBased on these assumptions, we can create an array with empty\
    \ elements at the beginning of each group of parenthesis that was found. Then\
    \ we can simply iterate over the string's characters to see if we should remove\
    \ a parenthesis until the end of the string or until we find a set of parenthesis\
    \ that end in a closing parenthesis. If a pair of parenthesis match ending is\
    \ found, we just remove that set of parenthesis and continue checking the rest\
    \ of the string for the next set of parenthesis. If no more pairs of parenthesis\
    \ are found, we can simply add a new empty element to the array and continue checking\
    \ the rest of the string.\n\n<code>", "  var open_brackets=[],\n      closing_parens=[],\n\
    \      current_bracket=\"\",\n      current_string=\"\";\n\n  for(var i=0; i<paren_string.length;i++){\n\
    \    current_string+=paren_string[i];\n    if(current_string==\"(\"){\n      open_brackets.push(current_bracket);\n\
    \    }else if(current_string==\")\"){\n      closing_parens.push(current_bracket);\n\
    \    }else if(current_string==\" \"){\n      if(open_brackets.length==0){\n  \
    \      continue;\n      }\n      var next_bracket=open_brackets.pop();\n     \
    \ if(closing_parens.indexOf(next_bracket)==-1){\n        if(open_brackets.length==0){\n\
    \          continue;\n        }else{\n          current_string=\"\";\n       \
    \   current_bracket=\"\";\n        }\n      }\n    }else if(current_string==\"\
    [\"){\n      open_brackets.push(current_bracket);\n    }else if(current_string==\"\
    ]\"){\n      closing_parens.push(current_bracket);\n    }\n  }\n\n  if(open_brackets.length>0\
    \ && closing_parens.length>0){\n    return [];\n  }else if(open_brackets.length>0){\n\
    \    return open_brackets;\n  }else if(closing_parens.length>0){\n    return closing_parens;\n\
    \  }else{\n    return [current_string];\n  }\n}\n", "  var groupArray = [];\n\
    \  var opening_braces;\n  paren_string = paren_string.trim();\n  if (paren_string.match(/^\\\
    s*$/)){\n    return [];\n  }\n\n  // Handle the case where there is only one opening\n\
    \  if (paren_string.match(/^[^()]$/)) {\n    return [paren_string];\n  }\n\n \
    \ // Loop through each of the paren groups\n  opening_braces = paren_string.match(/^\\\
    s*\\(\\s*$/);\n  paren_string = paren_string.replace(/^\\s*\\(\\s*|\\s*$/g, '');\n\
    \n  while (opening_braces != null){\n    // Grab the text of the paren\n    var\
    \ paren = opening_braces[1];\n\n    // Remove the paren from the string\n    paren_string\
    \ = paren_string.replace(paren, '');\n\n    // Grab the string within the paren\n\
    \    var inner = paren_string.match(/^\\s*\\(\\s*([^)]+)\\s*\\)\\s*$/);\n    paren_string\
    \ = paren_string.replace(/^\\s*\\(\\s*|\\s*$/g, '');\n\n    // Add the paren to\
    \ the groupArray\n    groupArray.push(paren);\n\n    // If there is another paren\
    \ group, recurse\n    if (inner.length > 0){\n      groupArray = groupArray.concat(separate_paren_groups(inner[1]));\n\
    \    }\n\n    // Grab the next paren group\n    opening_braces = paren_string.match(/^\\\
    s*\\(\\s*$/);\n    paren_string = paren_string.replace(/^\\s*\\(\\s*|\\s*$/g,\
    \ '');\n  }\n\n  return groupArray;\n}\n", "\tvar opening_paren_group_count =\
    \ {};\n\tvar opening_paren_groups = [];\n\tvar paren_groups = [];\n\tvar group_regex\
    \ = /(\\([^\\(\\)]+\\))/g;\n\twhile(paren_string.length > 0){\n\t\tparen_string\
    \ = paren_string.replace(group_regex, '');\n\t\tvar paren_matches = paren_string.match(group_regex);\n\
    \t\tif(paren_matches != null){\n\t\t\tvar paren_match = paren_matches[0];\n\t\t\
    \tvar paren_length = paren_match.length;\n\t\t\tvar paren_start = paren_string.indexOf(paren_match);\n\
    \t\t\tparen_string = paren_string.replace(paren_match, '');\n\t\t\tparen_groups.push(paren_string);\n\
    \t\t\topening_paren_group_count[paren_start] = 1;\n\t\t}\n\t}\n\tvar paren_group_length\
    \ = opening_paren_groups.length;\n\tfor(var i = 0; i < paren_group_length; i++){\n\
    \t\tif(opening_paren_groups[i] == \"\"){\n\t\t\topening_paren_groups[i] = \"()\"\
    ;\n\t\t}\n\t}\n\treturn paren_groups;\n}\n", "    //Create a variable to hold\
    \ our result\n    var result = [];\n    //Loop through the characters of the string\n\
    \    for (var i = 0, len = paren_string.length; i < len; i++){\n        //If the\
    \ character is a left paren\n        if (paren_string[i] == '('){\n          \
    \  //Create a new array and push the current character onto it\n            result.push('');\n\
    \            //Loop through the characters of the string\n            for (var\
    \ x = i + 1, len = paren_string.length; x < len; x++){\n                //If the\
    \ character is not a left paren\n                if (paren_string[x] != ')'){\n\
    \                    //Push the current character onto the result array\n    \
    \                result[i] += paren_string[x];\n                } else {\n   \
    \                 //End the current character grouping\n                    result.push(result[i]);\n\
    \                    //Reset the current character grouping\n                \
    \    result[i] = '';\n                    //Loop through the characters of the\
    \ string again\n                    for (var y = x + 1, len = paren_string.length;\
    \ y < len; y++){\n                        //If the character is a right paren\n\
    \                        if (paren_string[y] == '('){\n                      \
    \      //Push the current character onto the result array\n                  \
    \          result.push(paren_string[y]);\n                        }\n        \
    \            }\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\n", "  if(!paren_string) return [];\n  let paren_string = paren_string.replace(/\\\
    s+/g, '').toLowerCase();\n  let groups = [];\n  let open_brace_count = 0;\n  let\
    \ closed_count = 0;\n  let open_paren_positions = [];\n  let bracket_positions\
    \ = [];\n  for(let i = 0; i < paren_string.length; i++){\n    let char = paren_string.charAt(i);\n\
    \    if(char === '('){\n      open_paren_positions.push(i);\n      open_brace_count++;\n\
    \    }else if(char === '{') {\n      closed_count++;\n      bracket_positions.push(i);\n\
    \    }else if(char === ')'){\n      closed_count--;\n      if(closed_count <=\
    \ 0 && open_brace_count > 0 && open_paren_positions.length > 0){\n        bracket_positions.pop();\n\
    \        open_brace_count--;\n      }\n    }\n  }\n  for(let i = 0; i < open_paren_positions.length;\
    \ i++){\n    groups.push(paren_string.substr(open_paren_positions[i] - 1, 1));\n\
    \  }\n  return groups;\n}\n", "    var results = [];\n\n    var regex = new RegExp('('\
    \ + paren_string.split(' ').join('|') + ')', 'ig');\n    matches = paren_string.match(regex);\n\
    \n    if (matches){\n        for (i = 0; i < matches.length; i++){\n         \
    \   //Add an extra group to the beginning of the result set and remove the last\
    \ group\n            if (i == 0){\n                results.push(matches[i].substr(1,\
    \ matches[i].length - 2));\n            } else {\n                results.push(matches[i].substr(1,\
    \ matches[i].length - 1));\n            }\n        }\n    }\n    return results;\n\
    }\n", "  if(paren_string.length <= 0){\n    return [];\n  }\n  var nested_paren_string\
    \ = paren_string.replace(/(\\s|.)\\(/g, '$1(');\n  var non_nested_paren_string\
    \ = nested_paren_string.replace(/(\\s|.)\\)/g, '$1)');\n  non_nested_paren_string\
    \ = non_nested_paren_string.replace(/(\\s|.)\\(/g, '$1(');\n  non_nested_paren_string\
    \ = non_nested_paren_string.replace(/(\\s|.)\\)/g, '$1)');\n  var nested_paren_group\
    \ = non_nested_paren_string.match(/[^()]+/g);\n  var non_nested_paren_group =\
    \ non_nested_paren_string.match(/[^()]+/g);\n  if(nested_paren_group.length >=\
    \ nested_paren_group.length){\n    return nested_paren_group.map((str) => \"(\"\
    \ + str + \")\").concat(separate_paren_groups(non_nested_paren_string)).map((str)\
    \ => str);\n  }\n  return separate_paren_groups(non_nested_paren_string);\n}\n",
  "\treturn paren_string.replace(/\\s+/gi,\"\").match(/[^()]+/g);\n}", "\tlet output\
    \ = [];\n\tlet current = '';\n\tlet in_group = false;\n\tlet count = 0;\n\tfor\
    \ (let i = 0; i < paren_string.length; i++){\n\t\tlet char = paren_string[i];\n\
    \t\tif (char == '('){\n\t\t\tin_group = true;\n\t\t}\n\t\telse if (char == ')'){\n\
    \t\t\tif (in_group){\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\toutput.push(current);\n\
    \t\t\t\tcurrent = '';\n\t\t\t}\n\t\t}\n\t\telse if (char == ' ' && in_group){\n\
    \t\t\tcurrent = '';\n\t\t}\n\t\telse {\n\t\t\tcurrent += char;\n\t\t}\n\t}\n\t\
    if (current.length){\n\t\toutput.push(current);\n\t}\n\treturn output;\n}\n",
  "\tparen_string = paren_string.replace(/(\\s{2,})/g,\" \");\n\tparen_string = paren_string.replace(/(\\\
    (\\(|\\)\\)|\\(\\)|\\())/g,\"\"); //Remove extra brackets from paren_string\n\t\
    var new_string = \"\";\n\tvar paren_groups = []; //Create an array that will hold\
    \ the groups of parenthesis.\n\t\n\t//Iterate over each character in paren_string\n\
    \tfor(var i=0;i<paren_string.length;i++){ //i is index of current char in string\n\
    \t\t\n\t\t//If the current char is a parentheses, add it to the array\n\t\tif(paren_string[i]\
    \ == \"(\")\n\t\t\tparen_groups.push(paren_string[i]);\n\t\t\n\t\t//If the current\
    \ char is a parentheses, add it to the array\n\t\telse if(paren_string[i] == \"\
    )\"){\n\t\t\t//If there are any open parentheses in the array\n\t\t\tif(paren_groups.length\
    \ > 0){\n\t\t\t\t//Add any open parentheses to the first group\n\t\t\t\tnew_string\
    \ += paren_groups[0];\n\t\t\t\t//Then remove the first group from the array\n\t\
    \t\t\tparen_groups = paren_groups.slice(1);\n\t\t\t\t//Finally append the remaining\
    \ parentheses to the first group\n\t\t\t\tnew_string += paren_string[i];\n\t\t\
    \t}\n\t\t\telse{\n\t\t\t\tnew_string += paren_string[i];\n\t\t\t}\n\t\t}\n\t\t\
    //If the current char is a space, then add the char to the new_string\n\t\telse\
    \ if(paren_string[i] == \" \"){\n\t\t\tnew_string += paren_string[i];\n\t\t}\n\
    \t}\n\treturn new_string;\n}\n", "    var re_string = '\\\\(([^\\\\()]*?[^\\\\\
    (])\\\\)';\n    var matches;\n    while ((matches = re.exec(paren_string)) !==\
    \ null) {\n        if(matches.length>1) {\n            paren_string = paren_string.replace(matches[0],\
    \ \"$2\");\n        }\n    }\n    return paren_string.split(' ');\n}\n\n", " \
    \ // Use a regex to find the groups of parens\n  // Then return an array of the\
    \ paren groups as strings\n  return paren_string.match(/\\(([^()]+)\\)/ig);\n\
    }\n</code></pre>\n        </article>\n    </section>\n\n\n\n\n</div>\n\n<nav>\n\
    \    <h2><a href=\"index.html\">Home</a></h2><h3>Classes</h3><ul><li><a href=\"\
    HTTP.html\">HTTP</a></li><li><a href=\"Magister.html\">Magister</a></li><li><a\
    \ href=\"Session.html\">Session</a></li></ul><h3>Namespaces</h3><ul><li><a href=\"\
    Magister.html\">Magister</a></li></ul>\n</nav>\n\n<br class=\"clear\">\n\n<footer>\n\
    \    Documentation generated by <a href=\"https://github.com/jsdoc3/jsdoc\">JSDoc\
    \ 3.4.0</a> on Sat Jan 09 2017 23:53:16 GMT-0700 (MST)\n</footer>\n\n<script>\
    \ prettyPrint(); </script>\n<script src=\"scripts/linenumber.js\"> </script>\n\
    </body>\n</html>\n\n<|/ file ext=.html |>\n<| c |>\nYeah I know, but I'm stuck\
    \ on how to get the nested groups to separate.\n<|/ c |>\n<| c |>\nWhat do you\
    \ mean by \"nested groups\"? The code I provided separates nested parentheses\
    \ from the parenthesis string and returns the array of nested parentheses\n<|/\
    \ c |>\n<| c |>\nYes, the string \"( ) (( )) (( )( ))\" returns [\"()\", \"(())\"\
    , \"(()())\"]\n<|/ c |>\n<| c |>\nI added my entire code so you can see what I'm\
    \ talking about. I hope that helps\n<|/ c |>\n<| c |>\nOk, I see what you are\
    \ trying to do. I will update my answer.\n<|/ c |>\n<| a |>\nOk, I see what you\
    \ are trying to do now. You want to separate all parenthesis grouped together.\
    \ I think it would be best to use a regex. You can do that by doing something\
    \ like this:\n<code>", "\tvar bracket_level = 0,\n\t\tparentheses_stack = [],\n\
    \t\tparen_string = paren_string.toString();\n\tfor(var i=0; i < paren_string.length;\
    \ i++){\n\t\tvar cur = paren_string[i];\n\t\tif((paren_string[i] === '(') && parenthesis_stack.length){\n\
    \t\t\tparenthesis_stack[parenthesis_stack.length-1].push(cur);\n\t\t}else if((paren_string[i]\
    \ === ')') && parenthesis_stack.length){\n\t\t\tparenthesis_stack.splice(parenthesis_stack.length-1,\
    \ 1);\n\t\t}else if((cur === '(') && (parenthesis_stack.length)){\n\t\t\tparenthesis_stack.push([]);\n\
    \t\t}else if((cur === ')') && (parenthesis_stack.length)){\n\t\t\tbracket_level--;\n\
    \t\t\twhile(parenthesis_stack[parenthesis_stack.length-1].length){\n\t\t\t\tparenthesis_stack.pop();\n\
    \t\t\t}\n\t\t}else if((cur === '(') && (bracket_level === 0) && parenthesis_stack.length){\n\
    \t\t\tparenthesis_stack.push([]);\n\t\t}else if((cur === ')') && (bracket_level\
    \ === 0) && parenthesis_stack.length){\n\t\t\tparenthesis_stack.splice(parenthesis_stack.length-1,\
    \ 1);\n\t\t}else if((cur === '(') && (bracket_level > 0) && parenthesis_stack.length){\n\
    \t\t\tparenthesis_stack[parenthesis_stack.length-1].push(cur);\n\t\t}else if((cur\
    \ === ')') && (bracket_level > 0) && parenthesis_stack.length){\n\t\t\tbracket_level--;\n\
    \t\t}else if((cur === '(') && (bracket_level === 0) && (parenthesis_stack.length)){\n\
    \t\t\tparenthesis_stack.push([]);\n\t\t}else if((cur === ')') && (bracket_level\
    \ === 0) && (parenthesis_stack.length)){\n\t\t\tparenthesis_stack.splice(parenthesis_stack.length-1,\
    \ 1);\n\t\t}else if((cur === '(') && (bracket_level > 0) && (parenthesis_stack.length)){\n\
    \t\t\tparenthesis_stack[parenthesis_stack.length-1].push(cur);\n\t\t}else if((cur\
    \ === ')') && (bracket_level > 0) && (parenthesis_stack.length)){\n\t\t\tbracket_level--;\n\
    \t\t}\n\t}\n\treturn parenthesis_stack[0].toString();\n}\n", "\tvar paren_groups\
    \ = [];\n\tvar parentheses_open = [];\n\tvar parentheses_close = [];\n\tvar paren_open_counter\
    \ = 0;\n\tvar paren_close_counter = 0;\n\tvar parentheses_group = 0;\n\tvar parentheses_depth\
    \ = 0;\n\tvar parentheses_open_counter = 0;\n\tvar parentheses_close_counter =\
    \ 0;\n\twhile(parentheses_open_counter < paren_open_counter && parentheses_close_counter\
    \ < paren_close_counter){\n\t\tvar open_counter = 0;\n\t\tvar close_counter =\
    \ 0;\n\t\tvar group_counter = 0;\n\t\tvar depth_counter = 0;\n\t\tvar open_depth\
    \ = 0;\n\t\twhile(open_counter < parentheses_open_counter){\n\t\t\tvar open_index\
    \ = parentheses_open[open_counter];\n\t\t\twhile(paren_groups[group_counter] ===\
    \ undefined && parentheses_depth > depth_counter){\n\t\t\t\tgroup_counter++;\n\
    \t\t\t\tdepth_counter++;\n\t\t\t}\n\t\t\tif(paren_groups[group_counter] === undefined){\n\
    \t\t\t\tparen_groups[group_counter] = [];\n\t\t\t\tparenthesis_depth = depth_counter;\n\
    \t\t\t\tparentheses_depth = depth_counter;\n\t\t\t\twhile(close_counter < parentheses_close_counter){\n\
    \t\t\t\t\tvar close_index = parentheses_close[close_counter];\n\t\t\t\t\tif(close_index\
    \ < open_index){\n\t\t\t\t\t\tparen_groups[group_counter].push(parentheses_group);\n\
    \t\t\t\t\t}\n\t\t\t\t\tclose_counter++;\n\t\t\t\t}\n\t\t\t\topen_counter++;\n\t\
    \t\t}\n\t\t}\n\t\twhile(paren_groups[group_counter] !== undefined){\n\t\t\tparentheses_open_counter++;\n\
    \t\t\tparen_groups[group_counter].push(parentheses_group);\n\t\t\tparentheses_close_counter++;\n\
    \t\t\tgroup_counter++;\n\t\t}\n\t\twhile(parentheses_open_counter < parentheses_open_counter\
    \ && parentheses_close_counter < parentheses_close_counter){\n\t\t\tvar close_index\
    \ = parentheses_close[parentheses_close_counter];\n\t\t\tvar open_index = parentheses_open[parentheses_open_counter];\n\
    \t\t\twhile(close_counter < parentheses_close_counter){\n\t\t\t\tif(paren_groups[group_counter]\
    \ !== undefined){\n\t\t\t\t\tparentheses_close_counter++;\n\t\t\t\t\tif(parentheses_depth\
    \ > depth_counter){\n\t\t\t\t\t\tparen_groups[group_counter].push(parentheses_group);\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclose_counter++;\n\t\t\t}\n\t\t\twhile(open_counter\
    \ < parentheses_open_counter){\n\t\t\t\tvar open_index = parentheses_open[parentheses_open_counter];\n\
    \t\t\t\tif(parentheses_depth > depth_counter){\n\t\t\t\t\tparen_groups[group_counter].push(parentheses_group);\n\
    \t\t\t\t}\n\t\t\t\topen_counter++;\n\t\t\t}\n\t\t\tparentheses_open_counter++;\n\
    \t\t\tparentheses_close_counter++;\n\t\t\tgroup_counter++;\n\t\t}\n\t\tparentheses_open_counter\
    \ = 0;\n\t\tparentheses_close_", "\tif(!paren_string) return []\n\tlet group_strs\
    \ = []\n\tlet group_start = false\n\tlet level = 1\n\tfor (let i = 0; i < paren_string.length;\
    \ i++) {\n\t\tlet c = paren_string[i]\n\t\tif(c == '(') level++\n\t\telse if(c\
    \ == ')') {\n\t\t\tif(level == 0) group_strs.push(paren_string.slice(0, i))\n\t\
    \t\tlevel--\n\t\t}\n\t}\n\tif(level != 0) throw new Error(`Invalid paren string\
    \ for separation: ${paren_string}`)\n\treturn group_strs.map(s => s.trim())\n\
    }\n", "    // Separate groups of nested parentheses\n    // Use groups to separate\
    \ parentheses\n    // Groups are always separated by an opening parentheses or\
    \ a closing parentheses, and they are balanced\n    // Groups can be nested within\
    \ each other\n    var nested_paren_string = \"\";\n    var current_group = \"\"\
    ;\n    var in_group = false;\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        var char = paren_string[i];\n        if(char == \"(\" || char == \"{\"\
    \ || char == \"[\" || char == \"(\"){\n            if(in_group){\n           \
    \     current_group += char;\n            } else{\n                current_group\
    \ = \"\";\n                in_group = true;\n            }\n        } else{\n\
    \            if(current_group.length){\n                nested_paren_string +=\
    \ current_group;\n                current_group = \"\";\n            }\n     \
    \       current_group += char;\n            if(char == \")\" && in_group){\n \
    \               in_group = false;\n            }\n        }\n    }\n    if(current_group.length){\n\
    \        nested_paren_string += current_group;\n    }\n    \n    return nested_paren_string.match(/[\\\
    (\\)]+/g);\n}\n", "  var paren_groups = []\n  var paren_group_char\n  var paren_open_count\
    \ = 0\n  var paren_close_count = 0\n  var last_open_paren_char = \"\"\n  var last_open_paren_index\
    \ = 0\n  var next_open_paren_index\n  \n  for (var i=0; i<paren_string.length;\
    \ i++){\n    paren_group_char = paren_string[i]\n    \n    if (paren_group_char\
    \ === \"(\"){\n      paren_open_count++\n    } else if (paren_group_char === \"\
    )\"){\n      paren_close_count++\n    }\n    \n    if (paren_open_count === paren_close_count){\n\
    \      if (last_open_paren_char === \"(\"){\n        paren_groups.push(paren_string.substring(last_open_paren_index,\
    \ i+1))\n      }\n    }\n    \n    last_open_paren_char = paren_group_char\n \
    \   last_open_paren_index = i\n  }\n  \n  return paren_groups\n}\n", "  var group_array\
    \ = [];\n  var open_braces;\n  var close_braces;\n  var paren_braces;\n  var new_string;\n\
    \  var new_group;\n  for(var i = 0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      open_braces = open_braces || [];\n      open_braces.push(paren_braces\
    \ = paren_braces || []);\n    }\n    if(paren_string[i] === ')'){\n      close_braces\
    \ = close_braces || [];\n      close_braces.push(paren_braces = paren_braces ||\
    \ []);\n    }\n    if(close_braces) new_group = paren_braces.join('');\n    if(open_braces)\
    \ new_group = open_braces.join('') + new_group;\n    group_array.push(new_group);\n\
    \  }\n  if(close_braces) group_array.push(paren_braces.join(''));\n  return group_array;\n\
    }\n</code>\n<|/ a |>\n<| a tags=javascript,regex dscore=0 |>\nIf you need to process\
    \ multiple nested parentheses, I suggest using a stack-based algorithm that recursively\
    \ processes each parenthetical group. Here is an example implementation in javascript:\n\
    <code>", "    var paren_groups = paren_string.match(/\\(([^\\(\\)]+)\\)/gi);\n\
    \    return paren_groups;\n}\n", "    var group_match = [];\n    for(let i = 0;\
    \ i < paren_string.length; i++){\n        let current_group = paren_string[i];\n\
    \        let group_open = false;\n        let open_brace = 0;\n        let close_brace\
    \ = 0;\n        for(let j = i + 1; j < paren_string.length; j++){\n          \
    \  let next_char = paren_string[j];\n            if(next_char === '('){\n    \
    \            group_open = true;\n                open_brace++;\n            }else\
    \ if(next_char === ')'){\n                close_brace++;\n            }else if(next_char\
    \ === ' ' && !open_brace && !close_brace){\n                // This space is just\
    \ a single space between group elements\n                // so just keep going\n\
    \                continue;\n            }else if(next_char === ')' && group_open){\n\
    \                group_open = false;\n                open_brace--;\n        \
    \        close_brace--;\n                if(open_brace === 0 && close_brace ===\
    \ 0){\n                    group_match.push(current_group);\n                }\n\
    \            }else if(next_char === '(' && open_brace){\n                group_open\
    \ = true;\n                open_brace++;\n            }else if(next_char === ')'\
    \ && close_brace){\n                close_brace--;\n                if(open_brace\
    \ === 0 && close_brace === 0){\n                    group_match.push(current_group);\n\
    \                }\n            }\n        }\n    }\n    return group_match;\n\
    }", "    var open_parens = [],\n        closed_parens = [],\n        level = 0,\n\
    \        paren_level = 0,\n        curr_paren_string = paren_string;\n    while(curr_paren_string\
    \ != null){\n        if(curr_paren_string == \"(\"){\n            open_parens.push(paren_level);\n\
    \        }\n        else if(curr_paren_string == \")\"){\n            closed_parens.push(paren_level);\n\
    \        }\n        curr_paren_string = curr_paren_string.slice(0,-1);\n     \
    \   paren_level++;\n    }\n    open_parens = open_parens.reverse();\n    closed_parens\
    \ = closed_parens.reverse();\n    return open_parens.concat(closed_parens);\n}",
  "\tlet paren_count = 0;\n\tlet paren_array = [];\n\tfor(let char of paren_string){\n\
    \t\tif(char == \"(\") paren_count ++;\n\t\tif(char == \")\") paren_count --;\n\
    \t\tif(paren_count < 0) break;\n\t\tif(paren_count == 0){\n\t\t\tlet tmp_string\
    \ = paren_string.substring(0,paren_string.length-paren_count);\n\t\t\tlet tmp_count\
    \ = tmp_string.split(\"\").length;\n\t\t\tif(tmp_count > paren_array.length) paren_array\
    \ = paren_string.substring(0,paren_string.length-paren_count).split(\"\");\n\t\
    \t}\n\t}\n\treturn paren_array;\n}\n", "    var paren_strings = paren_string.match(/[^\\\
    (\\)\\s]+/g);\n    var paren_string_array = paren_strings.filter(Boolean);\n \
    \   return paren_string_array;\n}\n", "\treturn (paren_string||\"\").replace(/\\\
    \\([\\\\(])/g, \"$1\").match(/\\\\\\(([^\\(\\)]*)\\\\\\)/g)||[];\n}\n\n", "\t\
    let pattern = /\\(([^()]+)\\)/g;\n\tlet matches = paren_string.match(pattern);\n\
    \tif(matches === null || matches === undefined) {\n\t\treturn [];\n\t}\n\treturn\
    \ matches.map(function(match){\n\t\treturn match.replace(/\\s+/g, '');\n\t});\n\
    }\n", "  var result = \"\";\n  var group = \"\";\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    var char = paren_string.charAt(i);\n    if(char != \"(\"){\n    \
    \  result += group;\n      result += char;\n      group = \"\";\n    }else{\n\
    \      group += char;\n    }\n  }\n  result += group;\n  return result.split(\"\
    )(\").map(function(string){ return string.trim(); });\n}\n", "  let groups = [];\n\
    \  let open_groups = [];\n  let closed_groups = [];\n\n  let strings = paren_string.split(\"\
    \ \");\n  for(const string of strings){\n    if(!string || string === \"\"){\n\
    \      continue;\n    }\n    if(string.startsWith(\"(\")){\n      open_groups.push(string);\n\
    \    }else if(string.endsWith(\")\")){\n      closed_groups.push(string);\n  \
    \  }else{\n      groups.push(string + \"()\");\n    }\n  }\n\n  return groups.concat(open_groups,\
    \ closed_groups);\n}\n", "  let result = [];\n  paren_string = paren_string.trim();\n\
    \  let levels_open = paren_string.match(/\\(/g);\n  let levels_closed = paren_string.match(/\\\
    )/g);\n  let spaces_open = paren_string.match(/\\s+/g);\n  let spaces_closed =\
    \ paren_string.match(/\\)\\s+/g);\n  let openingBraces = 0;\n  let closingBraces\
    \ = 0;\n  let spacesBetweenBraces = 0;\n  for (let i = 0; i < levels_open.length;\
    \ i++){\n    openingBraces += 1;\n  }\n  for (let j = 0; j < levels_closed.length;\
    \ j++){\n    closingBraces += 1;\n  }\n  for (let m = 0; m < spaces_open.length;\
    \ m++){\n    spacesBetweenBraces += 1;\n  }\n  for (let n = 0; n < spaces_closed.length;\
    \ n++){\n    spacesBetweenBraces -= 1;\n  }\n  if (spacesBetweenBraces !== 0){\n\
    \    console.log(\"spacesBetweenBraces is not a multiple of 2 or the input is\
    \ not correctly nested\");\n  }\n  else{\n    if (openingBraces !== closingBraces){\n\
    \      console.log(\"openingBraces is not equal to closingBraces\");\n    }\n\
    \    else{\n      console.log(\"openingBraces is equal to closingBraces, meaning\
    \ the input string is correctly nested\");\n      result.push(paren_string);\n\
    \    }\n  }\n  return result;\n}\n", "  // Your code here\n  let output = []\n\
    \  let stack = [paren_string]\n  while (stack.length > 0) {\n    let new_string\
    \ = ''\n    let depth = 0\n    for (let index = 0; index < stack.length; ++index)\
    \ {\n      new_string += stack[index]\n      if (stack[index] === '(') {\n   \
    \     depth += 1\n      }\n      if (stack[index] === ')') {\n        depth -=\
    \ 1\n      }\n      if (depth > 0) {\n        stack[index] = ''\n      } else\
    \ {\n        stack[index] = new_string\n      }\n    }\n    output.push(new_string)\n\
    \  }\n  return output\n}\n", "\tlet result = [];\n\t// Get all groups of parentheses\n\
    \tlet parens = paren_string.match(/\\(([^()]*|(?R))*\\)/g);\n\t// If no groups\
    \ were found, return null\n\tif(parens == null) return null;\n\t// Loop over each\
    \ group of parens\n\tfor (let i = 0; i < parens.length; i++){\n\t\t// Get each\
    \ open paren group\n\t\tlet open_paren_group = parens[i];\n\t\t// Get the next\
    \ open paren group\n\t\tlet next_open_paren_group = parens[i+1];\n\t\t// If we\
    \ have an open paren group and a following close paren group\n\t\tif(open_paren_group\
    \ != null && next_open_paren_group != null){\n\t\t\t// Make sure the next open\
    \ paren group is properly closed\n\t\t\tif(next_open_paren_group != \")\"){\n\t\
    \t\t\t// Add the current open paren group to the result array if not already there\n\
    \t\t\t\tif(result.indexOf(open_paren_group) < 0){\n\t\t\t\t\tresult.push(open_paren_group);\n\
    \t\t\t\t}\n\t\t\t\t// Add the next open paren group to the result array if not\
    \ already there\n\t\t\t\tif(result.indexOf(next_open_paren_group) < 0){\n\t\t\t\
    \t\tresult.push(next_open_paren_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n", "  var paren_regex = /^\\s*\\(\\s*([^\\(\\)]+?)\\s*\\)\\s*$/gm;\n\
    \  var paren_matches;\n  var pars = [];\n  var match;\n  while(match = paren_regex.exec(paren_string)){\n\
    \    // Make sure parenthesis match is balanced.\n    // If it isn't add them\
    \ to the last array.\n    if(pars.length > 0 && !paren_matches.every(function(p){\
    \ return p.index === match.index && p.paren === paren_matches.paren; })) pars.pop();\n\
    \    pars.push(match[1]);\n    // Add those parenthesis to the current set of\
    \ parenthesis.\n    paren_matches = {index: paren_regex.lastIndex - match[0].length,\
    \ paren: match[1]};\n  }\n  return pars;\n}\n", "    var opening_paren_groups\
    \ = [];\n    var closing_paren_groups = [];\n    for (var i=0; i<paren_string.length;\
    \ i++){\n        if (paren_string[i] === '('){\n            opening_paren_groups.push(paren_string[i]);\n\
    \        } else if (paren_string[i] === ')'){\n            closing_paren_groups.push(paren_string[i]);\n\
    \        }\n    }\n    return opening_paren_groups.concat(closing_paren_groups);\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like your use of recursive functions\
    \ to solve this problem.\n<|/ c |>\n<| a |>\nOne solution with recursive functions:\n\
    <code>", "  var paren_groups = [];\n  var open_brackets = [];\n  var open_brackets_string\
    \ = \"\";\n  var nested_open_brackets = 0;\n  for(var i=0; i<paren_string.length;\
    \ i++){\n    switch(paren_string[i]){\n      case \"(\":\n        if(nested_open_brackets\
    \ == 0){\n          nested_open_brackets++;\n        }else{\n          nested_open_brackets--;\n\
    \        }\n        break;\n      case \")\":\n        nested_open_brackets++;\n\
    \        break;\n      case \")(\": // We close a bracket we opened earlier\n\
    \        nested_open_brackets--;\n        break;\n      case \")(\": // We close\
    \ a bracket we opened earlier which was already closed\n        nested_open_brackets--;\n\
    \        break;\n      default:\n        if(nested_open_brackets > 0 && nested_open_brackets\
    \ == 1){\n          open_brackets.push(paren_string[i]);\n        }\n        break;\n\
    \    }\n  }\n  if(nested_open_brackets > 0){\n    for(var i=0; i<open_brackets.length;\
    \ i++){\n      open_brackets_string += open_brackets[i] + \" \"; // Add space\
    \ in between groups of brackets we opened\n    }\n    return open_brackets_string;\n\
    \  }\n  if(open_brackets.length == 0){\n    return paren_string;\n  }\n  for(var\
    \ i=0; i<open_brackets.length; i++){\n    paren_groups.push(open_brackets[i]);\n\
    \  }\n  return paren_groups;\n}\n", "\tlet open_braces = []; // stores all the\
    \ open brace groups found by recursion\n\tlet close_braces = []; // stores all\
    \ the close brace groups found by recursion\n\tlet found_open_braces = 0; // stores\
    \ how many open braces are found so far\n\tlet found_close_braces = 0; // stores\
    \ how many close braces are found so far\n\tlet open_brace_counter = 0; // stores\
    \ how many open braces have yet to be closed\n\t\n\t//Recursively search through\
    \ each character in the string\n\tfor(let i = 0; i < paren_string.length; i++){\n\
    \t\t\n\t\t//If there is a closing brace within the open brace, add it to the close_brace\
    \ array\n\t\tif(paren_string[i] == \"(\" && paren_string[i+1] == \"(\"){\n\t\t\
    \tclose_braces.push(paren_string.slice(i,i+3));\n\t\t\tfound_close_braces += 1;\n\
    \t\t}\n\t\t\n\t\t//If there is a closing brace within the open brace, add it to\
    \ the close_brace array\n\t\tif(paren_string[i] == \")\" && paren_string[i+1]\
    \ == \"(\"){\n\t\t\topen_braces.push(paren_string.slice(i,i+3));\n\t\t\tfound_open_braces\
    \ += 1;\n\t\t}\n\t\t\n\t\t//If there is a closing brace within the open brace,\
    \ add it to the close_brace array\n\t\tif(paren_string[i] == \")\" && paren_string[i+1]\
    \ == \")\"){\n\t\t\topen_braces.push(paren_string.slice(i,i+3));\n\t\t\tfound_open_braces\
    \ += 1;\n\t\t}\n\t\t\n\t\t//If there is a closing brace within the open brace,\
    \ add it to the close_brace array\n\t\tif(paren_string[i] == \")\" && paren_string[i+1]\
    \ == \")\"){\n\t\t\tclose_braces.push(paren_string.slice(i,i+3));\n\t\t\tfound_close_braces\
    \ += 1;\n\t\t}\n\t\t\n\t\t//If there is a closing brace within the open brace,\
    \ add it to the close_brace array\n\t\tif(paren_string[i] == \"(\" && paren_string[i+1]\
    \ == \"(\" && paren_string[i+2] == \"(\"){\n\t\t\topen_braces.push(paren_string.slice(i,i+4));\n\
    \t\t\topen_brace_counter += 1;\n\t\t}\n\t\t\n\t\t//If there is a closing brace\
    \ within the open brace, add it to the close_brace array\n\t\tif(paren_string[i]\
    \ == \")\" && paren_string[i+1] == \"(\" && paren_string[i+2] == \"(\"){\n\t\t\
    \topen_braces.push(paren_string.slice(i,i+4));\n\t\t\topen_brace_counter += 1;\n\
    \t\t}\n\t\t\n\t\t//If there is a closing brace within the open brace, add it to\
    \ the close_brace array\n\t\tif(paren_string[i] == \")\" && paren_string[i+1]\
    \ == \"(\" && paren_string[i+2] == \")\"){", "  var nested_paren_groups = [];\
    \ // Store the separate groups in this variable\n\n  paren_string = paren_string.replace(/\\\
    s+/g,\"\"); // Remove all whitespace from the input string\n  paren_string = paren_string.replace(/^[()]+/,\
    \ \"\"); // Remove all spaces from the beginning of the string\n  paren_string\
    \ = paren_string.replace(/\\)[()]+$/g, \"\"); // Remove all spaces from the end\
    \ of the string\n\n  paren_string = paren_string.replace(/(\\s+)/g, \" $1 \");\
    \ // Replace all whitespaces with a single space\n\n  paren_string = paren_string.replace(/\\\
    (\\s+/g, \"(\"); // Remove all whitespaces before the first opening parenthese\n\
    \n  paren_string = paren_string.replace(/\\)+/g, \")\"); // Remove all whitespaces\
    \ after the first closing parenthesis\n\n  paren_string = paren_string.replace(/\\\
    (\\s+\\)/g, \"(\"); // Remove all whitespaces before and after the last closing\
    \ parenthesis\n\n  paren_string = paren_string.replace(/\\)\\s+\\)/g, \")\");\
    \ // Remove all whitespaces before and after the last opening parenthesis\n\n\
    \  paren_string = paren_string.replace(/^\\s+/, \"\"); // Remove all whitespaces\
    \ before the input string\n\n  paren_string = paren_string.replace(/\\)\\s+/,\
    \ \"\"); // Remove all whitespaces after the first opening parenthesis\n\n  paren_string\
    \ = paren_string.replace(/\\s+\\)/g, \"\"); // Remove all whitespaces after the\
    \ first closing parenthesis\n\n  paren_string = paren_string.replace(/\\(\\s+/g,\
    \ \"(\"); // Remove all whitespaces before the first opening parenthese\n\n  paren_string\
    \ = paren_string.replace(/\\s+\\)/g, \")\"); // Remove all whitespaces after the\
    \ first closing parenthesis\n\n  paren_string = paren_string.replace(/\\(\\s+\\\
    )/g, \"(\"); // Remove all whitespaces before and after the last closing parenthesis\n\
    \n  paren_string = paren_string.replace(/\\s+\\)\\s+/g, \") \"); // Remove all\
    \ whitespaces before and after the last opening parenthesis\n\n  paren_string\
    \ = paren_string.replace(/\\s+\\)\\s+\\)/g, \")\"); // Remove all whitespaces\
    \ before and after the last opening parenthesis\n\n  var paren_array = []; //\
    \ Create an array to store the individual paren groups\n\n  paren_string = paren_string.replace(/\\\
    s+/g,\"\").split(\"(\");\n  for(var i = 0; i < paren_string.length; i++){\n  \
    \  paren_string[i] = paren_string[i].replace(/^\\s+/, \"\").replace(/\\)\\s+/,\
    \ \"\");\n    paren_array.push(paren_string[i].trim());\n  }\n\n  return paren_array;\n\
    }\n", "  let out = [];\n  let open_brace_count = 0;\n  let paren_count = 0;\n\
    \  for(let i=0; i < paren_string.length; i++){\n    let c = paren_string[i];\n\
    \    if(c == \"(\"){\n      open_brace_count++;\n      if(open_brace_count > 1){\n\
    \        out.push(paren_string.substring(0,i));\n      }\n    }\n    else if(c\
    \ == \")\"){\n      open_brace_count--;\n      if(open_brace_count == 0){\n  \
    \      out.push(paren_string.substring(0,i+1));\n      }\n    }\n    else if(open_brace_count\
    \ > 0 && open_brace_count < 0){\n      out.push(paren_string.substring(0,i));\n\
    \    }\n    else if(open_brace_count < 0 && open_brace_count > 0){\n      out.push(paren_string.substring(0,i));\n\
    \    }\n  }\n  return out;\n}\n", "\tvar regex_exp = /([^(\\(\\)]+)\\(([^\\(\\\
    )]*)\\)/g;\n\tvar result = [];\n\tvar match;\n\tvar paren_balance = 0;\n\twhile\
    \ ((match = regex_exp.exec(paren_string)) != null) {\n\t\tparen_balance += 1;\n\
    \t\tresult.push(match[1] + \"(\" + match[2] + \")\");\n\t}\n\tif (paren_balance\
    \ > 0) {\n\t\tresult.push(paren_string);\n\t}\n\treturn result;\n}\n", "\tvar\
    \ paren_regex = /(\\([^\\(\\)]*\\))/g; //Matches all parentheses that are not\
    \ contained within another parentheses.\n\tvar paren_groups_array = [];\n\tvar\
    \ paren_count = 0; //To keep track of how many parentheses are actually contained\
    \ in the input string.\n\tvar match; //The entire regular expression match returned\
    \ from the previous call\n\n\twhile (match = paren_regex.exec(paren_string)){\n\
    \t\tif(match[1] !== undefined){\n\t\t\tvar paren_string_from_match = paren_string.substring(0,\
    \ match.index) + paren_string.substring(match.index + match[0].length, paren_string.length);\n\
    \t\t\tparen_groups_array.push(paren_string_from_match);\n\t\t\tparen_count +=\
    \ match[0].length;\n\t\t}\n\t}\n\n\treturn paren_groups_array;\n}\n", "    //console.log(\"\
    Entering separate_paren_groups\", paren_string);\n    var return_array = [];\n\
    \    var opening_paren_paren_stack = []; //keeps track of how many opening parens\
    \ are in each paren group\n    var opening_paren_stack = []; //keeps track of\
    \ the index of the first open paren\n    var closing_paren_stack = []; //keeps\
    \ track of the index of the first closing paren\n    var last_group_index = -1;\
    \ //the last group index\n    var paren_group_count = 0;\n    var last_opening_paren_paren_stack\
    \ = -1;\n    //console.log(\"Entering loop\");\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        //console.log(\"Entering loop body\");\n        if(paren_string[i]\
    \ == \"(\"){\n            //console.log(\"Entering if condition\");\n        \
    \    opening_paren_stack.push(i);\n            opening_paren_paren_stack.push(opening_paren_stack.length);\n\
    \        }\n        else if(paren_string[i] == \")\"){\n            //console.log(\"\
    Entering else if condition\");\n            if(opening_paren_paren_stack.length\
    \ != 0){\n                opening_paren_paren_stack.pop();\n                opening_paren_stack\
    \ = opening_paren_paren_stack[opening_paren_paren_stack.length-1];\n         \
    \   }\n            else{\n                //console.log(\"Exiting condition, no\
    \ opening parens found\");\n                break;\n            }\n        }\n\
    \        else if(opening_paren_stack.length > 0 && paren_string[i] == \")\"){\n\
    \            //console.log(\"Entering else condition\");\n            if(opening_paren_paren_stack.length\
    \ != 0){\n                opening_paren_paren_stack.pop();\n                opening_paren_stack\
    \ = opening_paren_paren_stack[opening_paren_paren_stack.length-1];\n         \
    \   }\n            else{\n                //console.log(\"Exiting condition, no\
    \ closing parens found\");\n                break;\n            }\n        }\n\
    \        else if(opening_paren_stack.length > 0 && paren_string[i] == \"(\"){\n\
    \            //console.log(\"Entering else condition\");\n            if(opening_paren_paren_stack.length\
    \ != 0){\n                opening_paren_paren_stack.pop();\n                opening_paren_stack\
    \ = opening_paren_paren_stack[opening_paren_paren_stack.length-1];\n         \
    \   }\n            else{\n                //console.log(\"Exiting condition, no\
    \ opening parens found\");\n                break;\n            }\n        }\n\
    \        else if(paren_string[i] == \" \"){\n            //console.log(\"Entering\
    \ else condition\");\n            if(opening_paren_stack.length > 0){\n      \
    \          opening_paren_paren_stack.pop();\n                opening_paren_stack\
    \ = opening_paren_paren_stack[", "  //This function will take in a string that\
    \ contains multiple nested parentheses and separate them into individual strings\
    \ \n  //(groups). These strings are delimited by opening brackets \"(\", closing\
    \ brackets \"(\", \",\", and closing brackets \"(\". \n  //However, nested parentheses\
    \ are allowed. For example: \"(()())\" would return ['()', '(()', '()()', '()()'].\n\
    \  \n  //Step 1: Create a variable called \"results\" to store the resulting array\
    \ of individual nested parentheses.\n  var results = '';\n  \n  //Step 2: Use\
    \ a for loop to create an array of each individual nested parenthesis group (the\
    \ result of the splitting of strings)\n  for(var i=0; i<paren_string.split('(').length;\
    \ i++){\n    results += paren_string.split('(')[i];\n  }\n  \n  //Step 3: Use\
    \ a for loop to create an array with each individual nested parenthesis group\
    \ (the result of the splitting of strings)\n  //(This last loop can eventually\
    \ be removed; I did it to be thorough)\n  var array2 = [];\n  for(var i=0; i<paren_string.split('(').length;\
    \ i++){\n    array2.push(paren_string.split('(')[i]);\n  }\n  \n  //Step 4: Use\
    \ a for loop to iterate over each item in the \"array2\" array\n  for(i=0;i<array2.length;i++){\n\
    \    //Step 5: Use a switch statement to check if the current item is an opening\
    \ or closing parenthesis (the result of the splitting of strings)\n    //(This\
    \ case statement should only be used if the current item is a \")\")\n    switch(array2[i]){\n\
    \      case '(':\n        //Step 6: If the current item is \"(\", then push an\
    \ empty string to the \"results\" array (this is the only case where the current\
    \ item will be pushed to the results array)\n        results.push(\"\");\n   \
    \     break;\n      case ')':\n        //Step 7: If the current item is \")\"\
    , then add \"array2[i]\" to the \"results\" array (this is the only case where\
    \ the current item will be added to the results array)\n        results.push(array2[i]);\n\
    \        break;\n      case ',':\n        //Step 8: If the current item is \"\
    ,\", then add \"array2[i]\" to the \"results\" array (this is the only case where\
    \ the current item will be added to the results array)\n        results.push(array2[i]);\n\
    \        break;\n    }\n  }\n  \n  //Step 9: Return the \"results\" array\n  return\
    \ results;\n}\n", "\tvar regex = /(\\s*\\(\\))(\\s*\\(\\))(\\s*\\(\\))(\\s*\\\
    (\\))(\\s*\\(\\))(\\s*\\(\\))/g;\n\tvar match = paren_string.match(regex);\n\t\
    var result = [];\n\tvar temp;\n\twhile(match != null){\n\t\ttemp = match[0]+match[4]+match[7]+match[10]+match[13];\n\
    \t\tresult.push(temp);\n\t\tmatch = paren_string.match(regex);\n\t}\n\treturn\
    \ result;\n}\n", "    if(paren_string == null || paren_string === \"\"){\n   \
    \     return [];\n    }\n    var groups = [];\n    var paren_regex = new RegExp(/\\\
    \\([^\\(\\)]*\\\\)/g);\n    var group_counter = 0;\n    var match = paren_regex.exec(paren_string);\n\
    \    while(match != null){\n        groups.push(paren_string.substr(0, match.index));\n\
    \        paren_string = paren_string.substr(match.index + match[0].length);\n\
    \        match = paren_regex.exec(paren_string);\n        group_counter++;\n \
    \   }\n    groups.push(paren_string);\n    return groups;\n}\n", "    var result_array\
    \ = [];\n    var current_group = [];\n    var brace_level = 0;\n    for(var i\
    \ = 0; i < paren_string.length; i++){\n        if(paren_string[i] == \"(\"){\n\
    \            brace_level++;\n        }\n        else if(paren_string[i] == \"\
    )\"){\n            brace_level--;\n        }\n        else if(paren_string[i]\
    \ == \" \"){\n            if(brace_level == 0){\n                current_group.push(paren_string[i]);\n\
    \                result_array.push(current_group);\n                current_group\
    \ = [];\n            }\n        }\n        else{\n            current_group.push(paren_string[i]);\n\
    \        }\n    }\n    return result_array;\n}\n", "  // Split string into array\
    \ of separate groups\n  return paren_string.match(/[^\\(\\)]+/g);\n}\n", "   \
    \ paren_string = paren_string.trim();\n    var pattern = /(\\(.*\\))|(\\(.*\\\
    ))/;\n    return paren_string.split(pattern).filter( function( item ){\n     \
    \   if( item !== undefined ){\n            return item;\n        }\n    }).filter(\
    \ function( item ){\n        if( item !== undefined && item !== \"\" ){\n    \
    \        return true;\n        }\n    });\n}\n", "  var paren_group_regex = /^\\\
    s*((?:\\(([^()]*)\\))*(?:\\(([^()]*)\\))*)\\s*$/;\n  return paren_string.match(paren_group_regex);\n\
    }\n", "  let arr = [];\n  let current_level = 1;\n  let next_level = 0;\n  let\
    \ open_braces = \"{[(]}\"\n  paren_string = paren_string.trim();\n  while(next_level\
    \ < current_level){\n    open_braces = open_braces.replace(/\\{/g, \"{\").replace(/\\\
    )/g, \"}\")\n    open_braces = open_braces.replace(/(^\\{|\\}$)/g, \"\")\n   \
    \ let regex = new RegExp(open_braces + \"|{|}\", \"g\");\n    let new_string =\
    \ paren_string.match(regex)\n    if(new_string == null){\n      arr.push(paren_string)\n\
    \      break\n    }\n    arr.push(new_string[0]);\n    paren_string = new_string[1]\n\
    \    current_level++\n    next_level++\n  }\n  return arr;\n}\n\n", "\tvar stack\
    \ = [];\n\tvar paren_groups = [];\n\tvar curr_paren_group = \"\";\n\tvar curr_paren_string\
    \ = \"\";\n\tfor(var i=0; i < paren_string.length; i++) {\n\t\tvar char_value\
    \ = paren_string.charAt(i);\n\t\tif(char_value===\"(\"){\n\t\t\tstack.push(curr_paren_string);\n\
    \t\t\tcurr_paren_string = \"\";\n\t\t\tcurr_paren_group = curr_paren_string;\n\
    \t\t}else if(char_value===\"(\"){\n\t\t\tcurr_paren_group += char_value;\n\t\t\
    }else if(char_value===\")\"){\n\t\t\tif(curr_paren_string===\"\"){\n\t\t\t\tcurr_paren_group\
    \ += char_value;\n\t\t\t}else{\n\t\t\t\tif(curr_paren_group!==\"\"){\n\t\t\t\t\
    \tstack.pop();\n\t\t\t\t\tcurr_paren_group = stack[stack.length-1];\n\t\t\t\t\
    }\n\t\t\t\tcurr_paren_string+=char_value;\n\t\t\t}\n\t\t}\n\t}\n\tstack.push(curr_paren_string);\n\
    \tcurr_paren_string = \"\";\n\tfor(var i=0; i < stack.length; i++){\n\t\tif(stack[i].length===0){\n\
    \t\t\tparen_groups.push(curr_paren_group);\n\t\t\tcurr_paren_group = \"\";\n\t\
    \t}\n\t}\n\treturn paren_groups;\n}\n", "    // Your code here\n    let parenGroups\
    \ = [];\n    let openGroups = 0;\n    for(let char of paren_string){\n       \
    \ if(char == '('){\n            openGroups++;\n        }else if(char == ')'){\n\
    \            openGroups--;\n        }\n        if(openGroups == 0){\n        \
    \    parenGroups.push(char);\n        }\n    }\n    return parenGroups;\n}\n",
  "  var input_string = paren_string;\n  var paren_stack = [];\n  var open_parens\
    \ = [];\n  var close_parens = [];\n  var paren_pairs = [];\n  var paren_pair_count\
    \ = 0;\n  var open_brace_count = 0;\n  var close_brace_count = 0;\n\n  for(var\
    \ i = 0; i < input_string.length; i++){\n    var char = input_string[i];\n\n \
    \   // If char is one of the open parens\n    if (char == \"(\"){\n      paren_stack.push(char)\n\
    \      open_parens.push(char)\n      open_brace_count++\n    }\n\n    // If char\
    \ is one of the closing parens\n    else if (char == \")\"){\n      paren_pair_count++\n\
    \      var paren_pair_text = paren_stack.pop();\n      paren_pairs.push(paren_pair_text)\n\
    \      if (open_parens.length > 0){\n        // If there are still open parens,\
    \ it means we closed all of these parens.\n        if (open_parens.pop() == char){\n\
    \          close_brace_count++\n        }\n      }\n      else {\n        // If\
    \ there are no more open parens, it means we ended up with just the one paren\
    \ pair.\n        // This could happen if there were an extra close parens open\
    \ in a different spot.\n        paren_pairs.push(char);\n      }\n    }\n\n  \
    \  // If char is one of the open braces, it means we closed all of these braces.\n\
    \    else if (char == \"{\"){\n      close_brace_count++\n    }\n\n    // If char\
    \ is one of the close braces, it means we opened all of these braces.\n    else\
    \ if (char == \"}\"){\n      open_brace_count++\n    }\n\n    // If there are\
    \ open brackets and an open parens has been encountered, it means we closed all\
    \ of them.\n    // This could happen if there were an extra close brace open in\
    \ a different spot.\n    else if (open_brace_count && close_brace_count && open_brace_count\
    \ == close_brace_count){\n      if (open_parens.length > 0){\n        // If there\
    \ are still open parens, it means we closed all of these parens.\n        if (open_parens.pop()\
    \ == char){\n          close_brace_count++\n        }\n      }\n      else {\n\
    \        // If there are no more open parens, it means we ended up with just the\
    \ one paren pair.\n        // This could happen if there were an extra close parens\
    \ open in a different spot.\n        paren_pairs.push(char);\n      }\n    }\n\
    \n    // If there still is an open parens but not any closed parens, it means\
    \ this paren was either part of the previous\n    // paren pair or an open brace\
    \ in some inner group\n    else if (open_parens.length && !close", "  let stack\
    \ = [];\n  let group_stack = [];\n  for (let i = 0; i < paren_string.length; i++){\n\
    \    let current_char = paren_string[i];\n    if (current_char == '('){\n    \
    \  // If the parens already exist in the stack, then we can add this new group\n\
    \      // to the stack as well\n      if (group_stack.length > 0) stack.push(group_stack);\n\
    \      // Reset the stack\n      group_stack = [];\n    } else if (current_char\
    \ == ')'){\n      // If the parens exist in the stack, then we can add this new\
    \ group to the stack\n      // and then pop this group\n      if (group_stack.length\
    \ > 0) stack.push(group_stack);\n      group_stack.pop();\n    } else {\n    \
    \  // Add this character to the current group\n      group_stack.push(current_char);\n\
    \    }\n  }\n  // If the parens exist in the stack, then we can add this new group\
    \ to the stack\n  // and then pop this group\n  if (group_stack.length > 0) stack.push(group_stack);\n\
    \  // Return the stack\n  return stack;\n}\n\n", "  return paren_string.replace(/\\\
    (([\\d\\s]*)\\)/g,function($0){\n    var groups = [];\n    var curly_open=true;\n\
    \    $0.replace(\"(\",\"\");\n    $0.replace(\")\",\"\");\n    $0.split(\"\").forEach(function(character){\n\
    \      if(curly_open && character ==\"(\"){\n        groups.push(\"(\");\n   \
    \     curly_open=true;\n      } else if(curly_open && character ==\")\"){\n  \
    \      groups.push(\"\");\n        curly_open=false;\n      } else {\n       \
    \ groups.push(character);\n      }\n    });\n    return groups.join(\"\");\n \
    \ });\n}\n", "    // Step 1: Tokenize your string into an array of \"tokens\"\n\
    \    // Each token is an array that consists of the following:\n    // - Type\
    \ of token (parenthesis or nonparenthesis)\n    // - Value of the token\n    //\
    \ - Number of parenthesis levels opened in the token\n    // - Whether this token\
    \ is nested within another token\n    // For example, the token '(' with value\
    \ ' ' is an open parenthesis with 2 levels of opening and 0 levels closed.\n \
    \   // The token ')' with value ' ' is close parenthesis with 0 levels of opening\
    \ and 1 level closed.\n    var tokens = tokenize_string(paren_string);\n    //\
    \ Step 2: Iterate over the tokens and group them into arrays\n    // The general\
    \ algorithm is as follows (see 'tokenize_string' for the full pseudocode):\n \
    \   // - Initialization: curr_group = \"()\"\n    // - For each token in the tokens\
    \ array\n    //     - If this token is a close parenthesis\n    //         - If\
    \ curr_group is currently empty\n    //             - Add the current token to\
    \ the current group\n    //             - Decrement curr_levels_opened (to account\
    \ for the fact that this token was a close parenthesis)\n    //             -\
    \ If curr_levels_opened is 0 and the next token is an open parenthesis\n    //\
    \                 - If curr_group is not yet empty\n    //                   \
    \  - Add the current token to the curr_group\n    //                     - Increment\
    \ curr_levels_opened by 1\n    //                     - If the next token is a\
    \ close parenthesis\n    //                       - Increment curr_levels_opened\
    \ by 1\n    //                       - Add curr_group to the array of groups\n\
    \    //             - Else\n    //                 - Increment curr_levels_opened\
    \ (to account for the fact that this token was an open parenthesis)\n    //  \
    \               - Add curr_group to the array of groups\n    //         - Else\n\
    \    //             - Decrement curr_levels_opened (to account for the fact that\
    \ this token was a close parenthesis)\n    //             - Add curr_group to\
    \ the array of groups\n    //     - If this token is an open parenthesis\n   \
    \ //         - If curr_group is currently empty\n    //             - Add curr_group\
    \ to the array of groups\n    //             - Decrement curr_levels_opened by\
    \ 1\n    //             - If curr_levels_opened is 0 and the next token is a close\
    \ parenthesis\n    //                 - Add curr_group to the array of groups\n\
    \    //                 - Increment curr_levels_opened by 1\n    //          \
    \       - Add curr_group to the array of groups\n    //             - Else\n \
    \   //                 - Increment curr_levels_opened (to account for the fact\
    \ that this token was an open parenthesis)\n    //             - Add ", "  var\
    \ current_group = [];\n  var output = [];\n  var open_braces = [];\n  var closed_in_a_row\
    \ = 0;\n  var brace_groups = 0;\n  var current_char_at_index = 0;\n  for(var i\
    \ = 0; i < paren_string.length; i++){\n    currentChar = paren_string[i];\n  \
    \  if(currentChar == '('){\n      if(current_char_at_index > 0){\n        current_char_at_index\
    \ = 0;\n        current_group.push(paren_string[i]);\n      }\n      open_braces.push(paren_string[i]);\n\
    \      brace_groups = 0;\n    } else if(currentChar == ')'){\n      if(open_braces.length\
    \ == 0){\n        console.warn(\"Not a balanced parenthesis group. No groups will\
    \ be created\");\n        return [];\n      }\n      closed_in_a_row = 0;\n  \
    \    if(current_char_at_index < open_braces.length){\n        if(open_braces[current_char_at_index]\
    \ == ')'){\n          current_char_at_index++;\n          closed_in_a_row = 1;\n\
    \          brace_groups++;\n        } else {\n          current_group.push(paren_string[i]);\n\
    \        }\n      } else if(open_braces[current_char_at_index] == ')'){\n    \
    \    current_char_at_index++;\n        closed_in_a_row = 1;\n      } else {\n\
    \        console.warn(\"Unexpected character \" + currentChar + \", expecting\
    \ a ')'\");\n        return [];\n      }\n      if(closed_in_a_row == 0){\n  \
    \      output.push(current_group);\n        current_group = [];\n      }\n   \
    \ } else if(open_braces.length > 0) {\n      current_group.push(paren_string[i]);\n\
    \    }\n  }\n  if(current_group.length > 0){\n    output.push(current_group);\n\
    \  }\n  return output;\n}\n", "\tvar paren_regex = /\\(\\)|(\\))|(\\s+)/;\n\t\
    var out = [];\n\tparen_string = paren_string.split(paren_regex);\n\tvar len =\
    \ paren_string.length;\n\tvar i;\n\tfor(i = 0; i < len; i++){\n\t\tvar c = paren_string[i];\n\
    \t\tif(c == '('){\n\t\t\tvar open_brackets = 1;\n\t\t\tvar c = paren_string[i];\n\
    \t\t\twhile(c != '(' && c != '('){\n\t\t\t\tif(c != ' ' || open_brackets > 0){\n\
    \t\t\t\t\tout.push(c);\n\t\t\t\t}\n\t\t\t\topen_brackets++;\n\t\t\t\tc = paren_string[++i];\n\
    \t\t\t}\n\t\t\tif(c != ')'){\n\t\t\t\tout.push(c);\n\t\t\t}\n\t\t}else{\n\t\t\t\
    out[out.length-1] += c;\n\t\t}\n\t}\n\treturn out;\n}\n", "    let paren_array\
    \ = [];\n    let paren_arr = [];\n    let paren_string = paren_string.trim();\n\
    \n    for(const char of paren_string){\n        if(char === '(' || char === '{'){\n\
    \            paren_arr.push(char);\n        }else if(char === ')'){\n        \
    \    paren_arr.push(char);\n            if(paren_arr.length === 2){\n        \
    \        paren_array.push(paren_arr.join());\n                paren_arr = [];\n\
    \            }\n        }else if(char === '}'){\n            paren_arr.push(char);\n\
    \            if(paren_arr.length === 1){\n                paren_array.push(paren_arr.join());\n\
    \                paren_arr = [];\n            }\n        }else if(char === ' '\
    \ || char === '\\n'){\n            continue;\n        }\n    }\n    return paren_array;\n\
    }\n", "  var arr_string=paren_string.split(\"\");\n  var output = [];\n\n  for(var\
    \ i = 0; i < arr_string.length; i++){\n    if(arr_string[i]==\"(\"){\n      output.push(arr_string[i]);\n\
    \    }\n    else if(arr_string[i]==\")\"){\n      if(output.length==0){\n    \
    \    output.push(arr_string[i]);\n      }\n      else{\n        if(arr_string[i+1]==\"\
    )\"){\n          output.push(arr_string[i]);\n          output.push(arr_string[i+1]);\n\
    \        }\n        else{\n          output.push(arr_string[i]);\n        }\n\
    \      }\n    }\n  }\n  \n  return output;\n}\n", "\tlet groups = []\n\tlet opening_paren\
    \ = 0\n\tlet closing_brace = 0\n\tfor(let char of paren_string){\n\t\tif(cmp(char,'(')===0){\n\
    \t\t\topening_paren++\n\t\t}else if(cmp(char,')')===0){\n\t\t\tclosing_brace++\n\
    \t\t}else{\n\t\t\tif(opening_paren > 0){\n\t\t\t\tif(closing_brace>0){\n\t\t\t\
    \t\tclosing_brace--\n\t\t\t\t}else{\n\t\t\t\t\tgroups.push(paren_string.slice(opening_paren,closing_brace+1))\n\
    \t\t\t\t\topening_paren = 0\n\t\t\t\t\tclosing_brace = 0\n\t\t\t\t}\n\t\t\t}\n\
    \t\t}\n\t}\n\tif(opening_paren > 0){\n\t\tgroups.push(paren_string.slice(opening_paren,closing_brace+1))\n\
    \t}\n\treturn groups\n}\n\n", "    // Your code goes here\n}\n", "    var open_braces\
    \ = paren_string.match(/[({\\s]+/g) || [];\n    var close_braces = paren_string.match(/[\\\
    s]+[)}\\]]+/g) || [];\n    \n    var nested_paren_string = \"\";\n    var curr_group\
    \ = \"\";\n    var curr_open_brace_index = 0;\n    var curr_close_brace_index\
    \ = 0;\n    \n    var curr_paren_count = 0;\n    \n    // Keep going through the\
    \ string and separating groups of nested parens\n    while(curr_open_brace_index\
    \ < open_braces.length){\n        curr_paren_count = 0;\n        curr_group =\
    \ open_braces[curr_open_brace_index];\n        curr_open_brace_index++;\n    \
    \    while(curr_close_brace_index < close_braces.length && curr_open_brace_index\
    \ < open_braces.length){\n            curr_close_brace_index++;\n            \n\
    \            if(!close_braces[curr_close_brace_index].startsWith(curr_group)){\n\
    \                nested_paren_string += curr_group;\n                curr_paren_count++;\n\
    \            }\n            \n            curr_group = open_braces[curr_open_brace_index];\n\
    \            curr_open_brace_index++;\n        }\n        if(curr_paren_count\
    \ > 0){\n            nested_paren_string += curr_group;\n            curr_paren_count++;\n\
    \        }\n    }\n    \n    return nested_paren_string;\n}\n", "  let paren_regex\
    \ = /\\(([^\\)]+)\\)/;\n  let matched_groups = paren_string.match(paren_regex);\n\
    \  if(matched_groups !== null){\n    matched_groups.forEach(element => {\n   \
    \   if(element.match(/\\(/) !== null){\n        element = element.substr(1, element.length\
    \ - 2);\n        element = element.trim();\n      }\n      if(element !== \"\"\
    ){\n        elements.push(element);\n      }\n    });\n  }\n  return elements;\n\
    }\n", "  var nested_paren_groups = paren_string.split(/\\((.+?)\\)/)\n\n  var\
    \ nested_paren_array = new Array(nested_paren_groups.length)\n\n  for(var i =\
    \ 0; i< nested_paren_groups.length; i++){\n    var nested_paren_item = nested_paren_groups[i].match(/[^(\\\
    (\\s|\\s\\)]+/g)\n    var nested_paren_item_array = new Array(nested_paren_item.length)\n\
    \n    for(var j = 0; j<nested_paren_item.length; j++){\n      nested_paren_item_array[j]\
    \ = nested_paren_item[j].trim()\n    }\n    nested_paren_array[i] = nested_paren_item_array\n\
    \  }\n  return nested_paren_array\n}\n", "    // Your code here\n    var arr =\
    \ [];\n    var opening_regex = new RegExp( \"\\\\(|\\\\)\" , \"g\" );\n    var\
    \ arr2 = [];\n    arr2 = paren_string.split(opening_regex);\n    for(var i = 0;\
    \ i < arr2.length; i++){\n        if(arr2[i] !== ''){\n            arr.push(arr2[i]);\n\
    \        }\n    }\n    return arr;\n}\n</code>\n<|/ a dscore=0 tags=javascript,regex\
    \ |>\n<| c |>\nI agree that the OP should just use nested groups, but unfortunately\
    \ it seems that the OP is also restricted to using groups and they have to be\
    \ separated.  I edited my answer to include an approach that should work if you\
    \ only need to use the groups you already have available.\n<|/ c |>\n<| c |>\n\
    Yes, thanks, I didn't realize that grouping was the only restriction. My solution\
    \ doesn't use nested groups.\n<|/ c |>\n<| c |>\nI don't think this solution is\
    \ working for nested parens.\n<|/ c |>\n<| c |>\nThis solution does work for nested\
    \ parens.  The function I posted only works if you don't need to use groups.\n\
    <|/ c |>\n<| a dscore=0 tags=javascript,regex |>\nI haven't been able to find\
    \ an elegant way of doing it with a regular expression, but I think this should\
    \ work for you:\n<code>", "    var groups = [];\n    var cur_open_bracket = -1;\n\
    \    var last_char_index = 0;\n    for (var i=0; i<paren_string.length; i++){\n\
    \        var char_at_this_index = paren_string.charAt(i);\n        // If this\
    \ is a space, then do nothing\n        if (char_at_this_index === \" \") {\n \
    \           // If we've already encountered a closing bracket, ignore this space\n\
    \            if (cur_open_bracket >= 0) {\n                last_char_index = i;\n\
    \            }\n        } else {\n            if (cur_open_bracket < 0 && char_at_this_index\
    \ === \")\"){\n                // If this is the last closing bracket in the string,\
    \ then ignore this space\n                if (i === paren_string.length - 1){\n\
    \                    groups.push(paren_string.substr(last_char_index + 1, i -\
    \ last_char_index - 1));\n                }\n                last_char_index =\
    \ i;\n            } else {\n                // If there is an open bracket in\
    \ the string, then close it\n                if (char_at_this_index === \")\"\
    ){\n                    cur_open_bracket--;\n                } else {\n      \
    \              // If this is not a closing bracket, then add the character to\
    \ the current group\n                    groups.push(paren_string.charAt(i));\n\
    \                }\n            }\n        }\n    }\n    return groups;\n}\n",
  "    paren_string = paren_string.trim();\n    \n    if(paren_string.length === 0){\n\
    \        return [];\n    }\n    \n    var opening_brackets = [];\n    var closing_brackets\
    \ = [];\n    \n    for(var i=0; i<paren_string.length; i++){\n        \n     \
    \   var c = paren_string.charAt(i);\n        \n        if(c === \"(\"){\n    \
    \        opening_brackets.push(c);\n        }\n        else if(c === \")\"){\n\
    \            closing_brackets.push(c);\n        }\n        \n    }\n    \n   \
    \ var group_arr = opening_brackets.map((c) => {\n        return closing_brackets.map((c_)\
    \ => {\n            return c;\n        }).join('');\n    }).reverse();\n    \n\
    \    return group_arr;\n}\n", "\tvar input_string = paren_string.replace(/\\s+/g,\
    \ \" \").replace(/(^\\s+|\\s+$)/g,\"\").replace(/\\s+/g,\" \");\n\tvar groups\
    \ = [];\n\tvar paren_group_open_braces = input_string.match( /(\\([^\\(\\)]+\\\
    ))/g );\n\tfor(var i = 0; i < paren_group_open_braces.length; i++){\n\t\tgroups.push(paren_group_open_braces[i]);\n\
    \t}\n\tfor(var i = groups.length - 1; i >= 0; i--){\n\t\tgroups[i] = groups[i].replace(/\\\
    s+/g, \" \").replace(/(^\\s+|\\s+$)/g,\"\").replace(/\\s+/g,\" \");\n\t}\n\treturn\
    \ groups;\n}\n", "  var open_braces = [],\n      closed_braces = [],\n      brackets\
    \ = [],\n      results = [];\n\n  paren_string.replace(/\\(\\s?/g,\"\").replace(/\\\
    s?\\)/g,\"\").split(\"\").forEach(function(chr){\n    if(chr === '('){\n     \
    \ open_braces.push(chr);\n    }\n    else if(chr === ')'){\n      if(open_braces.length\
    \ > 0){\n        open_braces.pop();\n      }\n      closed_braces.push(chr);\n\
    \    }\n    else{\n      brackets.push(chr);\n    }\n  });\n\n  //We now have\
    \ an array of characters representing the parenthesis.\n  //To get just the strings\
    \ within parenthesis, we loop through the array.\n  //For every parenthesis, we\
    \ add it to a new array and remove it from the parenthesis array\n  for(var i\
    \ = open_braces.length; i > 0; i--){\n    results.push(brackets.slice(0,i).join(''));\n\
    \    brackets = brackets.slice(i+1);\n  }\n  \n  for(var j = 0; j < closed_braces.length;\
    \ j++){\n    results.push(brackets.slice(0,j).join(''));\n  }\n\n  return results;\n\
    }\n", "    var groups = [];\n    var open_braces;\n    var open_parens = 0;\n\
    \    var close_parens = 0;\n    var group = \"\";\n    var current_index = -1;\n\
    \    \n    for (var i = paren_string.length-1; i >= 0; i--){\n        switch(paren_string[i]){\n\
    \            case '(':\n                if (group.length > 0){\n             \
    \       groups.push(group);\n                    group = \"\";\n             \
    \   }\n                open_braces = 1;\n                open_parens++;\n    \
    \            break;\n            case ')':\n                if (open_braces >\
    \ 0) {\n                    open_braces--;\n                    if (open_braces\
    \ === 0) {\n                        groups.push(group);\n                    \
    \    group = \"\";\n                    } else {\n                        group\
    \ += \")\";\n                    }\n                } else {\n               \
    \     group += \")\";\n                }\n                close_parens++;\n  \
    \              break;\n            case ' ':\n                group += \" \";\n\
    \                break;\n            default:\n                group += paren_string[i];\n\
    \                break;\n        }\n    }\n    groups.push(group);\n    return\
    \ groups;\n}\n", "    var groups = [];\n    for(let i=0;i<paren_string.length;i++){\n\
    \        switch(paren_string[i]){\n            case '(':\n                groups.push(paren_string.slice(i+1,i+2));\n\
    \                break;\n            case ')':\n                groups.pop();\n\
    \                break;\n        }\n    }\n    return groups;\n}\n", "    for(let\
    \ i = 0; i <= paren_string.length; i++){\n        if(paren_string.charAt(i) ==\
    \ '('){\n            paren_stack[paren_stack.length-1] = paren_string.charAt(i)\n\
    \        }\n        if(paren_string.charAt(i) == ')'){\n            paren_stack.pop()\n\
    \        }\n    }\n    return paren_stack\n}\n", "\tvar tokens = paren_string.match(/[^()]+/g)\
    \ || [];\n\tvar result_groups = [];\n\tvar current_group = [];\n\tfor(var i =\
    \ 0; i < tokens.length; i++){\n\t\tvar token = tokens[i];\n\t\tif(/^\\s*$/.test(token)){\n\
    \t\t\tcurrent_group.push(token);\n\t\t}\n\t\telse if(token == \"(\"){\n\t\t\t\
    if(current_group.length > 0){\n\t\t\t\tresult_groups.push(current_group);\n\t\t\
    \t\tcurrent_group = [];\n\t\t\t}\n\t\t}\n\t\telse if(token == \")\"){\n\t\t\t\
    var sub_groups = separate_paren_groups(current_group);\n\t\t\tfor(var i = 0; i\
    \ < sub_groups.length; i++){\n\t\t\t\tresult_groups.push(sub_groups[i]);\n\t\t\
    \t}\n\t\t}\n\t\telse{\n\t\t\tif(current_group.length > 0){\n\t\t\t\tcurrent_group.push(token);\n\
    \t\t\t}\n\t\t\telse{\n\t\t\t\tcurrent_group.push(token);\n\t\t\t}\n\t\t}\n\t}\n\
    \tif(current_group.length > 0){\n\t\tresult_groups.push(current_group);\n\t}\n\
    \treturn result_groups;\n}\n\n", "    // split the string into multiple strings\
    \ of any amount of parens\n    var paren_groups = paren_string.match(/[\\(\\)]+/g);\n\
    \n    // remove empty elements of the array\n    paren_groups = paren_groups.filter(function(item){\n\
    \        return item != '';\n    });\n\n    // convert string to array and return\
    \ it\n    return paren_groups;\n}\n", "  var current_open = 0;\n  var current_close\
    \ = 0;\n  var paren_string = paren_string.trim();\n  var paren_array = paren_string.match(/(\\\
    ()|(\\))/g);\n  var paren_array_length = paren_array.length;\n\n  for(var i =\
    \ 0; i < paren_array_length; i++) {\n    if(paren_array[i] === \"(\") {\n    \
    \  current_open++;\n    } else if(paren_array[i] === \")\") {\n      current_close++;\n\
    \    } else {\n      if(current_open > current_close) {\n        if(paren_array[i+1]\
    \ === \")\") {\n          paren_array.splice(i + 1, 1);\n          i--;\n    \
    \      paren_array_length--;\n        }\n      }\n    }\n  }\n  return paren_array;\n\
    }\n", "  let result = new Array();\n  let open_braces = 0;\n  let closing_brace\
    \ = 0;\n  let temp_array = new Array();\n\n  for (let i = 0; i < paren_string.length;\
    \ i++){\n    temp_array.push(paren_string[i]);\n    if (paren_string[i] === \"\
    (\"){\n      open_braces++;\n    }\n    else if (paren_string[i] === \")\"){\n\
    \      closing_brace++;\n    }\n    else if (paren_string[i] === \"{\" || paren_string[i]\
    \ === \"}\"){\n      closing_brace = 0;\n      if (open_braces === 0){\n     \
    \   result.push(temp_array);\n        temp_array = new Array();\n      }\n   \
    \ }\n  }\n  if (open_braces > 0){\n    result.push(temp_array);\n  }\n  return\
    \ result;\n}\n", "  var open_brace_groups = [], closed_brace_groups = [];\n  for(let\
    \ i = 0; i < paren_string.length; i++){\n    let char = paren_string[i];\n   \
    \ if(char === '('){\n      open_brace_groups.push(paren_string.slice(i+1));\n\
    \    }\n    if(char === ')'){\n      closed_brace_groups.push(paren_string.slice(i+1));\n\
    \    }\n  }\n  // Iterate through each of the closed brace groups and check whether\
    \ they're nested within each other\n  var is_nested_within_group = false;\n  for(let\
    \ i = 0; i < closed_brace_groups.length; i++){\n    if(!is_nested_within_group){\n\
    \      for(let j = i; j > 0; j--){\n        if(closed_brace_groups[j-1] === '('\
    \ && closed_brace_groups[j] === ')'){\n          is_nested_within_group = true;\n\
    \        }\n      }\n    }\n    if(!is_nested_within_group){\n      for(let j\
    \ = i; j > 0; j--){\n        if(closed_brace_groups[j-1] === '(' && closed_brace_groups[j-1]\
    \ === ')'){\n          closed_brace_groups.splice(j, 1);\n          break;\n \
    \       }\n      }\n    }\n  }\n  // Iterate through each of the open brace groups\
    \ and check whether they're nested within each other\n  var is_nested_within_group\
    \ = false;\n  for(let i = 0; i < open_brace_groups.length; i++){\n    if(!is_nested_within_group){\n\
    \      for(let j = i; j > 0; j--){\n        if(open_brace_groups[j-1] === '('\
    \ && open_brace_groups[j] === ')'){\n          is_nested_within_group = true;\n\
    \        }\n      }\n    }\n    if(!is_nested_within_group){\n      for(let j\
    \ = i; j > 0; j--){\n        if(open_brace_groups[j-1] === '(' && open_brace_groups[j-1]\
    \ === ')'){\n          open_brace_groups.splice(j, 1);\n          break;\n   \
    \     }\n      }\n    }\n  }\n  // Now that we've checked that there are no nested\
    \ groups in each of the brace groups,\n  // we'll remove any space from the beginning\
    \ of each group\n  for(let i = 0; i < open_brace_groups.length; i++){\n    open_brace_groups[i]\
    \ = open_brace_groups[i].trim();\n  }\n  for(let i = 0; i < closed_brace_groups.length;\
    \ i++){\n    closed_brace_groups[i] = closed_brace_groups[i].trim();\n  }\n  //\
    \ Now that we've checked that there are no nested groups in each of the brace\
    \ groups,\n  // we'll remove any space from the beginning ", "    //If no string\
    \ passed, default to empty string\n    if(!paren_string){\n        paren_string\
    \ = \"\";\n    }\n\n    //Split the string into separate groups based on parentheses\n\
    \    var paren_groups = paren_string.match(/(([^()]*|\\([^()]*\\))*)/g);\n\n \
    \   //If there are no more groups to split, return the original string\n    if(paren_groups.length\
    \ <= 0){\n        return [paren_string];\n    }\n\n    //Recursively call this\
    \ function to separate the groups within the string\n    var separated_groups\
    \ = separate_paren_groups(paren_groups[0]);\n\n    //Keep track of which group\
    \ we've already added parentheses to\n    var paren_group_count = 1;\n\n    //Add\
    \ the rest of this group to the new array\n    for(var i = 0; i < paren_groups.length;\
    \ i++){\n        //Keep track of which group we've already added parentheses to\n\
    \        if(paren_groups[i] != \"\"){\n            //If it is not a group, add\
    \ to array and increase count\n            separated_groups[separated_groups.length]\
    \ = paren_groups[i];\n            paren_group_count += 1;\n        }\n       \
    \ //If group is a group, recurse to separate group and add count of previous parentheses\n\
    \        else if(paren_groups[i][0] == \"(\"){\n            separated_groups[separated_groups.length]\
    \ = paren_groups[i];\n            paren_group_count += 1;\n        }\n       \
    \ //If group is not a group, but we have seen a group, then remove this parentheses\n\
    \        else if(paren_group_count != 0){\n            paren_group_count -= 1;\n\
    \        }\n    }\n\n    return separated_groups;\n}\n", "  let groups = paren_string.match(/\\\
    ((?!\\())/g);\n  let result = [];\n  if(groups){\n    groups.forEach((group) =>{\n\
    \      let group_split = group.replace(/\\((?!\\())/, '').split(')');\n      if(group_split.length\
    \ > 1){\n        group_split.forEach((group_split) =>{\n          group_split\
    \ = group_split.trim();\n          result.push(group_split);\n        });\n  \
    \    }\n    });\n  }\n  return result;\n}\n", "    var open_braces=new Array();\n\
    \    var close_braces=new Array();\n    var strings=new Array();\n\n    // Iterate\
    \ through the string and separate each group into its own string\n    for(var\
    \ i=0;i<paren_string.length;i++){\n        if(paren_string.charAt(i)==\"(\")\n\
    \            open_braces.push(i);\n        else if(paren_string.charAt(i)==\"\
    )\")\n            close_braces.push(i);\n        // Ignore spaces in the input\
    \ string\n        else if(paren_string.charAt(i)==\" \")\n            continue;\n\
    \        else {\n            if(open_braces.length>0){\n                if(paren_string.charAt(open_braces[open_braces.length-1])\
    \ == \")\"){\n                    close_braces.push(open_braces[open_braces.length-1]);\n\
    \                    open_braces.pop();\n                }\n            }\n  \
    \          strings.push(\"(\");\n            strings.push(paren_string.substring(i,paren_string.length));\n\
    \            strings.push(\")\");\n        }\n    }\n\n    // Return the array\
    \ of strings\n    return strings;\n}\n", "\t// Store the result and split the\
    \ string by parens\n\tvar separated = paren_string.split(/([\\(\\)])/);\n\t//\
    \ Iterate the array and remove all spaces from the string\n\tvar cleaned = [];\n\
    \tfor(var i = 0; i < separated.length; i++){\n\t\tcleaned.push(separated[i].trim());\n\
    \t}\n\treturn cleaned;\n}\n", "\tvar paren_array = [];\n\tvar paren_groups = paren_string.match(/[^()]+\\\
    )|(\\s*(?=[()]))/g);\n\tfor (var i=0; i<paren_groups.length; i++){\n\t\tparen_array.push(paren_groups[i].match(/[\\\
    (\\)]/g));\n\t}\n\treturn paren_array;\n}\n", "    //This function takes in a\
    \ string and returns the array of individual parentheses\n    //This function\
    \ uses a stack to track the number of open parentheses, and then it adds the correct\
    \ number of close parens\n    //It then returns an array of the strings of parentheses\n\
    \    //The input string cannot contain any spaces.\n    \n    var paren_count\
    \ = 0;\n    var stack = [];\n    var output = [];\n    for(var i=0; i<paren_string.length;\
    \ i++){\n        switch (paren_string[i]) {\n            case '(':\n         \
    \       //If there is a left parentheses, push it onto the stack\n           \
    \     if (paren_count > 0) {\n                    stack.push(paren_count);\n \
    \               }\n                paren_count++;\n                break;\n  \
    \          case ')':\n                //If there is a right parentheses, pop it\
    \ from the stack\n                while (stack.length > 0 && paren_count < stack[stack.length\
    \ - 1]) {\n                    output.push(paren_string[stack.length - 1 - paren_count]);\n\
    \                    paren_count++;\n                }\n                if (paren_count\
    \ == stack[stack.length - 1]) {\n                    stack.pop();\n          \
    \      } else {\n                    return output;\n                }\n     \
    \           break;\n            default:\n                //If the character is\
    \ whitespace, ignore it\n                if (paren_count == stack[stack.length\
    \ - 1]) {\n                    stack.pop();\n                }\n             \
    \   break;\n        }\n    }\n    return output;\n}\n", "  let paren_group_regex\
    \ = /\\(([^\\(\\)]+)\\)/;\n  let paren_matches = paren_string.match(paren_group_regex);\n\
    \  let paren_matches_arr = [];\n  if(paren_matches != null){\n    for(let match\
    \ in paren_matches){\n      paren_matches_arr.push(paren_matches[match]);\n  \
    \  }\n  }\n  return paren_matches_arr;\n}\n", "    \n    var group_arr = [];\n\
    \    var temp_arr = paren_string.split(/(\\(\\))?(\\(\\()|(\\(\\))?/g);\n    \n\
    \    for(var i = 0; i < temp_arr.length; i++){\n        var a = temp_arr[i];\n\
    \        var b = null;\n        if(a.match(/\\(\\)|\\(\\(\\()/g)){\n         \
    \   b = a.replace(/\\(\\)|\\(\\(\\()/g,\"\").split(/(\\(\\))?/g);\n        }else{\n\
    \            b = a.split(/(\\(\\))?/g);\n        }\n        for(var j = 0; j <\
    \ b.length; j++){\n            var tmp = b[j];\n            if(tmp != \"\"){\n\
    \                group_arr.push(tmp);\n            }\n        }\n    }\n    return\
    \ group_arr;\n}\n\n", "    // Keep track of paren groups we've seen\n    let paren_groups\
    \ = []\n    // Iterate through every character in the string\n    for (let i of\
    \ paren_string){\n        // If this is the character for an open paren, push\
    \ it to paren_groups\n        if (i == \"(\"){\n            paren_groups.push(paren_groups[paren_groups.length-1]+i)\n\
    \        }\n        // If this is the character for a close paren, pop an item\
    \ off paren_groups\n        else if (i == \")\"){\n            paren_groups.pop()\n\
    \        }\n        // If we're still inside paren_groups and it's not an open\
    \ paren, just keep pushing it\n        else if(paren_groups.length > 0 && i !=\
    \ \"(\"){\n            paren_groups.push(paren_groups[paren_groups.length-1]+i)\n\
    \        }\n    }\n    // Return the array built from paren_groups\n    return\
    \ paren_groups\n}", "  const stack = [];\n  let cur_group = \"\";\n  let is_in_group\
    \ = false;\n  for(let i = 0; i < paren_string.length; i++){\n    switch(paren_string[i]){\n\
    \      case \" \": if(!is_in_group){\n        stack[stack.length-1] += cur_group;\n\
    \        cur_group = \"\";\n      }else{\n        cur_group += paren_string[i];\n\
    \      }\n      break;\n      case \"(\":\n        if(!is_in_group){\n       \
    \   stack[stack.length-1] += cur_group;\n          cur_group = \"\";\n       \
    \ }else{\n          is_in_group = true;\n          cur_group += paren_string[i];\n\
    \        }\n        break;\n      case \")\":\n        if(is_in_group){\n    \
    \      stack[stack.length-1] += cur_group;\n          is_in_group = false;\n \
    \       }else{\n          throw \"Unbalanced Parentheses Exception\";\n      \
    \  }\n        break;\n      case \"{\":\n        if(!is_in_group){\n         \
    \ stack[stack.length-1] += cur_group;\n          cur_group = \"\";\n        }else{\n\
    \          if(stack[stack.length-1].length){\n            throw \"Nested Parentheses\
    \ Exception\";\n          }else{\n            is_in_group = true;\n          \
    \  cur_group += paren_string[i];\n          }\n        }\n        break;\n   \
    \   case \"}\":\n        if(is_in_group){\n          stack[stack.length-1] +=\
    \ cur_group;\n          is_in_group = false;\n        }else{\n          throw\
    \ \"Unbalanced Parentheses Exception\";\n        }\n        break;\n      default:\n\
    \        if(is_in_group){\n          cur_group += paren_string[i];\n        }else{\n\
    \          stack[stack.length-1] += cur_group;\n          cur_group = \"\";\n\
    \        }\n    }\n  }\n  return stack.reverse();\n}\n", "  if(paren_string){\n\
    \    let open_bracketsArr = [];\n    let closed_parensArr = [];\n    for(const\
    \ char of paren_string){\n      if(char === \"(\"){\n        open_bracketsArr.push(char)\n\
    \      }\n      if(char === \")\"){\n        closed_parensArr.push(char)\n   \
    \   }\n    }\n    open_bracketsArr.push(closed_parensArr.pop())\n    let final_result\
    \ = [];\n    for(let paren of open_bracketsArr){\n      if(paren){\n        final_result.push(paren);\n\
    \      }\n    }\n    return final_result\n  }\n}", "    var paren_groups = [];\n\
    \n    var index = 0;\n    while(paren_string.charAt(index) != \"(\"){\n      \
    \  index++;\n    }\n\n    while(paren_string.charAt(index) != \")\"){\n      \
    \  paren_groups.push(paren_string.substr(0, index));\n        index++;\n    }\n\
    \n    index++;\n    while(paren_string.charAt(index) != \")\"){\n        index++;\n\
    \    }\n\n    return paren_groups;\n}\n\n", "  if(paren_string.search(\"((\")\
    \ == -1){\n    return []\n  }\n  let paren_groups = paren_string.matchAll(/\\\
    (.*?\\)/)\n  let open_groups = paren_groups[0]\n  let closed_groups = paren_groups[1]\n\
    \  let result = open_groups.map((group) => group.substr(1))\n  result = result.concat(closed_groups.map((group)\
    \ => group.substr(1)))\n  return result\n}\n", "  var nested_paren_regex = new\
    \ RegExp('(' + paren_string + ')','g');\n  var nested_paren_string = paren_string.replace(nested_paren_regex,\
    \ '\\\\1\\\\2');\n  return nested_paren_string.split('\\\\2').join('\\\\0');\n\
    }\n\n", "\tvar groups = [];\n\tvar open_group = true;\n\tvar group_opening_counter\
    \ = 0;\n\tvar group_opening_brace_position = [];\n\tvar group_opening_paren_position\
    \ = [];\n\tvar group_opening_paren_group = [];\n\tvar opening_opening_paren_brace_position\
    \ = [];\n\tvar opening_opening_paren_position = [];\n\tvar opening_opening_paren_group\
    \ = [];\n\tvar brace_position = [];\n\t\n\tvar num_opening_parens = paren_string.match(/\\\
    (/g).length;\n\tvar num_closing_braces = paren_string.match(/\\)/g).length;\n\t\
    var num_opening_groups = num_opening_parens - 1;\n\tvar num_closing_groups = num_closing_braces\
    \ - 1;\n\t\n\tfor(var i = 0; i < num_opening_parens; i++){\n\t\tgroup_opening_paren_position.push(i);\n\
    \t}\n\t\n\tfor(var i = 0; i < num_opening_parens; i++){\n\t\tif(paren_string.match(/\\\
    (/g)[i] == '('){\n\t\t\tgroup_opening_paren_group.push(paren_string.match(/\\\
    (/g)[i]);\n\t\t}\n\t\telse{\n\t\t\tgroup_opening_paren_group.push(\")\");\n\t\t\
    }\n\t\topening_opening_paren_group.push(paren_string.match(/\\(/g)[i]);\n\t}\n\
    \t\n\tfor(var i = 0; i < num_closing_braces; i++){\n\t\tbrace_position.push(i);\n\
    \t}\n\t\n\tfor(var i = 0; i < num_opening_parens; i++){\n\t\tif(paren_string.match(/\\\
    (/g)[i] == '('){\n\t\t\tgroup_opening_paren_group.push(\")\");\n\t\t}\n\t\telse{\n\
    \t\t\tgroup_opening_paren_group.push(\"(\");\n\t\t}\n\t\topening_opening_paren_group.push(\"\
    )\");\n\t}\n\t\n\tfor(var i = 0; i < num_opening_parens; i++){\n\t\tif(paren_string.match(/\\\
    (/g)[i] == '('){\n\t\t\tgroup_opening_paren_group.push(\")\");\n\t\t}\n\t\telse{\n\
    \t\t\tgroup_opening_paren_group.push(\"(\");\n\t\t}\n\t\topening_opening_paren_group.push(\"\
    (\");\n\t}\n\t\n\tvar num_groups = group_opening_paren_group.length;\n\tfor(var\
    \ i = 0; i < num_opening_groups; i++){\n\t\tgroups.push(group_opening_paren_group[i]);\n\
    \t\tgroup_opening_counter = group_opening_counter + 1;\n\t\tif(group_opening_counter\
    \ == num_groups){\n\t\t\tgroup_opening_counter = 0;\n\t\t}\n\t\tgroups.push(group_opening_paren_group[group_opening_counter]);\n\
    \t\tgroup_opening_counter = group_opening_counter + 1;", "\tvar group_arr = paren_string.replace(/\\\
    (([^)]+?)\\)/g,'( $1 )').replace(/\\(/g,'( ').replace(/\\)/g,' ) ').replace(/\
    \ +/g,' ').trim().split(\" \");\n\tif(group_arr[0].length==0) group_arr.shift();\n\
    \treturn group_arr;\n}\n\n", "  const groups = paren_string.replace(/^\\s+|\\\
    s+$/g,'').match(/[^(]+\\([^(]*\\)/g) || [];\n  return groups.map( g => paren_string.substring(\
    \ g.length ) ).filter( (g, i) => groups[i] === g );\n}\n\n", "  var open_braces\
    \ = ['(', ')', '{', '}'];\n  var close_braces = ['{', '}'];\n\n  var group_stack\
    \ = [];\n  var return_array = [];\n\n  for (var i = 0; i < paren_string.length;\
    \ i++) {\n    if (paren_string[i] == open_braces[0]) {\n      if (group_stack.length\
    \ == 0) {\n        return_array.push(paren_string[i]);\n      } else {\n     \
    \   group_stack[group_stack.length-1].push(paren_string[i]);\n      }\n    } else\
    \ if (paren_string[i] == close_braces[0]) {\n      if (group_stack.length == 0)\
    \ {\n        return_array.push(paren_string[i]);\n      } else {\n        group_stack[group_stack.length-1].push(paren_string[i]);\n\
    \      }\n    } else if (paren_string[i] == open_braces[1] || paren_string[i]\
    \ == close_braces[1]) {\n      var current_group_stack = [];\n      var current_group\
    \ = [];\n      for (var j = 1; j < group_stack.length; j++) {\n        current_group\
    \ = [];\n        current_group_stack = group_stack[j];\n        for (var k = 0;\
    \ k < current_group_stack.length; k++) {\n          current_group.push(current_group_stack[k]);\n\
    \        }\n        return_array.push(current_group);\n      }\n      group_stack\
    \ = [];\n    } else if (paren_string[i] == ' ') {\n      group_stack.push([]);\n\
    \    } else {\n      if (group_stack.length == 0) {\n        return_array.push(paren_string[i]);\n\
    \      }\n    }\n  }\n  return return_array;\n}\n", "  const stack = [];\n  const\
    \ current_paren = paren_string;\n  let last_open_paren = -1;\n  let last_close_paren\
    \ = 0;\n  let groups = [];\n\n  while(current_paren.length > 0){\n    if(current_paren.charAt(0)=='('){\n\
    \      stack.push(current_paren.substr(1,current_paren.length-1))\n      current_paren\
    \ = current_paren.substr(1,current_paren.length-1);\n    } else {\n      if(current_paren.charAt(0)==')'){\n\
    \        stack.pop();\n        current_paren = current_paren.substr(1,current_paren.length-1);\n\
    \      }\n    }\n  }\n\n  groups = stack.reverse();\n  for(let i = 0; i < groups.length;\
    \ i++){\n    current_paren = current_paren.replace(groups[i],\"\");\n  }\n  return\
    \ current_paren;\n}\n\n", "\tvar regex_groups = /(([^()]*))(\\s*(([^()]*))*)/;\n\
    \tvar regex_paren = /(\\(|\\))/g;\n\tvar groups = [];\n\tvar last_index = 0;\n\
    \tvar paren_index = 0;\n\t\n\t// Loop through all groups and save them in an array\
    \ and return the array\n\twhile(paren_index < paren_string.length){\n\t\tvar match\
    \ = regex_groups.exec(paren_string);\n\t\t\n\t\t// If there's an opening brace\
    \ then add the group otherwise return the array as it is\n\t\tif(match){\n\t\t\
    \tgroups.push(paren_string.slice(last_index, match[0].length));\n\t\t\tlast_index\
    \ = regex_groups.lastIndex;\n\t\t\t\n\t\t\tparen_index++;\n\t\t}\n\t\telse{\n\t\
    \t\tgroups.push(paren_string.slice(last_index));\n\t\t\tlast_index = regex_groups.lastIndex;\n\
    \t\t}\n\t}\n\t\n\t// Add the last group if there's an opening brace\n\tif(last_index\
    \ != paren_string.length){\n\t\tgroups.push(paren_string.slice(last_index));\n\
    \t}\n\t\n\treturn groups;\n}\n", "    if(paren_string === undefined) return undefined;\n\
    \    else if(!paren_string) return [];\n    \n    var open_brace_count=0, \n \
    \       closed_paren_count =0, \n        open_paren_strings=[],\n        close_paren_strings=[];\n\
    \n    for(let i=0; i < paren_string.length; i++){\n        let char = paren_string[i];\n\
    \        switch(char){\n            case '(':\n                open_brace_count++;\n\
    \                break;\n            case ')':\n                closed_paren_count++;\n\
    \                break;\n            case '{':\n                open_paren_strings.push(paren_string.substr(0,i));\n\
    \                break;\n            case '}':\n                close_paren_strings.push(paren_string.substr(0,i));\n\
    \                break;\n            case '[':\n                open_paren_strings.push(paren_string.substr(0,i));\n\
    \                break;\n            case ']':\n                close_paren_strings.push(paren_string.substr(0,i));\n\
    \                break;\n            default:\n                open_paren_strings.push(char);\n\
    \                break;\n        }\n    }\n\n    console.log(open_paren_strings);\n\
    \    console.log(close_paren_strings);\n    console.log(open_brace_count);\n \
    \   console.log(closed_paren_count);\n\n    return open_paren_strings.concat(close_paren_strings).concat(open_paren_strings.slice(-closed_paren_count))\n\
    }\n", "\tvar paren_string = paren_string.replace(/\\s*\\([^\\)]*\\)\\s*|\\s+/g,'');\n\
    \tvar paren_string = paren_string.replace(/\\s*\\([^\\)]*\\)\\s*|\\s+/g,'');\n\
    \n\tvar\tgroup_stack = paren_string.split('(');\n\tvar\tresult = [];\n\n\tfor(var\
    \ i = 0, len = group_stack.length; i < len; i++){\n\t\tvar cur_str = group_stack[i].trim();\n\
    \n\t\tif(cur_str){\n\t\t\tresult.push(cur_str);\n\t\t}\n\t}\n\n\treturn result;\n\
    }\n", "\tlet paren_regex = /[()]+/g;\n\treturn paren_string.match(paren_regex).map(item\
    \ => {\n\t\treturn item.replace(/[()]+/g, \"\\\\\" + item);\n\t});\n}\n", "\t\
    var result = [];\n\t\n\tvar group_open = false;\n\t\n\t//This loop will keep going\
    \ until there is no more input. Once it hits a closing paren, it will add the\
    \ string to the result array\n\tfor(var i = 0; i < paren_string.length; i++){\n\
    \t\tif(paren_string[i] == \"(\"){\n\t\t\t//Check to see if this is the first open\
    \ paren\n\t\t\tif(!group_open){\n\t\t\t\tresult.push(paren_string.substr(0,i+1));\n\
    \t\t\t\tgroup_open = true;\n\t\t\t}else{\n\t\t\t\t//If this is the first open\
    \ paren, check the following character and see if it is a closing paren.\n\t\t\
    \t\tif(paren_string[i+1] == \"(\"){\n\t\t\t\t\tgroup_open = true;\n\t\t\t\t}else{\n\
    \t\t\t\t\t//If it is not the first open paren and the closing paren is not a space,\
    \ then we are inside the paren. Add it to the result array.\n\t\t\t\t\tresult.push(paren_string.substr(i+1));\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\t//If this is not an open paren, check to\
    \ see if it is a closing paren.\n\t\t\tif(paren_string[i] == \")\"){\n\t\t\t\t\
    //If it is the last open paren, then we are done with the string. Add it to the\
    \ result array.\n\t\t\t\tif(!group_open){\n\t\t\t\t\tresult.push(paren_string.substr(i+1));\n\
    \t\t\t\t}else{\n\t\t\t\t\t//If we are inside the paren, add it to the result array,\
    \ but ignore any spaces.\n\t\t\t\t\tresult.push(paren_string.substr(i+1).replace(/\
    \ /g,\"\"));\n\t\t\t\t}\n\t\t\t\tgroup_open = false;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return result;\n}\n", "  var paren_groups = [];\n  paren_string = paren_string.trim();\n\
    \  var regex = new RegExp(/(\\()(\\))|(\\()(\\()|(\\)())/g);\n  var matches =\
    \ paren_string.match(regex);\n  if(matches){\n    for(var i in matches){\n   \
    \   if(matches[i].length % 2 != 0){\n        var open_paren_index = paren_string.indexOf('(',i);\n\
    \        var close_paren_index = paren_string.indexOf(')',i);\n        if(close_paren_index\
    \ < 0 || close_paren_index > open_paren_index){\n          var open_paren_string\
    \ = paren_string.substr(0,i+1);\n          var close_paren_string = paren_string.substr(close_paren_index+1);\n\
    \          paren_groups.push(open_paren_string);\n          paren_groups.push(close_paren_string);\n\
    \        }\n      }\n    }\n  }\n  return paren_groups;\n}\n", "  var paren_string\
    \ = paren_string.replace(/\\s/g, \"\"); // remove all white space\n  var paren_string_array\
    \ = paren_string.match(/\\(.*\\)/g); // find all matches of \"(paren_char)\" in\
    \ the input string\n  if(paren_string_array == null){\n    return [];\n  }\n \
    \ else{\n    var open_paren_groups = []; // create an empty array to push open\
    \ paren groups into\n    var open_paren_group_array = []; // create an empty array\
    \ to push open paren groups themselves into for each match found\n    var close_paren_group_array\
    \ = []; // create an empty array to push close paren groups themselves into for\
    \ each match found\n    // loop through each match found and create an array to\
    \ push each paren group into the open_paren_group_array and close_paren_group_array\
    \ arrays\n    for(var i = 0; i < (paren_string_array.length); i++){\n      if(paren_string_array[i].match(/[\\\
    (\\)]/)){\n        if(open_paren_group_array.length > 0){\n          open_paren_group_array.push(open_paren_groups);\n\
    \          open_paren_groups = [];\n        }\n        close_paren_group_array.push(paren_string_array[i].replace(/[\\\
    (\\)]/g, \"\"));\n      }\n      else{\n        if(open_paren_groups.length >\
    \ 0){\n          open_paren_groups.push(paren_string_array[i]);\n        }\n \
    \       else{\n          open_paren_groups.push(paren_string_array[i].replace(/[\\\
    (\\)]/g, \"\"));\n        }\n      }\n    }\n    if(open_paren_groups.length >\
    \ 0){\n      open_paren_group_array.push(open_paren_groups);\n      open_paren_groups\
    \ = [];\n    }\n    return open_paren_group_array;\n  }\n}\n", "\tvar paren_regex\
    \ = new RegExp(\"\\(([^()]+|\\([^()]*\\))*\\)\");\n\tvar match = paren_regex.exec(paren_string);\n\
    \tvar paren_groups = [];\n\tvar current_group = [];\n\twhile(match !== null){\n\
    \t\t//This condition will be true when there are no more groups to be added.\n\
    \t\tif(current_group.length > 0){\n\t\t\t//We are finished processing this set\
    \ of parentheses\n\t\t\tif(current_group.length > 0){\n\t\t\t\tparen_groups.push(current_group);\n\
    \t\t\t}\n\t\t\t//Create a new array and start a new set of parentheses\n\t\t\t\
    current_group = [];\n\t\t}\n\t\t//Add the next value to the current array\n\t\t\
    current_group.push(match[1]);\n\t\t//Move to the next match\n\t\tmatch = paren_regex.exec(paren_string);\n\
    \t}\n\t//Finish off the current group\n\tif(current_group.length > 0){\n\t\tparen_groups.push(current_group);\n\
    \t}\n\treturn paren_groups;\n}", "\tvar paren_strings = paren_string.split(/\\\
    s*[\\(\\)]+\\s*/);\n\tvar result = [];\n\tvar current_item;\n\tvar current_paren\
    \ = 0;\n\tvar paren_string_index = 0;\n\tvar paren_openers = 0;\n\tfor(var i =\
    \ 0; i < paren_strings.length; i++){\n\t\tcurrent_item = paren_strings[i];\n\t\
    \tparen_string_index = paren_string.indexOf(current_item);\n\t\tif(paren_string_index\
    \ == -1){\n\t\t\tcontinue;\n\t\t}\n\t\tif(paren_openers == 0){\n\t\t\tcurrent_paren++;\n\
    \t\t}\n\t\telse{\n\t\t\tcurrent_paren--;\n\t\t}\n\t\tif(current_paren == 0){\n\
    \t\t\tif(current_item.slice(0,1) == \")\"){\n\t\t\t\tresult.push(current_item.slice(1));\n\
    \t\t\t}\n\t\t}\n\t\telse{\n\t\t\tcontinue;\n\t\t}\n\t\tif(paren_string_index +\
    \ current_item.length == paren_string.length){\n\t\t\tresult.push(current_item);\n\
    \t\t}\n\t\telse{\n\t\t\tparen_openers--;\n\t\t}\n\t}\n\treturn result;\n}\n",
  "\tvar tokens = paren_string.match(/[^(]*\\(([^)]*)\\)[^(]*\\)[^(]*\\(([^)]*)\\\
    )[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\\
    (([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\\
    )[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\\
    (([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\\
    )[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\\
    (([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\\
    )[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\\
    (([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\\
    )[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\\
    (([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\\
    )[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^(]*\\(([^)]*)\\)[^", "    // Split the\
    \ input string into separate groups\n    var split_str = paren_string.split(/[\\\
    (\\)]/);\n    // Keep a separate array for the groups split by parens\n    var\
    \ parent_groups = [];\n    // Keep a separate array for the groups not split by\
    \ parens\n    var nonParent_groups = [];\n    // For each group in the input string\n\
    \    for(var i = 0; i < split_str.length; i++){\n        // If it isn't a paren,\
    \ add it to the nonParent_groups array\n        if(split_str[i].charAt(0) != '('){\n\
    \            nonParent_groups.push(split_str[i]);\n        }\n        // Otherwise,\
    \ add a parent group\n        else{\n            parent_groups.push(split_str[i]);\n\
    \        }\n    }\n    // Return both parent and nonParent_groups\n    return\
    \ [parent_groups, nonParent_groups];\n}\n", "    // Write your logic here\n  \
    \  var groups = paren_string.match(/\\((.*)\\)/g);\n    if (groups === null){\n\
    \        return [paren_string];\n    }\n    var group_results = [];\n    for (i\
    \ = 0; i < groups.length; i++){\n        groups[i] = groups[i].replace(/\\s/g,\
    \ '');\n        group_results.push(groups[i]);\n    }\n    return group_results;\n\
    }\n", "\tlet paren_groups = paren_string.split(/(?=(\\\\)))/);\n\tlet paren_group_array\
    \ = [];\n\tlet group_index = 0;\n\tfor (let group of paren_groups){\n\t\tlet paren_group_string\
    \ = group;\n\t\tif (group_index < paren_groups.length){\n\t\t\tparen_group_string\
    \ += \")\";\n\t\t}\n\t\tparen_group_array.push(paren_group_string);\n\t\tgroup_index\
    \ += 1;\n\t}\n\treturn paren_group_array;\n}\n\n", "    var paren_string = paren_string.replace(/\\\
    s+/g,\" \");\n    var parent_array = [];\n    var paren_level = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        switch(paren_string[i]){\n  \
    \          case \"(\":\n                paren_level++;\n                parent_array.push(paren_string[i]);\n\
    \                break;\n            case \")\":\n                paren_level--;\n\
    \                if(paren_level == 0){\n                    parent_array.push(paren_string[i]);\n\
    \                }\n                break;\n            default:\n           \
    \     parent_array.push(paren_string[i]);\n        }\n    }\n    return parent_array;\n\
    }\n", "\tlet paren_groups = [];\n\tparen_string = paren_string.trim();\n\tlet\
    \ open_brackets = paren_string.match(/\\(/g);\n\tlet close_brackets = paren_string.match(/\\\
    )/g);\n\tlet i;\n\tif (open_brackets != null && close_brackets != null){\n\t\t\
    for(i=0;i<open_brackets.length;i++){\n\t\t\tparen_string = paren_string.replace(open_brackets[i],\"\
    \");\n\t\t\tparen_string = paren_string.replace(close_brackets[i],\"\");\n\t\t\
    }\n\t\tparen_string = paren_string.trim();\n\t\tparen_string = paren_string.split(\"\
    \ \");\n\t\tfor(i=0;i<paren_string.length;i++){\n\t\t\tparen_groups.push(paren_string[i].trim());\n\
    \t\t}\n\t\treturn paren_groups;\n\t}\n\treturn null;\n}\n", "\tvar input_string\
    \ = paren_string;\n\tvar paren_groups = [];\n\tvar paren_group_counter = 0;\n\t\
    var paren_group_start = false;\n\tvar paren_group_closing = false;\n\tvar paren_group_opening_counter\
    \ = 0;\n\tvar paren_group_opening_paren_counter = 0;\n\tvar paren_group_opening_paren_stack\
    \ = [];\n\n\tfor(var i = 0; i < input_string.length; i++){\n\t\tif(paren_group_opening_counter\
    \ == 0){\n\t\t\tif(paren_group_opening_paren_counter > 0){\n\t\t\t\tparen_group_opening_paren_stack.pop();\n\
    \t\t\t\tparen_group_opening_counter--;\n\t\t\t}\n\t\t}else if(paren_group_opening_paren_counter\
    \ == paren_group_opening_counter){\n\t\t\tif(input_string[i] == '('){\n\t\t\t\t\
    paren_group_opening_paren_stack.push(paren_group_opening_paren_counter);\n\t\t\
    \t\tparen_group_opening_counter++;\n\t\t\t}else if(input_string[i] == ')'){\n\t\
    \t\t\tvar paren_group_length = paren_group_opening_paren_stack.pop();\n\t\t\t\t\
    paren_group_opening_counter--;\n\t\t\t\tparen_group_closing = true;\n\t\t\t\t\
    for(var j = 1; j < paren_group_length; j++){\n\t\t\t\t\tparen_groups.push(paren_group_start\
    \ + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(paren_group_opening_paren_counter ==\
    \ 0){\n\t\t\tif(input_string[i] == '('){\n\t\t\t\tparen_group_opening_counter++;\n\
    \t\t\t}else if(input_string[i] == ')'){\n\t\t\t\tparen_group_closing = false;\n\
    \t\t\t\tparen_group_opening_paren_counter++;\n\t\t\t}\n\t\t}\n\t}\n\treturn paren_groups;\n\
    }\n", "    if(!paren_string){\n        throw new Error(\"no paren string provided!\"\
    );\n    }\n    let matches = [];\n    let stack = [];\n    let index = 0;\n  \
    \  for(let i = 0; i < paren_string.length; i++){\n        if(paren_string.charAt(i)\
    \ == '('){\n            stack.push(i);\n        }else if(paren_string.charAt(i)\
    \ == ')'){\n            let last_close_brace_index = stack.pop();\n          \
    \  for(let j = 0; j < last_close_brace_index - index; j++){\n                matches.push(paren_string.substring(index\
    \ + 1 + j, last_close_brace_index + 1 + j));\n            }\n            index\
    \ = last_close_brace_index + 1;\n        }else if(paren_string.charAt(i) == '\
    \ ' && stack.length > 0){\n            let last_close_brace_index = stack.pop();\n\
    \            for(let j = 0; j < i; j++){\n                matches.push(paren_string.substring(index\
    \ + 1 + j, last_close_brace_index + 1 + j));\n            }\n            index\
    \ = last_close_brace_index + 1;\n        }\n    }\n    for(let j = 0; j < index;\
    \ j++){\n        matches.push(paren_string.substring(j + 1, index + 1));\n   \
    \ }\n    return matches;\n}", "  let parenGroups = paren_string\n    .trim()\n\
    \    .split(/\\s*\\([^()]*\\)\\s*/)\n    .filter(Boolean);\n  return parenGroups;\n\
    }\n", "\tvar paren_groups = paren_string.match( /\\((.*?)\\)/g );\n\tif ( paren_groups\
    \ != null ){\n\t\treturn paren_groups;\n\t}\n\treturn null;\n}\n", "    //Get\
    \ the first character in the string and initialize a stack with it\n    var cur_char\
    \ = paren_string.charAt(0);\n    var stack = [];\n    stack.push(cur_char);\n\
    \    var paren_stack_string = \"\";\n    //While the stack is not empty\n    while\
    \ (stack.length > 0){\n        //Get the current character of the stack\n    \
    \    cur_char = stack.pop();\n        //If this character is a left paren then\
    \ push it onto the stack\n        if (cur_char == \"(\"){\n            stack.push(cur_char);\n\
    \        }\n        //If this character is a right paren then pop the stack until\
    \ you reach a left paren\n        else if (cur_char == \")\"){\n            while\
    \ (stack.length > 0){\n                cur_char = stack.pop();\n             \
    \   if (cur_char == \"(\"){\n                    stack.push(cur_char);\n     \
    \           }\n            }\n        }\n        //If this character is a left\
    \ paren then add it to the stack\n        else if (cur_char == \"{\"){\n     \
    \       stack.push(cur_char);\n            paren_stack_string += cur_char;\n \
    \       }\n        //If this character is a right paren then add it to the stack\n\
    \        else if (cur_char == \"}\"){\n            while (stack.length > 0){\n\
    \                cur_char = stack.pop();\n                if (cur_char == \"}\"\
    ){\n                    stack.push(cur_char);\n                }\n           \
    \ }\n        }\n        //If this character is a comma then add it to the stack\n\
    \        else if (cur_char == \",\"){\n            stack.push(cur_char);\n   \
    \         paren_stack_string += cur_char;\n        }\n        //If this character\
    \ is not a left paren or a right paren then add it to the string\n        else\
    \ {\n            paren_stack_string += cur_char;\n        }\n    }\n    //Return\
    \ the string containing the bracket groups\n    return paren_stack_string;\n}\n\
    </code>\n<|/ a tags=regex,javascript,html,jquery |>\n<| a tags=regex,javascript,html,jquery\
    \ dscore=0 |>\nIf it's only ever one level deep and you can guarantee no other\
    \ brackets are in it, it could be done like this:\n<code>\nvar match = /(\\([^)]*\\\
    ))/g.exec(\"(foo)\");\nif(match)\n    match[1] = match[1].slice(1,-1);\n</code>\n\
    <|/ a |>\n<| c |>\nI don't think this works - it misses the final bracket.\n<|/\
    \ c |>\n<| a dscore=0 |>\nThis works also if the parens are mixed within other\
    \ parens, as long as you know that there will be no nested parens, like ()()\n\
    <code>\nvar parens = \"(foo (bar ((baz)foo (bar)))\";\nvar matches = ", "  //\
    \ Split into groups and separate the groups with a single space \n  let groups\
    \ = paren_string.replace(/[()]/g, \" \").split(\" \");\n\n  // Create an array\
    \ of all groups\n  let grouped = groups.map(group => {\n    return group.replace(/\\\
    s\\s+/g, \" \");\n  });\n\n  // Return the array of groups separated by space\n\
    \  return grouped;\n}\n\n", "  // TODO: Implement this function\n  return [];\n\
    }\n", "    //Write your code here!\n    return paren_string.match(/[()]+/g);\n\
    }\n", "    let paren_array_of_groups = [];\n    let current_paren_group = \"\"\
    ;\n    let paren_string_list = paren_string.split(\"\");\n    \n    for(let i\
    \ = 0; i < paren_string_list.length; i++){\n        if(paren_string_list[i] ===\
    \ '('){\n            if(current_paren_group.length !== 0){\n                paren_array_of_groups.push(current_paren_group);\n\
    \                current_paren_group = \"\";\n            }\n        }else if(paren_string_list[i]\
    \ === ')'){\n            paren_array_of_groups.push(current_paren_group);\n  \
    \          current_paren_group = \"\";\n        }else{\n            current_paren_group\
    \ += paren_string_list[i];\n        }\n    }\n\n    if(current_paren_group.length\
    \ !== 0){\n        paren_array_of_groups.push(current_paren_group);\n    }\n \
    \   return paren_array_of_groups;\n}\n", "\tvar arr_return = [];\n\tvar current_group\
    \ = \"\";\n\tfor(var i = 0;i < paren_string.length;i++){\n\t\tif(paren_string.charAt(i)\
    \ === \"(\"){\n\t\t\tif(current_group !== \"\") arr_return.push(current_group);\n\
    \t\t\tcurrent_group = \"\";\n\t\t}else{\n\t\t\tif(current_group === \"\") current_group\
    \ += paren_string.charAt(i);\n\t\t\telse current_group += paren_string.charAt(i)\
    \ + \")\";\n\t\t}\n\t}\n\tif(current_group !== \"\") arr_return.push(current_group);\n\
    \treturn arr_return;\n}", "\tparen_string = paren_string.replace(/\\s/g, \"\"\
    );\n\tvar result = [];\n\tvar counter = 0;\n\tvar open_brace_count = 0;\n\tvar\
    \ close_brace_count = 0;\n\tvar paren_group = \"\";\n\tfor (var i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] === \")\"){\n\t\t\tif(open_brace_count === counter){\n\
    \t\t\t\tresult.push(paren_group);\n\t\t\t\tparen_group = \"\";\n\t\t\t\tclose_brace_count++;\n\
    \t\t\t}else{\n\t\t\t\tparen_group += paren_string[i];\n\t\t\t\tclose_brace_count++;\n\
    \t\t\t}\n\t\t}else if(paren_string[i] === \"(\"){\n\t\t\topen_brace_count++;\n\
    \t\t\tparen_group += paren_string[i];\n\t\t}else{\n\t\t\tparen_group += paren_string[i];\n\
    \t\t}\n\t}\n\tif(open_brace_count !== close_brace_count){\n\t\tresult.push(paren_group);\n\
    \t}\n\treturn result;\n}", "    var groups = [];\n    var current_group = null;\n\
    \    var open_brace_positions = [];\n    paren_string = paren_string.replace(/\\\
    s+/g, '');\n    for(var i = 0; i<paren_string.length; i++){\n        var letter\
    \ = paren_string[i];\n        if(letter == '('){\n            if(current_group){\n\
    \                open_brace_positions.push(current_group.length);\n          \
    \  }\n            current_group = [];\n        }else if(letter == ')'){\n    \
    \        var open_positions = open_brace_positions;\n            open_brace_positions\
    \ = [];\n            var first_open_position = open_positions[0];\n          \
    \  var last_close_position = open_positions[open_positions.length-1];\n      \
    \      if(last_close_position == current_group.length){\n                current_group.push(i);\n\
    \            }else{\n                for(var j=0; j<last_close_position; j++){\n\
    \                    var close_position = open_positions[j];\n               \
    \     if(close_position == current_group.length){\n                        current_group.push(i);\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n            if(current_group.length > 0){\n                groups.push(current_group);\n\
    \                current_group = null;\n            }\n        }else if(letter\
    \ == ','){\n            if(current_group){\n                current_group.push(i);\n\
    \            }\n        }\n    }\n    return groups;\n}\n</code>\n<|/ a tags=regex,string,javascript,php,jquery\
    \ |>\n<| c |>\nThat is indeed a very good answer! It is the simplest one so far\
    \ and very smart. Thank you very much!\n<|/ c |>\n<| c |>\nYou don't have to worry\
    \ about the order of the groups in the output. The function will take care of\
    \ that.\n<|/ c |>\n<| c |>\nThis code doesn't work in PHP 5.3.8, as `preg_split()`\
    \ appears to not accept regular expressions as delimiters.  Do you know if there's\
    \ a way to modify this code that doesn't require 5.3.8 compatibility?\n<|/ c |>\n\
    <| c |>\n, just use `preg_match()`. You'll need to convert the delimiters if they\
    \ need to be replaced.\n<|/ c |>\n<| a tags=regex,string,javascript,php,jquery\
    \ |>\nI wouldn't be too worried about performance too much since it's really not\
    \ that complex. You have to worry about performance only if you're dealing with\
    \ really large strings. So the only thing you should care about is readability\
    \ and maintainability, of course:\n<code>", "  var result = new Array();\n  var\
    \ depth = 0;\n  for( var i = 0; i < paren_string.length; i++){\n    // Handle\
    \ spaces within the group (i.e. \"( ) ()\")\n    var spaces = new Array(depth\
    \ + 1).join(\" \");\n    var open_brace = new Array(depth + 1).join(\"\");\n \
    \   // If this character is inside an open brace, decrement depth\n    if (paren_string[i]\
    \ == open_brace){\n      depth--;\n    } else {\n      // If this is a space outside\
    \ of an open brace, increment depth\n      if (paren_string[i] == \" \"){\n  \
    \      depth++;\n      } else {\n        // Otherwise, add it to the result\n\
    \        result.push(paren_string[i]);\n      }\n    }\n  }\n  return result;\n\
    }\n</code>\nThe code above is essentially a modified version of Morgan's code:\
    \ he only keeps track of which depth a parenthesis is currently in. That's a bit\
    \ more work, but it will make the code much easier to read and understand.\n<|/\
    \ a dscore=1 |>\n<| c |>\nYeah I've tried that, but for some reason it doesn't\
    \ work correctly. I'm sure it's something small I'm missing, but I can't seem\
    \ to figure out what it is.\n<|/ c |>\n<| c |>\nI just realized something. Your\
    \ code works when I'm only parsing parenthesis, but doesn't work when I'm parsing\
    \ nested parenthesis.\n<|/ c |>\n<| c |>\nI thought that might be the case. My\
    \ code should handle nested parenthesis just fine (unless there's something wrong\
    \ with my test case). Can you please post an example of it not working? I tested\
    \ it against your test cases.\n<|/ c |>\n<| c |>\nAh sorry, it works perfectly.\
    \ I just messed up where I was calling it. Thanks so much for your help!\n<|/\
    \ c |>\n<| c |>\nNo problem. Happy to help. If you found my answer helpful, please\
    \ consider marking it as the accepted answer.\n<|/ c |>\n<| a dscore=1 tags=javascript,algorithm\
    \ |>\nHere's my solution which I believe is both short and simple. It also doesn't\
    \ require any library (except for underscore)\n<code>\nvar paren_group = function(string){\n\
    \    var _group = [];\n    var _level = 0;\n    _paren_level = function(string){\n\
    \        var _level = 1;\n        for( var i = 0; i < string.length; i++){\n \
    \           var char = string[i];\n            if(char === '('){\n           \
    \     _level++;\n            }else if(char === ')'){\n                _level--;\n\
    \            }\n            if(_level <= 0){\n                _group.push(char);\n\
    \            }\n        }\n    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
