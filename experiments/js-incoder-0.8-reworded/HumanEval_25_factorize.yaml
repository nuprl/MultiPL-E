name: HumanEval_25_factorize
language: js
prompt: "//Return array of prime factors of given integer in the order from smallest\
  \ to largest.\n// Each of the factors should be arrayed number of times corresponding\
  \ to how many times it appeares in factorization.\n// Input number should be equal\
  \ to the product of all factors\n// >>> factorize(8)\n// [2, 2, 2]\n// >>> factorize(25)\n\
  // [5, 5]\n// >>> factorize(70)\n// [2, 5, 7]\nfunction factorize(n){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = factorize;\n  assert.deepEqual(candidate(2),[2]);\n  assert.deepEqual(candidate(4),[2,\
  \ 2]);\n  assert.deepEqual(candidate(8),[2, 2, 2]);\n  assert.deepEqual(candidate(57),[3,\
  \ 19]);\n  assert.deepEqual(candidate(3249),[3, 3, 19, 19]);\n  assert.deepEqual(candidate(185193),[3,\
  \ 3, 3, 19, 19, 19]);\n  assert.deepEqual(candidate(20577),[3, 19, 19, 19]);\n \
  \ assert.deepEqual(candidate(18),[2, 3, 3]);\n}\n\ntest();"
completions: ["    var factors = [];\n    for(var i = 0; i < n; i++){\n        for(var\
    \ j = 0; j < factors.length; j++){\n            if(factors[j] % i == 0){\n   \
    \             factors.push(i);\n                break;\n            }\n      \
    \  }\n    }\n    return factors;\n}\n", "  var primeFactors = [];\n  for(var i=2;i<=Math.sqrt(n);i++){\n\
    \    while(n%i == 0){\n      primeFactors.push(i);\n      n = n/i;\n    }\n  }\n\
    \  return primeFactors;\n}", "\tvar factors = [],\n\t\tfactor,\n\t\ti,\n\t\tprimeFactors\
    \ = primeFactorization(n);\n\t\n\tfor(i = 2; i < primeFactors.length; i++){\n\t\
    \tfactor = primeFactors[i];\n\t\twhile(factor % i){\n\t\t\tfactor /= i;\n\t\t\
    }\n\t\tfactors.push(factor);\n\t}\n\t\n\treturn factors;\n}", "\tif(n == 1) return\
    \ [1];\n\tlet results = [];\n\tlet divisor = 1;\n\tlet factor = 2;\n\twhile(divisor\
    \ * factor <= n){\n\t\tif(n % factor == 0){\n\t\t\tresults.push([factor]);\n\t\
    \t\tn /= factor;\n\t\t}else{\n\t\t\tfactor += 1;\n\t\t}\n\t\tdivisor *= factor;\n\
    \t}\n\treturn results;\n}\n", "\tvar factors = [], x = Math.floor(n/2), i, factor;\n\
    \tfor(i=0; i<factors.length; i++)\n\t\tfactor = factors[i];\n\t\t\n\t\tif(n%factor\
    \ === 0){\n\t\t\tfactors[factors.length] = factor;\n\t\t\tfactors.push(n/factor);\n\
    \t\t\tbreak;\n\t\t}\n\t\t\n\t\twhile(n % factor === 0 && factor--){\n\t\t\tfactors[factors.length]\
    \ = factor;\n\t\t\tn = n/factor;\n\t\t}\n\t\t\n\t\tif(factor<0)\n\t\t\tthrow new\
    \ Error('Factorization Error');\n\t\n\treturn factors;\n}\n", "\tif(n<1){\n\t\t\
    return [];\n\t}\n\tvar factors=[];\n\tfor(i=1;i<=n;i++){\n\t\tvar p=1;\n\t\twhile(n%i){\n\
    \t\t\tp*=i;\n\t\t}\n\t\tif(p!==n){\n\t\t\tfactors.push(p);\n\t\t}\n\t}\n\treturn\
    \ factors;\n}\n", "  var factors = [],\n      i;\n  for(i = 2; i <= Math.sqrt(n);\
    \ ++i){\n    if((n % i) === 0){\n      factors.push(i);\n      n = n / i;\n  \
    \  }\n  }\n  factors.push(n);\n  return factors;\n}\n", "\tlet factors = [];\n\
    \tfor(let i = 2; i < n; i++){\n\t\tlet divisors = 0;\n\t\twhile(n % i == 0){\n\
    \t\t\tdivisors++;\n\t\t\tn /= i;\n\t\t}\n\t\tfactors[divisors] = factors[divisors]\
    \  || [];\n\t\tfactors[divisors].push(i);\n\t}\n\treturn factors;\n}\n", "\tvar\
    \ factorization = [], factor = 0, i, j, primes = [];\n\tfor (i = 2; i <= n; i++){\n\
    \t\tprimes.push(2);\n\t}\n\tfor (i = 0; i < primes.length; i++){\n\t\tfor (j =\
    \ i; j < primes.length; j++){\n\t\t\tif (primes[j] % primes[i] === 0){\n\t\t\t\
    \tprimes[i] += 1;\n\t\t\t\tfactorization[factor] = primes[i];\n\t\t\t\tfactor++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn factorization;\n}\n", "    let divisor = factors.filter(n\
    \ => n % n === 0);\n    let factors = [];\n\n    for(let i = 0; i < divisor.length;\
    \ i++) {\n        let times = divisor[i] / n;\n        factors.push(times);\n\
    \        divisor[i] = divisor[i] % n;\n    }\n\n    return divisor;\n}\n", "\t\
    var factors = [],\n\t\ti,\n\t\tprimes = [];\n\n\t// Factor each possible number\n\
    \tfor(i = 2; i <= Math.sqrt(n); i++){\n\t\t// if factor is found, push it into\
    \ factors\n\t\tif(n % i == 0){\n\t\t\tfactors.push(i);\n\t\t}\n\t}\n\t// If factors\
    \ are found push them into primes array in order from smallest to largest\n\t\
    if(factors.length){\n\t\tfactors.forEach(function(factor){\n\t\t\tvar index =\
    \ 0;\n\t\t\t// Loop through factors array\n\t\t\twhile(index < factors.length\
    \ && factor % factors[index] == 0){\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\t// If factor\
    \ is not found push it into primes array\n\t\t\tif(index == factors.length){\n\
    \t\t\t\tprimes.push(factor);\n\t\t\t}\n\t\t});\n\t}\n\treturn primes;\n}", " \
    \ var factors = [];\n  for(var i=2; i<=Math.sqrt(n)+1; i++){\n    if(n % i ==\
    \ 0){\n      var factor = [i, n/i];\n      for(var j=0; j<factors.length; j++){\n\
    \        var factor = factors[j];\n        if(factor[0] == factor[1]){\n     \
    \     factors.push(factor);\n        }\n      }\n      factors.push(factor);\n\
    \    }\n  }\n  return factors;\n}\n", "\treturn primeFactors(n);\n}\n", "\t//\
    \ Find factors less than or equal to n\n\tfor(var i = factors.length-1; i>=0;\
    \ i--){\n\t\tif(factors[i]<=n){\n\t\t\t// Found a factor, remove it from the array\
    \ and reduce the product by that factor\n\t\t\tfactors.splice(i, 1);\n\t\t\tn\
    \ = n/factors[i];\n\t\t\t// If the product is not equal to the original input\
    \ number, the original number is a prime number.\n\t\t\t// We need to keep searching\
    \ for a more prime number. Let's repeat this process.\n\t\t\tif(n===1){\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// Return array of factors\n\treturn factors;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nIt would be helpful to explain how your solution\
    \ works. Just giving the code doesn't help the OP understand why it's working.\n\
    <|/ c |>\n<| c |>\nThis solution is very good but my project is using C++.\n<|/\
    \ c |>\n<| c |>\nYou probably can get help with your c++ issue. As I mentioned,\
    \ this is pure javascript.\n<|/ c |>\n<| a dscore=2 |>\nA very interesting question\
    \ and I wonder why nobody has given yet an answer. The only thing I can think\
    \ of is that this is probably the hardest thing to solve for computer science\
    \ graduates without being a mathematician. But it's also a pretty interesting\
    \ problem so I'm posting this anyways.\nI'm pretty sure that there's no efficient\
    \ way to check if a number is a prime. I did some research and I found these algorithms\
    \ that will probably be of some use to you:\nSieve of Eratosthenes\nThe first\
    \ algorithm is basically a sieve of eratosthenes. It essentially takes out the\
    \ numbers from your list that have already been multiplied in the process of multiplying\
    \ all the remaining numbers.\nFor example if your list was [1, 2, 3, 7, 8, 9,\
    \ 5] it would take out all the numbers that have been multiplied by 2: [2, 3,\
    \ 7, 9, 5] and multiply them all by 2, then take out all those that have been\
    \ multiplied by 3: [2, 3, 9, 5]. These would all be multiplied together by the\
    \ 7: [7, 9, 5] and multiplied together by 8: [9, 5].\nSo basically you multiply\
    \ your list by all prime numbers. Then you check if the list you've multiplied\
    \ is greater than your original number. If it is, then you know that your number\
    \ is prime.\n<code>", "    if (n <= 1){\n        return [1]\n    }\n    let f\
    \ = []\n    for (let i = 2; i <= Math.sqrt(n); i++){\n        if (n % i == 0){\n\
    \            f.push(i)\n            n = n / i\n        }\n    }\n    return f\n\
    }\n", "  let factors = [];\n  for(var i = 1; i <= n; i++){\n    let tempFactors\
    \ = factorizeHelper(i);\n    for(let j of tempFactors){\n      factors.push(j);\n\
    \    }\n  }\n  return factors;\n}\n", "    let factors = [];\n    let primes =\
    \ [];\n    let primeFactors = [];\n    let composites = [];\n    let compositeFactors\
    \ = [];\n    let n = Math.ceil(n);\n    let nMinusOne = n - 1;\n    let nMinusTwo\
    \ = n - 2;\n    let nMinusThree = n - 3;\n    let nMinusFour = n - 4;\n    let\
    \ nMinusFive = n - 5;\n    let nMinusSix = n - 6;\n    let nMinusSeven = n - 7;\n\
    \n    let isComposite;\n\n    let lastFactor = 1;\n    let lastFactorIsPrime;\n\
    \n    for(let i = 1; i <= n; i++){\n        isComposite = false;\n\n        for(let\
    \ j = 0; j < factors.length; j++){\n            if(factors[j] == i){\n       \
    \         isComposite = true;\n                break;\n            }\n       \
    \ }\n\n        if(isComposite == false){\n            primes.push(i);\n      \
    \      factors.push(i);\n            if(i * lastFactor != n){\n              \
    \  composites.push(i * lastFactor);\n                compositeFactors.push(lastFactor);\n\
    \            }\n        }\n\n        lastFactor = i;\n        lastFactorIsPrime\
    \ = false;\n\n        for(let j = 0; j < primes.length; j++){\n            if(primes[j]\
    \ * lastFactor == n){\n                lastFactorIsPrime = true;\n           \
    \     break;\n            }\n        }\n\n        if(lastFactorIsPrime == true){\n\
    \            primes.push(lastFactor);\n            factors.push(lastFactor);\n\
    \            composites.push(n);\n            compositeFactors.push(lastFactor);\n\
    \        }\n\n        lastFactor = 1;\n    }\n\n    return factors;\n}\n", " \
    \   const factors = []\n    for (let i = 2; i <= Math.sqrt(n); i++){\n       \
    \ if (n % i == 0){\n            factors.push(i);\n            n/= i;\n       \
    \ }\n    }\n    return factors;\n}\n", "\treturn n.toString().split('').map(Number).map(function(n){\n\
    \t\tvar factors = n.toString().split('');\n\t\tvar numFactors = factors.length;\n\
    \t\tvar primes = [];\n\t\tfor(var i = 0; i < numFactors; ++i){\n\t\t\tprimes.push(factors[i]);\n\
    \t\t}\n\t\treturn primes;\n\t});\n}", "  var factors = [],\n      factor = 1;\
    \ //factor is current factor we are working on.\n  while(n!==1){\n    //While\
    \ current number is not equal to one\n    for(var i=0;i<factors.length;i++){\n\
    \      //Check if the number is equal to factor we are working on\n      if(n%factors[i]===0){\n\
    \        //If so, remove it from the factors.\n        factors.splice(i,1);\n\
    \        //Make current number equal to factor\n        factor=factors[i];\n \
    \     }\n    }\n    //If no factor is found push it on to the array.\n    if(factors.length===0){\n\
    \      factors.push(n);\n    }\n    //Make current number equal to the current\
    \ factor\n    n=factor;\n  }\n  //Return array of factors\n  return factors;\n\
    }\n", "  var factors = [];\n  var i, f;\n  for (i = factors.length; i <= n; i++){\n\
    \    f = factorizeHelper(factors, i, n);\n    if (f.length) factors = f;\n  }\n\
    \  return factors;\n}\n", "    if (n <= 1) {\n      return [n, 1];\n    }\n  \
    \  var factors = [];\n    var i = 2;\n    var prev = 0;\n    while (i < n) {\n\
    \      if (n % i === 0) {\n        factors.push(i );\n        while (n % i ===\
    \ 0) {\n          n /= i;\n          i++;\n        }\n      } else {\n       \
    \ i++;\n      }\n    }\n    factors.push(n );\n    factors.push(prev);\n    factors.push(n\
    \ - 1);\n    return factors;\n}\n", "    var factors = [1];\n    for(var i = 2;\
    \ i < n; i++){\n        if(n % i === 0){\n            factors.push(i);\n     \
    \       n = n/i;\n        }\n    }\n    return factors;\n}", "    for(var factorization\
    \ = [], i = 2; i <= n; i++){\n        for(var j = 0; j < i; j++){\n          \
    \  if(n%i == 0){\n                factorization[j] = (factorization[j] || 0) +\
    \ 1;\n                n = n / i;\n            }\n        }\n    }\n    return\
    \ factorization;\n}\n", "  var factors = [];\n  var i = 2;\n  while(n % i != 0){\n\
    \    factors.push(i);\n    i++;\n  }\n  for(var i = factors.length; i--;){\n \
    \   var f = 0;\n    for(var j = factors.length; j--;){\n      f += factors[j]\
    \ * factors[i];\n    }\n    factors.splice(i,1,f);\n  }\n  return factors;\n}\n",
  "  let arr = factorization(n).map(e => e.filter((e, i) => e !== 1).length);\n  return\
    \ arr.sort((a, b) => b - a);\n}\n", "  var fs=[],\n      i=0,\n      f=0;\n  while(true){\n\
    \    f=i; i=n%i; n=i; //Get new f, i\n    fs[i-1]+=f; //Add to array in correct\
    \ place\n    if(i==0){ break; } //Stop as soon as we find i to be a factor\n \
    \ }\n  return fs;\n}\n", "    let factors = [];\n    let num = n;\n\n    //If\
    \ the given number is less than 2, return empty array\n    if(n < 2){\n      \
    \  return factors;\n    }\n\n    //If given number is prime, return its factors\n\
    \    if (is_prime(num)){\n        return [num];\n    }\n\n    //If given number\
    \ is composite and does not contain 1 then return empty array\n    if (num ===\
    \ 1){\n        return factors;\n    }\n\n    //Loop through the factorization\
    \ array and find those factors that contain current number\n    for (let i = 0;\
    \ i < factors.length; i++){\n        if (factors[i] < num){\n            continue;\n\
    \        } else {\n            while(num % factors[i] === 0){\n              \
    \  num = num / factors[i];\n                factors[i] = factors[i] + 1;\n   \
    \         }\n        }\n    }\n    return factors;\n}\n\n", "\tvar factors = [];\n\
    \tvar factorNumber = 1;\n\twhile(factorNumber <= n){\n\t\tvar divOfFactors = Math.floor(factorNumber/2);\n\
    \t\tfactors.push(divOfFactors);\n\t\tfactorNumber = divOfFactors * 2;\n\t}\n\t\
    return factors;\n}\n", "\tvar factors = [];\n\tif(n == 1){\n\t\treturn factors;\n\
    \t}\n\t\n\t// Get all prime factors of n\n\tvar primeFactors = primeFactorization(n);\n\
    \t\n\t// Get all factors less than n\n\tfor(var i = primeFactors.length - 1; i\
    \ >= 0; i--){\n\t\tif(n%primeFactors[i] == 0){\n\t\t\tfactors.push(primeFactors[i]);\n\
    \t\t\tn /= primeFactors[i];\n\t\t}\n\t}\n\t\n\tfactors.push(n);\n\treturn factors;\n\
    }\n", "\tvar factors = [];\n\tvar i;\n\tfor(i = 2; i <= Math.sqrt(n); i++){\n\t\
    \tif(n % i == 0){\n\t\t\tfor(var j = i; j <= Math.sqrt(n); j++){\n\t\t\t\tif(n\
    \ % j == 0){\n\t\t\t\t\tif(j != i){\n\t\t\t\t\t\tfactors.push(j);\n\t\t\t\t\t\t\
    n /= j;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(n\
    \ > 1){\n\t\tfactors.push(n);\n\t}\n\treturn factors;\n}\n", "\tlet factors =\
    \ []\n\tfor(let i = 2; i <= Math.sqrt(n); i++){\n\t\tif(n%i === 0) factors.push(i);\n\
    \t}\n\treturn factors;\n}\n", "\tvar factors = [];\n\t\n\twhile (n > 1) {\n\t\t\
    var x = Math.floor(n/2);\n\t\tfactors.push(x);\n\t\t\n\t\tfor (var i = x; i>1;\
    \ i--) {\n\t\t\tif ((n % i) == 0) {\n\t\t\t\tfactors.push(i);\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tn = Math.floor(n/2);\n\t}\n\t\n\treturn factors;\n}\n", "\t\
    let factors = [];\n\tlet largest = Math.ceil(n/2);\n\twhile (largest>=1){\n\t\t\
    let counter = 1;\n\t\twhile (counter*largest<=n){\n\t\t\tfactors.push(counter);\n\
    \t\t\tcounter++;\n\t\t}\n\t\tlargest--;\n\t}\n\tif (factors.length>0){\n\t\tfactors.push(2);\n\
    \t}\n\treturn factors;\n}\n", "\tif(!Number.isInteger(n) || n < 1){\n\t\tthrow\
    \ new TypeError(\"Please specify a valid integer for factorization.\");\n\t}\n\
    \n\tvar factorization = [],\n\t\tdivisor = 2,\n\t\tfactor;\n\n\twhile(divisor\
    \ < n){\n\t\tif(n % divisor){\n\t\t\tfactorization.push(divisor);\n\t\t\tdivisor++;\n\
    \t\t} else {\n\t\t\tfactorization.push(divisor);\n\t\t\tn /= divisor;\n\t\t}\n\
    \t}\n\n\treturn factorization;\n}\n", "  let factors = [];\n  let i = 2;\n  while(i\
    \ <= n){\n    if(n%i == 0){\n      factors.push(i);\n      n = n/i;\n      i++;\n\
    \    }\n  }\n  return factors;\n}\n", "  var factors = [];\n  for(var i = 2; i\
    \ < n; i++){\n    if(n % i == 0){\n      factors.push(i);\n      n = n / i;\n\
    \    }\n  }\n  if(n > 1){\n    factors.push(1);\n  }\n  return factors;\n}\n",
  "\t\n\t// create array of prime numbers upto given number\n\tvar primes = [];\n\t\
    for(var i=0;i<=n;i++){\n\t\tif(isPrime(i)){\n\t\t\tprimes.push(i);\n\t\t}\n\t\
    }\n\t\n\t// count each number in array\n\tvar count = {};\n\tfor(var i=0;i<primes.length;i++){\n\
    \t\tcount[primes[i]] = count[primes[i]]?count[primes[i]]+1:1;\n\t}\n\t\n\t// create\
    \ array of factors\n\tvar factors = [];\n\tfor(var i=1;i<primes.length;i++){\n\
    \t\tvar p = primes[i];\n\t\tvar c = count[p];\n\t\tfor(var j=1;j<c;j++){\n\t\t\
    \tfactors.push(p);\n\t\t}\n\t}\n\t\n\treturn factors;\n}\n\n", "\tlet factors\
    \ = [];\n\tlet min = 1;\n\tlet max = n;\n\twhile(max != min){\n\t\twhile(n % max\
    \ == 0){\n\t\t\tfactors.push(max);\n\t\t\tn /= max;\n\t\t}\n\t\twhile(n % min\
    \ == 0){\n\t\t\tfactors.push(min);\n\t\t\tn /= min;\n\t\t}\n\t\tif(n < min){\n\
    \t\t\tmin = max;\n\t\t}\n\t\telse{\n\t\t\tmax = min;\n\t\t}\n\t}\n\treturn factors;\n\
    }\n", "  var factors = [];\n  while(n%2 === 0){\n    n = n/2;\n    factors.push(2);\n\
    \  }\n  for(var i = 2; i <= Math.sqrt(n); i++){\n    if(n%i === 0){\n      n =\
    \ n/i;\n      factors.push(i);\n      factors.push(Math.sqrt(n));\n    }\n  }\n\
    \  return factors;\n}\n", "\tvar factors = [];\n\tfactorizationHelper(n, factors);\n\
    \treturn factors;\n}\n", "  let factors = []\n  for (var i = 2; i <= n; i++) {\n\
    \    while (n % i === 0) {\n      factors.push(i)\n      n /= i\n    }\n  }\n\
    \  return factors\n}", "    let factors = [];\n    let factor = 1;\n    let isPrime\
    \ = true;\n\n    for(let i = 1; i <= n; i++){\n        if(n % i === 0){\n    \
    \        factor *= i;\n            factors.push(factor);\n            isPrime\
    \ = true;\n\n            for(let j = 1; j <= (n - factor) / 2; j++){\n       \
    \         if(!isPrime && factors.indexOf(j * factor) !== -1){\n              \
    \      factors.push(j * factor);\n                    isPrime = false;\n     \
    \           }\n            }\n        }\n    }\n    return factors;\n}\n</code>\n\
    <|/ a tags=algorithm,python,javascript,factorization |>\n<| a dscore=0 |>\nA very\
    \ simple solution is to use the Sieve of Eratosthenes - https://en.m.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    <code>", "    var p = [];\n    for(var i = 0; i < n.length; i++){\n        var\
    \ x = n[i];\n        if(p.indexOf(x) == -1){\n            p.push(x);\n       \
    \ }\n    }\n    return p;\n}\n", "  var factors = [];\n  for (var i = 0; i < n;\
    \ i++){\n    factors.push(i);\n    for (var j = i + 1; j < n; j++){\n      if\
    \ (n % j == 0){\n        factors.push(j);\n        n = n / j;\n        break;\n\
    \      }\n    }\n  }\n  return factors;\n}\n\n", "\tvar factors=[];\n\tvar divisor=1;\n\
    \tvar divisorCount=1;\n\twhile(divisorCount*divisor<n){\n\t\twhile(divisorCount%n==0){\n\
    \t\t\tdivisorCount++;\n\t\t\tdivisor++;\n\t\t}\n\t\tfactors.push(divisor);\n\t\
    \tdivisorCount=1;\n\t\tdivisor=1;\n\t}\n\treturn factors;\n}\n", "\tconst factors\
    \ = [];\n\tfor(let i = 1; i < n; i++){\n\t\twhile(n % i == 0){\n\t\t\tfactors.push(i);\n\
    \t\t\tn /= i;\n\t\t}\n\t}\n\treturn factors;\n}\n", "\t\n\tif (n == 1){\n\t\t\
    return [];\n\t}\n\t\n\tlet factorArray = [];\n\t\n\tfor(let i = 1; i <= n; i++){\n\
    \t\tlet numOfTimes = 0;\n\t\tfor(let j = 0; j < factorArray.length; j++){\n\t\t\
    \tif(factorArray[j] == i){\n\t\t\t\tnumOfTimes++;\n\t\t\t}\n\t\t}\n\t\tfactorArray.push(numOfTimes);\n\
    \t}\n\treturn factorArray;\n}\n", "  if(!isInteger(n)) return [];\n  var arr =\
    \ [1],\n      factors = factorize(n);\n  for(var i = 1, ii = factors.length; i\
    \ < ii; i++){\n    var f = factors[i], \n        j = 1,\n        k = arr.length\
    \ - 1;\n    for(; k >= i && f[j] * f[k] === arr[k]; k--, j++);\n    if(k != i)\
    \ arr.splice(k, 0, 1);\n  }\n  arr.push(parseInt(n));\n  return arr;\n}", "\t\
    var factors = [],\n\t\tcurrentNum = 1;\n\twhile(n > 0){\n\t\tfor(var i = factors.length;\
    \ i--;){\n\t\t\tif(n % factors[i] === 0){\n\t\t\t\tfactors.splice(i, 1);\n\t\t\
    \t\tn = n / factors[i];\n\t\t\t\tcurrentNum *= factors[i];\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t\tif(!factors.length){\n\t\t\tfactors.push(n);\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn factors;\n}\n", "    var factors=[],primes=[],i=1,p;\n  \
    \  for(p=2;p*p<=n;p++){\n        if(n%p==0){\n            primes.push(p);\n  \
    \          factors.push(1);\n            for(i=2;i*i<=p;i++)\n               \
    \ factors.push(i*p);\n        }\n    }\n    for(i=primes.length-1;i>=0;i--){\n\
    \        factors.push(primes[i]);\n    }\n    return factors;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nI got it. Thank you\n<|/ c |>\n<| a tags=math,primes,factorization,algorithm\
    \ |>\nI found it interesting how some of the ideas presented here have become\
    \ \"opinions\" and are now hard to implement as standards. Here is a simpler solution\
    \ to the problem. \nI wrote a JavaScript function that returns a list of prime\
    \ factors of a number. \n<code>", "\tvar factors = [];\n\tfor(var i = 2; i <=\
    \ Math.sqrt(n); i++)\n\t\tif(n%i===0)\n\t\t\tfactors.push(i);\n\t\telse\n\t\t\t\
    break;\n\n\treturn factors;\n}\n", "\tvar factors = [];\n\t\n\twhile(n){\n\t\t\
    if(n%2 == 0){\n\t\t\tn = (n/2);\n\t\t\tfactors.push([2,2]);\n\t\t}\n\t\telse{\n\
    \t\t\tvar d = Math.sqrt(n);\n\t\t\tn = n/d;\n\t\t\tfactors.push([d,d]);\n\t\t\
    }\n\t}\n\t\n\treturn factors;\n}", "\tlet f = 1, factors = [], primes = []\n\t\
    for(let i = 2; i <= n; i++)\n\t\tfor(let j = i; j > 1; j--)\n\t\t\tif(n%j ===\
    \ 0){\n\t\t\t\tf = i*j\n\t\t\t\tprimes.push(f)\n\t\t\t\tbreak\n\t\t\t}\n\t\tfactors.push(f)\n\
    \treturn [factors,primes]\n}\n", "\tfor(var i = 1;i <= Math.sqrt(n);i++){\n\t\t\
    if(n % i === 0){\n\t\t\tvar j = Math.floor(i / 2);\n\t\t\tvar factors = factorize(n/i);\n\
    \t\t\tvar new_factors = [];\n\t\t\tfor (var k = 0; k < factors.length; k++){\n\
    \t\t\t\tnew_factors[k] = factors[k] + factors[j];\n\t\t\t}\n\t\t\treturn new_factors;\n\
    \t\t}\n\t}\n\treturn [n];\n}\n\n", "\tvar factors = [],\n\t\ti,\n\t\tf = factor(n);\n\
    \tfor(i = 0; i < f.length; i++){\n\t\tfactors.push(f[i]);\n\t}\n\treturn factors;\n\
    }\n", "  if(n === 1) return [n];\n  if(n === 2) return [2];\n\n  let factors =\
    \ [];\n\n  let smallerNum = n;\n  let greaterNum = n;\n  while(smallerNum * greaterNum\
    \ >= 1){\n    let smallerFactors = factorize(smallerNum);\n    let greaterFactors\
    \ = factorize(greaterNum);\n    if(smallerFactors.length === greaterFactors.length){\n\
    \      for(let i=0; i<smallerFactors.length; i++){\n        factors.push(smallerFactors[i]*greaterFactors[i]);\n\
    \      }\n      break;\n    }\n  }\n  return factors;\n}\n", "\tvar f = [];\n\t\
    var factors = [];\n\tvar div = [];\n\tvar isDivisible = true;\n\tvar i = 1;\n\n\
    \twhile(n >= i){\n\t\tdiv = Array(i);\n\t\tfor(var j=0;j<i;j++)\n\t\t\tdiv[j]\
    \ = n%i;\n\t\tfor(var j=i;j<div.length;j++)\n\t\t\tdiv[j] = 0;\n\t\tif(div.length\
    \ > 1){\n\t\t\tfactors.push(div);\n\t\t\tf.push(i);\n\t\t}\n\t\tn = Math.floor(n\
    \ / i);\n\t\ti++;\n\t}\n\n\tif(isDivisible){\n\t\tfor(var j=0;j<f.length;j++)\n\
    \t\t\tfactors.push(f[j]);\n\t}\n\n\treturn factors;\n}\n\n", "\tlet factors =\
    \ [];\n\tfor(let i = 2; i < n; i++){\n\t\twhile(n % i == 0){\n\t\t\tfactors.push(i);\n\
    \t\t\tn /= i;\n\t\t}\n\t}\n\tif(n > 1){\n\t\tfactors.push(n);\n\t}\n\treturn factors;\n\
    }\n", "    var factors = [],\n        factor,\n        i;\n\n    for(i = 1; i\
    \ <= n; i++){\n        factor = i;\n        while(factor * factor <= n){\n   \
    \         factor += 1;\n        }\n        factors.push(factor);\n    }\n    factors.sort();\n\
    \    return factors;\n}\n", "  var arr = factorization(n);\n  return arr.map(function(val){\n\
    \    return val.reduce((acc, el)=>acc*el, 1);\n  });\n}\n", "    var factors =\
    \ [];\n    var primeFactors = [];\n    for(var i = 1; i <= n; i++){\n        for(var\
    \ j = 0; j < factors.length; j++){\n            var factor = factors[j];\n   \
    \         if(factor*i === n){\n                primeFactors.push(factor);\n  \
    \              factors.splice(j, 1);\n                break;\n            }\n\
    \        }\n    }\n    factors.push(primeFactors);\n    return factors;\n}\n",
  "\tlet factors = []\n\tlet primes = []\n\tlet numOfPrimes = 2\n\tlet temp = [n]\n\
    \t\n\t// Finds factors and adds them to the array\n\twhile(temp.length){\n\t\t\
    let currentNum = temp.pop()\n\t\tlet currentFactors = []\n\t\t\n\t\t// If number\
    \ is prime\n\t\tif(isPrime(numOfPrimes)){\n\t\t\tprimes.push(numOfPrimes)\n\t\t\
    \tnumOfPrimes = 2\n\t\t}\n\t\t\n\t\t// Finds all factors of number using Euclid's\
    \ Algorithm.\n\t\t// If no factors are found then all prime numbers are added\
    \ to factors\n\t\tlet currentNumFactors = divisors(currentNum)\n\t\tlet factorsFound\
    \ = false\n\t\tfor(let i = 0; i < currentNumFactors.length; i++){\n\t\t\tif(currentNumFactors[i]\
    \ == 1){\n\t\t\t\tfactors.push(currentNumFactors[i])\n\t\t\t\tfactorsFound = true\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\t// If no factors are found\n\t\tif(factorsFound ===\
    \ false){\n\t\t\tprimes.push(numOfPrimes)\n\t\t\tnumOfPrimes = 2\n\t\t}\n\t\t\n\
    \t\tnumOfPrimes = numOfPrimes * 2\n\t}\n\t\n\treturn primes\n}\n", "    var i\
    \ = 2;\n    while(i <= Math.sqrt(n)){\n        if(n%i == 0){\n            var\
    \ arr = Array.from(Array(i+1).keys()).map(i => i*i);\n            return arr.concat(n/i);\n\
    \        }\n        i++;\n    }\n    return [];\n}\n", "  var factors = [];\n\
    \  for(var i = 2; i <= Math.sqrt(n); i++){\n    if(n % i == 0){\n      factors.push(i);\n\
    \      n = n / i;\n    }\n  }\n  return factors;\n}", "  var factors = [];\n \
    \ var primeFactors = [];\n  var multiple = 1;\n  var currentFactor = 1;\n\n  for(var\
    \ i = 0; i < n; i++){\n    multiple = multiple * i;\n  }\n\n  while(true){\n \
    \   currentFactor = multiple % i;\n    if(currentFactor != 1){\n      factors.push(currentFactor);\n\
    \    }\n\n    if(!multiple){\n      break;\n    }\n    multiple = multiple / i;\n\
    \n    for(var i = 0; i < n; i++){\n      currentFactor = multiple % i;\n     \
    \ if(currentFactor != 1){\n        factors.push(currentFactor);\n      }\n   \
    \   multiple = multiple / i;\n    }\n  }\n\n  for(var j = 0; j < factors.length;\
    \ j++){\n    primeFactors.push(factors[j]);\n  }\n  return primeFactors;\n}\n\n",
  "\tvar result = [];\n\t\n\tvar factorCount = 1;\n\t\n\twhile(n > 1){\n\t\tif(n %\
    \ 2 == 1){\n\t\t\tn /= 2;\n\t\t\t\n\t\t\tvar factorNumber = 2;\n\t\t\twhile(n\
    \ % factorNumber == 0){\n\t\t\t\tn /= factorNumber;\n\t\t\t\tresult.push(factorNumber);\n\
    \t\t\t\tfactorCount++;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tn /= 2;\n\t\t\tvar factorNumber\
    \ = 5;\n\t\t\twhile(n % factorNumber == 0){\n\t\t\t\tn /= factorNumber;\n\t\t\t\
    \tresult.push(factorNumber);\n\t\t\t\tfactorCount++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \tif(n > 1){\n\t\tresult.push(1);\n\t\tfactorCount++;\n\t}\n\t\n\treturn result;\n\
    }\n", "    var fac = [],\n        i,\n        facNum;\n    \n    for(i=2;i<=n;i++){\n\
    \        facNum = 0;\n        for(var f=0;f<fac.length;f++){\n            if(fac[f]\
    \ == i){\n                facNum++;\n                break;\n            }\n \
    \       }\n        fac.push(facNum);\n    }\n    \n    return fac;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nPlease add some explanation to this code, what are you doing,\
    \ how it works and why it works.\n<|/ c |>\n<| a tags=javascript,arrays,sorting,algorithm\
    \ |>\n<code>\nvar factorization = function(n) {\n  var a = [],\n      i = 2,\n\
    \      f = 1;\n  while (n / i > 0) {\n    if (n % i == 0) {\n      a.push(i);\n\
    \      n /= i;\n    } else {\n      ++f;\n    }\n    i++;\n  }\n  a.push(n);\n\
    \  return a.length ? a : [n];\n};", "\tvar res = [];\n\tfor(var i = 0; i < factors[n].length;\
    \ i++){\n\t\tres.push([n, factors[n][i]]);\n\t}\n\treturn res.sort();\n}\n", " \
    \   let arr = [];\n    let factor;\n    for(let i = 2; i <= n; i++){\n       \
    \ for(factor of factorization(i)){\n            if(factors.includes(factor)){\n\
    \                arr.push(factor);\n                break;\n            }\n  \
    \      }\n    }\n    return arr;\n}\n", "\tvar factors = [];\n\tvar numFactors\
    \ = 0;\n\tfactors.push(1);\n\tfor(var i = 0; i < n; i++){\n\t\tfor(var j = 0;\
    \ j < factors.length; j++){\n\t\t\twhile(n % factors[j] == 0){\n\t\t\t\tif(j ==\
    \ 0){\n\t\t\t\t\tnumFactors++;\n\t\t\t\t}\n\t\t\t\tfactors.push(factors[j]);\n\
    \t\t\t\tn /= factors[j];\n\t\t\t\tfactors[factors.length - 1]++;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn numFactors > 1 ? factors : null;\n}\n", "    let factors = [],\
    \ factor = 0, count = 0;\n    \n    while(n > 1){\n        factor = n / factor;\n\
    \        count += 1;\n        factors.push(factor);\n        n = factor;\n   \
    \ }\n    factors.push(1);\n    \n    return factors;\n}\n", "  var factors = [];\n\
    \  var i = 2;\n  while(factors.length<n && i<n+1){\n    if(isPrime(i)){\n    \
    \  factors.push(i);\n      while(factors.length<n && i<n+i){\n        i++;\n \
    \       if(isPrime(i)){\n          factors.push(i);\n        }\n      }\n    }\n\
    \    i++;\n  }\n  return factors;\n}\n", "\tlet factors = []\n\tfor(let i = 2;\
    \ i < Math.sqrt(n); i++){\n\t\tlet count = 0, isPrime = true\n\t\tlet j = 0\n\t\
    \twhile(j < factors.length && isPrime && isPrime == false){\n\t\t\tif(n % i ==\
    \ 0){\n\t\t\t\tisPrime = true\n\t\t\t\tfactors[j] = i\n\t\t\t\tcount++\n\t\t\t\
    }\n\t\t\tj++\n\t\t}\n\t\tif(count > 1){\n\t\t\tfactors.push(count)\n\t\t}\n\t\
    }\n\treturn factors\n}\n", "\tvar factors = [];\n\tvar i = 2;\n\twhile(n!=1){\n\
    \t\tvar j = 2;\n\t\twhile(n%i==0){\n\t\t\tj = j+2;\n\t\t}\n\t\tif(j==i){\n\t\t\
    \tfactors.push(i);\n\t\t\tn = n/i;\n\t\t}else{\n\t\t\ti = i+j;\n\t\t}\n\t}\n\t\
    return factors;\n}\n", "  for(var k = 1; k <= n / 2; k++){\n    if(n % k === 0){\n\
    \      return [k];\n    }\n  }\n}\n", "    if(n === 1 || n === 0){\n        return\
    \ [1]\n    }\n    let factors = []\n    for(let i=1;i<n;i++){\n        if(n %\
    \ i === 0){\n            while(n % i === 0){\n                factors.push(i)\n\
    \                n = n/i\n            }\n            factors.push(i)\n       \
    \ }\n    }\n    return factors\n}\n", "\tvar factors = [];\n\tvar i=0;\n\twhile(factors[i]\
    \ === undefined){\n\t\ti++;\n\t\tfactors.push(i);\n\t\tif(n%i === 0) return factors;\n\
    \t\twhile(n % i !== 0){\n\t\t\tn /= i;\n\t\t\tfactors.push(i);\n\t\t}\n\t}\n\t\
    if(n > 1 && factors.length < n) return factors;\n\tif(factors.length > n) return\
    \ factors.slice(factors.length - n);\n\treturn factors;\n}\n", "  var results\
    \ = [],\n      i=1,\n      a = bigInt(Math.sqrt(n)),\n      b = bigInt(n),\n \
    \     factor = bigInt(1);\n  while (!b.equals(a)) {\n    if (b.mod(a).equals(BigInt(1)))\
    \ {\n      results.push(factor);\n      factor = 1;\n    } else {\n      factor\
    \ = a;\n    }\n    b = b.div(a);\n    i++;\n  }\n  if (b.equals(a)) {\n    results.push(factor);\n\
    \  }\n  return results;\n}\n", "  var factors = [];\n  for (var i = 2; i < Math.sqrt(n);\
    \ i++){\n    if (n % i == 0) factors.push(i);\n    for (var j = Math.sqrt(n);\
    \ j > i; j--){\n      if (n % i == 0 && n % j == 0) factors.push(j);\n      if\
    \ (n % (i + j) == 0) factors.push(i + j);\n    }\n  }\n  return factors;\n}\n",
  "   var factors = [];\n   var factorizer = new Factorizer();\n   factors = factorizer.getFactors(n);\n\
    \   factors.sort(function(a, b){return b-a});\n   return factors;\n}\n</code>\n\
    <|/ a tags=algorithm,math,factorization,primes |>\n<| c |>\nThank you for the\
    \ reply. I am trying to understand your code. Why do you require the use of Math.sqrt(n)\
    \ and Math.floor(n) ?\n<|/ c |>\n<| c |>\nMath.sqrt calculates sqrt of a number.\
    \ This is not needed when you are already passing factorized number as input to\
    \ getFactors method. Math.floor(n) ensures that you get an integer as output.\n\
    <|/ c |>\n<| c |>\nThe above code doesn't work. getFactors method doesn't return\
    \ factorized number.\n<|/ c |>\n<| a dscore=1 |>\nI agree with answer. I am giving\
    \ the answer here because this question may be useful to some beginners. Just\
    \ to add my two cents.\n<code>", "\tvar result = new Array(n);\n\t\n\tfor(var\
    \ i = 0; i < n; i++){\n\t\tfor(var j = 0; j < i; j++){\n\t\t\tif(n%i==0){\n\t\t\
    \t\tresult[i] = result[i] + result[j];\n\t\t\t\tn = n/i;\n\t\t\t}\n\t\t}\n\t}\n\
    \t\n\treturn result;\n}\n", "    const factorization = new Array(n)\n    for(let\
    \ i=0; i<factorization.length; i++){\n        factorization[i] = Math.pow(n, i)\n\
    \    }\n    factorization.sort((a,b)=>b-a)\n    return factorization\n}\n", "\t\
    var factorArr = [];\n\tfactorArr[0] = n;\n\tfactorArr.length = 1;\n\tif(n%2 ===\
    \ 0) return factorArr;\n\tfor(var i = 0; i < n; i++){\n\t\tif(n%i===0){\n\t\t\t\
    factorArr.push(Math.floor(n / i));\n\t\t\tn = n/i;\n\t\t}\n\t}\n\treturn factorArr;\n\
    }\n", "  var fac = new Array();\n  for(var i=1;i<=n;i++){\n    for(var j=1;j<=Math.sqrt(n);j++){\n\
    \      if(n%j==0){\n        fac[fac.length] = j;\n        n=n/j;\n      }\n  \
    \  }\n  }\n  return fac;\n}\n", "\tn = n + 1; //Get rid of 1 factor by adding\
    \ one to it.\n\tvar factors = [];\n\twhile (n>1){\n\t\tif (n%2 == 0)\n\t\t\tn\
    \ = n/2;\n\t\telse\n\t\t\tn = n*3 + 1;\n\t\tfactors.push(n);\n\t}\n\treturn factors;\n\
    }\n", "  let factors = [];\n  let temp = 1;\n  if(n === 1) return factors;\n \
    \ for(let i = 1; i <= n; i++){\n    if(n % i === 0) factors.push(i);\n    if(i\
    \ === n){\n      for(let j = 0; j < factors.length; j++){\n        temp = temp\
    \ * factors[j];\n      }\n      factors.push(temp);\n      temp = 1;\n    }\n\
    \  }\n  return factors;\n}\n", "\tvar arr = [];\n\tvar prime = 2, flag = 0;\n\n\
    \tfor(var i = 0; i < n; i++){\n\t\tflag = 0;\n\t\tfor(var j = 0; j < prime; j++){\n\
    \t\t\tif(n%prime == 0) flag++;\n\t\t}\n\t\tif(flag == 2) arr.push(prime);\n\t\t\
    prime++;\n\t}\n\treturn arr;\n}", "  var f= [],\n  div= n%1\n  if(div>1){\n  while(div!==1){\n\
    \      f=f.concat(factorize(div))\n      div=n%div\n  }\n  f.push(1)\n  }\n  return(f);\n\
    }\n", "\tvar primes = [];\n\tvar factors = [];\n\tvar i;\n\tvar j;\n\tvar fact;\n\
    \tvar tmp;\n\n\t// If n is 0, return empty array\n\tif(n === 0){\n\t\treturn [];\n\
    \t}\n\n\tfor(i = 2; i <= n; i++){\n\t\tfact = i;\n\n\t\t// If factor is prime\
    \ than add it to the prime array\n\t\tfor(j = 0; j < primes.length; j++){\n\t\t\
    \ttmp = primes[j];\n\t\t\tif(fact % tmp === 0){\n\t\t\t\tprimes.push(fact);\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If no prime factors exist add 1 to factors\
    \ array\n\t\tif(primes.length === 0){\n\t\t\tfactors.push(1);\n\t\t}\n\t\telse{\n\
    \t\t\t// While the factor is not equal to 1 or it is the only factor of n\n\t\t\
    \twhile((fact !== 1) || (primes.indexOf(fact) > -1)){\n\t\t\t\tfact = fact / i;\n\
    \t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t\tif(j === primes.length){\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t\ttmp = primes[j];\n\t\t\t}\n\n\t\t\t// If fact is 1, add to\
    \ factors array\n\t\t\tif(fact === 1){\n\t\t\t\tfactors.push(fact);\n\t\t\t\t\
    j++;\n\t\t\t\tif(j === primes.length){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\
    tmp = primes[j];\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return sorted array\n\treturn factors;\n\
    }\n", "  \n  const factorsHash = {};\n  \n  for(let i = 1; i < n; i++){\n    //\
    \ Check if number has factors other than 1 (primes)\n    if(isPrime(i)){\n   \
    \   for(let j = 0; j < factorsHash[factorsHash.length - 1]; j++){\n        if(n\
    \ % i == 0){\n          factorsHash.push(j);\n        }\n      }\n    }else{\n\
    \      factorsHash.push(i);\n    }\n  }\n  \n  return factorsHash;\n}\n", "  \
    \  var factors = [];\n    for(var i = 2; i < Math.sqrt(n); i++){\n        if(n\
    \ % i == 0){\n            factors.push(i);\n            n /= i;\n        }\n \
    \   }\n    if(n > 1){\n        factors.push(n);\n    }\n    return factors;\n\
    }\n", "    var fac = [];\n    for(var i = 0; i < n; i++){\n        var rem = n%i;\n\
    \        while(i === rem){\n            fac.push(i);\n            i = i/2\n  \
    \      }\n    }\n    return fac;\n}\n", "  let result = n\n  let factors = []\n\
    \  while(result > 1){\n    factors.push(result%10)\n    result = (result/10)-1\n\
    \  }\n  factors.push(result)\n  factors.sort((a, b) => b-a)\n  return factors\n\
    }\n", "    try{\n        if(n % 2 == 0) return [2,2];\n        if(n % 3 == 0)\
    \ return [3,3]\n        if(n % 5 == 0) return [5,5]\n        if(n % 7 == 0) return\
    \ [7,7]\n        if(n % 11 == 0) return [11,11]\n        if(n % 13 == 0) return\
    \ [13,13]\n        if(n % 17 == 0) return [17,17]\n    }catch(e){\n        console.log(\"\
    Error: \" + e)\n    }\n}\n", "\tvar factors = [];\n\tfor(var i = 0; i < n; i++){\n\
    \t\tvar f = [];\n\t\tfor(var j = 0; j < i; j++)\n\t\t\tf.push(n%j);\n\t\tfactors.push(f);\n\
    \t\tn = Math.floor(n/i);\n\t}\n\treturn factors;\n}\n", "  var factors=[];\n \
    \ for (var i=2;i*i<=n;i++){\n    if (n%i==0){\n      factors.push(i);\n      factors.push(n/i);\
    \ //Factor of i is its prime factor, and n//i is its inverse number.\n    }\n\
    \  }\n  return factors;\n}\n", "    // Base case\n    if (n === 0) {return []}\n\
    \    // The array which will hold factors\n    var arr = [];\n    // Initialize\
    \ array to the factors of n\n    var arr = factorize(n);\n    // Sort the array\
    \ in ascending order\n    arr.sort();\n    // Remove the duplicates\n    var newArr\
    \ = [];\n    for (var i=0; i<arr.length; i++){\n        var flag = false;\n  \
    \      for (var j=0; j<newArr.length; j++){\n            if (newArr[j].indexOf(arr[i])\
    \ === -1){\n                newArr.push(arr[i]);\n                flag = true;\n\
    \                break;\n            }\n        }\n        if (!flag){\n     \
    \       newArr.push(arr[i]);\n        }\n    }\n    return newArr;\n}\n", "\t\
    var primes = [];\n\tvar factors = [];\n\n\tfor(var i = 2; i <= Math.sqrt(n); i++){\n\
    \t\tif(n % i == 0){\n\t\t\twhile(n % i == 0){\n\t\t\t\tprimes.push(i);\n\t\t\t\
    \tn = n/i;\n\t\t\t}\n\t\t\tfactors.push(n);\n\t\t\tn = 1;\n\t\t}\n\t}\n\tfactors.push(n);\n\
    \treturn factors;\n}\n", "  var factorization = factorizations[n] || []; // if\
    \ no such factorization exists create an empty factorization\n  // now iterate\
    \ over all such factorizations and check for primtive divisors.\n  factorization\
    \ = factorization.map(function(factor) {\n    // now find the count of factors\
    \ from 1 to n\n    return factor.reduce(function(count, factor) {\n      return\
    \ count + (factor >= n ? 1 : 0);\n    }, 0);\n  });\n  return factorization.filter(function(factor)\
    \ {\n    return factor;\n  });\n}\n", "  let factors = [];\n  if(n === 1) return\
    \ [];\n  factors.push(n);\n  let i = 2;\n  while(factors.length < i) {\n    if(n\
    \ % i === 0) {\n      factors.push(i);\n      n /= i;\n    } else {\n      i++;\n\
    \    }\n  }\n  return factors;\n}\n", "    // Factorizing algorithm from https://en.wikipedia.org/wiki/Factorization\n\
    \    var factors = new Array();\n    while(n >= 2){\n        var candidate = n\
    \ % 2;\n        while(candidate > 1){\n            candidate /= 2;\n        }\n\
    \        factors.push(candidate);\n        n /= 2;\n    }\n    return factors;\n\
    }", "   var arr = [];\n   var i;\n   var j;\n   var factor;\n   var num;\n   var\
    \ total = 1;\n   for(i = 2; i <= n / 2; i++)\n   {\n      num = 1;\n      for(j\
    \ = 2; j < i; j++)\n      {\n         if(i % j === 0)\n         {\n          \
    \  num *= j;\n         }\n      }\n      if(num > 1)\n      {\n         arr.push(num);\n\
    \      }\n   }\n   for(i = 0; i < arr.length; i++)\n   {\n      for(j = arr.length\
    \ - 1; j > -1; j--)\n      {\n         if(arr[j] > arr[j + 1])\n         {\n \
    \           factor = arr[j];\n            arr[j] = arr[j + 1];\n            arr[j\
    \ + 1] = factor;\n         }\n      }\n   }\n   return arr;\n}\n", "\tif(n < 2\
    \ || n % 2 != 0) return [2,2];\n\tvar res = [];\n\tvar i = 2;\n\tvar isPrime =\
    \ true;\n\twhile(true){\n\t\twhile(n % i == 0){\n\t\t\tisPrime = false;\n\t\t\t\
    break;\n\t\t}\n\t\tres.push(i);\n\t\tif(!isPrime) break;\n\t\tn = n / i;\n\t\t\
    i++;\n\t}\n\treturn res;\n}\n", "  var result = [];\n  var primeFactors = [];\n\
    \  // Get all prime factors and store them in primeFactors array\n  for(var i\
    \ = 0; i < n; i++){\n    for(var j = 2; j < primeFactors.length; j++){\n     \
    \ if(n % primeFactors[j] === 0){\n        break;\n      }\n    }\n    if(j ===\
    \ primeFactors.length){\n      primeFactors.push(n);\n    }\n  }\n  // Now that\
    \ all prime factors are stored in primeFactors array \n  // Get products of all\
    \ factors in primeFactors array and store them in result array\n  for(var k =\
    \ 0; k < primeFactors.length; k++){\n    var value = primeFactors[k];\n    var\
    \ valueTimes = 1;\n    for(var i = 0; i < k; i++){\n      valueTimes *= value;\n\
    \    }\n    result.push(valueTimes);\n  }\n  return result;\n}</code>\n<|/ a |>\n\
    <| c |>\nThanks, i will try this too.\n<|/ c |>\n<| c |>\nWorks great!\n<|/ c\
    \ |>\n<| a dscore=2 |>\nAnother answer with time complexity O(sqrt(n)) and without\
    \ memoisation\n<code>", "\tif(!isPrime(n)){\n\t\tthrow new Error('Factorization\
    \ is only applicable to prime numbers');\n\t}\n\tvar factors = [];\n\tif(n%2 ==\
    \ 0){\n\t\tfactors.push(2);\n\t\tn = n/2;\n\t}\n\twhile(n > 1){\n\t\tif(n%2 ==\
    \ 0){\n\t\t\tfactors.push(2);\n\t\t\tn = n/2;\n\t\t}\n\t\telse{\n\t\t\tvar isOdd\
    \ = true;\n\t\t\tfor(var i=3;i<factors.length;i++){\n\t\t\t\tif(n%factors[i] ==\
    \ 0){\n\t\t\t\t\tisOdd = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\
    if(isOdd){\n\t\t\t\tfactors.push(n);\n\t\t\t\tn = n/factors[n];\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn factors;\n}\n", "  if(n < 2) return [];\n  if(n === 2) return\
    \ [2];\n  return factorizeHelper([], n);\n}", "\tvar factors = [];\n\tfor(var\
    \ i = 0; i < n; i++){\n\t\tfactors.push(i); //Add factor number\n\t\twhile(n %\
    \ i == 0) //While the number is not divisible by i add i to the factor list\n\t\
    \t{\n\t\t\tfactors.push(i);\n\t\t\tn /= i;\n\t\t}\n\t}\n\tfactors.push(n);\n\t\
    return factors;\n}\n", "\tif(!(n%1) || !(n==Math.floor(n)) || !(n<=1e12+7*1e12+7*1e12+7*1e12+7*1e12+7*1e12+7*1e12+7*1e12+7*1e12+7*1e12)){\n\
    \t\treturn false;\n\t}\n\tvar p=[];\n\tfor(var i=2;i*i<n;i+=i){\n\t\tif(n%i==0){\n\
    \t\t\tp.push(i);\n\t\t\twhile(n/i>1){\n\t\t\t\tn/=i;\n\t\t\t\tp.push(i);\n\t\t\
    \t}\n\t\t}\n\t}\n\treturn p;\n}\n", "\tif(n === 0){return [0]}\n\tif(n === 1){return\
    \ [1]}\n\treturn factorize(n-1) + factorize(n-2)\n}\n", "    for(var i = 2; i\
    \ < n; i++){\n        if(n % i == 0){\n            for(var j = i*i; j < n; j +=\
    \ i){\n                if(n/j < i){\n                    return [j, Math.ceil(n/j)];\n\
    \                }\n            }\n        }\n    }\n}\n</code>\n<|/ a tags=factorization,number-theory,algorithm\
    \ dscore=2 |>\n<| c |>\nThanks a lot.This helps a lot.\n<|/ c |>\n<| a dscore=1\
    \ |>\nI found another O(n^2) solution and I believe this is faster :) Hope this\
    \ can help\n<code>", "\tlet factors = [];\n\tfor(let i = 1; i <= n; i++){\n\t\t\
    let temp = [];\n\t\tlet j = 1;\n\t\twhile(j*i < n){\n\t\t\tif(n % i == 0){\n\t\
    \t\t\ttemp.push(i);\n\t\t\t\tn = n/i;\n\t\t\t\ti = 1;\n\t\t\t\tj++;\n\t\t\t}else{\n\
    \t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif(temp.length != 0){\n\t\t\tfactors.push(temp);\n\
    \t\t}\n\t}\n\treturn factors;\n}\n\n", "    var factors = [];\n    var factorsArr\
    \ = [];\n    var i;\n    var isPrime;\n    for (i = 1; i <= n; i++) {\n      \
    \  isPrime = true;\n        for (var j = 2; j <= i; j++) {\n            if (i\
    \ % j === 0) {\n                isPrime = false;\n                break;\n   \
    \         }\n        }\n        if (isPrime){\n            factors.push(i);\n\
    \            factorsArr.push([i]);\n        }\n    }\n    for (var k = 1; k <=\
    \ Math.ceil(Math.sqrt(n)); k++) {\n        isPrime = true;\n        for (var j\
    \ = 1; j < k; j++) {\n            if (n % j === 0) {\n                isPrime\
    \ = false;\n                break;\n            }\n        }\n        if (isPrime)\
    \ {\n            var temp = factorsArr;\n            factorsArr = [];\n      \
    \      factors.push(Math.pow(2, k));\n            for (var j = 0; j < factors.length;\
    \ j++) {\n                factorsArr.push(temp[j]);\n            }\n        }\n\
    \    }\n    return factors;\n}", "\treturn primeFactors(n)\n\t\t.map(p => n%p)\
    \ // filter out factors without counts\n\t\t.filter(p => p>1) // filter out factors\
    \ without factors\n\t\t.map(p => [p,1]) // map factors to their counts\n\t\t.sort((a,b)\
    \ => b[1]-a[1]) // sort by count\n\t\t.map(x => x[1]*x[0]) // return factors in\
    \ ascending order\n\t\t.filter(p => p<=n) // filter out factors greater than the\
    \ number in the problem\n\t\t.map(p => p*(p-1)) // get multiplied by its inverse\
    \ \n\t\t.filter(p => p<n) // filter out factors less than the number in the problem\n\
    \t\t.map(p=>p**0.5) // square all the factors\n\t\t.sort((a,b)=>a-b)\n\t\t.map(x=>x+n);\
    \ // add in the original number\n}\n", "\tif(n%1 === 0){\n\t\treturn [n, 1];\n\
    \t}\n\tlet ret = [];\n\tfor(let i = 2;i*i < n;i++){\n\t\tlet temp = 1;\n\t\tfor(let\
    \ j = 2;i*j < n;j++){\n\t\t\tif(n%i == 0){\n\t\t\t\ttemp *= i;\n\t\t\t}\n\t\t\t\
    if(n%j == 0){\n\t\t\t\ttemp *= j;\n\t\t\t}\n\t\t}\n\t\tret.push(temp);\n\t}\n\t\
    ret.sort(function(a, b){\n\t\treturn b-a;\n\t});\n\treturn ret;\n}\n", "    const\
    \ factors = []\n    for(let i=1;i<=n;i++){\n        for(let j=1;j<=i;j++){\n \
    \           if(i%j === 0){\n                factors.push(j)\n                i\
    \ = i / j\n                j = 1\n            }\n        }\n    }\n    return\
    \ factors\n}\n", "  var f = factorization(n), arr = new Array(n);\n  for(var i=0;\
    \ i<f.length; i++){\n    arr[i] = f[i][0];\n  }\n  return arr;\n}\n", "    var\
    \ factors = [];\n    if(n===1) return [];\n    var sqrtn = (Math.sqrt(n)|0);\n\
    \    for(var i = 1;i <= sqrtn;i++){\n        if((n % i)===0) factors.push(i);\n\
    \    }\n    return factors;\n}", "\tlet primeFactors = [];\n\tconst factorizationsArr\
    \ = []; //Create empty array for storing factorization.\n\tlet n = n;\n\twhile\
    \ (n !== 1){\n\t\t//Check if number is divisible by any prime number or not\n\t\
    \tif (n % 2 == 0) n = (n - 1) / 2; //If number is not even, remove its last digit.\n\
    \t\telse n = n / 2;\n\t\t\n\t\tlet isPrime = true;\n\t\tfor (let i = 3; i <= Math.sqrt(n);\
    \ i += 2){\n\t\t\tif (n % i == 0){\n\t\t\t\tisPrime = false;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif (isPrime){\n\t\t\tprimeFactors.push(n); //Push prime number\
    \ into array if its not prime number.\n\t\t\tlet count = 0;\n\t\t\tfor(let i =\
    \ 0; i <primeFactors.length; i++){\n\t\t\t\tcount = (primeFactors[i] * primeFactors[i])\
    \ * Math.pow(primeFactors[i], primeFactors.length);\n\t\t\t\tfactorizationsArr.push(count);\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\treturn primeFactors.sort((a, b) => b - a);\n}\n", "\t\
    let factors = [];\n\tfor(let i = 2; i <= Math.sqrt(n); i++){\n\t\tlet count =\
    \ 0;\n\t\tfor(let j = 0; j < factors.length; j++){\n\t\t\tif(n%i == 0){\n\t\t\t\
    \tcount++;\n\t\t\t}\n\t\t}\n\t\tfactors.push([i, count]);\n\t}\n\treturn factors;\n\
    }\n", "    if (n === 0 || n === 1){\n        return [n];\n    }\n\n    var a =\
    \ [n];\n    var factors = [];\n    for(var i=1;i<=n;i++){\n        if(n%i ===\
    \ 0){\n            a.push(i);\n            factors.push(i);\n        }\n    }\n\
    \    return a;\n}\n", "\tvar i,\n\t\tfactors = [];\n\tfor(i = 2; i <= Math.sqrt(n);\
    \ i++){\n\t\tif(n % i === 0){\n\t\t\tfactors.push(i);\n\t\t}\n\t\tif(i * i > n){\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\treturn factors;\n}\n", "\tlet factors = [];\n\t\n\t\
    for(let i = 2; i <= n/i; i++){\n\t\tif((n % i == 0) && (factors.indexOf(i) ==\
    \ -1)){\n\t\t\tfactors.push(i);\n\t\t}\n\t}\n\t\n\treturn factors;\n}\n", "  \
    \ let f = [];\n   for (let i = 1; i <= n; i++){\n       while (n % i === 0){\n\
    \           f.push(i);\n           n = n / i;\n       }\n   }\n   return f;\n\
    }\n", "  if(n > 0){\n    return factorize0(n);\n  }else{\n    return [];\n  }\n\
    }\n", "\tvar factors = [];\n\tvar f = [];\n\tfor(var i=2; i<=n/2; i+=2){\n\t\t\
    f = [];\n\t\tfor(var j=1; j<=i; j++){\n\t\t\tif(n % i == 0){\n\t\t\t\tf.push(i);\n\
    \t\t\t\tfactors.push(f)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn factors;\n\
    }\n", "  var factors = [];\n  for(var i = 0; i <= Math.sqrt(n); ++i){\n    var\
    \ isPrime = isPrime2(i);\n    if(isPrime && i <= n){\n      factors.push(i);\n\
    \      n = n/i;\n    } else {\n      if(isPrime === false) throw new Error(\"\
    No such prime factor of \" + i + \"!\");\n      var j = 2;\n      while(j*i <=\
    \ n){\n        if(n % j === 0) {\n          factors.push(j);\n          n = n/j;\n\
    \          break\n        }\n        ++j;\n      }\n    }\n  }\n  factors.push(factors.length);\n\
    \  return factors;\n}\n", "\tlet facArr = [];\n\tlet factor = 1;\n\tfor (let i\
    \ = 2; i <= n / 2; i++)\n\t\twhile (n % i == 0){\n\t\t\tfactor *= i;\n\t\t\tfacArr.push(factor);\n\
    \t\t\tn /= i;\n\t\t}\n\twhile (n > 1) {\n\t\tfactor *= n;\n\t\tfacArr.push(factor);\n\
    \t\tn /= n;\n\t}\n\tfacArr.push(factor);\n\treturn facArr;\n}\n", "    let factors\
    \ = [];\n    let factorsCount = 1;\n    let i;\n    \n    for(i=1;i<=Math.sqrt(n);i++){\n\
    \        if(n % i == 0){\n            factors[factorsCount] = i;\n           \
    \ factorsCount *= i;\n            while(n % i == 0){\n                n /= i;\n\
    \                factorsCount *= i;\n            }\n        }\n    }\n    \n \
    \   factors[factors.length-1] = n;\n    factors[factors.length-2] = n;\n    return\
    \ factors;\n}\n</code>\n<|/ a tags=math,algorithm,primes,java |>\n<| c |>\nThis\
    \ is very inefficient. As you can see, this can be done in O(n) by just iterating\
    \ over the prime numbers. Of course, the OP has requested a solution that is O(log\
    \ n) but that cannot be done with your solution; you cannot use a sorted list\
    \ or array. Also, I think your algorithm produces the wrong result for n = 10.\n\
    <|/ c |>\n<| a |>\nO(sqrt(n)) solution is given below. \n<code>\npublic static\
    \ int[] primeFactors(int n)\n{\n    int i=2;\n    int j=0;\n    int factors[]\
    \ = new int[(n-1)/2]; \n    for(i=2; i<=Math.sqrt(n); i++)\n    {\n        while(j<factors.length\
    \ && n%i==0)\n        {\n            factors[j]=i;\n            n/=i;\n      \
    \      j++;\n        }\n    }\n    factors[factors.length-1]=n;\n    return factors;\n\
    }\n</code>\n<|/ a tags=math,algorithm,primes,java dscore=3 |>\n<| a tags=math,algorithm,primes,java\
    \ dscore=3 |>\nYou can use the following logic to find prime factors:\n<code>\n\
    public class Prime{\n    public static void main(String[] args){\n        int\
    \ num=9;\n        boolean flag=true;\n        for(int i=2;i<num;i++){\n      \
    \      if(num%i==0){\n                flag=false;\n                break;\n  \
    \          }\n        }\n        if(flag)\n            System.out.println(num);\n\
    \        else{\n            for(int i=2;i<=Math.sqrt(num);i++){\n            \
    \    if(num%i==0){\n                    flag=false;\n                    break;\n\
    \                }\n            }\n            if(flag)\n                System.out.println(num);\n\
    \        }\n    }\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic static boolean\
    \ isPrime(int number) {\n    if (number < 2) {\n        return false;\n    }\n\
    \n    // Only even factors need to be checked\n    boolean isPrime = true;\n \
    \   int incrementor = 2;\n    while (", "  var factors = [],\n      primes = [];\n\
    \n  for(var i = 2; i <= Math.sqrt(n); i++){\n    if (primes.indexOf(i) === -1)\
    \ {\n      primes.push(i);\n\n      for (var j = i * i; j < n; j += i) {\n   \
    \     factors.push(j);\n      }\n    }\n  }\n\n  return factors;\n}\n", "\tvar\
    \ factors=new Array();\n\tif(n <= 1){\n\t\tfactors.push(n);\n\t}\n\telse if(n\
    \ <= 3){\n\t\tfactors.push( new Array( 2, 3));\n\t}\n\telse if(n % 2 == 0){\n\t\
    \tfactors.push( new Array( 2));\n\t}\n\telse if(n % 3 == 0){\n\t\tfactors.push(\
    \ new Array( 3, 3));\n\t}\n\telse if(n % 5 == 0){\n\t\tfactors.push( new Array(\
    \ 5, 2));\n\t}\n\telse if(n % 7 == 0){\n\t\tfactors.push( new Array( 7, 1));\n\
    \t}\n\telse if(n % 11 == 0){\n\t\tfactors.push( new Array( 11, 1));\n\t}\n\telse{\n\
    \t\tfor(var i=3;i<=Math.sqrt(n);i+=i){\n\t\t\tif(n%i==0){\n\t\t\t\tfactors.push(i);\n\
    \t\t\t\tvar remain=n/i;\n\t\t\t\twhile(remain>i){\n\t\t\t\t\tremain--;\n\t\t\t\
    \t\tfactors.push(i, remain);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn factors;\n}", "\tn = n + 1;\n\tlet factors = [];\n\tfor(let i = 0; i\
    \ <= n; i++){\n\t\tlet d = i | 0;\n\t\tlet count = 0;\n\t\twhile((d & 1) > 0){\n\
    \t\t\td = d >> 1;\n\t\t\tcount++;\n\t\t}\n\t\tfactors.push(count);\n\t}\n\treturn\
    \ factors;\n}\n", "  var factors = [],\n      sqrt = Math.sqrt(n),\n      root\
    \ = n; //Find sqrt of number\n\n  while(root){\n    //Check if it is prime\n \
    \   if(n % root === 0){\n      //If it is, push to factors array\n      factors.push(root);\n\
    \    }\n    //Divide out number\n    root = Math.floor(root/divisor);\n  }\n\n\
    \  return factors;\n}\n", "\tlet factors = [];\n\tlet divisors = factorization(n);\n\
    \tlet remainder = n;\n\tfor(let i=0; i<divisors.length; i++){\n\t\tremainder =\
    \ remainder / divisors[i];\n\t\tfactors.push(divisors[i]);\n\t}\n\treturn [remainder,\
    \ factors];\n}\n", "\tvar f = factorization.factorization(n);\n\tvar prime = factorization.getPrimeFactors(f);\n\
    \tvar factors = [];\n\tfor(var i=0;i<prime.length;i++){\n\t\tfactors.push(f[prime[i]]);\n\
    \t}\n\treturn factors;\n}\n\n", "  n = parseInt(n);\n  var factors = [];\n  if(n\
    \ % 2 == 0){\n    factors.push(n);\n    return factors;\n  }\n  for(var i = 3;\
    \ i * i <= n; i += 2){\n    if(n % i == 0){\n      factors.push(i);\n      factors.push(n\
    \ / i);\n    }\n  }\n  return factors;\n}\n", "    const result = [];\n    let\
    \ factors = [];\n    factors(n, factors);\n    for(let i = 0; i < factors.length;\
    \ i++){\n        if(factors[i] == 1){\n            result.push(factors[i]);\n\
    \        } else {\n            for(let j = 0; j < factors[i]; j++){\n        \
    \        result.push(factors[i]);\n            }\n        }\n    }\n    return\
    \ result;\n}\n", "    let factors = [];\n    for(let i=2; i<n; i++){\n       \
    \ for(let j=0; j<factors.length; j++){\n            if(n%i===0 && factors[j]+1===i)\n\
    \                break;\n        }\n        if(j===factors.length){\n        \
    \    factors.push(i);\n        }\n    }\n    return factors;\n}", "\tlet factors\
    \ = [];\n\tlet factor = 1;\n\tfor(let i = 2; i <= n; i++){\n\t\tif(n % i === 0){\n\
    \t\t\tfactor *= i;\n\t\t\tfactors.push(i);\n\t\t\twhile(n > i){\n\t\t\t\tn = (n\
    \ - i) / i;\n\t\t\t}\n\t\t}\n\t}\n\treturn factors;\n}\n", "\tvar a = [];\n\t\
    while(n > 1){\n\t\tvar m = Math.floor(Math.sqrt(n));\n\t\tfor(var i = 2; i <=\
    \ m; i++)\n\t\t\tif(n % i == 0){\n\t\t\t\tn = n / i;\n\t\t\t\ta.push(i);\n\t\t\
    \t\tbreak;\n\t\t\t}\n\t\tif(n == 1)\n\t\t\tbreak;\n\t}\n\treturn a;\n}\n", "\t\
    var i,j,k=2;\n\tvar factors=[];\n\tfor(i=k;i>1;i*=k)\n\t\tfactors.push(~~(i/k));\n\
    \t\n\tfor (j=1; j<factors.length; j++){\n\t\tfor(i=1;i<factors.length;i+=k)\n\t\
    \t\tif(factors[i]==factors[j]){\n\t\t\t\tfactors[j]=0;\n\t\t\t\tfor(k=factors.length;k--;)\n\
    \t\t\t\t\tif(factors[k]==0)\n\t\t\t\t\t\tfactors.splice(k,1);\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t}\n\treturn factors;\n}\n", "\treturn factorize(factorization(n))\n\
    }\n", "\tvar factors = [];\n\twhile(n>=1){\n\t\tfactors.push(n%2);\n\t\tn = n/2;\n\
    \t}\n\tvar f = [];\n\tfor(var i=factors.length-1;i>=0;i--){\n\t\tf.push(factors[i]);\n\
    \t}\n\treturn f;\n}", "\tlet factors = []\n\twhile(n != 1){\n\t\tfactors.push(Math.floor(Math.sqrt(n)));\n\
    \t\tlet temp = n;\n\t\tn = Math.floor(n / Math.pow(factors[factors.length-1],factors[factors.length-1]))\n\
    \t}\n\treturn factors\n}\n", "\treturn primeFactorization(factor(n)[1]); // [1]\
    \ because each prime factor array contains both number itself and its count\n\
    }\n", "  let arr = new Array(n);\n  let count = 0;\n  for(let i = 1; i <= n; i++){\n\
    \    for(let j = 1; j <= Math.sqrt(i); j++){\n      if(i % j === 0){\n       \
    \ arr[count] = j;\n        count += 1;\n      }\n    }\n  }\n  return arr;\n}\n",
  "\tvar i, j, factor, factors = [], factorsCount = 0;\n\tfor(i = 0; i < n; i++){\n\
    \t\tfor(j = i + 1; j < n; j++){\n\t\t\tif(n % j == 0){\n\t\t\t\tfactor = n / j;\n\
    \t\t\t\tif(factorsCount < factor.length){\n\t\t\t\t\tfactors[factorsCount] = factor;\n\
    \t\t\t\t\tfactorsCount++;\n\t\t\t\t}\n\t\t\t\tif(j == i){\n\t\t\t\t\tfactors[factorsCount]\
    \ = j;\n\t\t\t\t\tfactorsCount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn factors;\n}\n", "\t// If number is already prime\
    \ then just return the array of it's factors\n\tif(isPrime(n)) return [n % 2 ?\
    \ 2 : 1];\n\t\n\t// Set number of times factor appears in factorization\n\tvar\
    \ factorCounter = 0;\n\t\n\t// Initialize prime factorization by checking prime\
    \ numbers\n\tvar primes = [];\n\tfor(var i = 1; i <= n; i++){\n\t\tif(isPrime(i))\
    \ primes.push(i);\n\t}\n\t\n\t// Start factorization from smallest number to largest\n\
    \tvar factorArray = [], factor = 2, currFact;\n\twhile(factorCounter < primes.length){\n\
    \t\tcurrFact = factors[primes[factorCounter]][factorCounter]; // Get current factor\
    \ by finding array index of it\n\t\tif(currFact){\n\t\t\t// If the current factor\
    \ appears more than once in factorization\n\t\t\tif(factorArray.indexOf(currFact)\
    \ != -1){\n\t\t\t\t// If factorArray array contains the current factor\n\t\t\t\
    \tfactorArray.splice(factorArray.indexOf(currFact), 1);\n\t\t\t\tfactorCounter\
    \ += 1;\n\t\t\t} else {\n\t\t\t\t// If factorArray array does not contain the\
    \ current factor\n\t\t\t\tfactorArray.push(currFact);\n\t\t\t}\n\t\t} else {\n\
    \t\t\t// If factor has not been found in factorization\n\t\t\tfactorCounter +=\
    \ 1;\n\t\t}\n\t\t\n\t\t// Update factor\n\t\tfactor += 2;\n\t}\n\treturn factorArray;\n\
    }\n", "    var factors = [];\n    if(n != 1 && n != -1){\n        factors.push(n);\n\
    \    }\n    for(var i = 2; i <= Math.sqrt(n); i++){\n        if(n % i == 0){\n\
    \            var j = n;\n            var div = i / j;\n            while(j > 1\
    \ && j * j > i){\n                j /= j;\n                factors.push(div);\n\
    \            }\n            while(j > 1){\n                factors.push(j);\n\
    \                j /= j;\n            }\n            while(j > 1 && j * j > i\
    \ && i != j){\n                j /= j;\n                factors.push(div);\n \
    \           }\n        }\n    }\n    return factors;\n}\n", "\tvar factors = [];\n\
    \tfor(let i=0;i<=n;i++)\n\t\tfactors.push([]);\n\t\n\tfor(let i=2;i<=n;i++){\n\
    \t\tif(factors[Math.floor(i/2)]==undefined){\n\t\t\tfactors[Math.floor(i/2)].push(i);\n\
    \t\t\tfactors[Math.ceil(i/2)].push(i);\n\t\t}\n\t\telse{\n\t\t\tlet x = factors[Math.floor(i/2)];\n\
    \t\t\tlet y = factors[Math.ceil(i/2)];\n\t\t\tlet newArr = x.concat(y);\n\t\t\t\
    factors[Math.floor(i/2)] = newArr;\n\t\t\tfactors[Math.ceil(i/2)] = newArr;\n\t\
    \t}\n\t}\n\treturn factors;\n}\n", "  var res = [];\n  var factors = factor(n);\n\
    \  factors.forEach(function(val, index){\n    res.push(val);\n  })\n  return res;\n\
    }\n", "\tvar factors = [];\n\tfor(var i = 1; i <= n; i++){\n\t\tvar flag = true;\n\
    \t\tfor(var j = factors.length; j > 0; j--){\n\t\t\tif(n%factors[j] == 0){\n\t\
    \t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tfactors.push(i);\n\
    \t\t}\n\t}\n\treturn factors;\n}\n", "  var primes = [2, 3];\n  for(var i = 4;\
    \ i <= Math.sqrt(n); i++){\n    if(n % i == 0){\n      primes.push(i);\n     \
    \ for(var j = i*i; j < n; j += i){\n        primes.push(j);\n      }\n    }\n\
    \  }\n  return primes;\n}\n", "\tvar factors = [];\n\tvar factorizations = [];\n\
    \n\tvar divisor = 1;\n\tfor(var i = 1; i<=n; i++){\n\t\twhile(n % i == 0){\n\t\
    \t\tdivisor *= i;\n\t\t\tn /= i;\n\t\t}\n\t\tif(divisor > 1){\n\t\t\tfactorizations.push(divisor);\n\
    \t\t}\n\t\tfactors.push(divisor);\n\t\tdivisor = 1;\n\t}\n\n\tif(n > 1){\n\t\t\
    factorizations.push(n);\n\t}\n\n\treturn factors;\n}\n", "    var factors = [];\n\
    \    factorization(n);\n    function factorization(n){\n        for (var i = 2;\
    \ i <= Math.sqrt(n); i++){\n            var k = n/i;\n            if (Math.sqrt(n)\
    \ % i === 0){\n                factors.push(Array.apply(null, new Array(i+1)).fill(k).map(function(a){\
    \ return a*a; }));\n            }\n        }\n    }\n    return factors;\n}\n",
  "  \n    var divisors = [];\n    var results = [];\n    var isPrime = true; \n \
    \   \n    // checking if input number is a prime number\n    for(var i = 2; i\
    \ <= Math.sqrt(n); i++){\n      \n      if(n%i === 0){\n        isPrime = false;\n\
    \      }\n    }\n    \n    if(isPrime === true){\n      results.push(n);\n   \
    \ } else {\n      var i = 2;\n      while(i * i <= n){\n        if(n%i === 0){\n\
    \          divisors.push(i);\n          results.push(n/i);\n        }\n      \
    \  i++;\n      }\n    }\n    \n    if(results.length === 0){\n      results.push(1);\n\
    \    }\n    return results;\n}", "  n = Math.ceil(n);\n  var factors = factorization.slice(0);\
    \ // copy of factorization array\n  for (var i = 0; i < factors.length; i++){\n\
    \    if (n / factors[i] < n){\n      factors = factors.slice(0, i).concat(factors.slice(i+1));\n\
    \      break;\n    }\n  }\n  return factors;\n}\n", "\tlet factors = [];\n\t\n\
    \tlet isPrime = true;\n\tfor(let i = 2; i <= n; i++){\n\t\tlet counter = 0;\n\t\
    \tfor(let j = 0; j < factors.length; j++){\n\t\t\tif(n === i * factors[j]){\n\t\
    \t\t\tcounter++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(counter === 0){\n\t\t\
    \tisPrime = false;\n\t\t\tfactors.push(i);\n\t\t}\n\t}\n\t\n\tif(!isPrime){\n\t\
    \tlet remainder = n % factors[0]; //Remainder when dividing n by each of factors\n\
    \t\tif(remainder === 0){\n\t\t\tfactors.push(1);\n\t\t}\n\t}\n\t\n\treturn factors;\n\
    }\n", "\tvar factors = [];\n\tvar counter = 1;\n\n\twhile(n > 1){\n\t\tif(n %\
    \ counter === 0){\n\t\t\tfactors.push(counter);\n\t\t\tn = Math.floor(n / counter);\n\
    \t\t}else{\n\t\t\tcounter++;\n\t\t}\n\t}\n\tif(n > 1)\n\t\tfactors.push(1);\n\n\
    \treturn factors;\n}\n", "\tvar factors = [];\n\tvar ifactor;\n\tfor(ifactor =\
    \ n%2; ifactor > 0; ifactor--){\n\t\tfactors.push(ifactor);\n\t\tn = n/ifactor;\n\
    \t}\n\tfor(; n > 1; n--){\n\t\tifactor = 2;\n\t\twhile(ifactor * ifactor < n){\n\
    \t\t\tifactor *= ifactor;\n\t\t}\n\t\tif(n % ifactor == 0){\n\t\t\tfactors.push(ifactor);\n\
    \t\t\tn = n/ifactor;\n\t\t}\n\t}\n\treturn factors;\n}\n", "    let factors =\
    \ []\n    let i = 2\n    while(Math.pow(i,2) <= n){\n        if(n % i == 0){\n\
    \            factors.push(i)\n            n /= i\n        }\n        i++\n   \
    \ }\n    if(n > 1)\n        factors.push(n)\n    return factors\n}", "  var ans\
    \ = [];\n  var f = factorization(n - 1);\n  var len = f.length;\n  for (var i\
    \ = 0; i < len; i++){\n    var num = f[i][0];\n    var count = 0;\n    for (var\
    \ j = 0; j < len; j++){\n      if (f[j][0] == num){\n        count++;\n      \
    \  break;\n      }\n    }\n    if (count == len){\n      ans.push(num);\n    }\n\
    \  }\n  return ans;\n}\n", "    var f = [],\n        i=0,\n        div = 2,\n\
    \        mod = n%div,\n        ans = [],\n        power = 1;\n\n    while(div\
    \ > 1){\n        if(mod){\n            f.push(n%div)\n            mod = n%div;\n\
    \            div = div*div;\n        }else{\n            f.push(div)\n       \
    \     ans.push(power);\n            div = div*div;\n            power *= 1;\n\
    \        }\n    }\n    if(mod){\n        f.push(n)\n        ans.push(power);\n\
    \    }\n    return ans;\n}\n", "    var factors = [];\n    for(var i=2; i<=n;\
    \ i++){\n        if(n % i == 0){\n            var f = factors.slice();\n     \
    \       f.push(i);\n            factors = f;\n        }\n    }\n    return factors;\n\
    }\n\n", "\tlet factors = [1];\n\tfor(let i = 2; i <= n; i++){\n\t\tif(n % i ===\
    \ 0){\n\t\t\tfactors.push(i);\n\t\t\twhile(n % i === 0){\n\t\t\t\tn /= i;\n\t\t\
    \t\tfactors.push(i);\n\t\t\t}\n\t\t}\n\t}\n\treturn factors;\n}\n", "    var factors\
    \ = new Array(), i, num;\n    for(i = 1; i <= n; i++){\n        num = n / i;\n\
    \        if(num > 1){\n            factors.push(num);\n            factors = factors.concat(factorize(num));\n\
    \        }\n    }\n    return factors;\n}\n", "\tlet factorization = []\n\tlet\
    \ divisor = 2\n\tlet num = 1\n\twhile(divisor <= n){\n\t\tlet div = n / divisor\n\
    \t\twhile(divisor !== div){\n\t\t\tdivisor *= div\n\t\t\tfactorization.unshift(divisor)\n\
    \t\t}\n\t\tdivisor += 1\n\t}\n\tfactorization.unshift(n)\n\treturn factorization\n\
    }\n", "\tvar factors = [];\n\tvar factor = 1;\n\tvar i = 2;\n\t\n\twhile(factor*i\
    \ <= n){\n\t\t\n\t\tif(n % factor == 0){\n\t\t\tfactors.push(factor);\n\t\t\t\
    factor *= i;\n\t\t}\n\t\ti++;\n\t}\n\treturn factors;\n}\n", "\tvar factors =\
    \ [];\n\tvar i = 1;\n\twhile (true){\n\t\ti++;\n\t\tif (n % i == 0) break;\n\t\
    \tfactors.push(i);\n\t}\n\treturn factors;\n}\n", "\tlet factors=[];\n\tlet temp=n;\n\
    \tlet i=2;\n\twhile(temp!==1){\n\t\twhile(temp%i === 0){\n\t\t\tfactors.push(i);\n\
    \t\t\ttemp/=i;\n\t\t}\n\t\ti++;\n\t}\n\tif(temp!==1) factors.push(temp);\n\tfactors.sort((a,b)=>{return\
    \ b-a;});\n\treturn factors;\n}\n", "  if(n === 0 || n === 1)return [];\n  let\
    \ factors = [];\n  let i = 2;\n  while(true){\n    while(n % i === 0) n = n /\
    \ i;\n    if(n === 1)break;\n    factors.push(i);\n    i = i * 2;\n  }\n  return\
    \ factors;\n}", "  var f = factorization(n);\n  var fp = f.filter(function(el){return\
    \ el == 1;})\n  return fp.map(function(el){return el * f.length;});\n}\n", " \
    \ n = Number(n); //convert to number\n  var factors = []; //store the factors\n\
    \  var primes = [];\n  var isPrime = true;\n\n  for(var i = 2; i <= n/2; i++){\n\
    \    if(n % i == 0){\n      primes.push(i);\n      factors.push(i);\n      isPrime\
    \ = false;\n      while(n % i == 0){\n        factors.push(n % i);\n        n\
    \ /= i;\n      }\n    }\n  }\n\n  //If number is prime then add it into primes\
    \ and remove it from factors.\n  if(isPrime){\n    primes.push(n);\n    factors.pop();\n\
    \  }\n\n  return [factors, primes];\n}\n", "\tlet factors = [];\n\tfor(let i =\
    \ 2; i < n; i++){\n\t\tlet fact = 1;\n\t\tfor(let j = 1; j < (n - i); j++){\n\t\
    \t\tfact *= j;\n\t\t}\n\t\tfactors.push(fact);\n\t}\n\treturn factors;\n}\n",
  "    \n    // Find factors of each number\n    let factors=[];\n    while(n>=1){\n\
    \        let p=1;\n        while(true){\n            let i=0;\n            for(let\
    \ j=0; j<factors.length; j++){\n                if(factors[j] === n){\n      \
    \              i++;\n                    break;\n                }\n         \
    \   }\n            if(i===factors.length)\n                factors.push(n);\n\
    \            else\n                n*=2;\n        }\n    }\n    \n    // Sort\
    \ factors in ascending order of their number of appearance\n    factors.sort((a,b)=>b.length-a.length);\n\
    \    \n    // Return array with all factors\n    return factors;\n}\n", "    var\
    \ arr = [], i = 2, factor = 1;\n    while(n > 1){\n        while(n % i == 0){\n\
    \            arr[i] = factor;\n            n = Math.floor(n / i);\n          \
    \  factor = 1;\n        }\n        i++;\n    }\n    arr[i] = factor;\n    return\
    \ arr;\n}\n", "\tvar factors = [];\n\tvar lastNum = 1;\n\tfor(var i=1;i<=Math.sqrt(n);i++){\n\
    \t\tif(n%i===0){\n\t\t\tvar newFactor = lastNum;\n\t\t\tlastNum = i;\n\t\t\tfactors.push(newFactor);\n\
    \t\t\tfactors.push(i);\n\t\t}\n\t}\n\treturn factors;\n}\n", "\tlet factors =\
    \ [];\n\tlet isPrime = true;\n\tlet i = 2;\n\twhile(factors.length < n){\n\t\t\
    for(let j = 2;j*j <= Math.sqrt(n); j++){\n\t\t\tif(n%j == 0){\n\t\t\t\tif(isPrime){\n\
    \t\t\t\t\tfactors.push(j);\n\t\t\t\t\tisPrime = false;\n\t\t\t\t}\n\t\t\t\tn =\
    \ n/j;\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!isPrime)\n\t\t\t\
    break;\n\t}\n\treturn factors;\n}\n", "    if(n !== 0 && n != 1){\n        var\
    \ factors = [];\n        for(var i = 0; i < n; i++){\n            var factor =\
    \ 1;\n            while(n % i == 0){\n                n /= i;\n              \
    \  factor *= i;\n            }\n            if(factor){\n                factors.push(factor);\n\
    \            }\n        }\n        return factors;\n    }else{\n        return\
    \ [n];\n    }\n}\n</code>\n<|/ a tags=math,algorithm dscore=1 |>\n<| a tags=math,algorithm\
    \ dscore=1 |>\nFactorization is just finding all the prime factors of a number\
    \ n using an Sieve of Eratosthenes.\n<code>\n#include <iostream>\n#include <vector>\n\
    #include <algorithm>\n\nclass prime_sieve\n{\n    public:\n    prime_sieve()\n\
    \    {\n        for(int i=2;i<=INT_MAX;i++)\n        {\n            if(i>1)\n\
    \            {\n                isPrime[i]=false;\n            }\n        }\n\
    \    }\n\n    bool isPrime(int n)\n    {\n        for(int i=2;i*i<n;i++)\n   \
    \     {\n            if(n%i==0)\n            {\n                return false;\n\
    \            }\n        }\n        return true;\n    }\n\n    void sievePrimeFactors()\n\
    \    {\n        for(int i=2;i*i<=INT_MAX;i++)\n        {\n            if(i>1)\n\
    \            {\n                if(!isPrime(i))\n                {\n         \
    \           int j=i*i;\n                    while(isPrime(j))\n              \
    \      {\n                        primeFactors.push_back(j);\n               \
    \         j+=i;\n                    }\n                }\n            }\n   \
    \     }\n    }\n\n    void printPrimeFactors(int n)\n    {\n        for(int i=0;i<primeFactors.size();i++)\n\
    \        {\n            if(n==primeFactors[i])\n            {\n              \
    \  std::cout<<primeFactors[i];\n            }\n        }\n    }\n\n    private:\n\
    \    bool isPrime[INT_MAX];\n    std::vector<int> primeFactors;\n};\n\nint main()\n\
    {\n    prime_sieve p;\n    p.sievePrimeFactors();\n    p.printPrimeFactors(10);\n\
    }\n</code>\n<|/ a |>\n<| a |>\nIf you want a recursive solution, here's one that\
    \ I've implemented a long time ago:\n<code>\n#include <iostream>\n#include <vector>\n\
    using namespace std;\n\nvoid primeFactors(int n, vector<int>& primeFactors) {\n\
    \    if (n == 1) {\n        primeFactors.push_back(n);\n        return;\n    }\n\
    \    if (n > 1) {\n        for (int i = 2; i < n; ++i) {\n            if (n %\
    \ i == 0) {\n                break;\n            }\n        }\n", "    let factors\
    \ = []\n    let i = 1\n    while(n % i){\n        if(!factors.includes(i)) factors.push(i)\n\
    \        factors.push(n % i)\n        i++\n    }\n    return factors\n}\n", "\t\
    var factors=[],i=0,p;\n\twhile(i<n){\n\t\tp=prime(i);\n\t\tif(p===1){\n\t\t\t\
    factors.push(i);\n\t\t\ti++;\n\t\t}else{\n\t\t\twhile(factors[i]<=p){\n\t\t\t\t\
    i++;\n\t\t\t}\n\t\t\tfactors[i]=p;\n\t\t}\n\t}\n\treturn factors;\n}\n", "\tvar\
    \ i,j,k,tmp;\n\tvar factors = [];\n\tvar factor;\n\tvar isPrime;\n\tvar isPrimeNum;\n\
    \tvar largestFactor = 1;\n\tfor(i = 2; i <= n; i++){\n\t\tisPrime = true;\n\t\t\
    factor = 2;\n\t\tisPrimeNum = true;\n\t\tfor(j = 1 ; j <= i; j++){\n\t\t\t//If\
    \ current number is divided by factor\n\t\t\tif(n % j == 0){\n\t\t\t\tfactor ++;\n\
    \t\t\t\t//If factor is greater than largest\n\t\t\t\tif(factor > largestFactor){\n\
    \t\t\t\t\tlargestFactor = factor;\n\t\t\t\t}\n\t\t\t\t//If current number is prime\n\
    \t\t\t\tif(j == i){\n\t\t\t\t\tisPrimeNum = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t\tif(!isPrimeNum){\n\t\t\tfactors.push(factor);\n\t\t}\n\t}\n\treturn factors;\n\
    }\n", "\tvar primes=[],\n\t\tfactor=[], //Factors array\n\t\ti=1,\n\t\tn2=n*2,\n\
    \t\tl=Math.sqrt(n2)-1,\n\t\tk=n2/2;\n\twhile(k>=1 && (n%i==0)){\n\t\ti++;\n\t\t\
    k--;\n\t}\n\tif(i>1){\n\t\tfactors.push(i);\n\t}\n\twhile(i>0){\n\t\twhile(!(n%i)\
    \ && n>1){\n\t\t\tn--;\n\t\t}\n\t\ti++;\n\t\twhile(n>1){\n\t\t\tn--;\n\t\t\tif(n%i==0){\n\
    \t\t\t\tfactors.push(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<factors.length;i++){\n\
    \t\tfactor=factor.concat(primes.slice(factors[i],factors[i]+1));\n\t}\n\treturn\
    \ factor;\n}\n", "\tif (n === 1 || (n > 1 && n % 1 === 0)){\n\t\treturn [1];\n\
    \t}\n\t\n\tvar prime_factors = [];\n\tvar new_num = 1;\n\t\n\tfor (var i = 1;\
    \ i <= n; i++){\n\t\tnew_num = Math.floor(new_num / i);\n\t\t\n\t\tfor (var j\
    \ = 0, len2 = prime_factors.length; j < len2; j++){\n\t\t\tif (prime_factors[j]\
    \ === new_num){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (new_num % prime_factors[j]\
    \ === 0){\n\t\t\t\tprime_factors.push(new_num);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\
    }\n\t}\n\t\n\treturn prime_factors;\n}\n", "\tvar primes = [];\n\tvar n = parseInt(n);\n\
    \tfor(var i = 2; i <= Math.sqrt(n); i++){\n\t\tfor(var j = 0; j < primes.length;\
    \ j++){\n\t\t\tvar test = (n % primes[j] == 0) ? false : true;\n\t\t\tif(test\
    \ == true){\n\t\t\t\tprimes.splice(j,1);\n\t\t\t\tj--;\n\t\t\t\tn = n/primes[j];\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprimes.push(n);\n\treturn primes;\n}\n",
  "\tif (n <= 1)\n\t\treturn [];\n\n\tvar factors = [];\n\tvar primes = [];\n\n\t\
    for(var i=2;i<n;i++){\n\t\tif (primes.indexOf(i) < 0){\n\t\t\tfor (var j = 1;\
    \ j < primes.length; j++){\n\t\t\t\tif (n % primes[j] === 0){\n\t\t\t\t\tfactors.push(primes[j]);\n\
    \t\t\t\t\tn = n / primes[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n\
    \ > 1){\n\t\t\t\tfactors.push(n);\n\t\t\t\tn = 1; // we dont care about this number,\
    \ so dont add it to factors\n\t\t\t}\n\t\t}\n\t}\n\treturn factors;\n}\n", " \
    \   factorizationArray = primeFactorization(n);\n    factorizationArray = sortFactors(factorizationArray);\n\
    \    factorizationArray = sortFactors(factorizationArray);\n    return factorizationArray;\n\
    }\n", "   var factors = [],\n   power = 1;\n   while(n!==1){\n      if(n % 2 ===\
    \ 0) power = power * 2;\n      else\n      {\n         if(n % 3 === 0) power =\
    \ power * 3;\n         else\n         {\n            if(n % 5 === 0) power = power\
    \ * 5;\n            else\n            {\n               if(n % 7 === 0) power\
    \ = power * 7;\n               else\n               {\n                  if(n\
    \ % 11 === 0) power = power * 11;\n                  else\n                  {\n\
    \                     if(n % 13 === 0) power = power * 13;\n                 \
    \    else\n                     {\n                        if(n % 17 === 0) power\
    \ = power * 17;\n                        else\n                        {\n   \
    \                        if(n % 19 === 0) power = power * 19;\n              \
    \             else\n                           {\n                           \
    \   if(n % 23 === 0) power = power * 23;\n                              else\n\
    \                              {\n                                 if(n % 29 ===\
    \ 0) power = power * 29;\n                                 else\n            \
    \                     {\n                                    if(n % 37 === 0)\
    \ power = power * 37;\n                                    else\n            \
    \                        {\n                                       if(n % 43 ===\
    \ 0) power = power * 43;\n                                       else\n      \
    \                                 {\n                                        \
    \  if(n % 59 === 0) power = power * 59;\n                                    \
    \      else\n                                          {\n                   \
    \                          if(n % 63 === 0) power = power * 63;\n            \
    \                                 else\n                                     \
    \        {\n                                                if(n % 79 === 0) power\
    \ = power * 79;\n                                                else\n      \
    \                                          {\n                               \
    \                    if(n % 97 === 0) power = power * 97;\n                  \
    \                                 else\n                                     \
    \              {\n                                                      power\
    \ = power * n;\n                                                      factors.push(power);\n\
    \                                                   }\n                      \
    \                          }\n                                             }\n\
    \                                          }\n                               \
    \        }\n                                    }\n                          \
    \       }\n                              }\n                           }\n   \
    \                     }\n                     }\n                  }\n       \
    \        }\n            }\n         }\n      }\n      n = n/2;\n   }\n   return\
    \ factors;\n}\n", "    var factors = [];\n    for (var i = 2; i <= Math.sqrt(n);\
    \ i++)\n    {\n        if (n % i === 0) {\n            factors.push(i);\n    \
    \        while (n % i == 0)\n            {\n                n /= i;\n        \
    \        factors.push(i);\n            }\n        }\n    }\n    factors.push(n);\n\
    \    return factors;\n}\n", "  if(n < 2) return []; //If n is less than two we\
    \ dont have factors.\n  else if(n%2==0) return [2]; //If number is even we return\
    \ only two.\n  else return [2,3].reduce(function(p,c){\n      return p*p*(n-2)+c;\
    \ //Reduce and find the product of the new factors\n  },1); //Return product of\
    \ new factors\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nIf you're looking\
    \ for an answer without using the reduce function, this is a simple way to find\
    \ the prime factors for a given number, without using the reduce function.\n<code>\n\
    var primeFactors = function (num) {\n    let ans = []\n    for (var i = 2; i <\
    \ num; i++) {\n      for (var j = 0; j < num / i; j++) {\n        if (num % i\
    \ == 0) {\n          ans.push(i)\n          break\n        }\n      }\n    }\n\
    \    return ans\n  }\n</code>\n<|/ a tags=javascript,primes |>\n<| c |>\nYour\
    \ answer is not optimal. Try factorizing this number `10001` you will get `[1,\
    \ 2]` as prime factors but there are three prime factors i.e `3`  so your answer\
    \ will return `[2]`. Also it will iterate more than necessary as you are just\
    \ iterating till the square root of the number. Try with number `1000000` you\
    \ will get `[2, 2, 2, 2, 2]` as the output.\n<|/ c |>\n<| a tags=javascript,primes\
    \ |>\nThis function will return an array of prime factors of a given number.\n\
    <code>\nconst factors = function(num) {\n  var divisor = 2;\n  var divisors =\
    \ [2];\n  while (divisor * divisor <= num) {\n    if (num % divisor == 0) {\n\
    \      divisors.push(divisor);\n      divisor++;\n    }\n    divisors.push(divisor);\n\
    \    divisor++;\n  }\n  return divisors;\n};\n", "\tvar factors = [],\n\t\tfactor\
    \ = 0,\n\t\ti = 1,\n\t\tj = n;\n\n\twhile(j){\n\t\twhile(j%i === 0){\n\t\t\tj/=\
    \ i;\n\t\t\tfactors.push(i);\n\t\t}\n\t\ti++;\n\t}\n\treturn factors;\n}\n<|/\
    \ file dstars=0 source=github |>", "\tif(n===0)\n\t\treturn [n]\n\t\n\tvar factors\
    \ = []\n\t\n\tfor(var i=0;i<primes.length;i++){\n\t\tvar factor = Math.floor(n/primes[i]);\n\
    \t\tfactors.push(factor)\n\t\tn = n-factor*primes[i];\n\t}\n\t\n\tfactors.push(Math.floor(n/n))\n\
    \t\n\treturn factors\n}\n\n", "\tlet factors = []\n\tlet primes = []\n\tlet sqrt\
    \ = Math.sqrt(n)\n\tlet half = n/2\n\tlet i = 1\n\tlet p = 2\n\tlet q = 2\n\t\
    while(true){\n\t\tif(n%p == 0){\n\t\t\tfactors.push(p)\n\t\t\tn /= p\n\t\t\ti++\n\
    \t\t\tcontinue\n\t\t}\n\t\tif(n%q == 0){\n\t\t\tfactors.push(q)\n\t\t\tn /= q\n\
    \t\t\ti++\n\t\t\tcontinue\n\t\t}\n\t\tlet isPrime = true\n\t\tfor(let j of primes){\n\
    \t\t\tif(n%j == 0){\n\t\t\t\tisPrime = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\
    \tif(isPrime){\n\t\t\tprimes.push(p)\n\t\t\tprimes.push(q)\n\t\t\tfactors.push(p)\n\
    \t\t\tfactors.push(q)\n\t\t}\n\t\tif(sqrt == half){\n\t\t\tbreak\n\t\t}\n\t\t\
    p++\n\t\tq++\n\t\tsqrt += 2\n\t}\n\tfactors.push(half)\n\treturn factors\n}\n",
  "\tlet factors = [];\n\tlet primes = [2];\n\tlet counter = 1;\n\twhile(n>1){\n\t\
    \tfor(let i=0;i<primes.length;i++){\n\t\t\tif(n%primes[i] == 0){\n\t\t\t\tcounter++;\n\
    \t\t\t\tlet tmp = [...primes];\n\t\t\t\ttmp.splice(tmp.length-1, 1, n);\n\t\t\t\
    \tfactors.push(tmp);\n\t\t\t\tn = Math.floor(n/primes[i]);\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t\tprimes.push(counter);\n\t\tcounter = 1;\n\t}\n\treturn factors;\n\
    }\n", "  var factors = [];\n  var num = n;\n\n  while(num > 1){\n    // find factor\n\
    \    var x = Math.floor(Math.sqrt(num));\n    for(var i = 1; i <= x; i++){\n \
    \     if(num % i == 0){\n        factors.push(i);\n        // break, since we\
    \ have found factor which we must eliminate from number\n        break;\n    \
    \  }\n    }\n    num = Math.floor(num / x);\n  }\n\n  return factors;\n}\n", "\t\
    var factors=[];\n\tfactorization(n,factors);\n\treturn factors;\n}\n", "\tvar\
    \ arr = new Array();\n\tvar div = n;\n\t\n\twhile(true){\n\t\twhile(div > 1){\n\
    \t\t\tdiv = div/2;\n\t\t\tarr.push(div);\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\t\
    break;\n\t\t}\n\t\t\n\t\tn = Math.floor(n/2);\n\t\t\n\t\tif(n % 2 != 0){\n\t\t\
    \tarr.push(2);\n\t\t}\n\t\t\n\t\tif(n > 1){\n\t\t\tarr.push(n);\n\t\t}\n\t}\n\t\
    \n\treturn arr;\n}\n", "\tlet factors = [];\n\tlet primeFactors = [];\n\tlet divisors\
    \ = [];\n\tlet divisor;\n\tlet isPrime;\n\tlet primeDivisor;\n\n\tfor(let i =\
    \ 2; i <= n; i++){\n\t\tisPrime = true;\n\t\tdivisor = i;\n\t\tprimeDivisor =\
    \ 1;\n\n\t\tfor(let j = 0; j <= i; j++){\n\t\t\tif(i%j == 0){\n\t\t\t\tisPrime\
    \ = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(isPrime){\n\t\t\tdivisors.push(divisor);\n\
    \t\t\tprimeFactors.push(divisor);\n\t\t\tdivisor = divisor*i;\n\t\t}\n\t}\n\n\t\
    let primeFactorsLength = primeFactors.length;\n\tfor(let i = 0; i < primeFactorsLength;\
    \ i++){\n\t\tfactors.push(divisors[i]);\n\t\tdivisor = divisor*primeFactors[i];\n\
    \t}\n\n\treturn factors;\n}\n\n", "    let factors = new Array(n).fill(0);\n \
    \   \n    while(n > 1){\n        let temp = n;\n        while(n % 2 == 0){\n \
    \           factors[temp % 2 == 0 ? 0 : 1]++;\n            n = Math.floor(n /\
    \ 2);\n        }\n        n = Math.floor(n / 2);\n    }\n    \n    return factors;\n\
    }", "    var factors = []\n    for(var i = 0; i < factorizations.length; i++){\n\
    \        if(factorizations[i].indexOf(n) >= 0){\n            factors.push(factorizations[i])\n\
    \        }\n    }\n    return factors\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
