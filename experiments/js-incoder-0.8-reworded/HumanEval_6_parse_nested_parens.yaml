name: HumanEval_6_parse_nested_parens
language: js
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n// [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = parse_nested_parens;\n  assert.deepEqual(candidate(\"(()()) ((())) () ((())()())\"\
  ),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"() (()) ((())) (((())))\"),[1,\
  \ 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"),[4]);\n}\n\ntest();"
completions: ["  var arr = [];\n  for(var i=0; i<paren_string.length; i++){\n    var\
    \ ch = paren_string.charAt(i);\n    if(ch === \"(\"){\n      arr.push(0);\n  \
    \  }else if(ch === \")\"){\n      var max_level = Math.max.apply(null, arr);\n\
    \      var new_arr = [];\n      for(var j=0; j<arr.length; j++){\n        new_arr.push(arr[j]\
    \ + 1);\n      }\n      arr = new_arr;\n      if(arr.indexOf(max_level) === -1){\n\
    \        arr.push(max_level);\n      }\n    }\n  }\n  return arr;\n}\n", "\tvar\
    \ level = 0;\n\tvar parens = [];\n\tvar nested_parens = [];\n\tvar nested_parens_level\
    \ = [];\n\tvar index = 0;\n\n\tparen_string = paren_string.trim();\n\n\t// Parse\
    \ all parentheses\n\twhile (index < paren_string.length){\n\t\t// Keep a record\
    \ of parentheses\n\t\tif (paren_string[index] === \"(\"){\n\t\t\tparens.push(paren_string);\n\
    \t\t\tindex++;\n\t\t}\n\t\t// Pop parentheses until we see a closing parenthesis\n\
    \t\tif (paren_string[index] === \")\"){\n\t\t\tvar temp_level = level;\n\n\t\t\
    \twhile (parens.length > 0 && parens[0] !== \"(\"){\n\t\t\t\tlevel--;\n\t\t\t\t\
    parens.pop();\n\t\t\t}\n\t\t\t\n\t\t\t// Record level for next loop\n\t\t\tnested_parens_level.push(level);\n\
    \t\t\tindex++;\n\n\t\t\t// Pop remaining parentheses until we hit a closing parenthesis\n\
    \t\t\twhile (parens.length > 0 && parens[0] !== \"(\"){\n\t\t\t\tlevel--;\n\t\t\
    \t\tparens.pop();\n\t\t\t}\n\t\t\t\n\t\t\t// Record the level of the final parentheses\n\
    \t\t\tnested_parens.push(level);\n\t\t}\n\t\tindex++;\n\t}\n\t\n\t// Return the\
    \ maximum level of nesting in the parentheses\n\treturn Math.max(...nested_parens_level);\n\
    }\n", "  var max_level = 0;\n  var levels = 0;\n  var output = [];\n  var output_index\
    \ = 0;\n  var parentheses_stack = [];\n  var levels_stack = [];\n\n  for(var i\
    \ = 0; i < paren_string.length; i++){\n    var c = paren_string[i];\n    if(c\
    \ == \"(\"){\n      parentheses_stack.push(c);\n      levels_stack.push(1);\n\
    \    }else if(c == \")\"){\n      var parenthesis_depth = parentheses_stack.length\
    \ - 1;\n      var max_level_of_the_parenthesis = levels_stack[parenthesis_depth];\n\
    \      if(levels_stack[parenthesis_depth] > max_level_of_the_parenthesis){\n \
    \       levels_stack[parenthesis_depth] = levels_stack[parenthesis_depth] - 1;\n\
    \        output.push(output_index);\n      }\n      levels_stack[parenthesis_depth]\
    \ += 1;\n      if(levels_stack[parenthesis_depth] == max_level_of_the_parenthesis){\n\
    \        levels_stack[parenthesis_depth] = max_level_of_the_parenthesis + 1;\n\
    \      }\n    }\n  }\n\n  return output;\n}\n", "  let parsed_parens = paren_string.match(/[^()]+/g);\n\
    \  let result = [];\n  for(let i in parsed_parens){\n    let currentLevel = parsed_parens[i].match(/[^()]+/g).length;\n\
    \    let lastLevel = result[result.length-1];\n    if(lastLevel > currentLevel)\
    \ result.push(currentLevel);\n  }\n  return result;\n}\n", "    var max_nested_level\
    \ = 0;\n    var max_paren_level = 0;\n    var paren_stack = [];\n    var group_index\
    \ = 0;\n\n    for(var i = 0; i < paren_string.length; i++){\n        var char\
    \ = paren_string.charAt(i);\n\n        if(char == '('){\n            paren_stack.push(group_index);\n\
    \            group_index++;\n        }\n        else if(char == ')'){\n      \
    \      group_index = paren_stack.pop();\n        }\n        else if(char == '\
    \ '){\n            //Do nothing.\n        }\n        else if(char == '('){\n \
    \           //Go deeper only if current level is not greater than maximum.\n \
    \           if(max_paren_level < group_index){\n                max_nested_level\
    \ = group_index - max_paren_level;\n            }\n            else{\n       \
    \         max_nested_level++;\n            }\n        }\n        else if(char\
    \ == ')'){\n            //Do nothing.\n        }\n        else if(char == '\\\
    n' || char == '\\r' || char == '\\t' || char == ''){\n            //Do nothing.\n\
    \        }\n        else{\n            //Go deeper only if current level is not\
    \ greater than maximum.\n            if(max_paren_level < group_index){\n    \
    \            max_nested_level = group_index - max_paren_level;\n            }\n\
    \            else{\n                max_nested_level++;\n            }\n     \
    \   }\n\n        //Keep track of the maximum level of nesting encountered.\n \
    \       if(max_nested_level > max_paren_level){\n            max_paren_level =\
    \ max_nested_level;\n        }\n    }\n\n    return max_paren_level;\n}\n", " \
    \ var paren_stack = [];\n  var parentheses_level = 0;\n  var paren_count = 0;\n\
    \  for(var i=0; i<paren_string.length; i++){\n    if(paren_string[i]==\"(\"){\n\
    \      paren_stack.push(paren_count);\n      paren_count = 0;\n    }\n    if(paren_string[i]==\"\
    )\"){\n      var current_depth = paren_stack.pop();\n      if(current_depth<paren_count){\n\
    \        parentheses_level = current_depth+1;\n      }\n      paren_count = paren_stack[paren_stack.length-1];\n\
    \    }\n  }\n  return parentheses_level;\n}\n", "  var groups = paren_string.trim().match(/\\\
    (([^()]+)\\)/g);\n  var nested_levels = [0, 0, 0];\n  var level = 0;\n  var nested_level_count\
    \ = 0;\n  if(groups){\n    for(var i = 0; i < groups.length; ++i){\n      var\
    \ group_str = groups[i].trim();\n      if(group_str.match(/\\(/)){\n        if(!level){\n\
    \          level = group_str.match(/\\(/g).length;\n          nested_levels[nested_level_count]\
    \ = level;\n          nested_level_count++;\n        } else {\n          nested_levels[nested_level_count]\
    \ = Math.max(nested_levels[nested_level_count], group_str.match(/\\(/g).length);\n\
    \        }\n      }\n      if(group_str.match(/\\)/)){\n        nested_level_count--;\n\
    \      }\n    }\n  }\n  return nested_levels;\n}\n", "    var parens_stack = [];\n\
    \    var paren_level = 0;\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        var current_char = paren_string[i];\n        parens_stack.push(current_char);\n\
    \        if(current_char === '('){\n            paren_level++;\n        }\n  \
    \      else if(current_char === ')'){\n            paren_level--;\n        }\n\
    \    }\n    while(parens_stack.length > 0){\n        paren_level++;\n        parens_stack.pop();\n\
    \    }\n    return paren_level;\n}\n", "    let levels = []\n    for (let i in\
    \ paren_string) {\n        if (paren_string[i].match(/[()]/)) {\n            levels.push(paren_string[i].replace(/([()]+)/,\
    \ '$1').length)\n        } else {\n            levels.push(0);\n        }\n  \
    \  }\n    return levels.sort(function(a, b){return b-a})\n}\n", "    let stack\
    \ = paren_string.split(\"\").reverse();\n    \n    let level = 0;\n    let max_level\
    \ = 0;\n\n    for (let i=0; i<stack.length; i++){\n        let char = stack[i];\n\
    \        \n        if (char === \"(\"){\n            level++;\n        }\n   \
    \     \n        if (char === \")\"){\n            level--;\n        }\n      \
    \  \n        if (level > max_level){\n            max_level = level;\n       \
    \ }\n    }\n    \n    return max_level;\n}\n\n", "\tlet paren_levels = []; //Levels\
    \ used to determine deepest parentheses\n\tlet current_level = -1;\n\tlet paren_count\
    \ = 0; //Number of opening parentheses\n\tlet last_open = 0; //Last index where\
    \ an opening parenthesis is found\n\tlet last_close = 0; //Last index where an\
    \ closing parenthesis is found\n\n\tfor (let i = 0; i < paren_string.length; i++){\n\
    \t\tlet char = paren_string.charAt(i);\n\n\t\tif (char == '('){\n\t\t\tparen_count++;\n\
    \t\t\tlast_open = i;\n\t\t}\n\n\t\tif (char == ')'){\n\t\t\tparen_count--;\n\t\
    \t\tif (paren_count == 0){\n\t\t\t\tparen_levels.push(current_level);\n\t\t\t\t\
    current_level = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (paren_count > 0 && char == ' '){\n\
    \t\t\tcurrent_level++;\n\t\t}\n\n\t\tif (paren_count < 0 && char == ' '){\n\t\t\
    \tcurrent_level--;\n\t\t}\n\t}\n\n\tlet deepest_level = 0;\n\tfor (let i = 0;\
    \ i < paren_levels.length; i++){\n\t\tdeepest_level = Math.max(deepest_level,\
    \ paren_levels[i]);\n\t}\n\treturn deepest_level;\n}\n", "  var levels = []; //store\
    \ the levels recursively\n  var index = 0; //index where we are in the paren_string\n\
    \  var paren_level = 0; //number of open parens (number of opening braces) that\
    \ are found in the paren_string so far\n  var paren_levels = []; //store the levels\
    \ of open parens\n\n  while (paren_level != paren_string.length && paren_string[index]\
    \ != '('){\n    paren_level++;\n    paren_levels.push(paren_level);\n    index++;\n\
    \  }\n\n  while (index < paren_string.length && paren_string[index] == '('){\n\
    \    index++;\n  }\n\n  var paren_levels_length = paren_levels.length;\n\n  while\
    \ (index < paren_string.length){\n    while (paren_levels[paren_levels_length\
    \ - paren_level] == paren_string[index]){\n      paren_levels[paren_levels_length\
    \ - paren_level]++;\n      index++;\n    }\n\n    paren_level--;\n    paren_levels_length--;\n\
    \    index++;\n  }\n\n  return paren_levels_length;\n}", "  paren_string = paren_string.trim();\n\
    \  const group_array = paren_string.split(' ');\n  let current_level = 0;\n  const\
    \ max_level = group_array.length - 1; // -1 because we will be adding the last\
    \ element as the deepest level.\n  const levels = [];\n  for (let i = 0; i < group_array.length;\
    \ i++){\n    if (group_array[i] === \"()\"){\n      current_level++;\n    }\n\
    \    else if (group_array[i] === \"[]\"){\n      current_level--;\n    }\n   \
    \ levels.push(current_level);\n  }\n  return levels;\n}\n", "\tvar depth = 0;\n\
    \tvar result = [];\n\tvar nested_level = 0;\n\tvar paren_strings = paren_string.split(\"\
    \ \");\n\tvar parentheses_level;\n\t\n\tfor (var i = 0; i < paren_strings.length;\
    \ i++) {\n\t\tparentheses_level = paren_strings[i].length;\n\t\t\n\t\tif (parentheses_level\
    \ == depth) {\n\t\t\tnested_level++;\n\t\t} else {\n\t\t\tresult.push(nested_level);\n\
    \t\t\tdepth = parentheses_level;\n\t\t\tnested_level = 1;\n\t\t}\n\t}\n\t\n\t\
    return result;\n}\n", "    var max_level = -1;\n    var level = 0;\n    var open_bracket\
    \ = 0;\n    var close_bracket = 0;\n    var nested_brackets = [];\n    var max_num_nested\
    \ = 0;\n    var cur_group = 0;\n\n    //We parse string from left to right\n \
    \   for (var i=0; i<paren_string.length; i++){\n        //If opening bracket is\
    \ encountered, increase the level of nesting and set current group\n        if\
    \ (paren_string[i] === \"(\" && open_bracket === 0){\n            level++;\n \
    \           cur_group = level;\n            open_bracket++;\n            //Check\
    \ if closing bracket is encountered for current group\n        } else if (paren_string[i]\
    \ === \")\" && open_bracket > 0 && level > cur_group){\n            level--;\n\
    \            open_bracket--;\n            //Check if current level is greater\
    \ than the level of nesting\n        } else if (level < cur_group){\n        \
    \    level++;\n        }\n\n        //If level is equal to or greater than the\
    \ max level set it as max level and update max number of nested\n        if (level\
    \ >= max_level){\n            max_level = level;\n            max_num_nested =\
    \ cur_group;\n        }\n\n        //If current level is less than max level add\
    \ nested bracket to the list\n        if (level <= max_level){\n            nested_brackets.push(paren_string[i]);\n\
    \        }\n    }\n\n    //Finally return the max_num_nested of the deepest nested\
    \ group\n    return max_num_nested;\n}\n", "    const paren_stack = [];\n    let\
    \ paren_level = 0;\n    \n    // Go through each character in the string\n   \
    \ for(let i = 0; i < paren_string.length; i++){\n        // If the character is\
    \ a left parenthesis, push it to stack\n        if (paren_string[i] === \"(\"\
    ){\n            paren_stack.push(i);\n            paren_level++;\n        }\n\
    \        // If the character is a right parenthesis, pop off from the stack\n\
    \        else if (paren_string[i] === \")\"){\n            while(paren_stack.length\
    \ > 0){\n                paren_level--;\n                if (paren_stack.length\
    \ === 0){\n                    paren_stack.pop();\n                    break;\n\
    \                }\n                else{\n                    paren_stack.shift();\n\
    \                }\n            }\n        }\n    }\n\n    return paren_level;\n\
    }\n", "\tvar max_level = 0;\n\tvar max_count = 0;\n\tvar parens = [];\n\tparen_string\
    \ = paren_string.trim();\n\tvar opening_count = 0;\n\tfor(var i=0;i<paren_string.length;i++){\n\
    \t\tvar open_paren = paren_string[i];\n\t\tvar close_paren = paren_string[paren_string.length-1-i];\n\
    \t\tif(open_paren == '('){\n\t\t\topening_count++;\n\t\t}\n\t\telse if(open_paren\
    \ == '('){\n\t\t\topening_count--;\n\t\t}\n\t\t\n\t\tif(open_paren == ')'){\n\t\
    \t\tif(opening_count != 0){\n\t\t\t\tmax_level--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\
    \tmax_count++;\n\t\t\t}\n\t\t\topening_count = 0;\n\t\t}\n\t\t\n\t\tif(opening_count\
    \ > max_count){\n\t\t\tmax_level = opening_count;\n\t\t}\n\t\tif(max_level < 0){\n\
    \t\t\tmax_level = 0;\n\t\t}\n\t\tparens.push(max_level);\n\t}\n\treturn parens;\n\
    }\n", "  var max_nested_level = 0;\n  var paren_level = 0;\n  var paren_nesting_level\
    \ = 0;\n  var nested_paren_count = 0;\n  for(var i=0; i<paren_string.length; i++){\n\
    \    var c = paren_string[i];\n    if(c === '('){\n      paren_level++;\n    \
    \  if(paren_level <= max_nested_level){\n        max_nested_level = paren_level;\n\
    \      }\n      if(paren_level === max_nested_level){\n        nested_paren_count++;\n\
    \      }\n    }else if(c === ')'){\n      paren_level--;\n      if(paren_level\
    \ < max_nested_level){\n        max_nested_level = paren_level;\n      }\n   \
    \ }\n  }\n  return nested_paren_count;\n}", "    var level_count = 0;\n    var\
    \ curr_level = 0;\n    var result_array = [];\n    var pos = 0;\n    var opening_parens\
    \ = paren_string.split(\"(\");\n    for (var i = 0; i < opening_parens.length;\
    \ i++){\n        var open_paren_level = opening_parens[i].length;\n        while\
    \ (pos < paren_string.length){\n            if (paren_string.charAt(pos) == \"\
    )\"){\n                if (curr_level == open_paren_level){\n                \
    \    result_array.push(curr_level);\n                    level_count++;\n    \
    \            }\n                curr_level--;\n            }\n            if (paren_string.charAt(pos)\
    \ == \"(\"){\n                curr_level++;\n            }\n            pos++;\n\
    \        }\n    }\n    return result_array;\n}\n", "\tvar paren_array = new Array();\n\
    \tvar group_level = 0;\n\tvar pos = 0;\n\tvar chr = paren_string.charAt(pos);\n\
    \twhile(chr != \")\" && chr != \"(\" && chr != \"\\\\\"){\n\t\tparen_array[paren_array.length]\
    \ = group_level;\n\t\tparen_array[paren_array.length] = pos;\n\t\tpos++;\n\t\t\
    if(chr != \")\"){\n\t\t\tchr = paren_string.charAt(pos);\n\t\t}else{\n\t\t\tgroup_level--;\n\
    \t\t\tpos++;\n\t\t\tchr = paren_string.charAt(pos);\n\t\t}\n\t}\n\twhile(chr !=\
    \ \"\\\\\"){\n\t\tpos++;\n\t\tchr = paren_string.charAt(pos);\n\t}\n\tparen_array[paren_array.length]\
    \ = group_level;\n\treturn paren_array;\n}\n", "  var max_nesting = 0;\n  var\
    \ nesting_level = [];\n  var paren_string = paren_string.trim();\n\n  // Trim\
    \ whitespace from beginning and end of the string\n  var trimmed_string = paren_string.replace(/^\\\
    s+/, '').replace(/\\s+$/, '');\n  var paren_regex = /^[()]*([\\(\\)])*$/;\n  var\
    \ all_parens = trimmed_string.match(paren_regex);\n\n  // Iterate through each\
    \ group in the string\n  all_parens.forEach(function(paren_string){\n    // Get\
    \ the length of the current group\n    var paren_regex_group_capture = paren_string.match(paren_regex);\n\
    \    var group_capture = paren_regex_group_capture[1];\n\n    // If the current\
    \ group has max nesting already set, set the current max nesting as the maximum\n\
    \    if(nesting_level[nesting_level.length - 1] === undefined) nesting_level[nesting_level.length\
    \ - 1] = 0;\n\n    // If the current group is at the same level as the maximum\
    \ nesting level, increment the max nesting level\n    if(nesting_level[nesting_level.length\
    \ - 1] === group_capture) nesting_level[nesting_level.length - 1]++;\n\n    //\
    \ If the current group is smaller than the current max nesting level, set the\
    \ current max nesting level to current group\n    if(nesting_level[nesting_level.length\
    \ - 1] < group_capture) nesting_level[nesting_level.length - 1] = group_capture;\n\
    \  });\n\n  // Return the max nesting level\n  return nesting_level;\n}\n", " \
    \   let max_level = 0;\n    let level = 0;\n    let open_paren_count = 0;\n  \
    \  let paren_string = paren_string.split(' ');\n    for(let i=0; i<paren_string.length;\
    \ i++){\n        if(paren_string[i]==='(') open_paren_count++;\n        if(paren_string[i]==='(')\
    \ level++;\n        if(paren_string[i]==='(') max_level = max(max_level, level);\n\
    \        if(paren_string[i]==='(') level--;\n        if(paren_string[i]===')')\
    \ open_paren_count--;\n        if(open_paren_count===0) return max_level;\n  \
    \  }\n    return 0;\n}\n\n", "  var paren_stack = [];\n  var paren_level = 0;\n\
    \  var paren_levels = [0];\n  var max_level = 0;\n  var max_level_stack = [];\n\
    \  for(var i=0; i<paren_string.length; i++){\n    if(paren_level >= paren_levels[paren_level]){\n\
    \      paren_stack.push(paren_levels[paren_level]);\n      max_level_stack.push(paren_level);\n\
    \    }\n    paren_levels[paren_level]++;\n    var char = paren_string.charAt(i);\n\
    \    if(char === '('){\n      paren_stack.push(paren_level);\n      max_level\
    \ = paren_level;\n    }\n    if(char === ')'){\n      paren_level--;\n      if(paren_level\
    \ === -1){\n        paren_level = max_level_stack.pop();\n      }\n      if(paren_stack.pop()\
    \ !== max_level){\n        paren_levels[paren_level] = paren_stack[paren_stack.length-1];\n\
    \      }\n    }\n  }\n  return paren_levels;\n}", "  var max_level = 0;\n  var\
    \ max_level_paren_count = 0;\n  var levels = 0;\n  var paren_counts = [];\n\n\
    \  //The loop below will get rid of any extra spaces around the parenthesis.\n\
    \  paren_string = paren_string.replace(/\\s/g, \"\");\n\n  //Loop through the\
    \ string and count the number of opening parentheses.\n  for(var i=0;i<paren_string.length;i++){\n\
    \    if(paren_string[i] == \"(\"){\n      paren_counts[paren_counts.length] =\
    \ 1;\n    }\n    else if(paren_string[i] == \")\"){\n      paren_counts[paren_counts.length\
    \ - 1]++;\n    }\n  }\n\n  //We loop through each level of parenthesis, and see\
    \ if it has more nesting than the previous level.\n  for(var i=paren_counts.length-1;i>=0;i--){\n\
    \    if(paren_counts[i] > max_level_paren_count){\n      max_level = i;\n    \
    \  max_level_paren_count = paren_counts[i];\n    }\n    if(paren_counts[i] ==\
    \ max_level_paren_count){\n      levels = i;\n    }\n  }\n\n  return levels;\n\
    }", "\tlet depth = 0;\n\tlet par_depth = 0;\n\tlet paren_depth_stack = [];\n\t\
    let paren_depth_stack_length = 0;\n\tfor(let c of paren_string){\n\t\tif(c ==\
    \ '('){\n\t\t\tparen_depth_stack[paren_depth_stack_length] = paren_depth_stack_length;\n\
    \t\t\tparen_depth_stack_length += 1;\n\t\t\tdepth += 1;\n\t\t}\n\t\tif(c == ')'){\n\
    \t\t\tlet current_depth = paren_depth_stack[paren_depth_stack_length - 1];\n\t\
    \t\tif( current_depth != paren_depth_stack[paren_depth_stack_length - 2] ){\n\t\
    \t\t\treturn false;\n\t\t\t}\n\t\t\tparen_depth_stack_length -= 1;\n\t\t\tdepth\
    \ -= 1;\n\t\t}\n\t}\n\tif( paren_depth_stack_length !== 0 ){\n\t\treturn false;\n\
    \t}\n\treturn depth;\n}\n", "    if(paren_string.indexOf(\"(\") < 0)\n       \
    \ return [];\n    var groups = paren_string.match(/[()()]/g);\n    if(groups.length\
    \ < 2)\n        return [];\n    var output = [];\n    var level = 0;\n    for(var\
    \ i = 0; i < groups.length; i++){\n        var index = output.indexOf(groups[i]);\n\
    \        if(index > -1){\n            level++;\n        }else{\n            output.push(groups[i]);\n\
    \            level = level + 1;\n        }\n        if(level > output.length){\n\
    \            output.push(level);\n        }\n    }\n    return output;\n}\n",
  "\t//Use map to keep track of the levels of parentheses.\n\tvar paren_stack = [];\n\
    \n\t//Iterate through the string and keep track of the current level of parenthesis.\n\
    \tfor(var i = 0; i < paren_string.length; i++){\n\t\tvar char = paren_string[i];\n\
    \t\tif(char == \"(\"){\n\t\t\tparen_stack.push(paren_stack.length);\n\t\t}else\
    \ if(char == \")\"){\n\t\t\tparen_stack.pop();\n\t\t}\n\t}\n\n\t//Return the number\
    \ of levels of nesting in the parenthetic string.\n\treturn paren_stack.length;\n\
    }\n", "  var result_array = [];\n  var opening_paren_indexes = [];\n  var opening_paren_length\
    \ = 0;\n  var curr_paren_level = 0;\n  var char;\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    char = paren_string.charAt(i);\n    switch(char){\n      case \"\
    )\": // end of a parentheses group\n        if(opening_paren_indexes.length ==\
    \ curr_paren_level){\n          result_array.push(opening_paren_length);\n   \
    \       opening_paren_indexes.length = 0;\n          opening_paren_length = 0;\n\
    \          curr_paren_level--;\n        } else {\n          opening_paren_indexes.push(i);\n\
    \          opening_paren_length++;\n        }\n        break;\n      case \"(\"\
    :\n        curr_paren_level++;\n        break;\n      default:\n        if(opening_paren_indexes.length\
    \ == 0){\n          result_array.push(0);\n        }\n        break;\n    }\n\
    \  }\n  return result_array;\n}\n", "    var nesting_depth = 1;\n    var nested_parens\
    \ = [];\n    for (var i=0; i < paren_string.length; i++){\n        var char =\
    \ paren_string[i];\n        if(char == \"(\"){\n            nesting_depth++;\n\
    \        } else if(char == \")\"){\n            nesting_depth--;\n           \
    \ if(nesting_depth == 0){\n                nested_parens.push(nesting_depth);\n\
    \            }\n        }\n    }\n    return nested_parens;\n}\n", "    var paren_depth\
    \ = [];\n    var level = 0;\n    var last_paren_char;\n    var paren_string_reversed\
    \ = paren_string.split('').reverse().join('');\n    for (var i = 0; i < paren_string_reversed.length;\
    \ i++) {\n        var ch = paren_string_reversed[i];\n        if (ch == '(') {\n\
    \            paren_depth.push(level);\n        } else if (ch == ')') {\n     \
    \       level = paren_depth.pop();\n        } else if (ch == ' ') {\n        \
    \    level += 1;\n        }\n        last_paren_char = paren_string_reversed[i];\n\
    \    }\n    return paren_depth.reverse();\n}\n", "    //First split the string\
    \ into individual groups of nested parentheses.\n    //This step is done to remove\
    \ unnecesary spaces and enclose each group\n    //with a set of brackets (). \n\
    \    var split_strings = paren_string.split(\" \");\n    var result = [];\n  \
    \  for(var i = 0; i < split_strings.length; i++){\n        //Split the groups\
    \ into individual parentheses.\n        var group_split = split_strings[i].split(/\\\
    (\\)/g);\n        var group_length = group_split.length;\n        var max_depth\
    \ = 0;\n        var group_depth = 0;\n        for(var j = 0; j < group_length;\
    \ j++){\n            //Find out how many levels of nesting exist in the current\
    \ group.\n            group_depth = group_depth + 1;\n            if(j == 0){\n\
    \                result.push(1);\n            }\n            else if(j == group_length-1){\n\
    \                result.push(group_depth);\n            }\n            else{\n\
    \                //Add number of open parentheses in the current group.\n    \
    \            result.push(group_depth);\n                if(group_depth >= max_depth){\n\
    \                    max_depth = group_depth;\n                }\n           \
    \ }\n        }\n    }\n    return result;\n}", "  const input_list = paren_string.trim().split(/\\\
    s+/);\n  const deepest_level_list = [];\n  let parentheses_level = 0;\n\n  input_list.forEach((item)=>{\n\
    \    if (item === \"()\"){\n      parentheses_level++;\n    }\n    else if (item\
    \ === \"()\" && parentheses_level > 0){\n      parentheses_level--;\n    }\n \
    \   deepest_level_list.push(parentheses_level);\n  });\n\n  return deepest_level_list;\n\
    }\n", "\tlet level = 0;\n\tlet index = 0;\n\tlet paren_group = [];\n\tlet group_size\
    \ = 0;\n\tlet temp_paren_string = \"\";\n\tlet parens_depth = [];\n\twhile(index\
    \ < paren_string.length){\n\t\tif(paren_string[index] == \")\"){\n\t\t\ttemp_paren_string\
    \ = temp_paren_string + paren_string.slice(index, paren_string.length);\n\t\t\t\
    parens_depth[level] = parens_depth[level - 1];\n\t\t\tgroup_size = group_size\
    \ + 1;\n\t\t}else if(paren_string[index] == \"(\"){\n\t\t\tparen_group[group_size]\
    \ = paren_string.slice(index, paren_string.length);\n\t\t\tgroup_size = group_size\
    \ + 1;\n\t\t\tparens_depth[level] = group_size;\n\t\t}\n\t\tindex = index + 1;\n\
    \t\tlevel = level + 1;\n\t}\n\tlet temp_paren_string = temp_paren_string.slice(1,\
    \ temp_paren_string.length);\n\treturn parens_depth;\n}", "    let nested_level\
    \ = 0\n    let paren_string_index = 0\n    while(paren_string_index < paren_string.length){\n\
    \        if(paren_string[paren_string_index] == '('){\n            nested_level++\n\
    \        }\n        else if(paren_string[paren_string_index] == ')'){\n      \
    \      nested_level--\n        }\n        paren_string_index++\n    }\n    return\
    \ nested_level\n}", "  var groups = [];\n  var depth = 0;\n  var group_length\
    \ = paren_string.length;\n  for(var i=0; i < paren_string.length; i++){\n    if(paren_string[i]\
    \ === '('){\n      depth++;\n    }\n    else if(paren_string[i] === ')'){\n  \
    \    depth--;\n    }\n    groups.push(depth);\n  }\n  return groups;\n}\n", "\t\
    var max_level = 0;\n\tvar level = 0;\n\tvar paren_count = 0;\n\tvar paren_char;\n\
    \tfor (var i = 0; i < paren_string.length; i++) {\n\t\tparen_char = paren_string[i];\n\
    \t\tif (paren_char === \"(\"){\n\t\t\tparen_count++;\n\t\t\tif (level < max_level){\n\
    \t\t\t\tmax_level = level;\n\t\t\t}\n\t\t\tlevel++;\n\t\t} else if (paren_char\
    \ === \")\"){\n\t\t\tparen_count--;\n\t\t\tif (paren_count <= 0){\n\t\t\t\tlevel--;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn max_level;\n}\n", "    var paren_count = 0;\n  \
    \  var paren_nest_level = [];\n    var group_paren_count = [];\n    for(var i\
    \ = 0; i < paren_string.length; i++){\n        if(paren_string[i] == \")\"){\n\
    \            paren_count--;\n        }else if(paren_string[i] == \"(\"){\n   \
    \         paren_count++;\n        }\n\n        // keep track of the current level\
    \ of nesting\n        group_paren_count.push(paren_count);\n        if(paren_count\
    \ == 0){\n            paren_nest_level.push(group_paren_count[group_paren_count.length\
    \ - 1]);\n        }\n\n        // reset paren count for next set of parens\n \
    \       paren_count = 0;\n    }\n\n    return paren_nest_level;\n}\n", "\tvar\
    \ paren_stack = [],\n\t\tparen_level = 0,\n\t\tparen_nesting = 0;\n\tvar nested_parens\
    \ = paren_string.split(\" \");\n\tfor (var i = 0; i < nested_parens.length; i++){\n\
    \t\tvar group = nested_parens[i];\n\t\tvar new_paren_level = paren_level + 1;\n\
    \t\tvar new_paren_nesting = paren_nesting + 1;\n\t\tif (paren_stack.length > 0\
    \ && paren_stack[paren_stack.length - 1] == new_paren_nesting + new_paren_level){\n\
    \t\t\t// This parenthesized expression is already at the maximum level so no more\
    \ nesting needs to be added.\n\t\t\tparen_level++;\n\t\t\tparen_nesting = 1;\n\
    \t\t\tcontinue;\n\t\t}\n\t\telse if (paren_stack.length > 0 && paren_stack[paren_stack.length\
    \ - 1] == new_paren_nesting - new_paren_level){\n\t\t\t// This parenthesized expression\
    \ is already at the minimum level so no more nesting needs to be removed.\n\t\t\
    \tparen_level--;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (new_paren_nesting > new_paren_level){\n\
    \t\t\tparen_stack.push(new_paren_nesting + new_paren_level);\n\t\t\tparen_level\
    \ = new_paren_level;\n\t\t\tparen_nesting = new_paren_nesting;\n\t\t\tcontinue;\n\
    \t\t}\n\t\telse if (new_paren_nesting < new_paren_level){\n\t\t\tparen_stack.pop();\n\
    \t\t}\n\t\telse \n\t\t{\n\t\t\t// This parenthesized expression has nothing to\
    \ the left of it so just add it.\n\t\t\tparen_stack[paren_stack.length - 1]++;\n\
    \t\t\tparen_nesting = new_paren_nesting;\n\t\t\tparen_level = new_paren_level;\n\
    \t\t\tcontinue;\n\t\t}\n\t}\n\treturn paren_stack;\n}\n", "  const paren_counts\
    \ = paren_string\n    .replace(/^[()]+|[()]+$/g,'')\n    .trim()\n    .split('')\n\
    \    .map(item => {\n      if(item.length == 0) return 0; //Handle empty group\n\
    \      return item.split('').map(c => {\n        switch(c) {\n          case '(':\
    \ return 1;\n          case ')': return -1;\n        }\n      });\n    })\n  \
    \  .reduce((a, b) => a.concat(b), []);\n  return paren_counts.reduce((max, count)\
    \ => Math.max(max, count), 0);\n}\n", "    if(!paren_string) return[];\n    var\
    \ paren_stack = [];\n    var paren_level = [];\n    for(var i=0; i<paren_string.length;\
    \ i++){\n        if(paren_stack.indexOf(paren_string[i]) == -1) paren_stack.push(paren_string[i]);\n\
    \        if(paren_string[i] == '(') paren_level.push(paren_stack.length);\n  \
    \      if(paren_string[i] == ')') paren_stack.pop();\n        if(paren_stack.length\
    \ >= paren_level[paren_stack.length-1]) paren_level.pop();\n    }\n    return\
    \ paren_stack;\n}\n", "    var nested_level = [];\n    var paren_level = [];\n\
    \    var paren_count = 0;\n    var i;\n    var groups = paren_string.split(\"\
    \ \");\n    for(i = 0; i < groups.length; i++){\n        if(groups[i][0] === \"\
    (\" && groups[i].length > 1 && groups[i+1][0] === \"(\"){\n            nested_level[paren_count]\
    \ = nested_level[paren_count] + 1;\n            paren_level[paren_count] = 0;\n\
    \            paren_count++;\n        } else if(groups[i][0] === \"(\" && groups[i].length\
    \ > 1){\n            nested_level[paren_count] = nested_level[paren_count] + 1;\n\
    \            paren_count++;\n        } else if(groups[i][0] === \"(\" && groups[i].length\
    \ === 1){\n            nested_level[paren_count] = 0;\n            paren_count++;\n\
    \        }\n    }\n    var result = [];\n    for(i = 0; i < paren_count; i++){\n\
    \        if(nested_level[i] === 0){\n            result.push(paren_level[i]);\n\
    \        }\n    }\n    return result;\n}\n", "  var nested_level = find_deepest_nested_parens_level(paren_string);\n\
    \  var result = [];\n  for(let i = 0; i < nested_level; i++){\n    result.push(paren_string.length\
    \ - nested_level + i);\n  }\n  return result;\n}\n", "    var levels = [];\n \
    \   var paren_regex = /\\((.*?)\\)/g;\n    var paren_count = 0;\n    var match\
    \ = paren_regex.exec(paren_string);\n    while(match !== null) {\n        paren_count++;\n\
    \        levels.push(paren_count);\n        match = paren_regex.exec(paren_string);\n\
    \    }\n    levels.forEach(function(level){\n        if(level === 0)\n       \
    \     return;\n        paren_string += ')';\n        paren_string += '(';\n  \
    \  });\n    return paren_count;\n}\n", "\tvar nested_paren_count = 0\n\tvar max_nested_paren_count\
    \ = 0\n\tvar parsed_input = []\n\tparen_string = paren_string.trim()\n\tvar level\
    \ = 0\n\t\n\t//loop through each character in input\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] == '(' || paren_string[i] == ')'){\n\t\t\t//if\
    \ the character is an open paren, add the level of nesting to the level count.\n\
    \t\t\t//if we are at the maximum level of nesting, then ignore this character\
    \ and keep going.\n\t\t\tif(paren_string[i] == ')'){\n\t\t\t\tlevel -= 1\n\t\t\
    \t}else{\n\t\t\t\tlevel += 1\n\t\t\t}\n\t\t\t\n\t\t\t//update the max count of\
    \ nested parentheses.\n\t\t\tif(level > max_nested_paren_count){\n\t\t\t\tmax_nested_paren_count\
    \ = level\n\t\t\t}\n\n\t\t\t//if the input already has some nested parentheses,\
    \ and the current level is greater than the max level of nested parentheses, add\
    \ the character to the array\n\t\t\tif(level > 0 && parsed_input.length > 0){\n\
    \t\t\t\tif(parsed_input[parsed_input.length - 1] != '(' && parsed_input[parsed_input.length\
    \ - 1] != '(' && parsed_input[parsed_input.length - 1] != '('){\n\t\t\t\t\tparsed_input.push('('\
    \ + paren_string[i])\n\t\t\t\t}else{\n\t\t\t\t\tparsed_input[parsed_input.length\
    \ - 1] += paren_string[i]\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tparsed_input.push(paren_string[i])\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\treturn parsed_input\n}\n", "\tvar paren_depth=1;\n\t\
    paren_string=paren_string.replace(/\\(\\(\\([^\\)]*\\)\\)\\)/g,'');//remove any\
    \ nested parantheses.\n\tvar levels=[paren_depth];\n\twhile(paren_string.indexOf('(')!=-1){//while\
    \ there is a left parenthesis in the string\n\t\tvar left=paren_string.substring(0,paren_string.indexOf('('));//get\
    \ the left parenthesis.\n\t\tvar right=paren_string.substring(paren_string.indexOf('(')+1,paren_string.lastIndexOf(')'));//get\
    \ the right parenthesis.\n\t\tvar next_paren_depth=paren_depth+1;\n\t\tif(levels[levels.length-1]>next_paren_depth){//if\
    \ the last element of levels is greater than the next parenthesis, add 1 to levels\n\
    \t\t\tlevels.push(next_paren_depth);\n\t\t}\n\t\tparen_string=paren_string.substring(right.lastIndexOf(')')+1,paren_string.length);//remove\
    \ right parenthesis from string.\n\t\tparen_string=paren_string+right;//add right\
    \ parenthesis to string.\n\t\tparen_depth=next_paren_depth;\n\t}\n\treturn levels;\n\
    }\n", "\tlet paren_stack = [];\n\tlet max_level = 0;\n\tfor (let i = 0; i < paren_string.length;\
    \ i++){\n\t\tlet char = paren_string[i];\n\t\tif (char === \"(\"){\n\t\t\tparen_stack.push(char);\n\
    \t\t} else if (char === \")\"){\n\t\t\tlet level = 0;\n\t\t\twhile (paren_stack.length\
    \ > 0 && paren_stack[level] === \"(\"){\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\tlet\
    \ max_level = level;\n\t\t\tlet current_level = level;\n\t\t\twhile(paren_stack.length\
    \ > 0 && paren_stack[level] === \")\"){\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\tif (level\
    \ === current_level){\n\t\t\t\t//Reached the top of the stack and we can't go\
    \ back\n\t\t\t\tmax_level = max_level + 1;\n\t\t\t\twhile (level < max_level &&\
    \ paren_stack.length > 0 && paren_stack[level] === \"(\"){\n\t\t\t\t\tlevel++;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\tparen_stack.pop();\n\t\t} else if (char === \" \"){\n\
    \t\t\t//Ignore spaces\n\t\t} else {\n\t\t\t//Push everything else to the stack\n\
    \t\t\tlet level = 0;\n\t\t\twhile (paren_stack.length > 0 && paren_stack[level]\
    \ === char){\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\tmax_level = Math.max(max_level,\
    \ level);\n\t\t\twhile (level < max_level && paren_stack.length > 0 && paren_stack[level]\
    \ === char){\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_level;\n}\n",
  "    var max_depth = 0;\n    var paren_stack = []; //Stack to store the depth of\
    \ each nested paranthesis.\n    var depth = 0; //Current depth of the paren_stack\n\
    \    var parens_found = false; //Flag to indicate whether parenthesis are found\
    \ or not.\n    for(var i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ == '(' || paren_string[i] == '{'){\n            depth++;\n        }else if(paren_string[i]\
    \ == ')' || paren_string[i] == '}'){\n            depth--;\n            if(parens_found\
    \ && depth < 0){\n                return -1; //Error found: Not enough closing\
    \ parenthesis.\n            }\n        }\n        if(parens_found && depth < 0){\n\
    \            return -1; //Error found: Not enough closing parenthesis.\n     \
    \   }\n        \n        //If parenthesis is found after processing each of the\
    \ previous character, \n        //set the parens_found flag to true so that we\
    \ do not reset parens_stack on each character.\n        if(parens_found && paren_string[i]\
    \ == ')'){\n            parens_found = true;\n        }\n        if(paren_string[i]\
    \ == ')' && parens_found && depth == 0){\n            parens_found = false;\n\
    \        }\n        \n        //If depth is less than 0, return error because\
    \ not enough closing parenthesis.\n        if(parens_found && depth < 0){\n  \
    \          return -1;\n        }\n        \n        //Push the depth of each nested\
    \ parenthesis to the paren_stack array.\n        paren_stack.push(depth);\n  \
    \  }\n    \n    //Return the max depth from paren_stack\n    return paren_stack.reduce(function(a,\
    \ b){return Math.max(a,b)});\n}\n", "  var groups = paren_string.replace(/\\)/g,\
    \ \")(\").split(/\\(/);\n  var levels = [0];\n  var nesting_level = 1;\n  for(var\
    \ i = 0; i < groups.length; i++){\n    levels[i] = (levels[i] || 0) + 1;\n   \
    \ if(levels[i] > nesting_level){\n      nesting_level = levels[i];\n    }\n  }\n\
    \  return nesting_level;\n}", "\tvar stack = [];\n\tvar max_level = 0;\n\tvar\
    \ deepest_level = 0;\n\tfor (var i = 0; i < paren_string.length; i++){\n\t\tvar\
    \ c = paren_string[i];\n\t\tif (c == \"(\"){\n\t\t\tif (stack.length == 0){\n\t\
    \t\t\tmax_level = 1;\n\t\t\t\tdeepest_level = 1;\n\t\t\t} else {\n\t\t\t\tdeepest_level\
    \ = Math.max(deepest_level, stack.length);\n\t\t\t\tmax_level = Math.max(max_level,\
    \ stack.length);\n\t\t\t}\n\t\t\tstack.push(c);\n\t\t} else if (c == \")\"){\n\
    \t\t\tif (stack.length != 0){\n\t\t\t\tdeepest_level = Math.max(deepest_level,\
    \ stack.length);\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t} else {\n\t\t\tstack.push(c);\n\
    \t\t}\n\t}\n\treturn max_level;\n}\n", "\tvar nested_level = 0;\n\tfor(var i =\
    \ 0; i< paren_string.length; i++){\n\t\tif((paren_string[i] == '(') || (paren_string[i]\
    \ == ')')){\n\t\t\tnested_level++;\n\t\t}\n\t\telse if((paren_string[i] == '[')\
    \ || (paren_string[i] == ']')){\n\t\t\tnested_level--;\n\t\t}\n\t}\n\treturn nested_level;\n\
    }\n", "\tlet nested_level = [0,1];\n\tlet max_level = 0;\n\tlet max_paren_level\
    \ = 0;\n\tfor (let i = 0; i < paren_string.split(\" \").length; i++){\n\t\tlet\
    \ level = paren_string.split(\" \").length - i - 1;\n\t\tif (level > max_level){\n\
    \t\t\tmax_level = level;\n\t\t}\n\t\tif (level > max_paren_level){\n\t\t\tmax_paren_level\
    \ = level;\n\t\t}\n\t}\n\tfor (let i = 0; i < paren_string.split(\" \").length;\
    \ i++){\n\t\tlet level = paren_string.split(\" \").length - i - 1;\n\t\tlet last_index\
    \ = i;\n\t\tfor (let j = i; j < paren_string.split(\" \").length; j++){\n\t\t\t\
    if (paren_string.split(\" \").length > j){\n\t\t\t\tif (paren_string.split(\"\
    \ \")[j] == paren_string.split(\" \")[j - 1] && paren_string.split(\" \")[j] ==\
    \ paren_string.split(\" \")[i - 1]){ // for nested parenthesis \n\t\t\t\t\tnested_level[j\
    \ - last_index] = nested_level[j - last_index] + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t}\n\t}\n\treturn nested_level[max_paren_level];\n}", "    var\
    \ groups = paren_string.match(/(?:[^()]|\\((?!\\)))+(?=\\))/g) || [];\n    var\
    \ max_depth = 0;\n    var depth = 0;\n    groups.forEach(function(group) {\n \
    \       depth = depth + 1;\n        var group_length = group.length;\n       \
    \ if (depth <= max_depth) {\n            if (group_length < max_depth) {\n   \
    \             depth = depth + 1;\n            } else {\n                max_depth\
    \ = depth;\n            }\n        } else {\n            max_depth = depth;\n\
    \        }\n    });\n    return max_depth;\n}\n", "    var level = 0;\n    var\
    \ index = 0;\n    var paren_level = 0;\n    var open_paren = 0;\n    var max_level\
    \ = 0;\n    var levels_stack = [];\n    var paren_stack = [];\n    var parens\
    \ = [];\n\n    for(index = 0; index < paren_string.length; index++){\n       \
    \ var char = paren_string[index];\n        var is_open = char.match(/^\\(/);\n\
    \        var is_close = char.match(/\\)/);\n\n        if(open_paren == is_open){\n\
    \            paren_level++;\n        }\n        if(open_paren == is_close){\n\
    \            paren_level--;\n        }\n\n        if(paren_level == 0 && paren_stack.length\
    \ == 0){\n            levels_stack.push(level);\n        }\n\n        if(is_open){\n\
    \            paren_stack.push(paren_level);\n            open_paren++;\n     \
    \   }\n        if(is_close){\n            if(paren_level < levels_stack[levels_stack.length-1]){\n\
    \                levels_stack.pop();\n                level--;\n            }\n\
    \            else{\n                open_paren--;\n            }\n        }\n\
    \    }\n\n    for(index = 0; index < levels_stack.length; index++){\n        max_level\
    \ = levels_stack[index];\n    }\n\n    return max_level;\n}\n", "    var groups\
    \ = paren_string.match(/[^()]+|(\\([^\\)]*\\))/g);\n    var levels = new Array();\n\
    \    for(var i = 0; i < groups.length; i++){\n        var group = groups[i];\n\
    \        var level = 0;\n        if(group.length >= 2){\n            while(group.length\
    \ > 0){\n                level++;\n                group = group.slice(0,1);\n\
    \            }\n        }\n        levels.push(level);\n    }\n    return levels;\n\
    }\n", "  var nested_parens = [];\n  var in_parens = false;\n  var cur_level =\
    \ 0;\n  paren_string.split(/\\s+/g).forEach(function(ele){\n    if(in_parens){\n\
    \      if(ele==')'){\n        nested_parens[cur_level]++;\n      }\n      else\
    \ if(ele==')' && nested_parens[cur_level]==0){\n        nested_parens[cur_level]--;\n\
    \      }\n      else{\n        cur_level++;\n      }\n    }\n    else{\n     \
    \ if(ele=='('){\n        in_parens = true;\n      }\n      else if(ele==')'){\n\
    \        in_parens = false;\n      }\n      else{\n        cur_level++;\n    \
    \  }\n    }\n  });\n  return nested_parens;\n}\n", "    var paren_count=paren_string.split(\"\
    \ \").length; //how many nested parentheses there are in the string\n    var max_nesting=0;\
    \ //initialize a counter to keep track of the deepest level of nesting\n    var\
    \ current_nesting=0; //initialize a counter to keep track of current nesting level\n\
    \n    for (var i=0; i<paren_string.length; i++){\n        if (paren_string.charAt(i)==\"\
    (\"){\n            current_nesting+=1;\n        } else if (paren_string.charAt(i)==\"\
    )\"){\n            current_nesting-=1;\n            if (current_nesting<max_nesting){\n\
    \                max_nesting=current_nesting;\n            }\n        }\n    }\n\
    \    return max_nesting;\n}\n</code>\n<|/ a tags=string,javascript |>\n<| a |>\n\
    I got this to work using recursion.\n\n<code>\nvar paren_count = function(s) {\n\
    \  var parenCount = 0;\n  var chars = s.split('');\n  var numOfParenthesis = chars.filter(function(element)\
    \ {\n    return element == '(' || element == ')';\n  }).length;\n  var numOfLeftParenthesis\
    \ = chars.filter(function(element) {\n    return element == '(';\n  }).length;\n\
    \  var numOfRightParenthesis = chars.filter(function(element) {\n    return element\
    \ == ')';\n  }).length;\n  if (numOfLeftParenthesis === numOfRightParenthesis)\
    \ {\n    return numOfParenthesis;\n  } else {\n    if (numOfLeftParenthesis >\
    \ numOfRightParenthesis) {\n      return numOfParenthesis + paren_count(s.substring(0,\
    \ s.length - 1));\n    } else {\n      return paren_count(s.substring(0, s.length\
    \ - 1));\n    }\n  }\n}\n", "  paren_string = paren_string.replace(/\\(/g, ' (\
    \ ').replace(/\\)/g, ' ) ');\n  var nested_paren_array = paren_string.split(\"\
    \ \");\n  var max_nested_level = 0;\n  for(var i = 0; i < nested_paren_array.length;\
    \ i++){\n    var cur_paren_level = parseInt(nested_paren_array[i]);\n    max_nested_level\
    \ = cur_paren_level > max_nested_level ? cur_paren_level : max_nested_level;\n\
    \  }\n  return max_nested_level;\n}\n", "  if(paren_string.trim() === \"\") return\
    \ [];\n  let max_level = 1;\n  const nesting_levels = [];\n  let max_nesting_level\
    \ = null;\n  const groups = paren_string.trim().match(/\\([^()]+\\)/g);\n  if(groups\
    \ != null){\n    for(let i = 0; i < groups.length; ++i){\n      const level =\
    \ parse_parens_group(groups[i], i, max_level);\n      if(nesting_levels[level]\
    \ === null) nesting_levels[level] = 0;\n      if(nesting_levels[level] >= max_nesting_level)\
    \ continue;\n      nesting_levels[level]++;\n      max_nesting_level = nesting_levels[level];\n\
    \    }\n  }\n  return nesting_levels;\n}\n", "\t// initialize to an array with\
    \ one level of nesting \n\tvar nested_parens = [];\n\t\n\t// initialize to an\
    \ empty string\n\tvar nested_parens_str = \"\";\n\t\n\t// use index to iterate\
    \ through the string and check each character\n\tfor(var index = 0; index < paren_string.length;\
    \ index++){\n\t\t// if the current character is '('\n\t\tif(paren_string[index]\
    \ === \"(\"){\n\t\t\t// if the last character was ')' then, it's a nested group\
    \ of two levels\n\t\t\tif(paren_string[index-1] === \")\"){\n\t\t\t\t// add 2\
    \ to nested_parens array\n\t\t\t\tnested_parens.push(2);\n\t\t\t\t\n\t\t\t\t//\
    \ continue checking the other characters with nested parentheses \n\t\t\t\tcontinue;\n\
    \t\t\t}\n\t\t\t\n\t\t\t// if the last character was ')' then it's a nested group\
    \ of one level\n\t\t\tif(paren_string[index-1] === \")\"){\n\t\t\t\t// add 1 to\
    \ nested_parens array\n\t\t\t\tnested_parens.push(1);\n\t\t\t\t\n\t\t\t\t// continue\
    \ checking the other characters with nested parentheses \n\t\t\t\tcontinue;\n\t\
    \t\t}\n\t\t\t\n\t\t\t// if none of the above conditions then it's a nested group\
    \ of zero levels\n\t\t\tnested_parens.push(0);\n\t\t}\n\t\t\n\t\t// if the current\
    \ character is ')'\n\t\tif(paren_string[index] === \")\"){\n\t\t\t// if there\
    \ is only one level of nested parentheses then add the level to the array\n\t\t\
    \tif(nested_parens.length === 1){\n\t\t\t\tnested_parens.push(0);\n\t\t\t\t\n\t\
    \t\t\t// continue checking the other characters with nested parentheses \n\t\t\
    \t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// if there are more than one level of nested\
    \ parentheses then \n\t\t\t// the last nested level of parentheses is added to\
    \ the array\n\t\t\tnested_parens.push(nested_parens.length-1);\n\t\t}\n\t}\n\t\
    \n\t// return the result from nested_parens array\n\treturn nested_parens;\n}\n",
  "\tvar nested_paren_arr = [];\n\tvar parentheses_stack = [];\n\tparentheses_stack.push(0);\n\
    \tfor(var i=0; i< paren_string.length; i++){\n\t\tif(paren_string[i] == '('){\n\
    \t\t\tparentheses_stack.push(parentheses_stack[parentheses_stack.length - 1] +\
    \ 1);\n\t\t}\n\t\telse if(paren_string[i] == ')'){\n\t\t\tvar current_level =\
    \ parentheses_stack.pop();\n\t\t\tif(current_level > nested_paren_arr.length){\n\
    \t\t\t\tnested_paren_arr.length = current_level;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ nested_paren_arr;\n}", "  let level_array = [];\n  for (let i = 1; i < paren_string.trim().length;\
    \ i++){\n    let chart = paren_string.charAt(i)\n    let parentheses_level = 0;\n\
    \    \n    while (parentheses_level < level_array.length){\n      parentheses_level\
    \ = level_array[parentheses_level]\n    }\n\n    if (parenstring_chart == chart){\n\
    \      if (parentheses_level == level_array.length - 1){\n        level_array[parentheses_level\
    \ + 1] = i\n      }\n    }\n    else {\n      level_array.push(parentheses_level)\n\
    \    }\n  }\n\n  return level_array\n}\n", "    var paren_count = 0;\n    var\
    \ max_paren_count = 0; //Stores the max level of nesting for each group.\n   \
    \ var nested_count = 0; //Stores the nesting level count for each group.\n   \
    \ var nested_string = \"\"; //Stores nested groups for each group.\n    var paren_string\
    \ = paren_string.trim(); //Remove leading and trailing whitespace.\n    var parens\
    \ = paren_string.split(\" \");\n    for (var i = 0; i < parens.length; i++){\n\
    \        if (parens[i] == \"(\"){\n            paren_count++;\n        } else\
    \ if (parens[i] == \")\"){\n            paren_count--;\n            if (paren_count\
    \ < 0){\n                max_paren_count = paren_count;\n            }\n     \
    \   } else {\n            if (paren_count > max_paren_count){\n              \
    \  max_paren_count = paren_count;\n            }\n        }\n    }\n    for (i\
    \ = 0; i < parens.length; i++){\n        if (parens[i] == \"(\"){\n          \
    \  nested_count += 1;\n        } else if (parens[i] == \")\"){\n            nested_count\
    \ -= 1;\n        }\n    }\n    if (nested_count <= 0 || max_paren_count <= 0){\n\
    \        throw \"Invalid paren string \\\"\" + paren_string + \"\\\" passed to\
    \ parse_nested_parens()\";\n    }\n    return nested_count;\n}\n", "    var nest\
    \ = [],\n        level = 0,\n        levels = [],\n        i, j, parens_level;\n\
    \    for (i = 0; i < paren_string.length; i++){\n        parens_level = paren_string[i].length;\n\
    \        level = level + parens_level;\n        while (parens_level > levels[level]){\n\
    \            levels[level] = 0;\n            level++;\n        }\n        levels[level]++;\n\
    \    }\n    for (j = 0; j < level; j++){\n        nest.push(levels[j]);\n    }\n\
    \    return nest;\n}\n", "    //Convert paren_string to an array of strings of\
    \ all the groups of parentheses in paren_string\n    var paren_group = paren_string.match(/[^()]*/g);\n\
    \n    //Sort the paren_group\n    paren_group.sort(function(a, b){\n        return\
    \ b.length - a.length;\n    });\n\n    //Parse each group of parentheses separated\
    \ by spaces to find their maximum depth.\n    var max_depth = paren_group.reduce(function(prev,\
    \ curr){\n        var depth = prev + curr.length;\n        //If the current group\
    \ of parentheses is empty, return it\n        if(curr === \"\") return depth;\n\
    \        //If the current group of parentheses has more than one group, return\
    \ the max depth of the group\n        if(curr.match(/\\(([^()]*?)\\)/g).length\
    \ >= 2) return depth;\n        //If the current group of parentheses has one group,\
    \ return it.\n        else return depth;\n    }, 0);\n\n    return max_depth;\n\
    }\n", "    paren_string = paren_string.replace(/[\\(\\)]/g,\"\");\n    var nest_count\
    \ = 0; \n    var nest_level = -1;\n    var group = [];\n    for(var i=0; i<paren_string.length;i++){\n\
    \        if(paren_string[i]==\"(\"){\n            group.push(paren_string[i]);\n\
    \        }else if(paren_string[i]==\")\"){\n            var current_level = nest_count+nest_level;\n\
    \            if(current_level == 0){\n                return group;\n        \
    \    }\n            nest_count++;\n            nest_level = current_level;\n \
    \           group.pop();\n        }\n    }\n    return group;\n}", "\tvar groups\
    \ = paren_string.split(\" \");\n\tvar level = 0;\n\tfor(var i = 0; i < groups.length;\
    \ i++){\n\t\tif(groups[i] === \"(\"){\n\t\t\tlevel++;\n\t\t}else if(groups[i]\
    \ === \")\"){\n\t\t\tlevel--;\n\t\t}\n\t}\n\treturn level;\n}\n", "\tvar level\
    \ = 0;\n\tvar nested_parens = [];\n\tvar parsing_parens_levels = [];\n\tvar current_parsing_parens_level\
    \ = 0;\n\tvar current_nested_parens = [];\n\t\n\t//This function returns a number\
    \ which represents the maximum level of nesting of a group of parentheses.\n\t\
    function get_deepest_level_of_nesting(paren_string){\n\t\tvar nesting = 0;\n\t\
    \tvar parens = paren_string.split(\" \");\n\t\tvar current_level = parens.length;\n\
    \t\tfor(var i = 0; i< parens.length; i++){\n\t\t\tvar p = parens[i].charAt(0);\n\
    \t\t\tif(p === \"(\")\n\t\t\t\tnesting++;\n\t\t\tif(p === \")\")\n\t\t\t\tnesting--;\n\
    \t\t\tcurrent_level = current_level - nesting;\n\t\t}\n\t\treturn current_level;\n\
    \t}\n\t\n\tfor(var i = 0; i< paren_string.length; i++){\n\t\tvar p = paren_string[i].charAt(0);\n\
    \t\tif(p === \"(\")\n\t\t\tlevel++;\n\t\tif(p === \")\")\n\t\t\tlevel--;\n\t\t\
    if(p === \" \" && level === 0){\n\t\t\tparsing_parens_levels.push(current_parsing_parens_level);\n\
    \t\t\tcurrent_nested_parens.push(current_parsing_parens_level);\n\t\t}\n\t\tif(p\
    \ === \" \" && level > 0){\n\t\t\tparsing_parens_levels.push(current_parsing_parens_level);\n\
    \t\t}\n\t\tcurrent_parsing_parens_level = current_parsing_parens_level - level;\n\
    \t\tif(p === \" \"){\n\t\t\tcurrent_parsing_parens_level++;\n\t\t}\n\t\tif(p ===\
    \ \")\" && parsing_parens_levels[parsing_parens_levels.length-1] === current_parsing_parens_level){\n\
    \t\t\tcurrent_parsing_parens_level--;\n\t\t}\n\t}\n\treturn parsing_parens_levels;\n\
    }\n", "\tvar nested_paren_stack = [paren_string];\n\tvar max_nest_level = 1;\n\
    \t\n\tfor(var i = 1; i < paren_string.length; i++){\n\t\tvar char = paren_string[i];\n\
    \t\tif(char === '(' || char === '{' || char === '['){\n\t\t\tnested_paren_stack.push(paren_string);\n\
    \t\t\tmax_nest_level = Math.max(max_nest_level, nested_paren_stack.length);\n\t\
    \t}else if(char === ')' || char === '}' || char === ']'){\n\t\t\tmax_nest_level\
    \ = Math.max(max_nest_level, nested_paren_stack.length - 1);\n\t\t\tnested_paren_stack.pop();\n\
    \t\t}\n\t}\n\t\n\treturn max_nest_level;\n}\n*/\n", "\tif(!paren_string) return\
    \ [];\n\tvar paren_string = paren_string.replace(/^\\s+|\\s+$/g, \"\"); //remove\
    \ leading/trailing spaces\n\tvar paren_string = paren_string.replace(/\\s+/g,\
    \ \" \"); //convert groups of spaces to a single space\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \"(\"); //convert groups of spaces to a single opening parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\)/g, \")(\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    (/g, \"(\"); //convert groups of spaces to a single opening parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\)/g, \")\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    (/g, \"(\"); //convert groups of spaces to a single opening parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\)/g, \")\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \"(\"); //convert groups of spaces to a single opening parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\s+/g, \"(\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \"(\"); //convert groups of spaces to a single opening parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\s+/g, \")\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \")\"); //convert groups of spaces to a single closing parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\s+/g, \")\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \")\"); //convert groups of spaces to a single closing parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\s+/g, \")\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \")\"); //convert groups of spaces to a single closing parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\s+/g, \")\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \")\"); //convert groups of spaces to a single closing parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\s+/g, \")\"); //convert groups of spaces\
    \ to a single closing parenthesis\n\tvar paren_string = paren_string.replace(/\\\
    s+/g, \")\"); //convert groups of spaces to a single closing parenthesis\n\tvar\
    \ paren_string = paren_string.replace(/\\s+/g, \")\"); //convert group", "   \
    \ var nested_level = [];\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        var index = paren_string.indexOf(\" \");\n        if(index !== -1){\n\
    \            nested_level[i] = paren_string.substring(index+1).length; // number\
    \ of levels of nesting of this group.\n        }\n        else{\n            nested_level[i]\
    \ = 0;\n        }\n    }\n    return Math.max.apply(null, nested_level);\n}",
  "  paren_string = paren_string.replace(/\\(/g,\" \");\n  paren_string = paren_string.replace(/\\\
    )/g,\" \");\n  var nested_levels = paren_string.trim().match(/\\w+/g).sort();\n\
    \  if(nested_levels.length > 0){\n    nested_levels.pop();\n    return nested_levels;\n\
    \  }\n  return [];\n}\n", "  let groups = paren_string.match(/\\(([^()]+)\\)/g)\n\
    \  let max_nesting = -1\n  groups.forEach((group)=>{\n    let group_nesting =\
    \ group.match(/[\\((]{0,1}([0-9]+)\\)[\\)]{0,1}/g)\n    group_nesting.forEach((nesting)=>{\n\
    \      if(parseInt(nesting) < max_nesting) max_nesting = parseInt(nesting)\n \
    \   })\n  })\n  return max_nesting\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere\
    \ is another solution that does not use regex but instead just counts the number\
    \ of open parentheses:\n<code>", "    let paren_string_pieces = paren_string.split(/\\\
    s+/);\n    let paren_string_count = 0;\n    let deepest_level = 0;\n    let nested_parentheses\
    \ = [];\n\n    for (let i = 0; i < paren_string_pieces.length; i++){\n       \
    \ paren_string_count = paren_string_count*1 + paren_string_pieces[i].length/2;\n\
    \        deepest_level = deepest_level*1 + i;\n    }\n\n    while (paren_string_count\
    \ > 0){\n        nested_parentheses.push(deepest_level);\n        paren_string_count--;\n\
    \    }\n\n    return nested_parentheses;\n}\n", "    var nesting_level = 0;\n\
    \    var max_nesting_level = 0;\n    var nest_arr = [];\n    for (var i = 0, len\
    \ = paren_string.length; i < len; i++){\n        var char = paren_string[i];\n\
    \        if (char === \"(\") nesting_level++;\n        else if (char === \")\"\
    ) nesting_level--;\n        if (nesting_level > max_nesting_level) max_nesting_level\
    \ = nesting_level;\n    }\n    return max_nesting_level;\n}\n", "    if(!paren_string)\
    \ return [];\n    paren_string = paren_string.replace(/\\s/g,'');\n\n    var levels\
    \ = [];\n    var open_level = 1;\n    var close_level = 0;\n    var current_level\
    \ = [];\n    var open_parens = [];\n    var closed_parens = [];\n    for(var i\
    \ = 0; i < paren_string.length; i++){\n        if(paren_string[i] == \"(\"){\n\
    \            current_level.push(paren_string[i]);\n            open_parens.push(open_level);\n\
    \            open_level++;\n        }\n        else if(paren_string[i] == \")\"\
    ){\n            closed_parens.push(close_level);\n            close_level = open_level;\n\
    \            open_level--;\n        }\n        else{\n            current_level.push(paren_string[i]);\n\
    \            if(open_level > close_level){\n                close_level = current_level.length;\n\
    \            }\n        }\n    }\n    if(current_level.length > close_level) close_level\
    \ = current_level.length;\n    open_parens.push(open_level);\n    closed_parens.push(close_level);\n\
    \    for(var i = 0; i < open_parens.length; i++){\n        levels.push(closed_parens[i]\
    \ - open_parens[i]);\n    }\n    return levels;\n}\n", "  var max_level = 0\n\
    \  var nested_levels = paren_string.match(/\\(\\s*\\(\\s*(\\((?:[^()]*|(?:\\([^()]*\\\
    )))*\\)\\s*)\\)\\s*\\)/)\n  if(nested_levels !== null){\n    nested_levels = nested_levels[2].match(/\\\
    (\\s*(\\((?:[^()]*|(?:\\([^()]*\\)))*\\)\\s*)\\)/)\n    while(nested_levels !==\
    \ null){\n      max_level = Math.max(max_level, nested_levels[1].length)\n   \
    \   nested_levels = nested_levels[2].match(/\\(\\s*(\\((?:[^()]*|(?:\\([^()]*\\\
    )))*\\)\\s*)\\)/)\n    }\n  }\n  return max_level\n}\n", "\tvar result = new Array();\n\
    \t\n\t//Split by white space\n\tvar splited = paren_string.split(\" \");\n\t\n\
    \tfor(var i = 0; i< splited.length; i++){\n\t\tvar temp = parse_paren_string(splited[i]);\n\
    \t\tif(temp.length > result.length){\n\t\t\tresult = temp;\n\t\t}\n\t}\n\t\n\t\
    return result;\n}\n", "    var level = 0;\n    var parentheses = new Array();\n\
    \    for(var i = 0; i < paren_string.length; i++) {\n        var c = paren_string.charAt(i);\n\
    \        if(c == ')') {\n            level--;\n            if(level == 0) {\n\
    \                parentheses.push(level);\n            }\n        } else if (c\
    \ == '(') {\n            level++;\n            parentheses.push(level);\n    \
    \    }\n    }\n    return parentheses;\n}\n", "    var out = [];\n    var level\
    \ = 0;\n    for (var i = 0; i < paren_string.length; i++){\n        var c = paren_string[i];\n\
    \        if (c === '('){\n            if (level <= 0) out.push(i);\n         \
    \   level++;\n        } else if (c === ')'){\n            level--;\n         \
    \   if (level == 0) out.push(i);\n        }\n    }\n    return out;\n}\n", " \
    \   let levels = [];\n    const last_pos = 0;\n    for(let i=0; i<paren_string.length;\
    \ i++){\n        const ch = paren_string.charAt(i);\n        if (ch == \"(\")\
    \ {\n            levels.push(paren_string.length - i);\n        } else if (ch\
    \ == \")\" && levels.length > 0){\n            levels.pop();\n        }\n    }\n\
    \    return levels;\n}\n", "\t// Get the parentheses counts. In the string above,\
    \ the counts are:\n\t// Number of left parens: 3\n\t// Number of right parens:\
    \ 3\n\t// Number of brackets: 3\n\t// Number of curly brackets: 1\n\tvar left_counts\
    \  = paren_string.match(/\\(/g).length - 1;\n\tvar right_counts = paren_string.match(/\\\
    )/g).length - 1;\n\tvar bracket_counts = paren_string.match(/\\{/g).length - 1;\n\
    \tvar curly_brackets = paren_string.match(/\\}/g).length - 1;\n\n\t// The function\
    \ should return an array.\n\treturn [left_counts, right_counts, bracket_counts,\
    \ curly_brackets];\n}\n", "    var depths = [];\n    var depth = 0;\n    var open_brackets\
    \ = [];\n    var closed_brackets = [];\n\n    //Iterate the input string\n   \
    \ for (var i=0; i<paren_string.length; i++){\n        //Find the next group of\
    \ parentheses\n        var p = paren_string.indexOf(\"(\", i+1);\n        //If\
    \ no more parentheses, break out of the loop\n        if (p==-1) break;\n    \
    \    //Create a deep copy of depths\n        depths = JSON.parse(JSON.stringify(depths));\n\
    \        //Iterate until parenthesis pair is closed.\n        for (var j=i+1;\
    \ j<=p; j++){\n            //If parenthesis pair is not closed, increment depth\n\
    \            if (paren_string[j]!=\")\"){\n                depths[depths.length-1]++;\n\
    \                depth = depths[depths.length-1];\n            }\n           \
    \ //If all parentheses are closed, remove depth from depths array\n          \
    \  else if (paren_string[j]==\")\") depths.pop();\n        }\n        //Add the\
    \ current parenthesis group to the open_brackets array\n        open_brackets.push(paren_string.substr(i+1,\
    \ (paren_string.length)-(i+1)));\n    }\n    //Return the deepest depth\n    return\
    \ depths[depths.length-1];\n}\n", "    return parse_nested_parens_helper(paren_string,\
    \ 0);\n}\n", "  var nested_parens_level = [];\n  var cur_level = 0;\n  paren_string\
    \ = paren_string.replace(/\\s+/g, '');\n  for(var i=0;i<paren_string.length;i++){\n\
    \    if(paren_string[i] == '('){\n      cur_level++;\n      nested_parens_level.push(cur_level);\n\
    \    }else if(paren_string[i] == ')'){\n      cur_level--;\n      if(cur_level\
    \ < 0) break;\n    }\n  }\n  return nested_parens_level;\n}\n", "  var max_level\
    \ = 0,\n      nested_level = 0,\n      parens = [],\n      i;\n  //loop through\
    \ each character\n  for (i=0; i<paren_string.length; i++){\n    if (paren_string[i]\
    \ == '('){\n      parens.push(nested_level);\n      nested_level++;\n    } else\
    \ if (paren_string[i] == ')'){\n      nested_level--;\n      max_level = Math.max(max_level,\
    \ nested_level);\n    } else if (paren_string[i] == ')' && nested_level > 0){\n\
    \      nested_level--;\n    }\n  }\n  return parens;\n}\n\n", "\tvar nested_parentheses_level\
    \ = [];\n\tvar nested_parentheses_array = [];\n\tvar nested_parentheses_level_count\
    \ = 0;\n\tvar brace_count = 0; //count of nested paranthesis brackets\n\tvar i;\n\
    \tfor(i = 0;i < paren_string.length;i++){\n\t\tvar char = paren_string.charAt(i);\n\
    \t\tif(char == \"(\")\n\t\t\tnested_parentheses_level_count ++;\n\t\tif(char ==\
    \ \")\")\n\t\t\tnested_parentheses_level_count --;\n\t\tif(nested_parentheses_level_count\
    \ == 0){\n\t\t\tnested_parentheses_level[nested_parentheses_level.length] = nested_parentheses_level_count;\n\
    \t\t\tnested_parentheses_level_count =-1;\n\t\t}\n\t\tif(nested_parentheses_level_count\
    \ == -1)\n\t\t\tnested_parentheses_level.length = 0;\n\t\tnested_parentheses_array[nested_parentheses_array.length]\
    \ = char;\n\t}\n\tvar output_string = \"\";\n\tvar max_level = -1;\n\tfor(i =\
    \ 0;i < nested_parentheses_level.length;i++){\n\t\tvar level_count = nested_parentheses_level[i];\n\
    \t\tvar char_array_string = nested_parentheses_array.join(\"\");\n\t\tif((level_count\
    \ > max_level) && (max_level != -1)){\n\t\t\toutput_string += char_array_string;\
    \ //add any parenthesis at the deepest level\n\t\t\toutput_string += \"(\";\n\t\
    \t}\n\t\tif((level_count != max_level) && (level_count != -1)){\n\t\t\toutput_string\
    \ += char_array_string;\n\t\t\toutput_string += \")\";\n\t\t}\n\t\tmax_level =\
    \ level_count;\n\t}\n\toutput_string += char_array_string; //add any remaining\
    \ parenthesis\n\treturn output_string;\n}\n", "\tvar nested_levels = new Array();\n\
    \tvar paren_count = 0;\n\tvar opening_braces = 0;\n\tvar level = 0;\n\tfor (var\
    \ i=0;i<paren_string.length;i++){\n\t\tif (paren_string[i] == '('){\n\t\t\tif\
    \ (paren_count==0){\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\topening_braces += 1;\n\t\
    \t}\n\t\telse if (paren_string[i] == ')'){\n\t\t\tif (opening_braces==0){\n\t\t\
    \t\tlevel--;\n\t\t\t}\n\t\t\topening_braces -= 1;\n\t\t}\n\t\telse if (paren_string[i]\
    \ == '('){\n\t\t\tlevel++;\n\t\t}\n\t\telse if (paren_string[i] == ')'){\n\t\t\
    \tlevel--;\n\t\t}\n\t\telse if (paren_string[i] == ' ' && paren_count==0 && opening_braces==0){\n\
    \t\t\tnested_levels[level] += 1;\n\t\t}\n\t}\n\treturn nested_levels;\n}\n", "\t\
    let level = 0;\n\tlet current_level = [];\n\tfor (let i = 0; i < paren_string.length;\
    \ i++){\n\t\tlet char = paren_string[i];\n\t\tif (char === \"(\"){\n\t\t\tcurrent_level.length\
    \ = 0;\n\t\t\tlevel++;\n\t\t} else if (char === \")\"){\n\t\t\tlevel--;\n\t\t\t\
    current_level.length--;\n\t\t}\n\t\tif (current_level.length > 0){\n\t\t\tcurrent_level.push(char);\n\
    \t\t}\n\t}\n\treturn level;\n}\n", "    var nested_levels = new Array();\n   \
    \ var depth = 0;\n    var para_string_regex = \"\\\\(([^)]+)\\\\)\";\n    var\
    \ regex = new RegExp(para_string_regex, 'g');\n    var nested_parens_group = regex.exec(paren_string);\n\
    \n    while (nested_parens_group != null){\n        nested_levels.push(depth);\n\
    \        para_string_regex = \"\\\\(([^)]+)\\\\)\";\n        regex = new RegExp(para_string_regex,\
    \ 'g');\n        nested_parens_group = regex.exec(paren_string);\n        depth++;\n\
    \    }\n    return nested_levels;\n}\n", "\tvar level = 0;\n\tvar groups = new\
    \ Array();\n\tfor(var i = 0;i < paren_string.length;i++){\n\t\tif( paren_string.charAt(i)\
    \ == '('){\n\t\t\tlevel++;\n\t\t}else if( paren_string.charAt(i) == ')' ){\n\t\
    \t\tlevel--;\n\t\t}\n\t\tif( level != 0 ){\n\t\t\tgroups.push(level);\n\t\t}\n\
    \t}\n\tconsole.log(groups);\n\treturn groups;\n}\n", "\tvar paren_count = 0;\n\
    \tvar max_level = 0;\n\tvar output = [];\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tvar c = paren_string[i];\n\t\tif(c == '('){\n\t\t\tparen_count++;\n\
    \t\t}else if(c == ')'){\n\t\t\tparen_count--;\n\t\t}else{\n\t\t\tif(paren_count\
    \ == 0){\n\t\t\t\toutput.push(max_level);\n\t\t\t}\n\t\t\tmax_level++;\n\t\t}\n\
    \t}\n\treturn output;\n}\n\n", "\tparen_string = paren_string.replace(/\\s/g,'');\n\
    \tvar paren_array = paren_string.match(/\\((?:[^()]+|(?R))*\\)/);\n\tvar max_nested_level\
    \ = 0;\n\tvar cur_level_of_nesting = 1;\n\tfor(var i = 0; i < paren_array.length;\
    \ i++){\n\t\tvar cur_paren_string = paren_array[i].match(/(?:\\((?!\\?=))+\\)/)[0];\n\
    \t\tcur_level_of_nesting = Math.max(cur_level_of_nesting, paren_array[i].match(/(?:\\\
    ((?!\\?=))+\\)/).length);\n\t\tmax_nested_level = Math.max(max_nested_level, cur_level_of_nesting);\n\
    \t}\n\treturn max_nested_level;\n}\n", "    var nested_level = [];\n    var max_level\
    \ = 0;\n    for (var i = 0; i < paren_string.length; i++){\n        if (paren_string[i]\
    \ == ')'){\n            var level = 0;\n            for (var j = 0; j < nested_level.length;\
    \ j++){\n                if (nested_level[j] == max_level){\n                \
    \    level = j;\n                }\n            }\n            if (level == max_level){\n\
    \                nested_level.push(0);\n            }\n            else {\n  \
    \              max_level = level;\n            }\n        }\n        else{\n \
    \           for (var j = 0; j < nested_level.length; j++){\n                if\
    \ (nested_level[j] == 0){\n                    nested_level[j] += 1;\n       \
    \             break;\n                }\n            }\n        }\n    }\n   \
    \ return nested_level;\n}\n", "\tvar nested_count = 1;\n\tvar nested_level = 0;\n\
    \tvar nesting_string = \"\";\n\tvar open_parens_index = 0;\n\tvar open_parens_string\
    \ = \"\";\n\tvar closed_parens_string = \"\";\n\n\t//loop through input string\
    \ and find matching number of open and close parens\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\tif(paren_string[i] == '('){\n\t\t\tif(open_parens_index != i){\n\t\
    \t\t\topen_parens_string = paren_string.substring(open_parens_index, i);\n\t\t\
    \t\topen_parens_index += 1;\n\t\t\t\tclosed_parens_string = paren_string.substring(i,\
    \ paren_string.length);\n\t\t\t\tnested_level += 1;\n\t\t\t\tnesting_string =\
    \ nesting_string + nesting_string.length + 1;\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i]\
    \ == ')'){\n\t\t\topen_parens_index += 1;\n\t\t\tif(nested_level > 0){\n\t\t\t\
    \tnested_count += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [nested_count, nested_level,\
    \ nesting_string, open_parens_string, closed_parens_string];\n}\n", "    let nest\
    \ = 0;\n    let nested_parens = [];\n    for (let i = 0; i < paren_string.length;\
    \ i++){\n        if (paren_string[i] === \"(\")\n            nest++;\n       \
    \ else if (paren_string[i] === \")\")\n            nest--;\n        if (nest <\
    \ 0)\n            nested_parens.push(nest);\n    }\n    return nested_parens;\n\
    }\n", "\t\n\tvar depths = [];\n\t\n\tparen_string = paren_string.replace(/\\(|\\\
    )/g, \"\").replace(/[ ]{2,}/g, \" \");\n\tvar num_opens = paren_string.match(/\\\
    (/g).length;\n\tvar num_closes = paren_string.match(/\\)/g).length;\n\t\n\tfor\
    \ (var i=0; i<paren_string.length; i++){\n\t\tif (paren_string[i] === '('){\n\t\
    \t\tdepths.push(num_opens);\n\t\t\tnum_opens++;\n\t\t}\n\t\telse if (paren_string[i]\
    \ === ')'){\n\t\t\tdepths.push(num_closes);\n\t\t\tnum_closes--;\n\t\t}\n\t}\n\
    \t\n\treturn Math.max.apply(null, depths);\n}\n", "  let depth = 1;\n  let output_array\
    \ = [];\n  paren_string.split(\" \").forEach(element => {\n    if(element.startsWith(\"\
    (\")){\n      if(element.endsWith(\")\")){\n        depth--;\n      } else{\n\
    \        depth++;\n      }\n    } else{\n      depth++;\n    }\n    if(depth <=\
    \ 0){\n      output_array.push(depth);\n    }\n  });\n  return output_array;\n\
    }\n", "  var levels = 0;\n  var max_level = 0;\n  var paren_stack = [];\n  for(var\
    \ i=0; i<paren_string.length; i++){\n    var c = paren_string[i];\n    if (c ==\
    \ \"(\"){\n      paren_stack.push(c);\n    } else if (c == \")\"){\n      var\
    \ last = paren_stack.pop();\n      if (last == \"(\"){\n        levels++;\n  \
    \    } else if (last == \")\"){\n        levels--;\n      }\n      if (levels\
    \ < max_level){\n        max_level = levels;\n      }\n    }\n  }\n  return max_level;\n\
    }\n", "    // This function returns the maximum number of nesting level of parenthesis.\n\
    \    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\
    \    // For this function, the return value of this function is always greater\
    \ than or equal to 1.\n    // Since (()())() and ((())) have maximum three levels\
    \ of nesting respectively,\n    // this function will return 3 as the maximum\
    \ nesting level of nesting.\n    if(paren_string.includes('(')){\n        let\
    \ groups = paren_string.split('(');\n        let max_level = 0;\n        for(let\
    \ i = 0; i < groups.length; i++){\n            let group_level = 1;\n        \
    \    let group = groups[i];\n            while(i + 1 < groups.length && groups[i\
    \ + 1].includes('(')){\n                group_level++;\n                i++;\n\
    \            }\n            if(group_level > max_level){\n                max_level\
    \ = group_level;\n            }\n        }\n        return max_level;\n    }\n\
    \    return 1;\n}\n", "  paren_string = paren_string.split(' ');\n  var max_level\
    \ = 0;\n  var current_level = 0;\n  for(var i in paren_string){\n    var cur_str\
    \ = paren_string[i];\n    if(cur_str.length == 0){\n      current_level++;\n \
    \   }else{\n      if(cur_str == \"(\"){\n        current_level++;\n      }else\
    \ if(cur_str == \")\"){\n        current_level--;\n      }\n      if(max_level\
    \ < current_level){\n        max_level = current_level;\n      }\n    }\n  }\n\
    \  return max_level;\n}\n", "  var nested_level = [];\n  \n  var parentheses =\
    \ paren_string.trim().replace(/( |\\n|\\r)/gm,\" \").replace(/ +/g,\" \").split(\"\
    \ \");\n  for(var i = 0; i < parentheses.length; i++){\n    var level = 0;\n \
    \   var paren_open = parentheses[i].indexOf(\"(\");\n    var paren_close = parentheses[i].indexOf(\"\
    )\");\n    while(paren_open > -1 && paren_close > -1){\n      if(paren_open <\
    \ paren_close){\n        level++;\n        paren_open = parentheses[i].indexOf(\"\
    (\", paren_open + 1);\n      }else{\n        level--;\n        paren_close = parentheses[i].indexOf(\"\
    )\", paren_close + 1);\n      }\n    }\n    nested_level.push(level);\n  }\n \
    \ return nested_level.length;\n}\n", "    return paren_string.split(' ').map((x,i)=>{\n\
    \        if(i && x.match(/^\\((.*)\\)$/)) x = x.match(/\\((.*)\\)$/)[1]; \n  \
    \      return x.match('\\\\(')?parseInt(x.match(/\\(.*?\\)$/)[1])+1:parseInt(x.match(/\\\
    (.*?\\)$/)[0]);\n    }).reduce((a,b)=>Math.max(a,b), 0);\n}\n", "    var parsed_parens\
    \ = [];\n    var paren_level = 0;\n    var paren_char_pos = 0;\n    var paren_char;\n\
    \    for(var i = 0; i<paren_string.length;i++){\n        paren_char = paren_string[i];\n\
    \        if(paren_char == '('){\n            paren_level++;\n        }else if(paren_char\
    \ == ')'){\n            paren_level--;\n        }\n        if(paren_level == 0){\n\
    \            parsed_parens.push(paren_level);\n        }\n    }\n    return parsed_parens;\n\
    }\n", "  var nested_parentheses_levels = [];\n  var opening_paren_strings = paren_string.split('\
    \ ');\n  opening_paren_strings.forEach(function(opening_paren_string){\n    var\
    \ opening_paren_string_level = 0;\n    var next_opening_paren_string = opening_paren_string;\n\
    \    while((next_opening_paren_string = next_opening_paren_string.trim()).length){\n\
    \      opening_paren_string_level++;\n      if(opening_paren_string_level > nested_parentheses_levels.length){\n\
    \        nested_parentheses_levels.push(opening_paren_string_level);\n      }\n\
    \    }\n  });\n  return nested_parentheses_levels;\n}\n", "\tvar paren_levels\
    \ = paren_string.match(/\\(([^)(]+)\\)/);\n\tvar max_nesting_level;\n\tvar max_nesting_depth\
    \ = 0;\n\n\tfor(var i=0; i<paren_levels.length; i++){\n\t\tvar parentheses = paren_levels[i].trim().replace(/(^\\\
    s*)|(\\s*$)/g,'');\n\t\tvar depth = parentheses.length - 1;\n\t\twhile(parentheses.charAt(depth)\
    \ != '(' && depth > 0){\n\t\t\tdepth--;\n\t\t}\n\t\twhile(parentheses.charAt(depth)\
    \ != ')' && depth < max_nesting_depth){\n\t\t\tdepth++;\n\t\t}\n\t\tif(parentheses.charAt(depth)\
    \ == ')'){\n\t\t\tmax_nesting_depth = depth;\n\t\t\tmax_nesting_level = i;\n\t\
    \t}\n\t}\n\n\treturn max_nesting_level;\n}\n", "\t\n\tvar nested_levels = [];\n\
    \tvar paren_stack = [];\n\tvar paren_level = 0;\n\t\n\tfor(var i = 0; i < paren_string.length;\
    \ i++){\n\t\t\n\t\tif(paren_string[i] == \"(\"){\n\t\t\t\n\t\t\tparen_stack.push(paren_level);\n\
    \t\t\tparen_level++;\n\t\t}\n\t\t\n\t\tif(paren_string[i] == \")\"){\n\t\t\t\n\
    \t\t\tvar current_level = paren_stack.pop();\n\t\t\t\n\t\t\tif(current_level >\
    \ nested_levels[paren_level]){\n\t\t\t\tnested_levels[paren_level] = current_level;\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\treturn nested_levels;\n}\n", "  var nested_paren_count\
    \ = 0;\n  var nested_paren_string = \"\";\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string.charAt(i) == '('){\n      nested_paren_count++;\n\
    \      nested_paren_string += paren_string.charAt(i);\n    }else if(paren_string.charAt(i)\
    \ == ')'){\n      nested_paren_count--;\n      if(nested_paren_count <= 0){\n\
    \        var last_char = paren_string.charAt(i);\n        if(last_char == '('\
    \ || last_char == '[' || last_char == '{'){\n          nested_paren_string = nested_paren_string.slice(0,\
    \ -1);\n          return [nested_paren_count, nested_paren_string];\n        }\n\
    \      }\n      nested_paren_string += paren_string.charAt(i);\n    }\n  }\n}\n",
  "    var result = [], level = 0;\n    for(var i = 0; i < paren_string.length; i++){\n\
    \        var ch = paren_string[i];\n        switch(ch){\n            case '(':\
    \ case ')': level++;\n            break;\n            case ')': level--;\n   \
    \         break;\n        }\n        if(level > 0){\n            result.push(level);\n\
    \        }\n    }\n    return result.reverse();\n}\n", "    //Base case when no\
    \ parentheses are present in the string.\n    if(paren_string.trim() === \"\"\
    ){\n        return [];\n    }\n    var groups = [];\n    var stack = paren_string.trim().split(\"\
    )\");\n    var paren_count = 0;\n    for(var i = 0; i < stack.length; i++){\n\
    \        var current = stack[i];\n        if(current.trim() === \"\"){\n     \
    \       stack.pop();\n            paren_count--;\n        }else{\n           \
    \ paren_count++;\n        }\n        if(paren_count === 0){\n            //The\
    \ parentheses at the end of this string are at the end of a group of parentheses\n\
    \            groups.push(stack.length);\n            stack = [];\n        }\n\
    \    }\n    return groups;\n}\n\n", "    var nested_paren_string = paren_string;\n\
    \    var levels = parse_nested_parens_levels(nested_paren_string);\n    return\
    \ levels;\n}\n", "    var level = 0;\n    var max_level = 0;\n    var nested_count\
    \ = 0;\n    var current_pos = 0;\n    var results = [];\n    var result_index\
    \ = 0;\n    while(true){\n        // Iterate through the nested parentheses groups\
    \ one by one\n        var num_left_bracket = paren_string.indexOf(paren_opening_pairs[level],\
    \ current_pos);\n        if(num_left_bracket > -1){\n            // Find the closing\
    \ bracket position\n            var num_right_bracket = paren_string.indexOf(paren_opening_pairs[level],\
    \ current_pos+1);\n            \n            if(num_right_bracket == -1){\n  \
    \              // The closing bracket is at the end of the parentheses group\n\
    \                results.push(level);\n                current_pos += level;\n\
    \                \n                if(level < max_level){\n                  \
    \  current_pos += level;\n                    level++;\n                    max_level\
    \ = level;\n                }\n            }\n            else{\n            \
    \    // The closing bracket is somewhere in the parentheses group\n          \
    \      results.push(level);\n                current_pos += level+1;\n       \
    \         \n                // Increase the level of nesting and find out if the\
    \ current group is going to be nested more levels\n                max_level =\
    \ level;\n            }\n            \n            nested_count++;\n        }\n\
    \        else{\n            // The parentheses group has ended\n            results.push(level);\n\
    \            current_pos += level;\n            \n            // Increase the\
    \ level of nesting and find out if the current group is going to be nested more\
    \ levels\n            max_level = level;\n        }\n        if(max_level == 0){\n\
    \            break;\n        }\n        \n        // The parentheses group is\
    \ still opening\n        if(level > 0){\n            level--;\n        }\n   \
    \ }\n    \n    return results;\n}\n", "    if(paren_string.trim().length == 0){\n\
    \        return [paren_string.length];\n    }\n\n    var nested_parens = [];\n\
    \    var groups = paren_string.trim().split(/[\\s(]+/);\n    var max_group_index\
    \ = 0;\n\n    for (var group_index = 0; group_index < groups.length; group_index++)\
    \ {\n        var group_string = groups[group_index];\n        var group_string_reverse\
    \ = group_string.split(\"\").reverse().join(\"\");\n\n        // Find the deepest\
    \ paren level of this group\n        for (var paren_index = 0; paren_index < group_string.length\
    \ - 1; paren_index++){\n            if (group_string_reverse[paren_index] == group_string_reverse[paren_index\
    \ + 1]){\n                nested_parens.push(paren_index);\n                max_group_index\
    \ = group_index;\n                break;\n            }\n        }\n    }\n\n\
    \    return [max_group_index + 1, nested_parens];\n}\n", "    var group_level\
    \ = [];\n    var current_level = 0;\n    var group_strings = paren_string.split(\"\
    \ \");\n    var current_string_index = 0;\n    var next_string_index = 1;\n  \
    \  while (next_string_index < group_strings.length) {\n        var next_string\
    \ = group_strings[next_string_index];\n        if (next_string == \"(\") {\n \
    \           group_level.push(current_level);\n            current_level = current_level\
    \ + 1;\n        } else {\n            var next_level = group_level[group_level.length-1];\n\
    \            if (next_level == current_level) {\n                next_level =\
    \ current_level;\n            }\n            group_level.push(next_level);\n \
    \           current_level = next_level;\n        }\n        next_string_index\
    \ = next_string_index + 1;\n    }\n    return group_level;\n}\n", "\tvar nested_depths\
    \ = new Array();\n\tvar nesting_depth = 0;\n\tvar paren_depth = 0;\n\tvar num_paren\
    \ = 0;\n\tvar paren_start = 0;\n\tvar paren_end = 0;\n\t\n\tfor(var i = 0; i <\
    \ paren_string.length; i++){\n\t\t\n\t\tif(paren_string[i] === '(')\n\t\t\tparen_depth++;\n\
    \t\telse if(paren_string[i] === ')')\n\t\t\tparen_depth--;\n\t\telse if(paren_depth\
    \ < 0)\n\t\t\tparen_depth = -1;\n\t\t\t\n\t\tif(paren_depth === -1){\n\t\t\tif(paren_start\
    \ === i){\n\t\t\t\tnested_depths[num_paren] = paren_depth;\n\t\t\t\tnum_paren++;\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\tif(paren_depth === 0 && paren_start !== i && paren_end\
    \ !== i){\n\t\t\t\n\t\t\tvar depth = nested_depths.length;\n\t\t\tif(paren_start\
    \ === i){\n\t\t\t\tnested_depths[num_paren] = depth;\n\t\t\t\tnum_paren++;\n\t\
    \t\t}\n\t\t\telse{\n\t\t\t\tnested_depths[num_paren] = nested_depths[num_paren\
    \ - 1];\n\t\t\t\tnum_paren--;\n\t\t\t}\n\t\t\t\n\t\t\tparen_end = i;\n\t\t}\n\t\
    }\n\t\n\treturn nested_depths;\n}\n", "  var depth = 0;\n  for (var i = 0; i <\
    \ paren_string.length; i++) {\n    depth = paren_string.charAt(i) == '(' ? depth\
    \ + 1 : depth - 1;\n  }\n  return depth;\n}\n</code>\n<|/ a tags=parentheses,javascript,recursion\
    \ dscore=0 |>\n<| a tags=parentheses,javascript,recursion |>\nThis is a simple\
    \ solution without any extra functions or libraries.\n<code>", "  let stack=[];\n\
    \  let res = [];\n  for (let i=0; i<paren_string.length; i++){\n    if (paren_string[i]\
    \ == '('){\n      stack.push(paren_string[i])\n    }\n    if (paren_string[i]\
    \ == ')'){\n      while(stack.length && paren_string[stack.length-1] != ')'){\n\
    \        res.push(stack.pop())\n      }\n    }\n  }\n  return res;\n}\n", "  \
    \  let parens_array = paren_string.split(\" \");\n    let nesting_depth = 0;\n\
    \    let parens_string = \"\";\n    for(let i = 0; i < parens_array.length; i++){\n\
    \        if(parens_array[i] == \"(\"){\n            parens_string += \")\";\n\
    \            nesting_depth++;\n        }\n        else if(parens_array[i] == \"\
    )\"){\n            parens_string += \"(\";\n            nesting_depth--;\n   \
    \     }\n    }\n    return nesting_depth;\n}\n", "\tlet depth = 0;\n\tconst parens\
    \ = new Array();\n\tparen_string.split(\" \").forEach(function(element){\n\t\t\
    if(element.length == 0)\n\t\t\treturn;\n\t\tif(element[0] == '('){\n\t\t\tif(depth\
    \ > 0)\n\t\t\t\tdepth++;\n\t\t\telse\n\t\t\t\tparens.push(depth);\n\t\t}\n\t\t\
    if(element[element.length - 1] == ')'){\n\t\t\tif(parens[parens.length - 1] ==\
    \ depth){\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t}\n\t});\n\treturn parens;\n}\n", " \
    \ var nested_parens = []\n  var i = 0\n  var prev_char_code\n  while (i < paren_string.length){\n\
    \    var char = paren_string.charAt(i)\n    var is_last_char = (i == paren_string.length\
    \ - 1)\n    if (char == '(' || char == ')' || char == '{' || char == '}' || char\
    \ == '[' || char == ']'){\n      if (is_last_char){\n        return nested_parens\n\
    \      }\n      nested_parens.push(char)\n    } else if (char == ' ' && is_last_char){\n\
    \      i++\n    }\n    i++\n  }\n  return nested_parens\n}\n", "    paren_string\
    \ = paren_string.replace(/\\s+/g, '');\n    const nested_parens_groups = paren_string.match(/[()\\\
    s]+/g);\n    return nested_parens_groups.map(x => paren_string.match(x) || [''])\n\
    \        .map(x => x.map(y => y.match(/[()]/g)))\n        .map(x => x.map(y =>\
    \ y[0] + y[1].length))\n        .reduce((acc, cur) => Math.max(acc, cur), 0);\n\
    }\n", "  var nested_depth = 0;\n  var paren_depths = [];\n  var paren_group_count\
    \ = 0;\n  var paren_groups = [];\n  for(var i = 0; i < paren_string.length; i++)\
    \ {\n    var c = paren_string.charAt(i);\n    if(c === \"(\") {\n      nested_depth++;\n\
    \      if(paren_depths[paren_depths.length-1] < nested_depth) paren_depths[paren_depths.length-1]\
    \ = nested_depth;\n      paren_groups[paren_group_count++] = i;\n    } else if(c\
    \ === \")\") {\n      nested_depth--;\n      if(nested_depth < 0) throw Error(\"\
    Not sure how to handle this string of parentheses\");\n      if(paren_depths[paren_depths.length-1]\
    \ > nested_depth) paren_depths[paren_depths.length-1] = nested_depth;\n      if(paren_depths[paren_depths.length-1]\
    \ === 0) paren_group_count--;\n    } else if(c === \" \") {\n      if(nested_depth\
    \ === 0) {\n        paren_group_count--;\n        if(paren_group_count < 0) throw\
    \ Error(\"Too many spaces found before a closing paren \")\");\n      } else if(nested_depth\
    \ === paren_depths[paren_depths.length-1]) {\n        paren_depths.pop();\n  \
    \      paren_group_count--;\n        if(paren_group_count < 0) throw Error(\"\
    Too many spaces found after a closing paren \")\");\n      }\n    } else {\n \
    \     if(nested_depth === 0) {\n        paren_group_count--;\n        if(paren_group_count\
    \ < 0) throw Error(\"Found an unexpected character: \" + c);\n      }\n    }\n\
    \  }\n  if(paren_depths.length > 0) throw Error(\"Too many closing parens \")\"\
    );\n  return paren_depths;\n}\n", "    let level = 0;\n    \n    let levels_nested\
    \ = [];\n    for(let i = 0; i < paren_string.length; i++){\n        if(paren_string[i]\
    \ === '('){\n            level++;\n            levels_nested[level] = level;\n\
    \        }\n        else if(paren_string[i] === ')'){\n            level--;\n\
    \            levels_nested[level] = level;\n        }\n    }\n    \n    return\
    \ levels_nested.slice(0, level+1);\n}\n", "\tparen_string = paren_string.replace(/\\\
    (/g, ' ( ').replace(/\\)/g, ' ) ').trim();\n\tvar level = 0;\n\tvar index = 0;\n\
    \tvar parens = [];\n\n\twhile(paren_string[index]){\n\t\tif(paren_string[index]\
    \ == '('){\n\t\t\tparens.push(level);\n\t\t\tlevel += 1;\n\t\t}\n\t\telse if(paren_string[index]\
    \ == ')'){\n\t\t\tif(parens.length > 0){\n\t\t\t\tlevel -= parens.pop();\n\t\t\
    \t\tindex++;\n\t\t\t}\n\t\t}\n\t\tindex++;\n\t}\n\treturn level;\n}\n", "\tvar\
    \ nested_paren_count = 0;\n\tvar nested_parens = [];\n\tvar input_stack = [];\n\
    \tvar input_string = paren_string;\n\tinput_string = input_string.replace(/[\\\
    (\\)]/g,\"\"); //Remove all open and close parens.\n\tinput_string = input_string.replace(/^\\\
    s*$/g,\"\"); //Remove all leading spaces.\n\t\n\twhile(!input_stack.length){\n\
    \t\tvar i = input_string.search(/\\(/);\n\t\tif(i >= 0){\n\t\t\tinput_stack.push(i);\n\
    \t\t}\n\t}\n\n\tinput_string = input_string.slice(input_stack.pop(),input_string.length);\n\
    \t\n\twhile(!input_stack.length){\n\t\tvar i = input_string.search(/\\)/);\n\t\
    \tif(i >= 0){\n\t\t\tinput_stack.push(i);\n\t\t}\n\t}\n\n\twhile(!input_stack.length){\n\
    \t\tvar i = input_string.search(/\\)/);\n\t\tif(i >= 0){\n\t\t\tinput_stack.push(i);\n\
    \t\t}\n\t}\n\n\tinput_string = input_string.slice(input_stack.pop(),input_string.length);\n\
    \n\twhile(!input_stack.length){\n\t\tvar i = input_string.search(/\\(/);\n\t\t\
    if(i >= 0){\n\t\t\tinput_stack.push(i);\n\t\t}\n\t}\n\n\tinput_string = input_string.slice(input_stack.pop(),input_string.length);\n\
    \n\twhile(input_string.length){\n\t\tvar i = input_string.search(/\\)/);\n\t\t\
    if(i >= 0){\n\t\t\tinput_stack.push(i);\n\t\t}\n\t\t\n\t\tvar j = input_string.search(/\\\
    (/);\n\t\tif(j < 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tnested_paren_count++;\n\t\
    \t\n\t\tvar new_paren_string = input_string.slice(input_string.length-j,input_string.length);\n\
    \t\tnested_parens.push(new_paren_string);\n\t\tinput_string = new_paren_string;\n\
    \t}\n\t\n\treturn nested_paren_count;\n}\n", "    return paren_string.split(\"\
    \ \").map(function(paren_string){\n        var opening_paran_count = paren_string.match(/[\\\
    (\\{]/).length;\n        var closing_paran_count = paren_string.match(/[\\)\\\
    }]/).length;\n        return Math.max(opening_paran_count, closing_paran_count);\n\
    \    });\n}\n\n", "\t// Remove extra whitespace and parentheses.\n\tparen_string\
    \ = paren_string.replace(/\\s+/g, \"\");\n\tparen_string = paren_string.replace(/(\\\
    ([^()]*\\))/g, \"$1\");\n\t// Split the string into multiple groups based on white\
    \ spaces.\n\tvar group_counts = paren_string.match(/\\S+/g);\n\t// Find the deepest\
    \ level of nesting.\n\tvar max_group_count = Math.max.apply(null, group_counts);\n\
    \treturn max_group_count;\n}\n\n", "\tvar stack = []; //Stack used for storing\
    \ depth of each parenthesis.\n\tfor(var i = 0; i <paren_string.length; i++){\n\
    \t\tvar c = paren_string.charAt(i);\n\t\tif(c == \"(\"){\n\t\t\tstack.push(0);\n\
    \t\t}\n\t\telse if(c == \")\"){\n\t\t\tvar opening_brace = stack.pop();\n\t\t\t\
    if(opening_brace === undefined){\n\t\t\t\tconsole.log(\"error parsing the string,\
    \ unexpected \")\");\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\tif(opening_brace){\n\t\
    \t\t\tstack.push(opening_brace);\n\t\t\t}\n\t\t}\n\t}\n\treturn stack;\n}\n",
  "    var paren_string = paren_string.replace(/\\(|\\)/g, \"\").trim();\n    paren_string\
    \ = paren_string.replace(/\\s+/g, \" \");\n    var paren_string = paren_string.split(\"\
    \ \");\n    var paren_levels = [];\n    for (var p = 0; p < paren_string.length;\
    \ p++){\n        if (paren_string[p].length == 0){\n            continue;\n  \
    \      }\n        var level_of_nesting = 0;\n        for (var s = 0; s < paren_string[p].length-1;\
    \ s++){\n            if (paren_string[p][s].match(/[a-zA-Z0-9]/)){\n         \
    \       level_of_nesting++;\n            }\n            else if (paren_string[p][s].match(/\\\
    s/)){\n                level_of_nesting--;\n            }\n        }\n       \
    \ paren_levels.push([paren_string[p][s], level_of_nesting]);\n    }\n    var max_level\
    \ = -1;\n    var max_level_of_nesting = 0;\n    for (var p = 0; p < paren_levels.length;\
    \ p++){\n        if (paren_levels[p][1] > max_level_of_nesting){\n           \
    \ max_level = paren_levels[p][0];\n            max_level_of_nesting = paren_levels[p][1];\n\
    \        }\n    }\n    return paren_levels[max_level];\n}\n", "    var max_level\
    \ = 0;\n    var paren_depth_array = [];\n    var paren_level = 0;\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string[i] === \")\"\
    ){\n            if(paren_depth_array[paren_level - 1] > max_level){\n        \
    \        max_level = paren_depth_array[paren_level - 1];\n            }\n    \
    \    }\n        else if(paren_string[i] === \"(\"){\n            paren_level++;\n\
    \            paren_depth_array[paren_level] = paren_depth_array.length; //Initialize\
    \ to zero\n        }\n        else if(paren_string[i] === \")\"){\n          \
    \  paren_level--;\n            if(paren_depth_array[paren_level] === 0){\n   \
    \             paren_depth_array.splice(paren_level, 1); //Remove all elements\
    \ of the array before this element\n            }\n        }\n    }\n    return\
    \ max_level;\n}\n", "    var paren_string = paren_string.toString();\n    if(paren_string.length\
    \ <= 1) return [];\n    var nested_parens = [];\n    var current_paren = 0;\n\
    \    var depth = 0;\n    var current_bracket = 0;\n    for(var i = 0, len = paren_string.length;\
    \ i < len; i++){\n        var p = paren_string[i];\n        var c = paren_string[i];\n\
    \        if(current_paren != c){\n            current_paren = c;\n           \
    \ depth = 1;\n            nested_parens.push(depth);\n        }else{\n       \
    \     depth += 1;\n        }\n        if(current_bracket != p){\n            current_bracket\
    \ = p;\n        }\n    }\n    nested_parens.reverse();\n    return nested_parens;\n\
    }\n", "  var maxdepth = -1;\n  var result = [];\n  for(var i = 0; i < paren_string.length;\
    \ i++){\n    var c = paren_string[i];\n    if(c === '(' || c === '{'){\n     \
    \ if(maxdepth === -1) maxdepth = i;\n    }else if(c === ')' || c === '}'){\n \
    \     if(maxdepth >= 0 && result.length > 0 && result[result.length - 1] === maxdepth){\n\
    \        result.pop();\n      }else{\n        result.push(maxdepth);\n      }\n\
    \    }\n  }\n  return result;\n}\n", "    var level = 0;\n    var max_level =\
    \ 0;\n    var max_level_count = 0;\n    var result = [];\n    var par;\n    for(var\
    \ i = 0; i< paren_string.length; i++){\n        par = paren_string[i];\n     \
    \   switch(par){\n            case '(':\n                level++;\n          \
    \      if(level > max_level){\n                    max_level = level;\n      \
    \              max_level_count = 0;\n                }\n                break;\n\
    \            case ')':\n                level--;\n                if(level > max_level){\n\
    \                    max_level = level;\n                    max_level_count =\
    \ 0;\n                }\n                break;\n            default:\n      \
    \          if(level == 0){\n                    max_level_count++;\n         \
    \       }\n                break;\n        }\n        result.push(level);\n  \
    \  }\n    if(max_level > 0){\n        result.push(max_level);\n    }\n    return\
    \ result;\n}\n", "\tlet groups = paren_string.trim().split(\"\\\\s+\");\n\tlet\
    \ results = [];\n\tfor(let g of groups){\n\t\tlet level = 0;\n\t\tlet gs = g.split(\"\
    (\");\n\t\tfor(let gs of gs){\n\t\t\tlet pos = gs.indexOf(\")\");\n\t\t\tif(pos>0){\n\
    \t\t\t\tlevel += parseInt(gs.slice(0, pos));\n\t\t\t}\n\t\t}\n\t\tresults.push(level);\n\
    \t}\n\treturn results;\n}\n\n", "    var nested_level_count = paren_string.match(/\\\
    (/g).length;\n    var max_level = Math.max(...paren_string.match(/)/g).map(function(i){return\
    \ paren_string.match(i).length});\n    return [max_level, nested_level_count];\n\
    }\n", "    var num_open_brackets = 0, num_closed_brackets = 0, cur_level = 0;\n\
    \    var nested_parens = [];\n    for(var i=0; i< paren_string.length; i++){\n\
    \        var p = paren_string[i];\n        switch(p){\n            case ')': num_closed_brackets++;\
    \ break;\n            case '(': num_open_brackets++; break;\n            case\
    \ ' ': break;\n            default: break;\n        }\n        if(num_open_brackets\
    \ > num_closed_brackets) nested_parens.push(cur_level);\n        if(p==')') num_closed_brackets--;\n\
    \        if(p=='(') num_open_brackets--;\n    }\n    return nested_parens;\n}\n",
  "  //Create an array to store number of levels of nesting.\n  var levels_nest_count\
    \ = [];\n  //Create an array to store total number levels of nesting.\n  var levels_nest_sum\
    \ = 0;\n  //Iterate over all the groups of parenthesis.\n  paren_string.split('\
    \ ').forEach(function(item){\n    //Check if this item is parentheses.\n    if(item.includes('(')){\n\
    \      //Find the number of levels of nesting.\n      var current_level = paren_string.indexOf(item);\n\
    \      levels_nest_count[current_level] = levels_nest_count[current_level] + 1;\n\
    \      //Find the total levels of nesting.\n      levels_nest_sum = levels_nest_sum\
    \ + levels_nest_count[current_level];\n    }\n  });\n  //Return the result of\
    \ this function.\n  return levels_nest_sum;\n}\n", "    let paren_groups = paren_string.match(/(\\\
    ((?>[^()]+|(?1))*\\))/g);\n    let nested_level = Math.max(...paren_groups.map(a\
    \ => paren_groups.length - a.split(\" \").length));\n    return nested_level;\n\
    }\n</code>\n<|/ a tags=javascript,regex,nested,recursion |>\n<| c |>\nThis is\
    \ exactly what I was looking for, thank you! Just a small typo, it should be `a.split(\"\
    \ \").length-1`.\n<|/ c |>\n<| a |>\n<code>\nlet str = \"()()(()())()\";\nlet\
    \ matcher = new RegExp(/(?:\\(\\))*(((?:\\(\\()|(?:\\(\\))?)(?:\\(\\))*|$))/g);\n\
    let m;\nwhile (m = matcher.exec(str)) {\n    if (m.index > 0) {\n        console.log(m.index\
    \ + \": \" + m[0]);\n    }\n}\n</code>\nThis code snippet uses regular expression\
    \ recursion to parse a parenthesis string. You can also test it on regex101.com.\n\
    <|/ a dscore=2 tags=javascript,regex,nested,recursion |>\n<| a dscore=2 |>\nThis\
    \ is not going to be a great answer on SO, but since it's a popular question,\
    \ I wanted to try and keep it short and sweet.\nI believe there is a simple solution\
    \ that will also take care of cases like \"((()))\" or \"(()()(()))\" where only\
    \ one of the groups is empty. I used a recursive function to determine if a single\
    \ group was empty and added a flag to denote when it is empty and when not. I\
    \ believe this is how most regex parsing is handled.\n<code>", "    //Use regex\
    \ to parse the input string.\n    // Get all parenthesis and put them into parens\
    \ array.\n    var parens = paren_string.match(/[\\(\\)]+/g);\n    var max_level\
    \ = 0;\n\n    // Iterate over all parens and check deepest level.\n    for(var\
    \ i=0; i<parens.length; i++){\n        if(parens[i] === \"\") continue;\n    \
    \    max_level = max(max_level, paren_depth(parens[i]));\n    }\n    return max_level;\n\
    }\n", "  var max_level = 1;\n  var paren_stack = [];\n  for(var i=0;i<paren_string.length;i++){\n\
    \    var char = paren_string[i];\n    if(char === '('){\n      paren_stack.push(1);\n\
    \    }\n    else if(char === ')'){\n      paren_stack.pop();\n    }\n    else\
    \ if(paren_stack.length === 0){\n      max_level = max(max_level, paren_stack);\n\
    \    }\n  }\n  return max_level;\n}\n", "    var nested_count=0; //This variable\
    \ will hold the count of nested parentheses inside paren_string\n    var max_depth=0;\
    \ //This variable will hold the max level of nesting inside paren_string\n   \
    \ var current_depth=0; //This variable will hold the current level of nesting\
    \ inside paren_string\n    var current_nested=0; //This variable will hold the\
    \ index of nested parentheses inside paren_string\n    for (var i=0; i<paren_string.length;\
    \ i++){\n        var ch = paren_string.charAt(i);\n        if (ch==')'){\n   \
    \         nested_count--;\n        }\n        if (ch=='('){\n            nested_count++;\n\
    \        }\n        if (nested_count>0){\n            //Found a matching parentheses\
    \ inside the paren_string\n            //Get the max level of nesting inside the\
    \ paren_string\n            if (current_depth<max_depth){\n                max_depth=current_depth;\n\
    \            }\n            current_depth=nested_count;\n            current_nested=i;\n\
    \        }\n    }\n    return max_depth;\n}\n", "  var max_level = 0;\n  var nested_level\
    \ = 0;\n  var groups = [];\n  var current_group = [];\n  var paren_match;\n  \n\
    \  // Loop through the groups and find out how many levels of parens exist in\
    \ this string\n  while(paren_string.match(/\\((?!\\)))/g)){\n    current_group.push(paren_string.match(/\\\
    ((?!\\))/g)[0]);\n    groups.push(current_group);\n    paren_match = paren_string.match(/\\\
    ((?!\\))/g)[0];\n    current_group = [paren_match];\n    max_level = maxLevel(current_group,\
    \ paren_match);\n    \n    if (max_level > nested_level){\n      nested_level\
    \ = max_level;\n    }\n  }\n  return groups;\n}\n", "\tlet paren_count = 0;\n\t\
    let output = [];\n\tfor (let i = 0; i < paren_string.length; i++){\n\t\tif (paren_string[i]\
    \ === \"(\"){\n\t\t\tparen_count++;\n\t\t}\n\t\telse if (paren_string[i] === \"\
    )\"){\n\t\t\tparen_count--;\n\t\t}\n\t\tif (paren_count === 0){\n\t\t\toutput.push(paren_count);\n\
    \t\t}\n\t}\n\treturn output;\n}\n", "  let paren_level = 0;\n  let nested_parens\
    \ = [];\n  paren_string.split(' ')\n    .map((paren) => {\n      paren = paren.trim();\n\
    \      if (!paren) return null; // don't output a null paren\n      if (paren[0]\
    \ === '(') paren_level += 1; // open paren\n      else if (paren[0] === '(') paren_level\
    \ -= 1;\n      else if (paren[0] === ')') paren_level += 1; // close paren\n \
    \     else if (paren[0] === ')') paren_level -= 1;\n\n      if (paren_level >\
    \ 0 && paren.length) nested_parens.push(paren_level);\n      return paren\n  \
    \  })\n    .filter(Boolean);\n  return nested_parens\n}", "  var nested_paren_groups\
    \ = [];\n  var paren_level = 0;\n  var paren_open_count = 0;\n  for(var i=0; i<paren_string.length;\
    \ i++){\n    if(paren_string[i]==\"(\" || paren_string[i]==\"[\" || paren_string[i]==\"\
    {\"){\n      paren_level++;\n      if(paren_open_count < paren_level){\n     \
    \   nested_paren_groups.push(paren_level);\n        paren_open_count = paren_level;\n\
    \      }\n    } else if(paren_string[i]==\")\" || paren_string[i]==\"]\" || paren_string[i]==\"\
    }\"){\n      paren_level--;\n      if(paren_level==0){\n        paren_open_count--;\n\
    \      }\n    }\n  }\n  if(paren_level > 0){\n    nested_paren_groups.push(paren_level);\n\
    \  }\n  return nested_paren_groups;\n}\n", "  // Get groups of the string by splitting\
    \ on spaces.\n  // We add an extra group at the end to capture the remaining part\
    \ of the string.\n  var groups = paren_string.split(\" \");\n  // To keep the\
    \ return value consistent with how we treat parentheses around expressions,\n\
    \  // we store the number of open parentheses (including those that are escaped\
    \ by \\).\n  // When we encounter a ) we decrement the number of open parentheses\
    \ by 1.\n  // After we encounter a ), we increment the number of open parentheses\
    \ by 1.\n  var number_of_open_parentheses = groups.join(\" \").match(/([^\\\\\
    ()]|[^()\\\\])+\\)/gi);\n  // We decrement the number of open parentheses after\
    \ we encounter a closing parentheses.\n  number_of_open_parentheses = number_of_open_parentheses\
    \ ? number_of_open_parentheses.length : 0;\n  // Iterate through each group and\
    \ count the level of nesting of parentheses.\n  // We are also storing the depth\
    \ of the deepest level of nesting encountered.\n  var max_nesting_depth = 0;\n\
    \  var current_nesting_depth = 0;\n  for(var i = 0; i < groups.length; i++){\n\
    \    var group = groups[i];\n    var group_depth = number_of_open_parentheses.exec(group);\n\
    \    if(group_depth){\n      current_nesting_depth = parseInt(group_depth[0].length);\n\
    \      // If the current depth doesn't match the deepest level encountered, then\
    \ we have a nested parentheses problem.\n      if(current_nesting_depth > max_nesting_depth){\n\
    \        max_nesting_depth = current_nesting_depth;\n      }\n    }else{\n   \
    \   current_nesting_depth++;\n    }\n  }\n  return max_nesting_depth;\n}\n", " \
    \   let max_count = []; //This array stores the maximum number of parentheses\
    \ in a level.\n    let paren_count = 0; //The index of the last paren count recorded.\n\
    \    let nested_count = 0; //The deepest level of nesting.\n    for (let i = 0;\
    \ i < paren_string.length; i++){\n        let ch = paren_string[i]; //The character\
    \ at this position.\n        if (ch == '(' || ch == '{' || ch == '['){\n     \
    \       paren_count++;\n            if (max_count.length < paren_count){\n   \
    \             max_count = [paren_count];\n            }\n        }else if (ch\
    \ == ')' || ch == '}' || ch == ']'){\n            paren_count--;\n           \
    \ nested_count++;\n            if (nested_count > max_count[paren_count]){\n \
    \               max_count[paren_count] = nested_count;\n            }\n      \
    \  }\n    }\n    return max_count\n}", "  let paren_string = paren_string.replace(/\\\
    s+/g, \"\");\n  let levels = [];\n  paren_string = paren_string.split(\"\");\n\
    \  while(paren_string.length){\n    levels.push(paren_string.length);\n    let\
    \ current_paren_string = paren_string[0];\n    paren_string.splice(0, 1);\n  \
    \  let current_paren_level = levels[levels.length-1];\n    while(current_paren_string.length\
    \ && current_paren_level > 0){\n      current_paren_level--;\n      current_paren_string\
    \ = current_paren_string.substr(0, current_paren_string.length - 1);\n    }\n\
    \  }\n  return levels;\n}", "    var levels = new Array();\n    var last_level\
    \ = 0;\n    var max_level = 0;\n    var groups = new Array();\n    for(var i=0;\
    \ i< paren_string.length; i++){\n        var c = paren_string.charAt(i);\n   \
    \     if(last_level==0 && c==\"(\") levels.push(0);\n        if(last_level==0\
    \ && c==\")\") levels.push(0);\n        if(c==\" \" && levels.length==0){\n  \
    \          levels.push(1);\n        }\n        else{\n            if(last_level\
    \ < levels.length){\n                levels[last_level]++;\n            }\n  \
    \          else{\n                levels.push(1);\n            }\n        }\n\
    \        last_level = levels.length - 1;\n        if(levels[levels.length-1] >\
    \ max_level){\n            max_level = levels[levels.length-1];\n        }\n \
    \   }\n    return max_level;\n}", "    var levels = [];\n    var depth = 0;\n\
    \    var parens = paren_string.split(\" \");\n    for(var i = 0; i < parens.length;\
    \ ++i){\n        if(parens[i][0] == \"(\"){\n            ++depth;\n        }else\
    \ if(parens[i][0] == \")\"){\n            --depth;\n        }\n        if(depth\
    \ <= 0){\n            levels.push(depth);\n        }\n    }\n    return levels.length\
    \ + 1;\n}\n", "    var parens_level = 0;\n    var parens_depth = 0;\n    var parens\
    \ = [];\n    for(var i=0; i<paren_string.length; i++){\n        var current_char\
    \ = paren_string[i];\n        if(current_char == \"(\"){\n            if(parens_level\
    \ == 0){\n                parens_level++;\n                parens_depth++;\n \
    \           }else{\n                parens_level--;\n            }\n         \
    \   if(parens_level > parens_depth){\n                parens_depth = parens_level;\n\
    \            }\n            parens.push(parens_level);\n        }\n    }\n   \
    \ return parens;\n}\n\n", "  var nested_parentheses = new Array();\n  var groups\
    \ = paren_string.split(\" \");\n  for(var i = 0; i < groups.length; i++){\n  \
    \  nested_parentheses.push(0);\n  }\n  for(var i = 0; i < groups.length; i++){\n\
    \    var group = groups[i];\n    for(j = 0; j < group.length; j++){\n      if(group[j]\
    \ === \"(\"){\n        nested_parentheses[groups.length - 1]++;\n      }\n   \
    \   else if(group[j] === \")\"){\n        nested_parentheses[groups.length - 1]--;\n\
    \      }\n    }\n  }\n  return nested_parentheses;\n}\n", "    var nested_parens\
    \ = []\n    var depth = 0;\n    var pos = 0;\n    var open_brackets = 0;\n   \
    \ var close_brackets = 0;\n\n    var open_parens = paren_string.match(/\\(/g);\n\
    \    var close_parens = paren_string.match(/\\)/g);\n\n    for(pos; pos < paren_string.length;\
    \ pos++){\n        var ch = paren_string[pos];\n\n        //Skip all characters\
    \ in parens if they are in the open_brackets count.\n        if(open_brackets\
    \ && open_brackets == ch){\n            open_brackets++;\n        }\n\n      \
    \  //If there is no opening or closing parens then output the current depth.\n\
    \        //Else, increment the depth.\n        if(open_brackets && close_brackets\
    \ && close_brackets == ch){\n            depth++;\n        }\n        else if(open_brackets\
    \ && close_parens && close_parens == ch){\n            depth--;\n        }\n\n\
    \        //If the depth is zero then output the current depth and start over with\
    \ a new one.\n        if(depth == 0){\n            nested_parens.push(depth);\n\
    \            depth = 0;\n        }\n\n        //Add the char to open_brackets\
    \ count if its an opening parens\n        if(ch == \"(\"){\n            open_brackets++;\n\
    \        }\n\n        //Add 1 to close_brackets count if the closing parens was\
    \ found\n        if(ch == \")\"){\n            close_brackets++;\n        }\n\
    \    }\n\n    return nested_parens;\n}\n", "    var groups = [];\n    for(var\
    \ i = 0; i < paren_string.length; i++){\n        if(paren_string.charAt(i) ===\
    \ \"(\"){\n            var open_groups = groups.length;\n            groups.push(0);\n\
    \        }\n        else if(paren_string.charAt(i) === \")\"){\n            var\
    \ open_groups = groups.length - 1;\n            if(open_groups > 0){\n       \
    \         groups[open_groups] = groups[open_groups] + 1;\n            }\n    \
    \    }\n    }\n    return groups;\n}\n", "    var levels = paren_string.match(/\\\
    (\\((.*)\\)\\)/g);\n    var max_level = levels.length;\n    var levels_depth =\
    \ [];\n\n    for (var i = 0, len = levels.length; i < len; i++){\n        var\
    \ level_content = levels[i].match(/\\((.*)\\)/g)[0];\n        var level_strings\
    \ = level_content.split(\" \");\n        var level_count = 1;\n\n        while(level_count\
    \ < max_level){\n            if(level_strings.indexOf(level_strings[level_count])\
    \ == -1){\n                break;\n            }else{\n                level_count++;\n\
    \            }\n        }\n\n        levels_depth.push(level_count);\n    }\n\
    \    return levels_depth;\n}\n", "\tconst paren_depth_map = {};\n\tparen_string\
    \ = paren_string.split(' ');\n\t\n\tfor(let paren_string of paren_string){\n\t\
    \tif(paren_string[0] == '('){\n\t\t\tparen_depth_map[paren_string] = paren_depth_map[paren_string]\
    \ || 0;\n\t\t\tparen_depth_map[paren_string]++;\n\t\t}\n\t\telse if(paren_string[paren_string.length-1]\
    \ == '('){\n\t\t\tparen_depth_map[paren_string] = paren_depth_map[paren_string]\
    \ || 0;\n\t\t\tparen_depth_map[paren_string]--;\n\t\t}\n\t}\n\t\n\tlet max_depth\
    \ = 0;\n\tlet result_depth = [];\n\t\n\tfor(let paren_string of paren_string){\n\
    \t\tfor(let paren_depth of paren_depth_map[paren_string]){\n\t\t\tresult_depth.push(paren_depth);\n\
    \t\t}\n\t\t\n\t\tmax_depth = Math.max(max_depth, result_depth.length);\n\t\tresult_depth\
    \ = [];\n\t}\n\t\n\treturn max_depth;\n}\n", "    var level = 0;\n    var levels\
    \ = [];\n    var levels_stack = [];\n    for (var i=0; i<paren_string.length;\
    \ i++) {\n        var c = paren_string[i];\n        if (c == '(') {\n        \
    \    levels.push(level);\n            level++;\n        }\n        else if (c\
    \ == ')') {\n            levels_stack.push(levels.pop());\n            level =\
    \ levels_stack[levels_stack.length-1];\n        }\n    }\n    return levels;\n\
    }\n", "  var level = 0\n  var output = []\n  var parens = []\n  var depth = 0\n\
    \  for(var i = 0; i < paren_string.length; i++){\n    var char = paren_string[i]\n\
    \    if (char == \"(\"){\n      parens.push(char)\n      depth += 1\n    } else\
    \ if (char == \")\"){\n      depth -= 1\n      if (parens.length === 0){\n   \
    \     if (depth === 0){\n          output.push(level);\n        }\n        level\
    \ += 1\n      }\n      parens.pop()\n    }\n  }\n  return output\n}\n", "    var\
    \ group_count = 0; //Keep track of group level\n    var max_level = 0;\n    var\
    \ level = 0;\n    var nesting_level = 0; //level of nested parentheses\n    var\
    \ paren_start = 0; //Index of start of a parentheses\n    var paren_end = 0; //Index\
    \ of end of a parentheses\n    var paren_level = 0; //Level of corresponding parentheses\n\
    \    var groups = []; //Keep track of parenthetical groups for recursive calls\n\
    \    \n    //Go through each character of parentheses\n    for(var i=0; i<paren_string.length;\
    \ i++){\n        //If it's a left parenthesis\n        if(paren_string[i]==\"\
    (\"){\n            //Increment group count\n            group_count++;\n     \
    \       //If group count exceeds maximum level\n            if(group_count > max_level){\n\
    \                max_level = group_count;\n            }\n            //If nested\
    \ level exceeds the maximum level\n            if(nesting_level > max_level){\n\
    \                nesting_level = max_level;\n            }\n            //Initialize\
    \ level to zero\n            level = 0;\n            //If the left parenthesis\
    \ is at a deeper level of nesting, increment level\n            if(nesting_level\
    \ == level){\n                level++;\n            }\n        }\n        else\
    \ if(paren_string[i]==\")\"){\n            //Decrement group count\n         \
    \   group_count--;\n        }\n    }\n    //Return array of parenthetical groups\n\
    \    return groups;\n}\n", "    var nested_depth = []; //stores the depth of nesting\n\
    \    var nested_paren_stack = []; //stores how many open and how many closes we've\
    \ encountered\n    \n    for(var paren_idx = 0; paren_idx < paren_string.length;\
    \ paren_idx++){\n        //The nested depth is calculated using the following\
    \ rule:\n        // If we encounter a left parenthesis, we increase our current\
    \ depth.\n        // If we encounter a right parenthesis, we decrease our current\
    \ depth.\n        // If our depth is 0 at this point, then we encounter a left\
    \ parenthesis.\n        // So, we decrease our current depth and also add the\
    \ number of open parentheses to the stack.\n        // If our depth is 0 at this\
    \ point, then we encounter a right parenthesis.\n        // So, we increase our\
    \ current depth and also add the number of open parentheses to the stack.\n  \
    \      if((paren_string[paren_idx] == \"(\") && (paren_stack[paren_idx] == 1)){\n\
    \            nested_depth.push(paren_idx);\n            paren_stack[paren_idx]\
    \ = 2;\n            nested_paren_stack.push(paren_stack[paren_idx]);\n       \
    \ } else if((paren_string[paren_idx] == \")\") && (paren_stack[paren_idx] == 2)){\n\
    \            nested_depth.pop();\n            paren_stack[paren_idx] = nested_paren_stack.pop();\n\
    \        }\n    }\n    return nested_depth;\n}\n", "\t// Split string into groups\n\
    \tlet levels_of_nesting = paren_string.split(\" \");\n\tlet max_level = levels_of_nesting.length\
    \ - 1;\n\t\n\treturn max_level;\n}\n\n", "    var nested_level = 0;\n    var paren_string_parts\
    \ = paren_string.split(\" \");\n    var parens_found = [];\n    for(var i = 0;\
    \ i < paren_string_parts.length; i++){\n        var paren_parts = paren_string_parts[i].split(\"\
    (\");\n        for(var j = 0; j < paren_parts.length; j++){\n            parens_found.push(paren_parts[j]);\n\
    \        }\n    }\n    var nested_parens_found = [];\n    for(var i = 0; i < parens_found.length;\
    \ i++){\n        for(var j = 0; j < parens_found.length; j++){\n            if((parens_found[j]\
    \ == parens_found[i]) && (parens_found[j] != \"\")){ //don't count the empty string\n\
    \                if(nested_parens_found.indexOf(parens_found[j]) < 0){\n     \
    \               nested_parens_found.push(parens_found[j]);\n                }\n\
    \            }\n        }\n    }\n    return nested_parens_found.length;\n}\n",
  "\tparen_string = paren_string.split(\" \");\n\tvar max_depth = 0;\n\tvar max_level_of_nesting\
    \ = 0;\n\tvar depth = 0;\n\tfor(var i = 0; i < paren_string.length; i++){\n\t\t\
    if(paren_string[i].charAt(0) == \"(\"){\n\t\t\tdepth++;\n\t\t}\n\t\tif(paren_string[i].charAt(0)\
    \ == \")\"){\n\t\t\tdepth--;\n\t\t\tif(depth <= 0){\n\t\t\t\tif(max_level_of_nesting\
    \ < depth){\n\t\t\t\t\tmax_level_of_nesting = depth;\n\t\t\t\t}\n\t\t\t\tif(max_depth\
    \ < depth){\n\t\t\t\t\tmax_depth = depth;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    return max_level_of_nesting;\n}\n", "\tvar stack = [];\n\tvar result = [];\n\t\
    for(var i=0; i<paren_string.length; i++){\n\t\tif(!paren_string.charAt(i).match(/[\\\
    (\\)]/g)){\n\t\t\tresult.push(paren_string[i]);\n\t\t}else{\n\t\t\tvar p = paren_string.charAt(i).match(/[\\\
    (\\)]/g)\n\t\t\tfor(var j=0; j<p.length; j++){\n\t\t\t\tif(stack.length == 0){\n\
    \t\t\t\t\tstack.push(p[j]);\n\t\t\t\t}else{\n\t\t\t\t\tif(stack.length>0){\n\t\
    \t\t\t\t\tstack.push(stack[stack.length-1]);\n\t\t\t\t\t}\n\t\t\t\t\tstack.push(p[j]);\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n", "  var paren_string =\
    \ paren_string.split(' ');\n  var max_nesting = 1;\n  var result = [];\n  for(var\
    \ i = 0; i < paren_string.length; i++){\n    var sub_paren_string = paren_string[i].split(')');\n\
    \    if(sub_paren_string.length !== 0){\n      if(sub_paren_string.length > max_nesting){\n\
    \        max_nesting = sub_paren_string.length;\n      }\n    }\n  }\n  for(var\
    \ i = 0; i < paren_string.length; i++){\n    var sub_paren_string = paren_string[i].split(')');\n\
    \    var current_nesting = sub_paren_string.length;\n    for(var j = 0; j < max_nesting\
    \ - current_nesting; j++){\n      result.push(j);\n    }\n  }\n  return result;\n\
    }\n\n", "  return paren_string.match(/[^()]/g).map(x => paren_string.indexOf(x)+1).sort().reverse()\n\
    }\n", "    var nested_levels = 0;\n    var nested_parans = paren_string.split(\"\
    \ \");\n    var number_of_paranses = nested_parans.length;\n    for(var i in nested_parans){\n\
    \        var current_parans = nested_parans[i];\n        if(current_parans ==\
    \ \"\"){\n            number_of_paranses--;\n        }else{\n            var index\
    \ = current_parans.search(/[^()]+/g);\n            if(index > -1){\n         \
    \       var inner_paranses = current_parans.substr(0,index).split(\"()\");\n \
    \               if(inner_paranses.length == 1){\n                    if(current_parans.charAt(index-1)\
    \ == '('){\n                        number_of_paranses--;\n                  \
    \  }\n                }\n            }\n        }\n        nested_levels++;\n\
    \    }\n    return number_of_paranses;\n}\n\n", "\tvar level = 0;\n\tvar paren_count\
    \ = 0;\n\tvar nesting = [];\n\tvar pos = 0;\n\tvar last_pos = 0;\n\tvar has_paren\
    \ = false;\n\tvar nested_string = \"\";\n\t\n\twhile(pos < paren_string.length){\n\
    \t\tvar char = paren_string[pos];\n\t\t\n\t\tswitch(char){\n\t\t\tcase \"(\":\n\
    \t\t\t\tif(last_pos == pos){\n\t\t\t\t\tnesting[nesting.length-1] += 1;\n\t\t\t\
    \t} else {\n\t\t\t\t\tnesting.push(1);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase\
    \ \"(\":\n\t\t\t\thas_paren = true;\n\t\t\t\tbreak;\n\t\t\tcase \")\":\n\t\t\t\
    \tif(nesting.length){\n\t\t\t\t\tif(nesting[0]){\n\t\t\t\t\t\tnesting[0] -= 1;\n\
    \t\t\t\t\t\tif(nesting[0] == 0){\n\t\t\t\t\t\t\tnesting.shift();\n\t\t\t\t\t\t\
    \tlevel += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"\
    Unbalanced parentheses\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \")\":\n\t\t\t\
    \tif(!nesting.length){\n\t\t\t\t\tthrow \"Unbalanced parentheses\";\n\t\t\t\t\
    }\n\t\t\t\thas_paren = false;\n\t\t\t\tbreak;\n\t\t\tcase \" \":\n\t\t\t\tif(!nesting.length){\n\
    \t\t\t\t\tthrow \"Unbalanced parentheses\";\n\t\t\t\t}\n\t\t\t\tnested_string\
    \ += char;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnested_string += char;\n\t\
    \t\t\tbreak;\n\t\t}\n\t\tpos += 1;\n\t\tlast_pos = pos;\n\t}\n\t\n\tif(has_paren){\n\
    \t\tthrow \"Unbalanced parentheses\";\n\t}\n\t\n\treturn [level, nesting];\n}\n",
  "\tlet nested_level = 0;\n\tlet parentheses_set = new Set();\n\tfor (let index =\
    \ 0; index < paren_string.length; index++){\n\t\tif (paren_string[index] === '('){\n\
    \t\t\tif (nested_level == 0) parentheses_set.add(index);\n\t\t\tnested_level++;\n\
    \t\t}\n\t\telse if (paren_string[index] === ')'){\n\t\t\tif (nested_level > 0)\
    \ parentheses_set.add(index);\n\t\t\tnested_level--;\n\t\t}\n\t}\n\tlet result\
    \ = [];\n\tfor (let ele of parentheses_set){\n\t\tfor (let index = ele; index\
    \ < paren_string.length; index++){\n\t\t\tif (paren_string[index] === '('){\n\t\
    \t\t\tnested_level++;\n\t\t\t}\n\t\t\telse if (paren_string[index] === ')'){\n\
    \t\t\t\tnested_level--;\n\t\t\t}\n\t\t\tresult.push(nested_level);\n\t\t}\n\t\
    }\n\treturn result;\n}\n", "  return paren_string.match(/\\(.*?\\)/g).map(function(n){\n\
    \    return n.match(/[^()]+/g).map(function(e){\n      return e.length\n    }).reduce(function(n,\
    \ a){\n      return n\n    }, 0)\n  }).reduce(function(n, a){\n    return a.length\n\
    \  }, 0)\n}\n", "  var parsed_parens = [];\n  var parens = paren_string.split(\"\
    \ \");\n\n  for (var i = 0; i< parens.length; i++){\n    var curr_index = parsed_parens.length;\n\
    \    parens = parens[i].split(\"(\");\n    for (var j=0; j<parens.length; j++){\n\
    \      if(j==0)\n      {\n        var first_chars = parens[j].charAt(0);\n   \
    \     if(first_chars == \"(\" || first_chars == \")\"){\n          parsed_parens.push(0);\n\
    \        }\n        parsed_parens.push(curr_index+1);\n      }\n      else\n \
    \     {\n        var curr_index = parsed_parens.pop();\n        var last_chars\
    \ = parens[j].charAt(parens[j].length-1);\n        if(last_chars == \")\"){\n\
    \          parsed_parens.push(curr_index+1);\n        }\n        else\n      \
    \  {\n          parsed_parens.push(curr_index+1);\n        }\n      }\n    }\n\
    \  }\n  return parsed_parens;\n}\n", "  var par_list = [];\n  var temp_paren_list\
    \ = [];\n  var paren_index = 0;\n  var paren_count = 0;\n  var nested_count =\
    \ 1;\n  var has_parens = false;\n  var i;\n  for(i = 0; i < paren_string.length;\
    \ i++){\n    if(paren_string[i] === \"(\"){\n      paren_count++;\n      if(has_parens){\n\
    \        temp_paren_list[paren_index] = paren_count;\n      }\n      par_list[par_list.length]\
    \ = paren_index;\n      par_list[par_list.length] = paren_string[i];\n      par_list[par_list.length]\
    \ = 0;\n      has_parens = true;\n    }else if(paren_string[i] === \")\"){\n \
    \     paren_count--;\n      if(has_parens){\n        par_list[par_list.length]\
    \ = par_list[par_list.length] + (temp_paren_list[paren_index]);\n      }\n   \
    \   if(par_count === 0){\n        par_list[par_list.length] = par_list[par_list.length]\
    \ - nested_count - 1;\n      }\n      par_list[par_list.length] = 0;\n      if(has_parens\
    \ && par_count === 0){\n        par_list[par_list.length] = par_list[par_list.length]\
    \ + nested_count;\n      }\n      has_parens = false;\n    }else{\n      par_list[par_list.length]\
    \ = par_list[par_list.length] + paren_string[i];\n    }\n  }\n  return par_list;\n\
    }\n", "  var nested_parens = [];\n  var opening_paren_regex = /\\((.*)\\)/g;\n\
    \  var nested_paren_regex = /(\\((.*)\\))/g;\n  var matched_paren_groups = [];\n\
    \  var max_nested_paren_count = 0;\n  var paren_group_regex = /^\\((.*)\\)/g;\n\
    \  var match = paren_string.match(paren_group_regex);\n  while (match){\n    matched_paren_groups.push(match[1]);\n\
    \    match = paren_string.match(paren_group_regex);\n  }\n  for (var i = 0; i\
    \ < matched_paren_groups.length; i++){\n    var matched_paren_group = matched_paren_groups[i];\n\
    \    var paren_count = matched_paren_group.length;\n    var deepest_paren_count\
    \ = paren_count;\n    for (var j = 0; j < matched_paren_groups.length; j++){\n\
    \      if (matched_paren_groups[j].substr(0, paren_count) == matched_paren_group){\n\
    \        deepest_paren_count = j;\n      }\n    }\n    if (deepest_paren_count\
    \ > max_nested_paren_count){\n      max_nested_paren_count = deepest_paren_count;\n\
    \    }\n  }\n  for (var i = 0; i < matched_paren_groups.length; i++){\n    var\
    \ matched_paren_group = matched_paren_groups[i];\n    var paren_count = matched_paren_group.length;\n\
    \    var deepest_paren_count = paren_count;\n    for (var j = 0; j < matched_paren_groups.length;\
    \ j++){\n      if (matched_paren_groups[j].substr(0, paren_count) == matched_paren_group){\n\
    \        deepest_paren_count = j;\n      }\n    }\n    nested_parens.push(deepest_paren_count);\n\
    \  }\n  return nested_parens;\n}\n", "\t// Initialize the array of levels to keep\
    \ track of the depth of nesting\n\tvar max_level = 0;\n\t\n\t// Initialize the\
    \ current level index\n\tvar current_level = 0;\n\t\n\t// Loop through all the\
    \ groups in the paren string\n\tfor(var i = 0; i < paren_string.length; i++){\n\
    \t\t// If current level is greater than the max level, set the max level to the\
    \ current level\n\t\tif(current_level > max_level)\n\t\t\tmax_level = current_level;\n\
    \t\t\n\t\t// If current level is equal to max level, increment current level\n\
    \t\tif(current_level == max_level){\n\t\t\tcurrent_level++;\n\t\t}\n\t\t\n\t\t\
    // If current level is less than max level, decrement current level\n\t\telse\
    \ if(current_level < max_level){\n\t\t\tcurrent_level--;\n\t\t}\n\t}\n\t\n\t//\
    \ Return the max level of nesting\n\treturn max_level;\n}\n", "\t// Count how\
    \ many groups are in the paren string.\n\tvar paren_counter = 0;\n\t// Count the\
    \ number of opening and closing parens.\n\tvar open_counter = 0;\n\tvar close_counter\
    \ = 0;\n\t// Keep track of deepest level nested parentheses.\n\tvar deepest_level\
    \ = 0;\n\t// Parse the paren string and record every opening paren.\n\tfor(var\
    \ i=0; i<paren_string.length; i++){\n\t\tswitch(paren_string[i]){\n\t\t\tcase\
    \ \")\":\n\t\t\t\tif(open_counter<close_counter){\n\t\t\t\t\topen_counter++;\n\
    \t\t\t\t}else{\n\t\t\t\t\tclose_counter++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\
    case \"(\":\n\t\t\t\tif(open_counter<close_counter){\n\t\t\t\t\topen_counter++;\n\
    \t\t\t\t}else{\n\t\t\t\t\tclose_counter++;\n\t\t\t\t}\n\t\t\t\tdeepest_level =\
    \ deepest_level + 1;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t// Return the deepest level.\n\
    \treturn deepest_level;\n}\n", "    var paren_depth=new Array();\n    var curr_depth=0;\n\
    \    var curr_opening_paren=false;\n    var curr_opening_paren_start_i=0;\n  \
    \  for (var i=0;i<paren_string.length;i++){\n        if (paren_string.charAt(i)==\"\
    (\" || paren_string.charAt(i)==\" \" || paren_string.charAt(i)==\"\\t\" || paren_string.charAt(i)==\"\
    \\r\" || paren_string.charAt(i)==\"\\n\"){\n            paren_depth[curr_depth]=curr_depth;\n\
    \            curr_depth++;\n        } else if (paren_string.charAt(i)==\")\"){\n\
    \            curr_depth--;\n            var deepest_level_of_nesting=paren_depth[curr_depth];\n\
    \            paren_depth[curr_depth]=deepest_level_of_nesting;\n        }\n  \
    \  }\n    return paren_depth;\n}\n", "    let count = 0; //Used to count the number\
    \ of opening parenthesis\n    let max_level = 0; //Used to store the maximum level\
    \ of nesting within parenthesis.\n    let result = new Array(); //To store the\
    \ result\n    for (let i = 0; i < paren_string.length; i++){\n        if (paren_string[i]\
    \ == \"(\" || (paren_string[i] == \")\" && count > max_level)){\n            count++;\n\
    \        }\n        else if (paren_string[i] == \")\" && count == max_level){\n\
    \            count--;\n        }\n        else if (paren_string[i] == \")\" &&\
    \ count == 0){\n            result.push(max_level);\n            max_level++;\n\
    \        }\n    }\n    return result;\n}\n", "    var level = 0;\n    var nesting_stack\
    \ = [];\n    for(var i in paren_string){\n        switch(paren_string[i]){\n \
    \           case ' ':\n                if(level!=0){\n                    nesting_stack.push(level);\n\
    \                }\n                break;\n            case '(':\n          \
    \      nesting_stack.push(level);\n                break;\n            case ')':\n\
    \                var level = nesting_stack.pop();\n                if(level!=0){\n\
    \                    nesting_stack.push(level);\n                }\n         \
    \       break;\n            default:\n                break;\n        }\n    }\n\
    \    return nesting_stack.length;\n}\n</code>\n<|/ a dscore=2 tags=parsing,algorithm,javascript,php\
    \ |>\n<| a tags=parsing,algorithm,javascript,php |>\nI did this a while ago, I\
    \ wrote a very simple parser in JavaScript using regular expressions.\nIt doesn't\
    \ handle nested parentheses very well, but it's worth looking at for something\
    \ more complex than simple parentheses.\n<code>\nvar myString = \"(())\";\n\n\
    var myArray = myString.match(/[\\(\\)]/g);\n", "    var nested_level = [];\n \
    \   for (var i = 0 ; i < paren_string.length ; i++){\n        if (paren_string[i]\
    \ == '('){\n            nested_level.push(i);\n        }\n        else if (paren_string[i]\
    \ == ')'){\n            if (nested_level.length > 0){\n                nested_level.pop();\n\
    \            }\n        }\n    }\n    return nested_level.length\n}\n", "  const\
    \ brackets = [];\n  let count = 1;\n  let max_count = 0;\n\n  // Create an array\
    \ out of the string.\n  paren_string = paren_string.split(\"\");\n  paren_string.forEach((char)\
    \ => {\n    if(char === \")\") {\n      brackets.pop();\n    } else if(char ===\
    \ \"(\") {\n      brackets.push(char);\n    } else {\n      brackets.push(char);\n\
    \      count++;\n      if(count > max_count) {\n        max_count = count;\n \
    \     }\n    }\n  });\n  return max_count;\n}\n", "  const stack = [];\n  let\
    \ depth = 0;\n\n  paren_string.split(' ').forEach( (sub_string) => {\n    if (sub_string.length\
    \ > 1) {\n      const level_count = sub_string.match(/\\(\\))/g).length;\n   \
    \   stack.push(level_count);\n    }\n  });\n  \n  return stack;\n}\n</cell>\n\
    <text>\nExercise 3\nHow could you use this function to implement the function\
    \ count_parentheses() below?\n\n\n</text>\n<cell>", "  if(!paren_string){\n  \
    \  return [];\n  }\n\n  var nested=0;\n  var open_parens=[];\n\n  for(var i=0;\
    \ i<paren_string.length; i++){\n    if(paren_string[i]==\"(\"){\n      nested++;\n\
    \      if(nested>0){\n        open_parens.push(nested);\n      }\n    }else if(paren_string[i]==\"\
    )\"){\n      nested--;\n    }\n  }\n\n  if(nested<0){\n    return [];\n  }\n \
    \ for(var i=0; i<open_parens.length; i++){\n    open_parens[i]=open_parens[i]-nested;\n\
    \  }\n\n  return open_parens;\n}\n", "    var paren_level = []\n    var paren_count\
    \ = []\n    var paren_stack = []\n    for(var i = 0; i < paren_string.length;\
    \ i++){\n        var char = paren_string.charAt(i)\n        var level = 0\n  \
    \      switch(char){\n            case '(':\n                paren_stack.push(char)\n\
    \                level++\n                paren_level[level] = paren_stack.length\n\
    \                break\n            case ')':\n                var level_diff\
    \ = paren_level.length - paren_stack.length\n                for(var i = 0; i\
    \ < level_diff; i++){\n                    paren_level.pop()\n               \
    \ }\n                break\n        }\n        paren_count.push(level)\n    }\n\
    \    return paren_count\n}\n", "\t// Create an array to store the output\n\tvar\
    \ nested_paren_levels = [];\n\t// Start by counting the number of open and close\
    \ parentheses\n\tvar open_brackets = paren_string.match(/\\(/g).length;\n\tvar\
    \ close_brackets = paren_string.match(/\\)/g).length;\n\t// Now iterate over the\
    \ string, count the level of nesting for each bracket and then add it to an array\
    \ as it is encountered\n\tfor(var i = 0; i < paren_string.length; i++){\n\t\t\
    if(paren_string[i] == \"(\"){\n\t\t\t// Increment the bracket count by one\n\t\
    \t\topen_brackets++;\n\t\t}else if(paren_string[i] == \")\"){\n\t\t\t// Decrement\
    \ the bracket count by one\n\t\t\topen_brackets--;\n\t\t\t// If the count is zero,\
    \ then the bracket is closed, so add the level to the array and decrement the\
    \ level if an open bracket is encountered\n\t\t\tif(open_brackets == 0){\n\t\t\
    \t\tnested_paren_levels.push(open_brackets);\n\t\t\t\topen_brackets = close_brackets;\n\
    \t\t\t}\n\t\t}\n\t}\n\t// Finally, return the array of levels\n\treturn nested_paren_levels;\n\
    }\n", "  var nesting_levels = paren_string.match(/\\(([^\\(\\)]+)\\)/g);\n  return\
    \ nesting_levels\n}\n", "    let nested_paren_counter = 0; //This counter helps\
    \ keep track of nesting levels for each group separately.\n    let paren_groups\
    \ = paren_string.split(\" \");\n    for( let paren_group of paren_groups){\n \
    \       let paren_group_items = paren_group.split(\"(\");\n        for( let paren_item\
    \ of paren_group_items){\n            if(paren_item.includes(\")\")) nested_paren_counter--;\n\
    \            else nested_paren_counter++;\n        }\n    }\n    return nested_paren_counter;\n\
    }\n</code>\nThis is not the fastest solution but it is more readable than some\
    \ of the other solutions here.\n<|/ a |>\n<| a dscore=2 |>\nThis might do the\
    \ trick for you. Not sure if it will work for very large inputs\n<code>", "  \
    \  var parentheses_levels = [],\n        index = 0,\n        level = 0,\n    \
    \    num_open_parentheses = 0,\n        open_parentheses_found = 0;\n\n    while\
    \ (index < paren_string.length){\n        var char = paren_string[index];\n  \
    \      switch (char) {\n            case ')': num_open_parentheses = --open_parentheses_found;\
    \ break;\n            case '(': ++num_open_parentheses;\n                parentheses_levels.push(level);\n\
    \                break;\n            case ' ': ++level;\n                break;\n\
    \            default:\n                throw(\"Unexpected character '\" + char\
    \ + \"' at index \" + index);\n        }\n        ++index;\n    }\n\n    if (num_open_parentheses\
    \ !== 0){\n        throw(\"Mismatched '()' in \" + paren_string);\n    }\n   \
    \ return parentheses_levels.length;\n}\n", "\tvar levels = [];\n\tvar num_levels\
    \ = 0;\n\tfor(var i=0;i<paren_string.length;i++){\n\t\tswitch(paren_string[i]){\n\
    \t\t\tcase \"(\":\n\t\t\t\tlevels[num_levels++] = 1;\n\t\t\t\tbreak;\n\t\t\tcase\
    \ \"(\":\n\t\t\t\tlevels[num_levels++] = 0;\n\t\t\t\tbreak;\n\t\t\tcase \")\"\
    :\n\t\t\t\tlevels[num_levels--];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.log(\"\
    Unknown char at index \" + i + \" in \" + paren_string[i]);\n\t\t\t\tbreak;\n\t\
    \t}\n\t}\n\t\n\treturn levels;\n}\n", "    var output_array = new Array();\n \
    \   var group_array = new Array();\n    \n    var current_group_level = 1;\n \
    \   for(var i = 0; i< paren_string.length; i++){\n        \n        switch(paren_string[i]){\n\
    \        case '(':\n            group_array[current_group_level] = group_array[current_group_level-1]\
    \ + 1;\n            current_group_level++;\n            break;\n        case ')':\n\
    \            current_group_level = group_array[current_group_level];\n       \
    \     break;\n        }\n        \n    }\n    \n    return output_array;\n}\n",
  "    var max_depth = 0;\n    var depth = 0;\n    var group_length = 0;\n    var\
    \ group = [];\n    var result = new Array();\n    \n    for (var i=0; i<paren_string.length;\
    \ i++){\n        var char = paren_string.charAt(i);\n        \n        if (char\
    \ == \"(\")\n            depth++;\n        else if (char == \")\")\n         \
    \   depth--;\n        \n        if (depth > max_depth){\n            group = paren_string.substr(i,\
    \ group_length);\n            result.push(max_depth);\n            max_depth =\
    \ depth;\n            group_length = 0;\n        }\n        else \n          \
    \  group_length++;\n    }\n    \n    return result.reverse();\n}\n\n", "\tvar\
    \ nested_count = 0\n\tvar paren_count = 0\n\tvar paren_nesting = [paren_count]\n\
    \n\tfor(let i = 0; i < paren_string.length; i++){\n\t\tif(paren_count != 0){\n\
    \t\t\tparen_nesting.push(paren_count)\n\t\t}\n\t\tif(paren_string[i] != \")\"\
    ){\n\t\t\tparen_count++\n\t\t}else{\n\t\t\tparen_count--\n\t\t\tnested_count +=\
    \ paren_count\n\t\t\tif(nested_count <= 0){\n\t\t\t\tparen_nesting.pop() // Remove\
    \ last paren_count so we don't go too deep\n\t\t\t\treturn paren_nesting\n\t\t\
    \t}\n\t\t}\n\t}\n\n\treturn paren_nesting\n}\n\n", "  if(paren_string.length ==\
    \ 0){\n    return [];\n  }\n  return paren_string.match(/\\((?=\\((?=\\(|\\)))\\\
    )\\)/) \n}", "  var groups = paren_string.split(' ');\n  var nested_groups = _.filter(groups,\
    \ function(val){\n    var match = val.match(/[(]/g);\n    return (match !== null)\
    \ && (match.length > 1);\n  });\n  if(nested_groups.length < 1){\n    return [];\n\
    \  }\n  var max_count = 0;\n  var deepest_level = [];\n  _.each(nested_groups,\
    \ function(item){\n    var match = (item.match(/[()]/g) || []);\n    _.each(match,\
    \ function(val){\n      if(val === '('){\n        if(deepest_level.length > max_count){\n\
    \          max_count = deepest_level.length;\n        }\n      }\n      else if(val\
    \ === ')'){\n        if(deepest_level.length < max_count + 2){\n          deepest_level.push(max_count\
    \ + 1);\n        }\n      }\n    });\n  });\n  return deepest_level;\n}\n", "\t\
    paren_string=paren_string.replace(/\\s+/g, \"\"); //Remove all whitespace\n\t\
    var levels=[];\n\tvar openStack=[]; //Stack to keep track of opening and closing\
    \ brackets.\n\tvar closedStack=[]; //Stack to keep track of closed brackets.\n\
    \tvar open=false;\n\tvar count=0;\n\tfor(var i=0;i<paren_string.length;i++){\n\
    \t\tif(paren_string[i]==\"(\"){\n\t\t\topenStack.push(paren_string[i]);\n\t\t\t\
    open=true;\n\t\t}\n\t\telse if(paren_string[i]==\")\"){\n\t\t\tclosedStack.pop();\n\
    \t\t\tlevel=closedStack.length-1;\n\t\t\topen=false;\n\t\t}\n\t\telse{\n\t\t\t\
    if(open){\n\t\t\t\tlevels.push(level);\n\t\t\t\topenStack.push(paren_string[i]);\n\
    \t\t\t}\n\t\t\telse{\n\t\t\t\tlevel=openStack.length;\n\t\t\t\topenStack.push(paren_string[i]);\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\t//Find deepest level of nesting using level array.\n\
    \tvar output=0;\n\tfor(var i=0;i<levels.length;i++){\n\t\tif(levels[i]>output){\n\
    \t\t\toutput=levels[i];\n\t\t}\n\t}\n\t\n\treturn output+1;\n}\n\n", "    let\
    \ max_depth = 0;\n    let paren_level = 0;\n    let level = 0;\n    let nested_count\
    \ = 0;\n    let paren_stack = [];\n    let paren_stack_string = \"\";\n    for(let\
    \ i = 0; i < paren_string.length; i++){\n        let c = paren_string[i];\n  \
    \      if(c == \")\"){\n            //Pop from the stack and increment the level\
    \ of nesting by 1\n            paren_stack.pop();\n            paren_stack_string\
    \ = paren_stack_string + paren_stack_string.substring(0,paren_stack_string.length\
    \ - 1);\n            level += 1;\n        }\n        else if(c == \"(\"){\n  \
    \          //Push to the stack\n            paren_stack.push(c);\n           \
    \ level += 1;\n        }\n        //Count the number of levels of nesting\n  \
    \      if(c == \" \" && paren_stack_string != \"\"){\n            //If there is\
    \ a space between a group of parentheses, increment the level of nesting\n   \
    \         level += 1;\n        }\n        //Increment the number of nested parentheses\
    \ if it is balanced parentheses.\n        if(c == \"(\"){\n            nested_count\
    \ += 1;\n        }\n        if(c == \")\"){\n            if(paren_stack_string.length\
    \ > 0){\n                //If the parentheses are balanced and the level of nesting\
    \ is greater than the maximum level, increment the level of nesting.\n       \
    \         level += 1;\n            }\n        }\n        if(c == \" \" && paren_stack_string.length\
    \ > 0){\n            //If the parentheses are balanced, increment the level of\
    \ nesting.\n            level += 1;\n        }\n        //Update the maximum level\
    \ of nesting if it is greater than the previous maximum level\n        if(level\
    \ > max_depth && max_depth == 0){\n            max_depth = level;\n        }\n\
    \    }\n    return max_depth;\n}\n", "\tlet paren_stack = [];\n\tlet level = 0;\n\
    \tfor(let paren of paren_string.split(\" \")){\n\t\tif(paren.length && paren !=\
    \ \"()\"){\n\t\t\tparen_stack.push(paren.length);\n\t\t}\n\t\telse {\n\t\t\twhile(paren_stack.length\
    \ > 0 && paren_stack[paren_stack.length - 1] > level){\n\t\t\t\tparen_stack.pop();\n\
    \t\t\t}\n\t\t\tlevel += paren_stack[paren_stack.length - 1];\n\t\t\tparen_stack.push(level);\n\
    \t\t}\n\t}\n\treturn paren_stack;\n}\n", "  paren_string = paren_string.trim();\n\
    \  var nested_parens = [];\n  var parenLevel = 0;\n  var inGroup = paren_string.match(/^\\\
    ((.+)\\)/);\n  if(inGroup){\n    parenLevel = inGroup[1].length;\n    paren_string\
    \ = inGroup[1];\n  }\n  var innerParenLevel = paren_string.match(/\\((.+)\\)/);\n\
    \  if(innerParenLevel){\n    parenLevel = Math.min(parenLevel, innerParenLevel[1].length);\n\
    \    paren_string = innerParenLevel[1];\n  }\n  for(var i=0; i<paren_string.length;\
    \ i++){\n    if(paren_string[i] == '('){\n      parenLevel++;\n    }\n    else\
    \ if(paren_string[i] == ')'){\n      parenLevel--;\n    }\n    if(parenLevel ==\
    \ 0){\n      nested_parens.push(parenLevel);\n    }\n  }\n  if(nested_parens.length\
    \ < 1){\n    return [];\n  }\n  else{\n    return nested_parens.slice(0,1);\n\
    \  }\n}\n", "    var parentheses_level = [];\n    var nested_parenthesis_level\
    \ = [];\n    var depth = 0;\n    for(var i=0; i<paren_string.length; i++){\n \
    \       if(paren_string[i] == \"(\"){\n            depth++;\n        }\n     \
    \   else if(paren_string[i] == \")\"){\n            depth--;\n        }\n    \
    \    if(depth == 0){\n            parentheses_level.push(parentheses_level.length);\n\
    \        }\n        else if(depth == 1){\n            nested_parenthesis_level.push(nested_parenthesis_level.length);\n\
    \        }\n    }\n    return Math.max(...parentheses_level) + Math.max(...nested_parenthesis_level);\n\
    }\n", "  var max_level = 1;\n  var nest_levels = 0;\n\n  var paren_stack = [];\n\
    \  paren_string.replace(/\\(|\\)/g, \"\").split(\"\").forEach(function(letter){\n\
    \    if (letter == '(' || letter == ')') {\n      if (paren_stack.indexOf(letter)\
    \ == -1){\n        nest_levels++;\n      }\n      else {\n        nest_levels--;\n\
    \      }\n    }\n    else {\n      nest_levels = 0;\n    }\n\n    if (nest_levels\
    \ > max_level) {\n      max_level = nest_levels;\n    }\n  });\n\n  return max_level;\n\
    }\n", "\tvar paren_depth_counts = {}\n\tvar paren_depth_total = 0\n\tfor(var i\
    \ = 0; i < paren_string.length; i++)\n\t{\n\t\tparen_depth_counts[paren_string[i]]\
    \ = paren_depth_counts[paren_string[i]] ? paren_depth_counts[paren_string[i]]\
    \ + 1 : 1\n\t\tparen_depth_total += paren_depth_counts[paren_string[i]]\n\t}\n\
    \tvar parsed_nested_parens = []\n\tfor(var i = 0; i < paren_depth_total; i++)\n\
    \t{\n\t\tparsed_nested_parens.push(paren_string.length)\n\t}\n\tfor(var paren_string\
    \ in paren_depth_counts)\n\t{\n\t\tvar paren_depth = paren_depth_counts[paren_string]\n\
    \t\tfor(var i = paren_string.length - 1; i >= 0; i--)\n\t\t{\n\t\t\tparen_depth\
    \ = paren_depth_counts[paren_string[i]]\n\t\t\tparsed_nested_parens[paren_depth]\
    \ = parsed_nested_parens[paren_depth - 1]\n\t\t}\n\t}\n\treturn parsed_nested_parens\n\
    }\n", "    var nested_paren_count = 0;\n    var nested_paren_level = -1;\n   \
    \ var nested_paren_string = paren_string.replace(/^\\s*\\(\\s*|\\s*\\)\\s*$/g,'').trim();\n\
    \    for(var i = 0; i < nested_paren_string.length; i++){\n        if(nested_paren_string[i]\
    \ == '('){\n            nested_paren_count++;\n        }\n        else if(nested_paren_string[i]\
    \ == ')'){\n            nested_paren_count--;\n        }\n        else if(nested_paren_count\
    \ == 0){\n            nested_paren_level++;\n        }\n        else if(nested_paren_count\
    \ < 0){\n            nested_paren_count--;\n            nested_paren_level--;\n\
    \        }\n    }\n    return nested_paren_level;\n}\n</code>\n<|/ a tags=string,javascript,parsing,regex\
    \ dscore=3 |>\n<| c |>\nThanks for your answer! But I forgot to add that the solution\
    \ should support nested parentheses expressions such as `((()())())`. Also if\
    \ there are no nested parentheses, it returns the length of the parenthesized\
    \ string.\n<|/ c |>\n<| c |>\nYou can't have nested parentheses that way. As soon\
    \ as you encounter a `(` you start counting nested parentheses and when you encounter\
    \ a `)` you stop counting them. You must keep count of how many opening and closing\
    \ parentheses you have until you come across a `)` or `)` with no opening and\
    \ closing parentheses to balance them out.\n<|/ c |>\n<| a dscore=2 |>\nI wrote\
    \ a small parser that can parse nested parentheses with all kind of input. Here\
    \ is the code (just tested on Node.js)\n<code>\nlet input = \"( ((()()()) (())\
    \ )() ((()))())\";\nlet output = [];\nlet level = 0;\nlet stack = [];\ninput.split(\"\
    \").forEach((letter) => {\n    if (letter === \"(\") {\n        stack.push(level);\n\
    \    } else if (letter === \")\") {\n        level = stack.pop();\n    } else\
    \ if (letter === \"(\") {\n        if (stack.length === level) {\n           \
    \ level++;\n        }\n    } else if (letter === \")\") {\n        if (stack.length\
    \ === 0) {\n            output.push(level);\n        }\n    }\n});"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
