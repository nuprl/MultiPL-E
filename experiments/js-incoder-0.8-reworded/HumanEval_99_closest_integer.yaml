name: HumanEval_99_closest_integer
language: js
prompt: "//Create a function that takes a value (string) representing a number\n//\
  \ and returns the closest integer to it. If the number is equidistant\n// from two\
  \ integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\"\
  )\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from\
  \ zero means that if the given number is equidistant\n// from two integers, the\
  \ one you should return is the one that is the\n// farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\nfunction closest_integer(value){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = closest_integer;\n  assert.deepEqual(candidate(\"10\"),10);\n  assert.deepEqual(candidate(\"\
  14.5\"),15);\n  assert.deepEqual(candidate(\"-15.5\"),-16);\n  assert.deepEqual(candidate(\"\
  15.3\"),15);\n  assert.deepEqual(candidate(\"0\"),0);\n}\n\ntest();"
completions: ["\tvar valAsNum = parseFloat(value);\n\tvar closestVal = Math.round(valAsNum);\n\
    \tvar closestDifference = valAsNum - closestVal;\n\tif (closestDifference >= 0){\n\
    \t\treturn closestVal;\n\t} else {\n\t\treturn closestVal - 1;\n\t}\n}\n", "\t\
    return value.toFixed(2).split('.')[0]\n}\n", "    var valInt = parseInt(value,10);\n\
    \    return (Math.abs(valInt-Math.floor(valInt))+valInt);\n}\n</code>\n<|/ a tags=javascript,algorithm\
    \ dscore=4 |>\n<| c |>\nThis assumes that `-Infinity` is closer to `0` than it\
    \ is to `Infinity` (which is true of most numbers).\n<|/ c |>\n<| c |>\n- Nope,\
    \ `-Infinity` is closer to `0`.\n<|/ c |>\n<| c |>\nI understand that you're saying\
    \ \"-Infinity\" should be closer to zero than it is to \"Infinity\". But why is\
    \ \"-Infinity\" closer to zero? It's not mathematically correct, either. Or do\
    \ you mean \"-Infinity\" should be closer to `-Infinity` than it is to \"Infinity\"\
    ? In which case, your algorithm gives 17 as the result for \"-Infinity\", not\
    \ -18. My algorithm gives -18 as the \"closest\" number to the number \"Infinity\"\
    , which is closer to zero.\n<|/ c |>\n<| c |>\n- You're right. As you said yourself,\
    \ it depends on how you define \"close\". I interpreted \"close\" as not being\
    \ equidistant from two (distinct) integers. Therefore, the number closest to zero\
    \ should be closer to negative infinity, not positive infinity.\n<|/ c |>\n<|\
    \ c |>\nOh, I see. Yes, I meant \"close\" as \"not equidistant from two distinct\
    \ integers\". I thought my definition of \"close\" was correct. :-)\n<|/ c |>\n\
    <| a |>\nThis is an implementation of the algorithm that Dylan Smith described:\n\
    <code>", "    // If the given value is a number, return its integer value.\n \
    \   // If the given value is a string, parse the value as a number and then\n\
    \    // return its integer value.\n    return isNaN(value) ? parseInt(value, 10)\
    \ : parseInt(value, 10);\n}\n", "  return Math.round((value - parseFloat(value))/Math.pow(10,10))\n\
    }\n", "  var rounded = Math.round(value);\n  if(Math.abs(value - rounded) < 1e-5)\
    \ return rounded;\n  if(Math.abs(value - rounded) < 1e-3) return rounded;\n  if(Math.abs(value\
    \ - rounded) < 1e-2) return rounded;\n  if(Math.abs(value - rounded) < 0.1) return\
    \ rounded;\n  if(Math.abs(value - rounded) < 2) return rounded;\n  if(Math.abs(value\
    \ - rounded) < 4) return rounded;\n  if(Math.abs(value - rounded) < 10) return\
    \ rounded;\n  if(Math.abs(value - rounded) < 20) return rounded;\n  if(Math.abs(value\
    \ - rounded) < 100) return rounded;\n  if(Math.abs(value - rounded) < 200) return\
    \ rounded;\n  if(Math.abs(value - rounded) < 1000) return rounded;\n  if(Math.abs(value\
    \ - rounded) < 2000) return rounded;\n  if(Math.abs(value - rounded) < 10000)\
    \ return rounded;\n  if(Math.abs(value - rounded) < 20000) return rounded;\n \
    \ if(Math.abs(value - rounded) < 100000) return rounded;\n  if(Math.abs(value\
    \ - rounded) < 200000) return rounded;\n  if(Math.abs(value - rounded) < 1000000)\
    \ return rounded;\n  if(Math.abs(value - rounded) < 10000000) return rounded;\n\
    \  if(Math.abs(value - rounded) < 100000000) return rounded;\n  if(Math.abs(value\
    \ - rounded) < 1000000000) return rounded;\n  if(Math.abs(value - rounded) < 10000000000)\
    \ return rounded;\n  if(Math.abs(value - rounded) < 100000000000) return rounded;\n\
    \  if(Math.abs(value - rounded) < 1000000000000) return rounded;\n  if(Math.abs(value\
    \ - rounded) < 10000000000000) return rounded;\n  if(Math.abs(value - rounded)\
    \ < 100000000000000) return rounded;\n  if(Math.abs(value - rounded) < 1000000000000000)\
    \ return rounded;\n  if(Math.abs(value - rounded) < 10000000000000000) return\
    \ rounded;\n  if(Math.abs(value - rounded) < 100000000000000000)\n    return rounded;\n\
    \  if(Math.abs(value - rounded) < 1000000000000000000) return rounded;\n  throw\
    \ new Error(\"Couldn't determine closest integer\");\n}\n", "\tvar roundedValue\
    \ = Math.round(value);\n\tif(value % 1 != 0) return Math.round(roundedValue);\n\
    \tvar diff = roundedValue - value;\n\tif(diff <= 0) return roundedValue;\n\treturn\
    \ Math.floor(roundedValue);\n}\n", "  if (value.length === 0){\n    console.error('value\
    \ parameter is empty');\n    return;\n  }\n  var number = parseInt(value);\n \
    \ return Math.round(Math.abs(number));\n}\n", "  value = parseFloat(value); //\
    \ remove any decimals\n  value = Math.abs(value); // round to closest number\n\
    \  value = Math.floor(value); // round down\n  return value; // return closest\
    \ integer\n}\n", "  value = +value;\n  if (value < 0 || value > MAX_INT) {\n \
    \   return -MAX_INT;\n  }\n  return Math.floor(value + 0.5);\n}\n", "  if(value\
    \ == 0) return value;\n  var factor = Math.pow(10, Math.floor(Math.log10(value)));\n\
    \  var intvalue = parseInt(value / factor);\n  return intvalue >= Math.pow(10,\
    \ Math.floor(Math.log10(value+1))) ? intvalue : value - (intvalue * factor);\n\
    }\n", "    return Math.floor(value * Math.pow(10, Math.floor(Math.log(Math.abs(value))\
    \ / Math.LN10)));\n}\n", "  var difference = parseFloat(value) - parseFloat(this.value);\n\
    \  var closest_integer = difference < 0 ? Math.ceil(difference) : Math.floor(difference);\n\
    \  return this.value = closest_integer;\n}\n", "  return Math.round((value-0)*10)/10\n\
    }\n", "  var difference = parseInt(value) - parseInt(floor(value))\n  if(difference\
    \ === 0){\n    difference = 1e-9\n  }\n  return parseInt(floor(value) + difference)\n\
    }\n", "  if( value.length == 0 ){\n    return null;\n  }\n  let closestToZero\
    \ = Math.floor( value ),\n      closestToValue = Math.round( value );\n  return\
    \ ( closestToValue === value ) ? closestToZero : closestToValue;\n}\n", "    //If\
    \ the string is a single digit, just use that.\n    if(/^\\d+$/.test(value))\n\
    \        value = value.charAt(0);\n\n    //If the string is negative, invert it\
    \ to find the closest integer.\n    //And return the inverse value.\n    if(value\
    \ === \"-\") \n        value = Math.abs(parseInt(value.substr(1),10));\n\n   \
    \ //If the number is already an integer, return it unchanged.\n    if(parseInt(value,10)\
    \ === value)\n        return value;\n\n    //If the number is equidistant from\
    \ two integers, round it away from zero.\n    //Then subtract the difference from\
    \ one integer from the other.\n    //That will give the closest integer.\n   \
    \ return Math.round(Math.abs(parseInt(value,10) - value))\n        - parseInt(value,10);\n\
    }\n", "\treturn Math.round(value)\n}\n", "  // Convert the string to a number\n\
    \  var converted_value = parseFloat(value);\n\n  // If the number is already an\
    \ integer, just return it\n  if(Number.isInteger(converted_value)){\n    return\
    \ converted_value;\n  }\n\n  // If the number is odd, return it\n  if(converted_value\
    \ % 2 !== 0){\n    return converted_value;\n  }\n\n  // If it's zero, return zero\n\
    \  if(converted_value === 0){\n    return 0;\n  }\n\n  // Return the next lower\
    \ integer if it's a rounding half up\n  if(converted_value % 0.5 == 0.5){\n  \
    \  return converted_value + 1;\n  }\n\n  // Return the next lower integer if it's\
    \ a rounding half down\n  return converted_value - 1;\n}", "  // Get all numbers\
    \ in the string\n  var numbers = value.split(\"\");\n  // Create a new array containing\
    \ the numbers but with the first character removed\n  var numsString = numbers.splice(0,\
    \ 1);\n  // Iterate over all numbers in the array\n  for(var i = 0; i < numsString.length;\
    \ i++){\n    // Split each number into a value and an operator\n    var numValue\
    \ = parseFloat(numsString[i]);\n    var operator = numsString[i-1];\n    // If\
    \ the number is equidistant from two integers, round it away from zero\n    if\
    \ (operator === \"-\"){\n      // If the number is negative, round it up\n   \
    \   if (numValue < 0){\n        numValue *= (-1);\n      }\n      // If the number\
    \ is positive, round it down\n      else {\n        numValue *= (-1);\n      }\n\
    \    }\n    // Push the number into the new array\n    numbers.unshift(numValue);\n\
    \  }\n  // Create a new number from the array\n  var closestInteger = parseInt(numbers.join(\"\
    \"));\n  return closestInteger;\n}\n", "  var num = parseFloat(value);\n  return\
    \ Math.round(Math.abs(num-Math.floor(num)));\n}\n", "  let a = Number(value),\n\
    \    b = Number(value),\n    closest;\n\n  // First round\n  if(a<b){\n    closest\
    \ = a.toFixed(1);\n    a = b - a;\n  }else{\n    closest = b.toFixed(1);\n   \
    \ b = a - b;\n  }\n\n  // Second round\n  if(a<b){\n    closest = (a+b)/2;\n \
    \ }else{\n    closest = (b-a)/2;\n  }\n\n  // Return closest or original value\n\
    \  return Math.abs(closest - value) < 1e-12 ? closest : value;\n}\n", "  return\
    \ Math.ceil(value)\n}\n", "    var intValue = parseFloat(value);\n    var diff\
    \ = Math.abs(intValue - intValue);\n    for(var i = 0; i < intValues.length; i++){\n\
    \        var dist = intValues[i] - intValue;\n        if (dist < diff) {\n   \
    \         diff = dist;\n            closestInteger = intValues[i];\n        }\n\
    \    }\n    return closestInteger;\n}\n", "  if(!value){\n    return 0;\n  }\n\
    \  var num = parseFloat(value);\n  var numArray = num.toString().split(\".\");\n\
    \  var smallestNum = parseInt(numArray[0]);\n  var largestNum = parseInt(numArray[1]);\n\
    \n  if(num < 0){\n    return smallestNum;\n  }\n  if(num > 0){\n    return largestNum;\n\
    \  }\n  if(smallestNum === largestNum){\n    return smallestNum;\n  }\n  return\
    \ Math.round((largestNum - smallestNum) / 2);\n}\n", "\treturn Math.round(value-Math.floor(value\
    \ / Math.abs(value))) * Math.abs(value);\n}\n", "  var rounded_value = roundToFloat(value,\
    \ 0);\n  var diff_x = Math.abs(rounded_value - value);\n  var diff_y = Math.abs(rounded_value\
    \ - value - 1);\n  return diff_x >= diff_y ? rounded_value : rounded_value - 1;\n\
    }\n", "  //create a variable to hold the current closest integer\n  var closestInt;\n\
    \  //create a variable to hold the current difference between input value and\
    \ closest integer\n  var diff;\n  //create a variable to hold the last input value\
    \ before we were called\n  var lastInput = value;\n  //Create a loop to go through\
    \ all possible values\n  for(var i=0;i<=value;i++){\n    //calculate the difference\
    \ between the input value and the current closest integer\n    diff = value -\
    \ i;\n    //if current difference is greater than the current closest integer\n\
    \    if(diff > closestInt){\n      //update the closest integer to the current\
    \ difference\n      closestInt = diff;\n    }\n  }\n  //return the closest integer\n\
    \  return closestInt;\n}\n", "    if (value.indexOf('.') === -1){\n        return\
    \ parseInt(value);\n    }\n\n    var value = value.split('.')[1];\n    var difference\
    \ = closest_integer(value) - parseInt(value);\n\n    return difference;\n}\n",
  "  let closest = Math.round(value);\n  if(closest < 0){\n    closest = 0;\n  }\n\
    \  else if(closest > 0){\n    closest = closest;\n  }\n  return closest;\n}\n",
  "  return Math.ceil(value)\n}\n", "  var fraction = value.split(\".\");\n  var int_val\
    \ = parseInt(fraction[0]);\n  var diff = (int_val - Math.floor(int_val)) * Math.pow(10,\
    \ fraction[1].length);\n  if (diff < 0){\n    diff = Math.abs(diff);\n  }\n  return\
    \ Math.floor(int_val + diff);\n}\n", "  var number = value\n  var closest = (Math.abs(number)\
    \ === Math.abs(Math.round(number)) ? Math.round(number) : parseInt(number));\n\
    \  return closest\n}\n", "  //If given number is not numeric, return null\n  if(isNaN(value))\
    \ return null;\n  //If given number is a string, remove all non-numeric characters\n\
    \  if(typeof value === 'string') value = value.replace(/\\D/g, '');\n  //If given\
    \ number is negative, negate it\n  if(value < 0) return -closest_integer(+value);\n\
    \  //If given number is equal to the value of its closest integer,\n  // return\
    \ the value of that integer\n  if(value === (value % 1)) return value;\n  //If\
    \ given number is more than the value of its closest integer,\n  // return the\
    \ value of that integer\n  if(value > value % 1) return value;\n  //If given number\
    \ is less than the value of its closest integer,\n  // return the value of the\
    \ nearest lower integer\n  return closest_integer(value - Math.floor(value));\n\
    }\n", "\tvar integer = Math.floor(value);\n\tvar diff = Math.abs(value - integer);\n\
    \tif(diff < 0.5){\n\t\treturn integer;\n\t}else{\n\t\treturn integer + 1;\n\t\
    }\n}\n", "\tvar number = parseFloat(value);\n\tvar roundDown = number % 1 ===\
    \ 0;\n\tvar roundUp = !roundDown;\n\tvar closestInteger = null;\n\tif (roundDown){\n\
    \t\tclosestInteger = Math.ceil(number);\n\t}\n\telse if (roundUp){\n\t\tclosestInteger\
    \ = Math.floor(number);\n\t}\n\telse {\n\t\t// Round equidistantly up to closest\
    \ integer.\n\t\t// Since two integers equidistant from each other are rounded\
    \ to\n\t\t// the same closest integer, the difference between the rounded \n\t\
    \t// closest integer and the original number is always less than\n\t\t// or equal\
    \ to 0.5 when rounded down. \n\t\tvar difference = Math.abs(roundDown ? Math.ceil(number)\
    \ - number : Math.floor(number) - number);\n\t\tif (difference <= 0.5){\n\t\t\t\
    closestInteger = number;\n\t\t}\n\t\telse {\n\t\t\tclosestInteger = Math.ceil(number);\n\
    \t\t}\n\t}\n\treturn closestInteger;\n}", "\tif(!value){\n\t\tconsole.error(\"\
    the value parameter cannot be null.\");\n\t\treturn false;\n\t}\n\tif(value.constructor\
    \ === Number){\n\t\tvalue = String(value);\n\t}\n\tif(!value.includes(\".\")){\n\
    \t\treturn Math.round(value+1);\n\t}\n\tlet parts = value.split(\".\");\n\tlet\
    \ whole_value = parseInt(parts[0]);\n\tlet fraction_value = parseFloat(parts[1]);\n\
    \tlet multiplier = 1;\n\tlet increment = 1;\n\tif(fraction_value>1){\n\t\tmultiplier\
    \ = fraction_value;\n\t\tincrement = 1 / multiplier;\n\t}\n\twhile(Math.abs(whole_value-Math.round(whole_value)+increment)>1e-10){\n\
    \t\twhole_value+=increment;\n\t\tif(whole_value<0){\n\t\t\twhole_value+=1;\n\t\
    \t}\n\t}\n\treturn whole_value;\n}\n", "\tvar closest;\n\tif(Math.abs(parseInt(value))==parseFloat(value)){\n\
    \t\treturn parseInt(value);\n\t}\n\tclosest = Math.round((parseInt(value))||0);\n\
    \tif(closest==parseInt(value)){\n\t\treturn closest;\n\t}\n\tif(closest<0){\n\t\
    \tclosest += Math.pow(10,Math.abs(closest).length);\n\t}\n\treturn closest;\n\
    }\n", "  var roundedValue;\n  var roundedDiff;\n\n  // Make sure that the given\
    \ number is parsable\n  try {\n    roundedValue = parseInt(value);\n  }\n  catch(e)\
    \ {\n    roundedValue = undefined;\n  }\n\n  // Return either an integer or the\
    \ number given if roundedValue wasn't given\n  if (isNaN(roundedValue)) {\n  \
    \  return roundedValue;\n  }\n\n  // If the given number was equidistant from\
    \ two integers, round it to the\n  // integer that is the farthest from zero\n\
    \  roundedDiff = Math.abs(roundedValue - value);\n  if(roundedDiff >= .5){\n \
    \   return roundedValue;\n  }\n\n  // Otherwise, round away from zero\n  return\
    \ value - Math.ceil(roundedDiff);\n}\n", "\tvar fraction = /^-?\\d*\\.?\\d*$/.test(value)\n\
    \t\tif(fraction){\n\t\t\tvalue = value.split('.');\n\t\t\tvalue = value[0]+(value[1]+'').length;\n\
    \t\t}\n\treturn Math.floor(value-0.5)+1;\n}\n", "  return Math.floor(Math.round(value));\n\
    }\n", "    return Math.round((+value) + 0.5) -\n        Math.round((+value) -\
    \ 0.5);\n}\n", "\tif(!(value.constructor == String))\n\t\tthrow new Error(\"closest_integer\
    \ expects a string as input\");\n\tvar val = parseFloat(value);\n\tvar ints =\
    \ closest_integer(val);\n\treturn ints[ints.length - 1];\n}\n", "  if (typeof(value)\
    \ === 'number'){\n    return Math.round(value)\n  }\n  else if (value.charAt(0)\
    \ === '-'){\n    return Math.abs(value)\n  }\n  else {\n    return Math.round(value)\n\
    \  }\n}\n", "  var diff = Math.abs(parseFloat(value)-Math.floor(parseFloat(value)));\n\
    \  var integer = Math.floor(parseFloat(value));\n\n  if (diff<0){\n    diff =\
    \ -diff;\n    integer += 1;\n  }\n  return integer;\n}\n</code></pre>\n<p>We will\
    \ use the same implementation as we did in the previous section: <code>closest_integer</code>\
    \ returns a value that is the nearest integer (i.e. rounds down) to the given\
    \ value. <code>Math.abs(...)</code> returns the absolute value of the given number.\
    \ <code>Math.floor(...)</code> returns the nearest integer to the given value.</p>\n\
    <p>To compare your function to this implementation, you should use the <code>closest_integer</code>\
    \ function we defined above as the <code>closest_integer</code> function in your\
    \ tests.</p>\n<h3 id=\"part-3-functional-programming\">Part 3: Functional programming</h3>\n\
    <p>We have seen how easy it is to create functions in Javascript using functional\
    \ programming techniques (i.e. using closures and higher order functions).</p>\n\
    <p>Functional programming is a programming paradigm that uses the concept of function\
    \ composition to achieve a more declarative and readable code. Functional programming\
    \ is also the foundation of functional reactive programming (RxJS).</p>\n<h4 id=\"\
    first-step-using-a-map\">First step: Using a map</h4>\n<p>We have seen before\
    \ that <code>map</code> and <code>filter</code> take an argument of the form <code>(number,\
    \ index)</code> where <code>index</code> is an arbitrary number. We will see more\
    \ use of this <code>index</code> argument in the following sections.</p>\n<p>We\
    \ will also see more use of <code>map</code> and <code>filter</code> in the following\
    \ sections.</p>\n<h4 id=\"second-step-using-a-map-function\">Second step: Using\
    \ a map function</h4>\n<p><code>map</code> and <code>filter</code> can also take\
    \ a function as an argument. In this case, the function will receive the value\
    \ of the element and an arbitrary number. The function needs to return a new element\
    \ that has been modified in some way.</p>\n<p>For example we could change the\
    \ value of the element to <code>\"<strong>x</strong>\"</code> if the value is\
    \ a <code>0</code>:</p>\n<p>```js run let result = [3, 5, 4, 2, 4, 8, 10, 10].map(function(x,\
    \ index){\n  if (x==0) return '<strong>x</strong>';\n  return x;\n});\nalert(result.join('\
    \ '))\n```</p>\n<p>This code is equivalent to the following:</p>\n<p>```js run\
    \ let result = [3, 5, 4, 2, 4, 8, 10, 10].map(function(x){\n  return (x==0) ?\
    \ '<strong>x</strong>' : x;\n});\nalert(result.join(' '))\n```</p>\n<p>In some\
    \ cases, the modification is not trivial. In this case we could simply multiply\
    \ all value", "    var smallest = 0, closest = 0;\n    for(var i = value.length\
    \ - 1; i >= 0; i--){\n        var current = +value[i];\n        if(current ===\
    \ current && current < smallest){\n            smallest = current;\n         \
    \   closest = i;\n        }\n    }\n    return closest;\n}\n", "  var n = Number(value)\n\
    \  var closest_integer = Math.round(n);\n  return Math.abs(closest_integer) ===\
    \ n ? closest_integer : closest_integer - 1;\n}\n", "    \n    var closest_integer\
    \ = null;\n    var closest_difference = Infinity;\n    \n    for(var i in values){\n\
    \        if(Math.abs(values[i] - value) <= Math.abs(closest_difference - value)){\n\
    \            closest_integer = values[i];\n            closest_difference = Math.abs(values[i]\
    \ - value);\n        }\n    }\n    \n    return closest_integer;\n}\n", "  var\
    \ integer = parseInt(value);\n  var difference = Math.abs(integer - nearest_integer(integer));\n\
    \  if (difference <= 0) return integer;\n  var multiple = Math.pow(10, Math.ceil(Math.log(difference)\
    \ / Math.LN10));\n  return Math.round(multiple * Math.abs(integer)) / multiple;\n\
    }\n", "  return Math.ceil(parseInt(value) / Math.abs(parseInt(value) - parseInt(value)));\
    \ //round to closest integer\n}\n", "  return Math.floor(value + 0.5)\n}\n", " \
    \   var a = Math.round(value), // rounds the number up or down to the next integer\n\
    \        b = Math.abs(a - Math.floor(Math.abs(a)));\n    if (a >= 0){\n      \
    \  return b;\n    } else {\n        return a - 1;\n    }\n}\n", "  return closest_number(value).valueOf();\n\
    }\n", "\treturn Math.floor(Math.abs(Math.round(value) - value));\n}\n", "\tvar\
    \ diff = closest_integer(value) - closest_integer(value%1);\n\tif (diff === 0){\n\
    \t\treturn Math.round(value);\n\t}\n\treturn diff;\n}\n", "    var distance,\n\
    \        divisor,\n        difference,\n        quotient,\n        differenceAbs,\n\
    \        result;\n    if(value){\n        //We know that if it's a number, the\
    \ return will also be a number.\n        //The only exception is when the number\
    \ is a negative number.\n        //If the number is negative, take the absolute\
    \ value.\n        if(typeof value === \"number\"){\n            //If the number\
    \ is negative, take the absolute value.\n            if(value < 0){\n        \
    \        value = Math.abs(value);\n            }\n            difference = Math.abs(value\
    \ - Math.round(value));\n            quotient = Math.floor((difference / Number.EPSILON)\
    \ + Number.EPSILON);\n            divisor = Math.pow(10, quotient);\n        \
    \    differenceAbs = Math.abs(value - divisor);\n            if(differenceAbs\
    \ > divisor){\n                quotient++;\n            }\n            result\
    \ = Math.round(value * divisor) / divisor;\n            if(quotient < Number.EPSILON){\n\
    \                result = result - 1;\n            }\n            //If the number\
    \ is not an integer, take the floor of the result and subtract 1.\n          \
    \  if(!isFinite(result)){\n                result = Math.floor(result);\n    \
    \            result -= 1;\n            }\n        }\n    }\n    return result;\n\
    }\nexports.closest_integer = closest_integer;", "\tvar intVal = Math.round(value);\n\
    \tif(intVal - Math.floor(number) < 1e-5){\n\t\treturn intVal;\n\t}\n\telse{\n\t\
    \treturn Math.floor(number);\n\t}\n}\n<|/ file filename=common.js ext=.js source=github\
    \ |>", "  var round = function(num){\n    return Math.round(num);\n  }\n\n  //\
    \ Check if value is equidistant from two integers\n  var isEquidistant = function(num1,\
    \ num2){\n    var difference = round(num1 - num2);\n    return difference >= 0\
    \ ? difference : difference + 1;\n  }\n\n  // If the given value is a string,\
    \ try to convert it to a number before\n  // checking if its the equidistant from\
    \ two other numbers\n  var getValueAsNumber = function(value){\n    return +value\n\
    \  }\n\n  // If the given value is not a string, return it\n  if(typeof value\
    \ !== 'string'){\n    return value;\n  }\n\n  var result,\n      num1 = getValueAsNumber(value),\n\
    \      num2 = getValueAsNumber(value);\n\n  // If both numbers given are equidistant\
    \ from zero, return one of the two\n  // numbers\n  if(isEquidistant(num1, num2)){\n\
    \    return num1;\n  }\n\n  // If one is negative, round away from zero\n  if(num1\
    \ < 0){\n    num1 = round(num1 + 1);\n    return num1;\n  }\n\n  // Check if the\
    \ other is negative\n  if(num2 < 0){\n    num2 = round(num2 + 1);\n    return\
    \ num2;\n  }\n\n  // If neither of the given numbers are negative, return the\
    \ smallest\n  // of one or the other\n  if(num1 > num2){\n    return num1;\n \
    \ }\n  else {\n    return num2;\n  }\n}\n\nvar closest_integer_options = {\n \
    \ 'name': 'closest_integer',\n  'category': 'Basic',\n  'description': 'Closest\
    \ integer to a given number',\n  'examples': ['closest_integer(-3)', 'closest_integer(9.5)',\
    \ 'closest_integer(9.6)'],\n  'seealso': []\n};\n\nvar closest_rational_options\
    \ = {\n  'name': 'closest_rational',\n  'category': 'Basic',\n  'description':\
    \ 'Closest rational to a given number',\n  'examples': ['closest_rational(-3)',\
    \ 'closest_rational(0)', 'closest_rational(1)', 'closest_rational(16)', 'closest_rational(5.5)',\
    \ 'closest_rational(5.6)', 'closest_rational(1/3)', 'closest_rational(-4)', 'closest_rational(1/-3)'],\n\
    \  'seealso': ['closest_integer', 'closest_float']\n};\n", "  return Math.floor(Math.abs(value));\n\
    }\nexports.closest_integer = closest_integer;\n", "  if (value.indexOf('.') !==\
    \ -1){\n    return Math.round(value.replace(/\\.0$/,''))\n  }\n  else {\n    const\
    \ v = +value\n    const diff = v - Math.floor(v)\n    return diff < 0 ? v - diff\
    \ : diff\n  }\n}\n", "  if (value === null) {\n    throw new Error(\"cannot parse\
    \ \" + value);\n  }\n  var number = +value;\n  if (Math.abs(number - number) <\
    \ 1e-9) {\n    // Special case: if the number was originally a string or number,\n\
    \    // it was probably a float and we can just return the original value.\n \
    \   // In which case we'll just treat it as zero.\n    number = 0;\n  }\n  if\
    \ (Math.abs(number) < Number.MIN_VALUE) {\n    // Special case: if the number\
    \ is negative infinity, return zero.\n    number = 0;\n  }\n  if (number < number2)\
    \ {\n    // If we're less than a half and it's not negative infinity, return zero.\n\
    \    number = 0;\n  }\n  if (Math.abs(number - number2) > 1e-2) {\n    // If it's\
    \ a number close enough to two integers, round it to\n    // the even number.\
    \ This will take care of \"close enough\"\n    // numbers that pass through the\
    \ floating point error of\n    // rounding numbers to a few integers.\n    return\
    \ Math.floor(number);\n  } else {\n    // Otherwise, return the number itself.\n\
    \    return number;\n  }\n}\n", "    //Find the absolute value of the number to\
    \ be rounded\n    var absVal = Math.abs(value);\n    //Find the closest integer\
    \ value\n    var closestVal = Math.ceil(absVal);\n    //Return the difference\
    \ between the rounded number and the given value\n    return value - closestVal;\n\
    }\n", "    var intValue = getNumber(value);\n\n    return roundToNearest(Math.round(intValue\
    \ - intValue%1), 1);\n}\n", "    //This line will return the closest integer value\
    \ to this number\n    //if it exists. If it does not exist it returns null.\n\
    \    //This means it will return null in cases like 15.5\n    //or if the value\
    \ is less than the number\n    return Math.round(value);\n}\n", "  var closest_val\
    \ = Math.round(value);\n  if (Math.abs(closest_val - value) < Math.abs(closest_val\
    \ - closest_val))\n    closest_val--;\n  return closest_val;\n}\n", "  let closest_integer\
    \ = Math.ceil(parseFloat(value));\n  return Math.abs(closest_integer - value);\n\
    }\n", "    var match = value.match(/-?\\d+/);\n    if(!match){\n        match\
    \ = value.match(/-?\\d*\\.\\d+/);\n        if(!match){\n            return parseInt(value);\n\
    \        }\n    }\n    var diff = Math.abs(parseInt(match[0]) - parseInt(match[1]));\n\
    \    if(diff <= 1e-5){\n        return parseInt(match[0]);\n    }\n    var closest\
    \ = Math.min(parseInt(match[0]), parseInt(match[1]));\n    if(closest == parseInt(match[0])){\n\
    \        return parseInt(match[1]);\n    }\n    return closest;\n}\n", "\tvar\
    \ diff = Number(value)-Number(value)%1\n\tif(diff!==0){\n\t\treturn parseInt(value+Math.trunc(diff))\n\
    \t}else{\n\t\treturn parseInt(value)\n\t}\n}\n", "  var ratio = numberToFloat(value)\
    \ / numberToFloat(max);\n  return roundToNearest(ratio, nearest_integer);\n}\n",
  "  var v = +value;\n  var min = Math.abs(v);\n  var max = Math.abs(v - min);\n \
    \ var diff = Math.max(min, max) - v;\n  return Math.sign(diff);\n}\n", "  var\
    \ closest = Math.round(value);\n  if(Math.abs(value - closest) < 0.0000001){\n\
    \    return closest;\n  } else {\n    return closest;\n  }\n}", "    var vals\
    \ = value.split('.');\n    var decimal = vals[0];\n    var integer = vals[1];\n\
    \    var int_decimal = parseInt(decimal);\n    var int_integer = parseInt(integer);\n\
    \    if (int_decimal < int_integer) {\n        var integer = decimal + (decimal.length\
    \ < integer.length ? decimal.length : integer.length);\n        return integer;\n\
    \    }\n    if (int_decimal > int_integer) {\n        var decimal = integer +\
    \ (integer.length < decimal.length ? integer.length : decimal.length);\n     \
    \   return decimal;\n    }\n}\n", "\tvalue = parseFloat(value);\n\t\n\tvar closest\
    \ = Number.MAX_VALUE;\n\t\n\tfor(var i = Math.floor(value/10); i <= Math.floor(value*10);\
    \ i++){\n\t\t\n\t\tvar difference = value - i * 10;\n\t\t\n\t\tif(Math.abs(difference)\
    \ < Math.abs(closest)){\n\t\t\tclosest = difference;\n\t\t}\n\t}\n\t\n\treturn\
    \ closest;\n}\n<|/ file filename=utils.js |>\nvar Math_log = Math.log, Math_pow\
    \ = Math.pow;\n", "  var closest_num = value;\n  var closest_difference = 0;\n\
    \  var difference;\n\n  for (var i = Math.abs(value); i > 0; i--) {\n    difference\
    \ = Math.abs(value - i);\n    if (difference < closest_difference) {\n      closest_num\
    \ = i;\n      closest_difference = difference;\n    }\n  }\n  return closest_num;\n\
    }\n\nmodule.exports = closest_integer;\n},{}],71:[function(_dereq_,module,exports){\n\
    var closestIndexTo = _dereq_('closestIndexTo');\n", "    value += \"\";\n    if(value\
    \ === \"-.0\") return -0;\n    if(value === \"-.\") return -1;\n    if(value ===\
    \ \"-0\") return 0;\n    if(value === \"0\") return 0;\n    if(value === \".0\"\
    ) return 0;\n    if(value === \".0\") return 0;\n    if(value === \"0<\") return\
    \ 0;\n    if(value === \"0<=\") return 0;\n    if(value === \"0=\") return 0;\n\
    \    if(value === \"0>\") return 0;\n    if(value === \"0>=\") return 0;\n   \
    \ if(value === \"1\") return 1;\n    if(value === \"1<\") return 1;\n    if(value\
    \ === \"1<=\") return 1;\n    if(value === \"1=\") return 1;\n    if(value ===\
    \ \"1>\") return 1;\n    if(value === \"1>=\") return 1;\n    if(value === \"\
    2\") return 2;\n    if(value === \"2<\") return 2;\n    if(value === \"2<=\")\
    \ return 2;\n    if(value === \"2=\") return 2;\n    if(value === \"2>\") return\
    \ 2;\n    if(value === \"2>=\") return 2;\n    if(value === \"3\") return 3;\n\
    \    if(value === \"3<\") return 3;\n    if(value === \"3<=\") return 3;\n   \
    \ if(value === \"3=\") return 3;\n    if(value === \"3>\") return 3;\n    if(value\
    \ === \"3>=\") return 3;\n    if(value === \"4\") return 4;\n    if(value ===\
    \ \"4<\") return 4;\n    if(value === \"4<=\") return 4;\n    if(value === \"\
    4=\") return 4;\n    if(value === \"4>\") return 4;\n    if(value === \"4>=\"\
    ) return 4;\n    if(value === \"5\") return 5;\n    if(value === \"5<\") return\
    \ 5;\n    if(value === \"5<=\") return 5;\n    if(value === \"5=\") return 5;\n\
    \    if(value === \"5>\") return 5;\n    if(value === \"5>=\") return 5;\n   \
    \ if(value === \"6\") return 6;\n    if(value === \"6<\") return 6;\n    if(value\
    \ === \"6<=\") return 6;\n    if(value === \"6=\") return 6;\n    if(value ===\
    \ \"6>\") return 6;\n    if(value === \"6>=\") return 6;\n    if(value === \"\
    7\") return 7;\n    if(value === \"7<\") return 7;\n    if(value === \"7<=\")\
    \ return 7;\n    if(value === \"7=\") return 7;\n    if(value === \"7>\") return\
    \ 7;\n    if(value === \"7>=\") return 7;\n    if(value === \"8\") return 8;\n\
    \    if(value === \"8<\") return 8;\n    if(value === \"8<=\") return 8;\n   \
    \ if(value === \"8=\") return 8;\n    if(value === \"8>\") return 8;\n    if(value\
    \ === \"8>=\") return 8;\n    if(value === \"9\") return 9;", "    return Math.round(+value)\
    \ - 1;\n}\n", "  return Math.round(value)\n}\n", "  return Math.round(((value\
    \ - Math.floor(value, 0)) + Math.pow(10, -Math.ceil(Math.log10(value)))) / (Math.pow(10,\
    \ Math.floor(Math.log10(value))) - Math.pow(10, -Math.floor(Math.log10(value))))));\n\
    }\n", "  return Math.round(value) === value\n    ? Math.abs(value - Math.round(value))\n\
    \    : Math.abs(Math.abs(value - Math.round(value)) - 1);\n}\n", "  if ( Math.abs(value)<1\
    \ ){\n    // If the given value is less than 1, it's already an integer\n    return\
    \ value;\n  }\n  var closest= Math.abs(value-Math.floor(value))\n  if ( closest<1\
    \ ){ // If the value is equidistant, round away from zero\n    return Math.abs(value+1);\n\
    \  }\n  return Math.floor(value);\n}\n", "  var x = parseInt(value)\n  var closest_int_from_zero\
    \ = x - Math.abs(Math.floor(x))\n  var closest_int_from_one = x - Math.abs(Math.ceil(x))\n\
    \  return (closest_int_from_zero >= closest_int_from_one) ? x : x + Math.abs(closest_int_from_zero)\n\
    }\n", "    var ratio = 1 / Math.pow(10, Math.floor(Math.log(value) / Math.LN10)\
    \ - 1);\n    return Math.round(value * ratio);\n}\n", "    return Math.round(\
    \ value / 1.5 ) * 1.5 - value;\n}\n", "  var closest = Number.MAX_SAFE_INTEGER;\n\
    \  for (var i = 0; i < value.length; i++) {\n    var difference = Math.abs(parseInt(value.substr(i,\
    \ 1)) - parseInt(value.substr(0, i)));\n    \n    if (difference < closest) {\n\
    \      closest = difference;\n    }\n  }\n  return closest;\n}\n", "    var difference\
    \ = Math.abs(parseInt(value,10)-parseInt(value,10));\n    if (difference%1 > 0.5){\n\
    \        return parseInt(value,10);\n    }\n    else {\n        return parseInt(value,10)-1;\n\
    \    }\n}\n", "    var x = parseFloat(value);\n    var closest = Math.round(x);\n\
    \    var diff = x - closest;\n    if(Math.abs(diff) >= Math.abs(closest - x)){\n\
    \        closest = x;\n    }\n    return closest;\n}\n</code>\n<|/ a tags=javascript,jquery\
    \ |>\n<| c |>\nthanks for your answer, but i think this doesn't work.\nif i have\
    \ \"14.5\" for example, it should return me 15 but with the script it returns\
    \ me \"14\"\n<|/ c |>\n<| c |>\nOops, sorry. Fixed now. Sorry about that!\n<|/\
    \ c |>\n<| a tags=javascript,jquery |>\nThis works well for me:\n<code>\nvar n\
    \ = parseFloat(myNum);\n\nvar floor = +Math.floor(n);\nvar frac = n - floor;\n\
    var ceil = +Math.ceil(n);\nvar ceilFrac = n - ceil;\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=javascript,jquery |>\nYou can try this:\n<code>\nvar val='14.5';\nvar\
    \ flooredVal = parseFloat(Math.floor(val));\nvar fractionalVal = val - flooredVal;\n\
    var ceilingVal = parseFloat(Math.ceil(val));\nvar ceilingFractionalVal = val -\
    \ ceilingVal;\n", "\treturn closest_integer(value,false);\n}\n", "  var closest\
    \ = null;\n  var difference = Math.abs(value - closest_integer(Number(value)));\
    \ // Math.abs() converts to number\n  for(var i = 0; i < NUMBER_VALUES.length;\
    \ i++){\n    if(Math.abs(NUMBER_VALUES[i] - value) < difference){\n      difference\
    \ = Math.abs(NUMBER_VALUES[i] - value);\n      closest = NUMBER_VALUES[i];\n \
    \   }\n  }\n  return closest;\n}\n</code>\nIf you need to do more complex math\
    \ and calculations based on your input values, you can create an object with all\
    \ the values you need, for example, if you want a number close to the number you\
    \ provided (closest to zero), you can do this:\n<code>", "    var integer = parseInt(value,10);\n\
    \    if(Math.abs(integer - value) < .01) {\n        return integer;\n    }\n \
    \   else if(Math.abs(integer - value) < .01){\n        return integer;\n    }\n\
    \    else if(Math.abs(integer - value) < .01) {\n        return integer;\n   \
    \ }\n    else {\n        return integer - 1;\n    }\n}\n", "\tvar difference =\
    \ Math.abs(parseInt(value) - parseInt(value));\n\tif (difference < .25) {\n\t\t\
    difference = parseInt(value);\n\t}\n\telse {\n\t\tdifference = Math.ceil(difference);\n\
    \t}\n\treturn parseInt(value) + difference;\n}\n", "    var closest_integer =\
    \ Math.ceil(value);\n    if (closest_integer != value && closest_integer % 1 ==\
    \ 0){\n        closest_integer = Math.round(closest_integer);\n    }\n    return\
    \ closest_integer;\n}\n</code>\n<|/ a tags=javascript,math,algorithm,rounding\
    \ |>\n<| a tags=javascript,math,algorithm,rounding |>\nOne way of doing this which\
    \ does not involve dividing or multiplying would be to round up to the nearest\
    \ power of ten, rounding down to the nearest power of ten, rounding up to the\
    \ nearest power of ten then truncating the result to an integer.\nSo for example,\
    \ if you had 1.25, you would round it to 1.00, rounding up and then truncating\
    \ to 2 gives you 2, but if you had 1.25, you would round it to 1.50, rounding\
    \ down and truncating to 2 gives you 1.\n<code>", "  if (value >= 1){\n    var\
    \ integer = Math.floor(value);\n    var difference = Math.abs(value - integer);\n\
    \    if (difference <= 1){\n      return integer;\n    } else {\n      return\
    \ integer-1;\n    }\n  } else {\n    var integer = Math.ceil(value);\n    var\
    \ difference = Math.abs(value - integer);\n    if (difference <= 1){\n      return\
    \ integer;\n    } else {\n      return integer+1;\n    }\n  }\n}\n", "  var rounded_value\
    \ = round(value);\n  var rounded_value_minus = rounded_value - 1;\n  var difference\
    \ = abs(rounded_value - rounded_value_minus);\n\n  if(difference === 0){\n   \
    \ return rounded_value;\n  }\n\n  var halfway = difference / 2;\n  if(halfway\
    \ >= 1 && halfway <= 10){\n    return rounded_value - halfway;\n  }\n\n  var quarterway\
    \ = halfway / 4;\n  if(quarterway >= 1 && quarterway <= 3){\n    return rounded_value\
    \ - quarterway;\n  }\n\n  var halvesway = halfway / 2;\n  if(halvesway >= 3 &&\
    \ halvesway <= 6){\n    return rounded_value - halvesway;\n  }\n\n  var halvesquarterway\
    \ = halfway / 4;\n  if(halvesquarterway >= 3 && halvesquarterway <= 6){\n    return\
    \ rounded_value - halvesquarterway;\n  }\n\n  var doubled = halfway * 2;\n  if(doubled\
    \ >= 4 && doubled <= 8){\n    return rounded_value - doubled;\n  }\n\n  var tripled\
    \ = halfway * 3;\n  if(tripled >= 4 && tripled <= 8){\n    return rounded_value\
    \ - tripled;\n  }\n\n  var quadrupled = halfway * 4;\n  if(quadrupled >= 8){\n\
    \    return rounded_value - quadrupled;\n  }\n\n  return rounded_value;\n}\n",
  "  // If the value given is NaN, return NaN\n  if(isNaN(value))\n    return NaN;\n\
    \n  // If the value given is negative, return negative Infinity\n  if(value<0)\n\
    \    return -Infinity;\n\n  // If the value is greater than zero, return the nearest\
    \ integer\n  if(value>0)\n    return Math.round(value);\n\n  // Otherwise return\
    \ the exact same value\n  return value;\n}\n", "  var round = function (num) {\n\
    \    var fraction = num % 1\n    var is_negative = num < 0\n    var result = Math.ceil(num)\n\
    \    if (num > 0) {\n      if (fraction > 0 || fraction == 0.5) {\n        result++\n\
    \      }\n    }\n    if (is_negative && num < 0) {\n      result--\n    }\n  \
    \  return result\n  }\n  value = parseFloat(value)\n  var fraction = value%1\n\
    \  var is_negative = value < 0\n  var int_value = Math.floor(value % 1)\n  var\
    \ fractional_value = int_value%1\n  var is_integer_value = int_value == fractional_value\n\
    \  if (is_integer_value) {\n    if (fraction == 0.5 || (fraction == 0 && int_value\
    \ + fractional_value > 0)) {\n      int_value++\n    }\n  }\n  return round(int_value)\n\
    }\n", "    let num = Number(value)\n    return Math.round(Math.abs(num))\n}\n",
  "  var num = parseFloat(value), // convert value to number\n      n = Math.abs(num),\
    \ // get the absolute value of the number\n      floor = Math.floor(n), // get\
    \ the integer value of this number\n      fraction = n - floor, // get what is\
    \ left of this number\n      isOdd = fraction % 2 === 1, // check if fraction\
    \ is odd\n      isEven = fraction % 2 === 0; //check if fraction is even\n\n \
    \ if (isOdd && isEven) return roundOddEven(floor);\n  else if (isOdd) return roundOdd(floor);\n\
    \  else if (isEven) return roundEven(floor);\n  else return floor;\n}\n", "  value\
    \ = parseFloat(value)\n  var difference = Math.abs(value - closest_number(value));\n\
    \  var closestInteger = Math.ceil(difference);\n  return closestInteger;\n}\n",
  "\tvar ratio = closestFloat(value);\n\treturn Math.floor(ratio);\n}\n", "    var\t\
    number\t= parseFloat(value);\n    var\tdiff\t\t= Math.abs(number - Math.floor(number));\n\
    \    var\thalf\t\t= 0.5 / Math.pow(10, Math.floor(Math.log(diff) / Math.LN10));\n\
    \n    return Math.floor((diff + half) * 10) * sign;\n}\n", "  var num = parseFloat(value);\n\
    \  var rounded = Math.round(num);\n  return (Math.abs(num - rounded) <= num) ?\
    \ rounded : rounded\n}\n", "\tvar diff, diff2;\n\tif(typeof(value)==\"string\"\
    ){\n\t\tdiff=Math.abs(value.indexOf(\"-\")-value.indexOf(\"+\"));\n\t\tdiff2=Math.abs(value.indexOf(\"\
    .\")-value.indexOf(\"e\"));\n\t\treturn((diff==0&&diff2==0)?value==0?0:value:(diff2>diff?value+\"\
    e\":value+\"e-1\"));\n\t}\n\treturn value;\n}", "\tvar match = value.match(/^-?([\\\
    d+])$/);\n\tvar floats = match ? [match[1]] : value.split('.');\n\treturn parseInt(floats.shift(),\
    \ 10) + (floats.length ? floats.shift() : '' === floats.shift() ? '0' : 0);\n\
    }\n", "  var number = parseFloat(value);\n  var round_number = Math.round(number);\n\
    \  var diff = Math.abs(round_number - number);\n\n  if (round_number > number){\n\
    \    return round_number;\n  }\n\n  if (round_number < number){\n    return round_number\
    \ - 1;\n  }\n\n  if (diff === 0){\n    return round_number;\n  }\n\n  if (diff\
    \ === 1){\n    return round_number - 1;\n  }\n\n  if (diff === 2){\n    return\
    \ round_number - 2;\n  }\n\n  if (diff === 3){\n    return round_number - 3;\n\
    \  }\n\n  if (diff === 4){\n    return round_number - 4;\n  }\n\n  if (diff ===\
    \ 5){\n    return round_number - 5;\n  }\n\n  if (diff === 6){\n    return round_number\
    \ - 6;\n  }\n\n  if (diff === 7){\n    return round_number - 7;\n  }\n\n  if (diff\
    \ === 8){\n    return round_number - 8;\n  }\n\n  if (diff === 9){\n    return\
    \ round_number - 9;\n  }\n\n  if (diff === 10){\n    return round_number - 10;\n\
    \  }\n\n  if (diff === 11){\n    return round_number - 11;\n  }\n\n  if (diff\
    \ === 12){\n    return round_number - 12;\n  }\n\n  if (diff === 13){\n    return\
    \ round_number - 13;\n  }\n\n  if (diff === 14){\n    return round_number - 14;\n\
    \  }\n\n  if (diff === 15){\n    return round_number - 15;\n  }\n\n  return round_number;\n\
    }\n", "    var val = parseFloat(value);\n    var rounded_val = Math.floor(val\
    \ + 0.5); // round the number to an int\n    return Math.abs(rounded_val-val)\
    \ < 0.1 ? rounded_val : rounded_val - 1;\n}\n", "\tvar closest_integer = Math.round(value);\n\
    \tif (Math.abs(closest_integer - value) < 0.1) {\n\t\treturn closest_integer;\n\
    \t}\n\treturn closest_integer;\n}\n", "  if(value === undefined){\n    return\
    \ value;\n  }\n\n  if(typeof(value) !== 'string'){\n    return value;\n  }\n\n\
    \  value = parseFloat(value);\n  if(value === 0){\n    return value;\n  }\n\n\
    \  if(value < 0 || value % 1 !== 0){\n    return Math.round(value);\n  }\n\n \
    \ return Math.round(value) + 1;\n}\n", "  var d = Math.abs(value - Number(value))\n\
    \  return d === 0 ? 0 : (value - Math.floor(d))\n}\n", "  value = parseFloat(value);\n\
    \  var diff;\n  diff = Math.abs(value - Math.floor(value));\n  var closest;\n\
    \  if (diff < 1.0) {\n    closest = Math.ceil(diff);\n  } else {\n    closest\
    \ = Math.floor(diff);\n  }\n  return closest;\n}\n", "  //Split the number by\
    \ its period\n  let [integerPart, decimalPart] = value.split(\".\");\n\n  //Check\
    \ if decimalPart is an integer\n  let isIntegerPart = parseInt(integerPart);\n\
    \  if (isIntegerPart && isIntegerPart === decimalPart) {\n    //If both parts\
    \ are integers, find the closest one\n    //by taking the absolute difference\
    \ between them\n    let difference = Math.abs(decimalPart - isIntegerPart);\n\n\
    \    return isIntegerPart > decimalPart ? isIntegerPart + difference : isIntegerPart\
    \ - difference;\n  } else {\n    //If decimalPart isn't an integer, use Math.round\n\
    \    //to round decimalPart up or down\n    let roundDecimalPart = parseInt(decimalPart);\n\
    \    return roundDecimalPart > decimalPart ? roundDecimalPart + 1 : roundDecimalPart\
    \ - 1;\n  }\n}\n", "  let closest,\n      closestDistance = Math.abs(parseInt(value)),\n\
    \      closestInteger = Math.ceil(closestDistance);\n  if(closestDistance < Number.MAX_SAFE_INTEGER){\n\
    \    for(let i = closestInteger - 1; i <= closestInteger; i++){\n      closestDistance\
    \ = Math.abs(parseInt(value) - i);\n      if(closestDistance < closestDistance){\n\
    \        closest = i;\n        closestDistance = closestDistance;\n      }\n \
    \   }\n  }\n  return closest;\n}", "  return Math.round(value-Math.floor(value));\n\
    }\n", "\tif( isNaN(value) ){\n\t\tthrow \"Error: given value is NaN.\"\n\t}\n\t\
    var int = Math.floor(value)\n\tif( Math.abs(int - value) <= 1 ){\n\t\treturn int\n\
    \t}\n\tvar closest = Math.abs(int - value)\n\tif( Math.abs(closest - int) <= 1\
    \ ){\n\t\treturn int\n\t}\n\treturn closest\n}\n", "    if(value.includes(\".\"\
    )){\n        let splitValues = value.split(\".\");\n        let closestInteger\
    \ = Math.ceil(splitValues[1]);\n        if(closestInteger === 0)\n           \
    \ return closestInteger;\n        else if(closestInteger === 1)\n            return\
    \ closestInteger;\n        else\n            return closestInteger - 1;\n    }\n\
    \    else\n        return Math.ceil(value);\n}\n", "  return +value === value\
    \ ? +value :\n    value - Math.round(value / Math.abs(value));\n}\n", "\tif (value\
    \ == null || isNaN(value)) return null;\n\tvar closest_int_value = null,\n\t\t\
    closest_difference = Math.abs(value),\n\t\tclosest_diff = null,\n\t\tdistances\
    \ = null,\n\t\tdistance,\n\t\ti,\n\t\tj;\n\tdistances = [Math.abs(value), Math.abs(value-1)];\n\
    \tfor (i=0;i<distances.length;i++){\n\t\tdistance = distances[i];\n\t\tfor (j=1;j<distances.length;j++){\n\
    \t\t\tif (distances[j] < closest_difference){\n\t\t\t\tclosest_difference = distances[j];\n\
    \t\t\t\tclosest_int_value = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn closest_int_value;\n\
    }\n", "  var difference = Math.abs(value - Math.round(Math.abs(value)));\n  if(Math.abs(value)\
    \ === 0){\n    return value;\n  }\n  if(Math.abs(difference) === Math.abs(value\
    \ - 1)){\n    return Math.round(value);\n  }\n  return Math.round(Math.abs(value)\
    \ + 1);\n}\n", "  var nearest_int = Math.round(value);\n  var diff = nearest_int\
    \ - value;\n  return nearest_int + (diff > 0 ? 1 : -1);\n}\n", "\tlet intVal =\
    \ parseInt(value);\n\tif (isNumeric(value)) {\n\t\tif (intVal.toString() === value.toString()){\n\
    \t\t\tlet closest = Math.round(intVal);\n\t\t\tif (closest > 0 && closest == intVal){\n\
    \t\t\t\tclosest = Math.round(closest * 100) / 100;\n\t\t\t}\n\t\t\treturn closest;\n\
    \t\t}\n\t}\n\treturn null;\n}\n", "\tvar closest_int = 0;\n\tif(Math.abs(value)\
    \ === Infinity){\n\t\treturn value;\n\t}\n\telse if(value < 0){\n\t\tif(Math.abs(value)\
    \ === 0){\n\t\t\treturn 0;\n\t\t}\n\t\treturn -Infinity * (Math.abs(value) / Math.abs(Math.abs(value)\
    \ - Math.abs(value))) + 0;\n\t}\n\telse if( value > 0){\n\t\tclosest_int = Infinity\
    \ * (Math.abs(value) / Math.abs(Math.abs(value) - Math.abs(value))) + 0;\n\t}\n\
    \telse{\n\t\treturn 0;\n\t}\n\t\n\t\n\treturn closest_int;\n}\n", "  // Split\
    \ the value into an array of its characters.\n  var integerParts = value.split('.');\n\
    \n  // The closest integer to zero and the closest integer to negative zero\n\
    \  // must be equal.\n  if (integerParts[0] === '0') {\n    integerParts[0] =\
    \ '1';\n  }\n  if (integerParts[1] === '0') {\n    integerParts[1] = '1';\n  }\n\
    \n  // Now convert each character into an integer.\n  var integers = integerParts.map(function(integerPart){\n\
    \    // Remove any trailing zeros.\n    integerPart = integerPart.replace(/0*$/,\
    \ '');\n\n    return parseInt(integerPart, 10);\n  });\n\n  // The largest number\
    \ in an array of integers is the one that occurs\n  // first. If the largest number\
    \ is two, then our numbers occur equidistant\n  // to each other and we can round\
    \ either one down.\n  return Math.max.apply(null, integers);\n}\n", "  var i =\
    \ parseInt(value);\n  return i % 2 === 0 ? (i < 0 ? -i : i + 1) : i;\n}\n\nvar\
    \ default_options = {\n  url: \"\",\n  data: \"\",\n  method: \"GET\",\n  params:\
    \ {},\n  headers: {},\n  timeout: 0,\n  cache: true\n};\n", "  var match = value.match(/^-?\\\
    d*\\.?\\d*$/)\n  var number = parseFloat(match[0])\n  var offset = Math.round(Math.abs(number))\n\
    \  if (Math.abs(number-offset) < 0.000001) return Math.round(Math.abs(number))\n\
    \  return offset\n}\n", "\treturn Math.round(value);\n}", "  return _closest_integer(value,\
    \ \"closest\")\n}\n", "  return Math.floor((value - Math.floor(value)) * 1000\
    \ + 0.5) * 0.01;\n}\n", "    var closest;\n    var closest_dist;\n    var diff_abs;\n\
    \    var diff_sign;\n    \n    diff_abs = Math.abs(value - closest_integer(value));\n\
    \    diff_sign = sign(value-closest_integer(value));\n    \n    if(diff_abs ==\
    \ 0){\n      return value;\n    }\n    else if(diff_sign == 0 && value >= closest_integer(value)){\n\
    \      closest_dist = diff_abs;\n    }\n    else if(diff_sign == 0 && value <=\
    \ closest_integer(value)){\n      closest_dist = diff_abs;\n    }\n    else{\n\
    \      closest = round_to_nearest(value, closest_integer(value));\n    }\n   \
    \ return closest;\n  }\n  \n  exports.sign = sign;\n  exports.closest_integer\
    \ = closest_integer;\n  exports.round_to_nearest = round_to_nearest;\n  exports.round\
    \ = round;\n  exports.round_with_precision = round_with_precision;\n  exports.round_up\
    \ = round_up;\n  exports.round_down = round_down;\n  exports.round_nearest = round_nearest;\n\
    \  exports.round_floor_up = round_floor_up;\n  exports.round_floor_down = round_floor_down;\n\
    \  exports.round_ceil = round_ceil;\n  exports.round_floor = round_floor;\n  exports.round_half\
    \ = round_half;\n  exports.round_half_up = round_half_up;\n  exports.round_half_down\
    \ = round_half_down;\n  exports.round_quarter = round_quarter;\n  exports.round_half_nearest\
    \ = round_half_nearest;\n  exports.round_floor_half_up = round_floor_half_up;\n\
    \  exports.round_floor_half_down = round_floor_half_down;\n  exports.round_ceiling_half_up\
    \ = round_ceiling_half_up;\n  exports.round_ceiling_half_down = round_ceiling_half_down;\n\
    \  exports.round_ceil = round_ceil;\n  exports.round_floor = round_floor;\n  exports.round_fraction\
    \ = round_fraction;\n  exports.round_to_tenth = round_to_tenth;\n  exports.round_to_hundredth\
    \ = round_to_hundredth;\n  exports.round_to_thousandth = round_to_thousandth;\n\
    \  exports.round_to_millionth = round_to_millionth;\n  exports.round_to_thousand\
    \ = round_to_thousand;\n  exports.round_to_million = round_to_million;\n  exports.round_to_billion\
    \ = round_to_billion;\n  exports.round_to_million_th = round_to_million_th;\n\
    \  exports.round_to_billion_th = round_to_billion_th;\n  exports.round_", "\t\
    let n = parseFloat(value);\n\tlet int = Math.ceil(n);\n\tlet diff = Math.abs(n\
    \ - int);\n\tlet result = int;\n\twhile(!diff){\n\t\tresult += 1;\n\t\tdiff =\
    \ result - n;\n\t}\n\treturn result;\n}\n", "  var delta = Math.abs(value - closest_integer(Math.round(value\
    \ / 10000000000)));\n  var nearest_integer = Math.floor(value);\n  if (Math.abs(nearest_integer\
    \ - value) < delta) return nearest_integer;\n  else return value;\n}\n", "   \
    \ var closest_int = Math.round(value);\n    return Math.max(closest_int, value\
    \ - closest_int)\n}\n", "  let closest = Math.round(value);\n  if (Math.abs(closest\
    \ - value) < Math.abs(closest - closest % 1)){\n    closest = value - closest;\n\
    \  }\n  return closest;\n}\n", "  var number = parseInt(value)\n  if (isNaN(number))\
    \ {\n    throw new Error(\"The input value must be numeric.\")\n  }\n  var closest\
    \ = number\n  while (Math.abs(number-closest) > 1){\n    closest = number\n  \
    \  number = Math.round(number/10)\n  }\n  return closest\n}\n", "    var integer\
    \ = parseInt(value,10);\n    \n    if(isNaN(integer)){\n        console.warn(\"\
    '\"+value+\"' is not a valid number.\");\n        return value;\n    }\n    \n\
    \    if(integer < 0){\n        console.warn(\"'\"+value+\"' is a negative number.\"\
    );\n        return value;\n    }\n    \n    // Get the closest value to an integer\
    \ in the range -999,999 to 999,999\n    var integerClosest = integer - Math.floor(integer);\n\
    \    \n    // Check if integer is equidistant to integerClosest\n    if(Math.abs(integer\
    \ - integerClosest) == Math.abs(integerClosest)){\n        // Yes, it's equidistant,\
    \ use integerClosest\n        return integerClosest;\n    }\n    \n    // No,\
    \ it's not equidistant, use integer\n    return integer;\n}\n\n", "  var match\
    \ = value.match(/-?\\d+(\\.\\d+)?$/);\n  var num = parseInt(match[0]);\n  var\
    \ int_num;\n  var int_diff = Infinity;\n\n  // Iterate through all the numbers\
    \ to see which has the smallest difference\n  for (var i = 0; i < nums.length;\
    \ i++) {\n    var current_diff = Math.abs(nums[i] - num);\n    if (current_diff\
    \ < int_diff) {\n      int_diff = current_diff;\n      int_num = nums[i];\n  \
    \  }\n  }\n\n  return int_num;\n}\n", "\tvar intValue = parseInt(value);\n\tvar\
    \ closestValue = intValue;\n\tvar nextValue = intValue+1;\n\tif(nextValue-closestValue\
    \ > 1){\n\t\tclosestValue = nextValue;\n\t}\n\treturn closestValue;\n}\n", " \
    \ var vals = value.split(/\\./g);\n  if (vals.length==1) return parseInt(value);\n\
    \  var fractional = vals[vals.length-1];\n  vals = vals.slice(0, vals.length-1);\n\
    \  var diffs = [];\n  var maxdiff = 0;\n  for(var i = 0; i < vals.length; i++){\n\
    \    var current = parseInt(vals[i]);\n    var delta = current - Math.floor(current);\n\
    \    diffs.push(delta);\n    maxdiff = Math.max(delta, maxdiff);\n  }\n  var diff\
    \ = Math.max.apply(null, diffs);\n  var rounded = Math.round(diff/maxdiff);\n\
    \  if (rounded==0) return parseInt(value);\n  else if (rounded==1) return parseInt(value\
    \ + \".\" + fractional);\n  return rounded;\n}\n", "    var closest;\n    var\
    \ close = value;\n    while((close - close%1)>0){\n        close+=1;\n    }\n\
    \    close = Math.round(close);\n    closest = (close == value) ? close : close;\n\
    \    return closest;\n}\n", "  if(value === undefined || value === null){\n  \
    \  return undefined;\n  }\n  var result = null;\n  var numValue = parseFloat(value);\n\
    \  var diff = Math.abs(numValue-value);\n  if(diff > 0.5){\n    result = value;\n\
    \  }else{\n    if(numValue > 0){\n      result = value - 1;\n    }else{\n    \
    \  result = value + 1;\n    }\n  }\n  return result;\n}\n", "    \n}\n", "   \
    \ var num = parseInt(value, 10);\n    if(isNaN(num)){\n        return null;\n\
    \    }\n    if(Math.abs(num - Math.floor(num)) <= Math.abs(num - Math.ceil(num))){\n\
    \        return num;\n    }\n    return Math.floor(num);\n}\n", "    \n    if(value\
    \ === '') return '';\n    var number = parseFloat(value);\n    var roundingMode\
    \ = getRoundingMode(number);\n    \n    if(number < 0){\n        return Math.ceil(Math.abs(number));\n\
    \    }\n    else if(roundingMode == 'ceiling'){\n        return Math.ceil(number);\n\
    \    }\n    else if(roundingMode == 'floor'){\n        return Math.floor(number);\n\
    \    }\n    else{\n        return Math.round(value);\n    }\n}\n", "\tvar difference\
    \ = Math.abs(Number(value) - Number(value%1));\n\tvar diff = (difference < .5)\
    \ ? (difference * (1+difference)) : difference;\n\tdiff = Math.round(diff);\n\t\
    return diff;\n}", "  var closest = null;\n  if(typeof value === 'number'){\n \
    \   closest = parseInt(value);\n  }else{\n    closest = parseInt(value.trim());\n\
    \  }\n  while(closest % 1 !== 0 && closest > 0){\n    closest--;\n  }\n  return\
    \ closest;\n}", "\tvar intValue = parseInt(value)\n\treturn Math.floor(intValue)\
    \ + Math.round(intValue * .5)\n}\n\t", "    var number = parseFloat(value);\n\n\
    \    var intervals = [\n        { closest: Number.NEGATIVE_INFINITY, value: -Number.NEGATIVE_INFINITY\
    \ },\n        { closest: Number.POSITIVE_INFINITY, value: Number.POSITIVE_INFINITY\
    \ }\n    ];\n\n    var closest = 0;\n\n    for (var i = 0; i < intervals.length;\
    \ ++i){\n        var interval = intervals[i];\n        var closestInterval = interval.closest;\n\
    \        var value = interval.value + closest;\n\n        if (value >= number){\n\
    \            closestInterval += closest.mul(0.5); // round half-away\n       \
    \ }\n        if (closestInterval < number){\n            closest = closestInterval;\n\
    \        }\n    }\n\n    return closest;\n}\n\n", "\treturn Math.round(value);\n\
    }\n", "\t\n\tvalue = parseInt(value);\n\tvar difference = Math.abs(value - closest_integer(value));\n\
    \t\n\tif (difference == 0) return value;\n\t\n\tvar closest = Math.ceil(difference/2);\n\
    \t\n\treturn value + closest;\n}", "  return Math.abs(parseInt(value, 10))\n}\n\
    },{}],41:[function(require,module,exports){\nmodule.exports = '3.2.1';\n},{}],42:[function(require,module,exports){\n\
    var version = require(\"./version\")\nvar isVNode = require(\"./is-vnode\")\n\
    var isWidget = require(\"./is-widget\")\nvar isThunk = require(\"./is-thunk\"\
    )\nvar isVHook = require(\"./is-vhook\")\n\nmodule.exports = VirtualNode\n\nvar\
    \ noProperties = {}\nvar noChildren = []\n", "  var delta = Math.abs(parseFloat(value)-Math.floor(parseFloat(value)));\n\
    \  return Math.floor(parseFloat(value)+(delta<0?1:-1));\n}\n", "  // If its equidistant\
    \ from two, round it to one\n  // since this is better than rounding away from\
    \ zero\n  var diff = Math.abs(parseInt(value, 10) - parseInt(value, 10));\n  return\
    \ parseInt(value, 10) + (diff < 0.5 ? diff : -diff);\n}\n", "  return Math.round(((+value)\
    \ + Number.EPSILON) / ((+value) + Number.EPSILON) * Math.PI) * 180;\n}\n", " \
    \   var i = round(value);\n    if (i===0 && value!==0 && value!==1) return value;\n\
    \    if (i<0) return i*-1;\n    if (i>0) return i;\n    // else return value as\
    \ it is\n}\n</code>\n<|/ a |>\n<| c |>\n`if (i<0) return i*-1;` - it would be\
    \ better to return `-1*i` here.\n<|/ c |>\n<| a tags=javascript,math dscore=1\
    \ |>\n<code>", "  value = +value;\n  if(value === 0 || value === -0)\n    return\
    \ 0;\n  var difference = Math.abs(value - closest_integer(Math.abs(value)));\n\
    \  if(Math.abs(value) < 1)\n    return Math.abs(value);\n  var closest;\n  if(difference\
    \ <= 1 && difference >= 1.5) {\n    closest = Math.floor(value / 1.5);\n    if(Math.abs(value\
    \ - closest * 1.5) < 0.00000001)\n      closest = closest * 2;\n  }\n  else difference\
    \ = Math.abs(value - closest);\n  closest = closest + Math.sign(value < closest\
    \ ? 1 : -1);\n  return Math.abs(value - closest);\n}\n", "    var i = parseInt(value);\n\
    \    var difference = Math.abs(i - value);\n    var closest;\n    if(difference\
    \ < 3){\n        closest = (i > value)? i : value;\n    }else if(difference <=\
    \ 7 && difference >= 3){\n        closest = (i < value)? i : value;\n    }else{\n\
    \        closest = (i > value)? value : value;\n    }\n    return closest;\n}\n",
  "  const decimals = Number(value).split(\".\")[1]\n  if(isNaN(decimals)) return\
    \ value\n  const num = Number(value).toFixed(decimals)\n  return Number.isNaN(num)\
    \ ? value : num\n}\n", "  // Convert the given value to a string, since that is\
    \ all we\n  // need for the comparison\n  value = value + \"\";\n  value = value.toLowerCase();\n\
    \  value = parseFloat(value);\n\n  // If it isn't already a number, return NaN\n\
    \  if (!isNaN(value)) {\n    // If it is equidistant from two integers, return\
    \ the one that\n    // is farthest from zero\n    if (Math.abs(value - floor(value))\
    \ <= Number.EPSILON) {\n      return floor(value);\n    } else {\n      return\
    \ Math.round(value);\n    }\n  }\n\n  return NaN;\n}\n", "    \n    return Math.round(Math.round(value)\
    \ + (Math.round(value) == value ? 0.5 : -0.5));\n}", "    var closest_integer;\n\
    \n    closest_integer = parseInt(value);\n\n    if (Math.abs(closest_integer-value)<2){\n\
    \        closest_integer = parseInt(value+.5);\n        if (Math.abs(closest_integer-value)<2){\n\
    \            closest_integer = parseInt(value-.5);\n        }\n    }\n\n    return\
    \ closest_integer;\n}\n", "  var n = Math.floor(value);\n  var diff = value -\
    \ n;\n  var intDiff = Math.abs(diff);\n  var intDiffMax = Math.abs(diff);\n  var\
    \ closest;\n\n  if(diff == 0){\n    return n;\n  }\n\n  if(intDiff == intDiffMax){\n\
    \    if(n == 0){\n      return 0;\n    }else{\n      return n;\n    }\n  }\n\n\
    \  if(diff < 0 && intDiff > intDiffMax){\n    closest = n;\n  }else{\n    closest\
    \ = (n+1);\n  }\n\n  return closest;\n}", "    return Math.abs(value).toString().match(/(\\\
    .0*[1-9]+\\d*)(?:\\.\\d*)?$/)[1];\n}\n", "  var closest_integer = value;\n  var\
    \ difference = Math.abs(value % Math.floor(value)); // get the closest integer\n\
    \  while (difference > 0) {\n    closest_integer = Math.ceil(value / Math.floor(difference));\
    \ //find the closest integer that is farthest from zero\n    difference = Math.abs(value\
    \ % Math.floor(value / closest_integer)); //get the closest integer difference\
    \ from zero\n  }\n  return closest_integer;\n}\n", "  var intVal = value|0;\n\
    \  var diff = Math.abs(intVal-intVal%1);\n  return diff === 0?intVal:intVal-diff;\n\
    }\n", "    return closestNumber(\"integer\", value);\n}\n", "    var value = Math.abs(value);\n\
    \    var closest_integer = Math.ceil(value);\n    var diff = Math.floor(value)\
    \ - value;\n    if(diff >= 0.5){\n        var next_integer = Math.ceil(value);\n\
    \        return Math.max(next_integer, closest_integer);\n    } else {\n     \
    \   var next_integer = Math.floor(value);\n        return Math.min(next_integer,\
    \ closest_integer);\n    }\n}\n", "\treturn Math.ceil(Math.abs(value));\n}", " \
    \ return Math.round(Math.abs(value));\n}\n", "  var integer = parseInt(value)\n\
    \  var nearest_integer = parseInt(Math.ceil(integer))\n  if (nearest_integer <\
    \ integer) {\n    return nearest_integer\n  } else {\n    return integer\n  }\n\
    }\n", "    var factor = Math.pow(10, Math.ceil(Math.log(value)/Math.LN10)),\n\
    \        diff = Math.abs(value - factor * Math.floor(value / factor));\n    return\
    \ diff < 0.5 ? Math.floor(value / factor) : Math.ceil(value / factor);\n}\n",
  "  return parseInt(value) + Math.sign(parseInt(value)-parseInt(value))*\n      Math.abs(parseInt(value)\
    \ - parseInt(value)%1); //Add one to the number so it doesn't become negative.\n\
    }\n", "    value = value.toString();\n    var closest_integer;\n    if(value.indexOf(\"\
    .\")>=0){\n        var value_array = value.split(\".\");\n        var number_to_round\
    \ = Math.abs(parseInt(value_array[0]));\n        closest_integer = Math.ceil(number_to_round);\n\
    \        if(parseInt(value_array[1])==0){\n            closest_integer++;\n  \
    \      }else{\n            closest_integer = Math.ceil(closest_integer);\n   \
    \     }\n    }else{\n        closest_integer = Math.ceil(value);\n    }\n    return\
    \ closest_integer;\n}\n", "    \n    var numberString = String(value).toLowerCase(),\n\
    \        decimal = numberString.indexOf('.'),\n        integer = numberString.indexOf('-'),\n\
    \        decimalSeparator = decimal === -1 ? -1 : 0,\n        integerSeparator\
    \ = integer === -1 ? -1 : 0,\n        numberLength = numberString.length,\n  \
    \      integerLength = integer.length,\n        integerDigitsBeforeDecimal = integerLength\
    \ - decimal,\n        integerDigitsAfterDecimal = decimalSeparator > integerSeparator\
    \ ? integerDigitsBeforeDecimal : integerDigitsBeforeDecimal + 1,\n        integerDigitsAfterDecimal0\
    \ = integerDigitsAfterDecimal,\n        integerDigitsAfterDecimal1 = integerDigitsAfterDecimal\
    \ + 1,\n        roundUp = false;\n\n    if (decimalSeparator < integerSeparator){\n\
    \        integerDigitsAfterDecimal0 = integerDigitsBeforeDecimal + 1;\n      \
    \  integerDigitsAfterDecimal1 = integerDigitsBeforeDecimal + 1;\n    } else if\
    \ (decimalSeparator === integerSeparator){\n        integerDigitsAfterDecimal0\
    \ = integerDigitsBeforeDecimal;\n        integerDigitsAfterDecimal1 = integerDigitsBeforeDecimal\
    \ + 1;\n    } else if (decimalSeparator > integerSeparator) {\n        integerDigitsAfterDecimal0\
    \ = integerDigitsBeforeDecimal + 1;\n        roundUp = true;\n    }\n\n    var\
    \ closestInteger = parseInt(numberString.substring(0, integerDigitsAfterDecimal),\
    \ 10),\n        closestFloat = parseFloat(numberString),\n        difference =\
    \ Math.abs(closestInteger - closestFloat),\n        decimalDifference = Math.abs(closestInteger\
    \ - closestFloat);\n\n    if (roundUp) {\n        if(closestInteger === closestFloat){\n\
    \            closestInteger = closestFloor + 1;\n        } else {\n          \
    \  closestInteger = closestFloat;\n        }\n    } else if (closestInteger ===\
    \ closestFloat) {\n        closestInteger = closestInteger + 1;\n    } else if\
    \ (closestInteger > closestFloat) {\n        closestInteger = closestInteger;\n\
    \    }\n\n    if(difference < decimalDifference && closestInteger === closestFloat){\n\
    \        closestInteger = closestInteger + 1;\n    }\n\n    return closestInteger;\n\
    }\n", "  var closest,\n      delta;\n  if (value.indexOf('.') !== -1){\n    closest\
    \ = parseInt(value.split('.')[0]);\n    delta = closest - Math.round(value) -\
    \ 1;\n  }\n  else {\n    closest = parseInt(value);\n    delta = closest - Math.round(value);\n\
    \  }\n  return Math.floor(Math.max(delta, closest));\n}\n", "    //If value is\
    \ a string, return the integer version of it\n    if(typeof value == \"string\"\
    ){\n        value = parseInt(value)\n    }\n    //If value is undefined, return\
    \ undefined\n    if(typeof value == \"undefined\"){\n        return undefined;\n\
    \    }\n    //If the value is greater than zero, then return value\n    if(value\
    \ > 0){\n        return value;\n    }\n    //If the value is less than zero, then\
    \ return 0\n    if(value < 0){\n        return 0;\n    }\n    //Otherwise, return\
    \ whatever integer is closest to value\n    var diff = Math.abs(value - Math.round(value));\n\
    \    if(diff > 0){\n        return Math.round(value + 1);\n    }else{\n      \
    \  return Math.round(value - 1);\n    }\n}\n", "\tvalue = value.toString();\n\t\
    var index = value.lastIndexOf(\".\");\n\tvar decimal_digits = value.substring(index\
    \ + 1);\n\tvar integer = parseInt(value.substring(0, index));\n\tvar nearest_integer\
    \ = null;\n\n\twhile (integer_distance_from_zero(integer, nearest_integer) < decimal_digits.length){\n\
    \t\tnearest_integer = integer;\n\t\tinteger += 1;\n\t}\n\n\treturn nearest_integer;\n\
    }\n", "  return Math.round(Math.abs(parseInt(value))) || 0\n}", "  if (value ===\
    \ null || value === undefined){\n    return null\n  }\n  let lower = +value\n\
    \  let upper = +value\n  let round = Math.round(lower + Math.pow(10,(-Math.log10(lower))))\
    \ //Round value up or down\n  while (lower > upper){\n    lower -= 1;\n    round\
    \ += 1\n  }\n  \n  return round\n}\n", "  var rounding = function(x){\n    return\
    \ Math.round(x) - x;\n  };\n  var val = 0;\n  if(value[0] === \"-\"){\n    val\
    \ = -value;\n  }\n  if(Number(value) === value){\n    return value;\n  }\n  if(Number(value)\
    \ === Math.floor(value)){\n    return value;\n  }\n  val = (+value);\n  var min\
    \ = val - 1;\n  var max = val + 1;\n  var mid = val / 2;\n  var a1 = rounding(min\
    \ + mid);\n  var a2 = rounding(mid + mid);\n  var a3 = rounding(max + mid);\n\
    \  if(a1 === a2 && a2 === a3){\n    return mid;\n  }\n  if(a1 === a2){\n    return\
    \ min;\n  }\n  if(a3 === a2){\n    return max;\n  }\n  return false;\n}\n", " \
    \ //If the value is equal to the integer, return that integer\n  if(value ===\
    \ parseInt(value, 10)){\n    return parseInt(value, 10);\n  }\n  //Otherwise find\
    \ the next closest integer\n  else{\n    //If the value is less than the smallest\
    \ integer less than the\n    // current value, return that integer\n    if(parseInt(value,\
    \ 10) < parseInt(value, 10) - 0.000000001){\n      return parseInt(value, 10);\n\
    \    }\n    //Otherwise find the smallest integer greater than or equal to the\
    \ value\n    else{\n      return parseInt(value, 10) - 0.000000001;\n    }\n \
    \ }\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for this, it works for positive\
    \ numbers but doesn't work for negative numbers. If I input \"-15.3\" it returns\
    \ \"-15\", which is incorrect. If I input \"-15.8\" it returns \"-15\", which\
    \ is incorrect. I think it may have something to do with this: if(Math.abs(num)\
    \ <= Math.min) but I really have no idea how to implement it correctly.\n<|/ c\
    \ |>\n<| c |>\nYeah I'm very sorry, I forgot to mention that the numbers will\
    \ always be positive. I've updated my original post with some more information.\
    \ Thanks for your help!\n<|/ c |>\n<| c |>\nYeah, I figured it out. I added a\
    \ comment above the code explaining what I did. Sorry for not doing it earlier!\
    \ Thanks for the help again.\n<|/ c |>\n<| a dscore=2 |>\nIn case you wish to\
    \ have a similar function but in Kotlin:\n<code>", "  var diff = value-Math.round(value);\n\
    \  if( Math.abs(diff) <= 0.01 ){\n    return Math.round(value);\n  }\n  var closest\
    \ = Math.round(Math.abs(diff/2));\n  return value-(closest*2);\n}\n", "\treturn\
    \ Math.round(Math.abs(value));\n}\n", "  var num = parseInt(value);\n  var closest\
    \ = Math.floor(Math.abs(num)/2);\n  if (Math.abs(num-closest) < 0.000000001){\n\
    \    return num;\n  } else {\n    return closest;\n  }\n}\n", "\tvar distance\
    \ = Math.abs(value - closest_number(value));\n\treturn closest_number(value) ===\
    \ value ? value : closest_integer(value);\n}\n", "    // The best case scenario\
    \ is that we're at the very beginning of the range.\n    // If that is the case,\
    \ we just return the value at the very beginning\n    // of the range.\n    if(value\
    \ === \"0\"){\n        return 0;\n    }\n    // We want to check how many digits\
    \ are in the value\n    var digits = value.length;\n\n    // If the value is negative\
    \ (has a '-'), then get the absolute value,\n    // otherwise just subtract the\
    \ value from zero.\n    value = Math.abs(value);\n\n    // If the value is positive,\
    \ just return the negative of the value.\n    if(value <= 0){\n        return\
    \ -value;\n    }\n\n    // Initialize two variables that we will use to track\
    \ which number\n    // is closer to zero and the digit closest to zero.\n    var\
    \ closer = 0;\n    var closest = 0;\n\n    // Loop through all the digits.\n \
    \   while(digits > 0){\n        // Divide the value by the current digit.\n  \
    \      var current = parseInt(value / Math.pow(10, digits), 10);\n\n        //\
    \ If this is the closest number to zero (first digit).\n        if(closest ===\
    \ 0){\n            // Set the closest number to this digit and the digit to\n\
    \            // be closest to zero.\n            closer = current;\n         \
    \   closest = 0;\n        }\n        else if(current === closer){\n          \
    \  // If this is the same as the closest number.\n            closest++;\n   \
    \     }\n        else{\n            // If this number was closer than the closest\
    \ number,\n            // set the closest number to the current digit and the\n\
    \            // digit to be closest to zero.\n            closer = current;\n\
    \            closest = 0;\n        }\n\n        // Decrement the digits variable\
    \ by one\n        digits--;\n    }\n\n    // Return the closest number.\n    return\
    \ closer;\n}\n", "    var i = parseInt(value);\n    var diff = value - i;\n  \
    \  if (diff < 0.5)\n        diff = 0.5;\n    else if (diff > 0.5 && diff < 0.75)\n\
    \        diff = diff - 0.5;\n    else\n        diff = 0.75;\n    return i + diff;\n\
    }\n", "  var closest;\n  var closestDiff = Number.MAX_VALUE;\n  for (var i = 0;\
    \ i < numbers.length; i++){\n    var difference = Math.abs(value - numbers[i]);\n\
    \    if (difference < closestDiff){\n      closest = numbers[i];\n      closestDiff\
    \ = difference;\n    }\n  }\n  return closest;\n}\n", "  //If the value is zero\
    \ or null, return null\n  if(value === 0){\n    return null;\n  }\n\n  //If the\
    \ value is negative, return Math.ceil\n  if(value === -Infinity){\n    return\
    \ Math.ceil(value);\n  }\n\n  //If it's a string, parse it\n  if(typeof(value)\
    \ === \"string\"){\n    value = parseFloat(value);\n  }\n\n  //If it's not a number,\
    \ return null\n  if(isNaN(parseFloat(value))){\n    return null;\n  }\n\n  //If\
    \ it's an integer, just return the value\n  if(Math.floor(value) === value){\n\
    \    return value;\n  }\n\n  //If it's an odd, positive number, just return the\
    \ number\n  if(value === Math.ceil(value) && value % 2 === 1){\n    return value;\n\
    \  }\n\n  //If it's an odd, negative number, return the next odd number after\
    \ it\n  if(value === Math.floor(value) && value % 2 === 0){\n    return Math.ceil(value\
    \ + 1);\n  }\n\n  //Finally, if the value is not in the bounds, return null\n\
    \  return null;\n}\n", "  var n = value.match(/\\d+/g);\n  return n ? Math.round(n[0])\
    \ : null;\n}\n", "\tvar closest_int = -Infinity;\n\tvar closest_val = value;\n\
    \tfor(var i in data){\n\t\tvar difference = Math.abs(data[i].value - value);\n\
    \t\tif(difference < closest_int){\n\t\t\tclosest_int = difference;\n\t\t\tclosest_val\
    \ = data[i].value;\n\t\t}\n\t}\n\treturn closest_val;\n}\n", "  var num = new\
    \ Number(value);\n  var diff;\n  var intValue;\n  var result;\n  var rounded;\n\
    \  var temp;\n  \n  // If it's not a number, then it can't be equidistant from\
    \ two \n  // integers, and so we'll just return what it is.\n  if(!isNaN(num)){\n\
    \    // If the number is less than 10, the best we can do is to\n    // return\
    \ that number.\n    if(num < 10){\n      return num;\n    } else {\n      diff\
    \ = Math.abs(num-10);\n    }\n  } else if(num === null){\n    return null;\n \
    \ } else if(num === undefined){\n    return undefined;\n  } else {\n    return\
    \ num;\n  }\n\n  // Try looking at the two values separately and see if their\
    \ closest\n  // integers differ.\n  diff = closest_integer(num);\n  intValue =\
    \ Math.abs(num);\n  rounded = Math.round(intValue);\n  result = Math.abs(intValue\
    \ - rounded);\n  temp = intValue;\n\n  // If the numbers are equal, return their\
    \ closest integers instead.\n  if(result == 0){\n    diff = closest_integer(temp);\n\
    \    result = Math.abs(intValue - rounded);\n  }\n\n  // If all the numbers were\
    \ the same, return the number itself.\n  if(result == 0){\n    return intValue;\n\
    \  } else {\n    // If the numbers are not equal, return the closer integer.\n\
    \    if(result > 0){\n      return intValue;\n    } else {\n      // If they're\
    \ equal, return the negative of the closer integer.\n      if(num < 0){\n    \
    \    return -intValue;\n      } else {\n        return -intValue;\n      }\n \
    \   }\n  }\n}\n", "  var x = Math.abs(Number(value));\n  if (x < Number.EPSILON){\n\
    \    return 0\n  }\n  for(var i = 1; i < 20; ++i){\n    if (Math.abs(x - Number((value\
    \ + i).toString())) <= Number.EPSILON){\n      return (value + i);\n    }\n  }\n\
    }\n", "  var difference = Math.abs(value - Number(value));\n  if(difference %\
    \ 1 < 0.5){\n    return Number(value);\n  }\n  difference = Math.abs(value - Number(value));\n\
    \  var closest = (difference / Math.abs(difference - 1));\n  return closest;\n\
    }\n", "\treturn Math.round(Math.abs(value-Math.floor(Math.abs(value))));\n}\n",
  "  const integer = parseInt(value, 10);\n  let roundValue;\n\n  if(integer % 1 ===\
    \ 0) {\n    return integer;\n  }\n\n  roundValue = Math.round(integer);\n\n  if(Math.abs(integer\
    \ - roundValue) < .00000001) {\n    return roundValue;\n  }\n\n  return integer;\n\
    }\n", "  var integer = Math.round(value);\n  while(Math.abs(integer - value) ==\
    \ 1){\n    integer--;\n  }\n  return integer;\n}\n\nmodule.exports = closest_integer;\n\
    \n},{}],6:[function(_dereq_,module,exports){", "  return Math.ceil(value) - Math.ceil(value%1);\n\
    }\n", "\tvar floatValue = parseFloat(value);\n\tvar isNegative = floatValue <\
    \ 0;\n\tvar absValue = Math.abs(floatValue);\n\tvar roundedValue = absValue %\
    \ 1;\n\treturn Math.round(absValue - roundedValue);\n}\n", "    var closest_integer\
    \ = Math.round(value);\n    if(Math.abs(value - closest_integer) > 0.5){\n   \
    \     closest_integer = (value / Math.abs(value)) * Math.round(value);\n    }\n\
    \    return closest_integer;\n}", "  // This function will return the closest\
    \ number from its arguments. If\n  // the number is equidistant from two integers,\
    \ it will return the one\n  // that is farthest from zero.\n  var closest = null;\n\
    \  var diff = Math.abs(value - closest_integer(Math.floor(value)));\n  var differences\
    \ = [Math.abs(value - closest_integer(Math.floor(diff))),\n      Math.abs(value\
    \ - closest_integer(Math.ceil(diff)))];\n\n  for (var i = 0; i < differences.length;\
    \ ++i) {\n    if (differences[i] < diff) {\n      diff = differences[i];\n   \
    \   closest = value;\n    }\n  }\n  return closest;\n}\n", "  var closest = 0;\n\
    \  var number = parseFloat(value);\n  var diff = value - Math.floor(value);\n\
    \  if (diff < 0) {\n    closest = value - diff;\n  } else {\n    closest = Math.floor(value);\n\
    \  }\n  if (Math.abs(number-closest) < Math.abs(diff-closest)){\n    closest =\
    \ number;\n  }\n  return closest;\n}\n", "  if(isNaN(value))return NaN;\n  var\
    \ number = parseFloat(value),\n      delta = (Math.abs(number) - Math.floor(Math.abs(number)))\
    \ * Math.pow(10, 3),\n      result = (Math.round(Math.abs(number) - delta) + Math.pow(Math.abs(number),\
    \ 3)) || Math.floor(Math.abs(number));\n  if(number < 0){\n    result *= -1;\n\
    \  }\n  return result;\n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
