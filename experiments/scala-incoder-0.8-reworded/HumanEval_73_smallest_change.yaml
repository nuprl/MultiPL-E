name: HumanEval_73_smallest_change
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a list arr of integers, find the minimum number of elements that\n\
  \    // need to be changed to make the list palindromic. A palindromic list is a\
  \ list that\n    // is read the same backwards and forwards. In one change, you\
  \ can change one element to any other element.\n    // For example:\n    // >>>\
  \ smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong,\
  \ 7l.toLong, 9l.toLong, 6l.toLong)))\n    // (4l)\n    // >>> smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong)))\n    // (1l)\n\
  \    // >>> smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong,\
  \ 1l.toLong)))\n    // (0l)\n    def smallestChange(arr : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 5l.toLong, 4l.toLong, 7l.toLong, 9l.toLong, 6l.toLong)))\
  \ == (4l));\n    assert(smallestChange((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
  \ 4l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 4l.toLong, 4l.toLong, 2l.toLong))) == (1l));\n    assert(smallestChange((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))) == (0l));\n    assert(smallestChange((List[Long](3l.toLong,\
  \ 1l.toLong, 1l.toLong, 3l.toLong))) == (0l));\n    assert(smallestChange((List[Long](1l.toLong)))\
  \ == (0l));\n    assert(smallestChange((List[Long](0l.toLong, 1l.toLong))) == (1l));\n\
  \    }\n\n}\n"
completions: ["        val min_arr = arr.reverse.sliding(2).map(_.reverse).zipWithIndex.filter(_._2\
    \ == 0).map(_._1).size\n        (min_arr == arr.size)\n            ? 0\n     \
    \       : min_arr", "        if (arr.isEmpty) return 0\n        var min_changes\
    \ = 0\n        var min_changes_i = arr.size - 1\n        while (min_changes_i\
    \ >= 0) {\n            var i = min_changes_i\n            val next_i = i + 1\n\
    \            var last_i = min_changes_i - 1\n            if (i + 1 < arr.size\
    \ && arr(i) == arr(next_i)) {\n                last_i = i\n                i =\
    \ next_i\n            }\n            var count = 1\n            for (i;  i <=\
    \ last_i;  ++i) {\n                count += arr(i) - arr(i)\n            }\n \
    \           count += 1\n            if (count < min_changes) {\n             \
    \   min_changes = count\n                min_changes_i = i\n            }\n  \
    \      }\n        return min_changes", "        val l1 = arr.toArray\n       \
    \ val l2 = l1.reverse\n        val res = l1\n        val len = arr.length\n\n\
    \        for (i <- len to 0 by -1) {\n            val j = (len + i - 1) \\ 2\n\
    \            var min = i\n            var m1 = arr(i).toLong\n            var\
    \ m2 = arr(l1(0).toLong).toLong\n            var m3 = arr(l1(1).toLong).toLong\n\
    \            var m4 = arr(l1(2).toLong).toLong\n            var m5 = arr(l1(3).toLong).toLong\n\
    \            var m6 = arr(l1(4).toLong).toLong\n            var m7 = arr(l1(5).toLong).toLong\n\
    \            var m8 = arr(l1(6).toLong).toLong\n            var m9 = arr(l1(7).toLong).toLong\n\
    \            var m10 = arr(l1(8).toLong).toLong\n            var m11 = arr(l1(9).toLong).toLong\n\
    \            var m12 = arr(l1(10).toLong).toLong\n            var m13 = arr(l1(11).toLong).toLong\n\
    \            var m14 = arr(l1(12).toLong).toLong\n            var m15 = arr(l1(13).toLong).toLong\n\
    \            var m16 = arr(l1(14).toLong).toLong\n            var m17 = arr(l1(15).toLong).toLong\n\
    \            var m18 = arr(l1(16).toLong).toLong\n            var m19 = arr(l1(17).toLong).toLong\n\
    \            var m20 = arr(l1(18).toLong).toLong\n            var m21 = arr(l1(19).toLong).toLong\n\
    \            var m22 = arr(l1(20).toLong).toLong\n            var m23 = arr(l1(21).toLong).toLong\n\
    \            var m24 = arr(l1(22).toLong).toLong\n            var m25 = arr(l1(23).toLong).toLong\n\
    \            var m26 = arr(l1(24).toLong).toLong\n            var m27 = arr(l1(25).toLong).toLong\n\
    \            var m28 = arr(l1(26).toLong).toLong\n            var m29 = arr(l1(27).toLong).toLong\n\
    \            var m30 = arr(l1(28).toLong).toLong\n            var m31 = arr(l1(29).toLong).toLong\n\
    \            var m32 = arr(l1(30).toLong).toLong\n            var m33 = arr(l1(31).toLong).toLong\n\
    \            var m34 = arr(l1(32).toLong).toLong\n            var m35 = arr(l1(33).toLong).toLong\n\
    \            var m36 = arr(l1(34).toLong).toLong\n            var m37 = arr(l1(35).toLong).to",
  "        val minChange = arr.foldLeft(0) {\n            (i, elem) => {\n       \
    \         if (elem < i.toLong) {\n                    i.toLong\n             \
    \   } else {\n                    i\n                }\n            }\n      \
    \  }\n        minChange", "        val lv = arr.toList.reverse\n        if(lv.tail.forall(_.toLong\
    \ == lv.head.toLong)) 0L else lv.head + smallestChange(lv.tail)", "        //\
    \ sort the list in descending order\n        val sorted_arr = arr.sortBy(-_)\n\
    \        var i : Int = 0\n        var j : Int = 1\n        // check even number\n\
    \        while (i < arr.length) {\n            if (sorted_arr(i) == sorted_arr(j))\
    \ {\n                i += 1\n                j += 1\n            } else {\n  \
    \              if (sorted_arr(i) < sorted_arr(j)) {\n                    i +=\
    \ 1\n                } else {\n                    j += 1\n                }\n\
    \            }\n        }\n        return j", "        val len = arr.length\n\
    \        var i = 0\n        var count = 0\n        var minimum = 0L\n        while\
    \ (i < len) {\n            var last = i + 1\n            while (last < len) {\n\
    \                if (arr(i) != arr(last)) {\n                    val temp = arr(i)\n\
    \                    arr(i) = arr(last)\n                    arr(last) = temp\n\
    \                    last = i + 1\n                } else {\n                \
    \    last += 1\n                }\n                i += 1\n            }\n   \
    \         count += 1\n            if (count < minimum) {\n                minimum\
    \ = count\n            }\n        }\n        return minimum", "        arr.foldLeft(0){\n\
    \            (acc:Long, i:Long, list:List[Long]) => {\n                if (list.isEmpty\
    \ || list.isDefined && list.head != i) {\n                    acc += 1\n     \
    \           }\n                else {\n                    acc += list.size -\
    \ 1\n                }\n            }\n        }", "        if(arr.isEmpty) 0\n\
    \        else arr.reverse.diff(arr).length", "        var ans = Long.MaxValue\n\
    \        arr.foreach { x =>\n            if (x == arr.last) ans = x\n        \
    \    else {\n                if (x % 2 == 0) ans = Math.min(ans, x - 1)\n    \
    \            else {\n                    if (x % 3 == 0) ans = Math.min(ans, x\
    \ - 3)\n                    else {\n                        if (x % 5 == 0) ans\
    \ = Math.min(ans, x - 5)\n                        else ans = Math.min(ans, x -\
    \ 2)\n                    }\n                }\n            }\n        }\n   \
    \     ans.toLong", "        val arr = arr.reverse\n        val n = arr.size\n\
    \        val min = n*(n+1)/2\n        val max = arr.last\n        for (i <- 1\
    \ to max) {\n            val sublist = arr(i-1) ++ arr(i) ++ arr(i+1)\n      \
    \      if (sublist.equals(reverse(sublist)))\n                return i\n     \
    \   }\n        return 0", "        val changed = arr.filter(_ < 0).length\n  \
    \      val unchanged = arr.filter(_ > 0).length\n        if (unchanged == 0) {\n\
    \            0\n        } else if (changed < unchanged) {\n            changed\
    \ + 1\n        } else {\n            1\n        }", "        val arr = arr.toList\n\
    \        val length = arr.length\n        var index = 0\n        var min = 0\n\
    \        var max = length - 1\n        while(min < max) {\n            val mid\
    \ = (min + max) / 2\n            val leftArr = arr.take(mid)\n            val\
    \ rightArr = arr.drop(mid)\n            if(isPalindromic(leftArr) && isPalindromic(rightArr))\n\
    \                min = mid\n            else max = mid\n        }\n        min",
  "        // O(N^2)\n        def isPalindromic(arr : List[Long], i : Int, j : Int)\
    \ : Boolean = arr.take(i).reverse == arr.drop(j)\n        def solve(arr : List[Long],\
    \ i : Int, j : Int, n : Long) : Long = {\n            if (i == j) n\n        \
    \    else if (isPalindromic(arr, i, j)) solve(arr, i + 1, j - 1, n + 2)\n    \
    \        else solve(arr, i, j, n)\n        }\n        solve(arr, 0, arr.size -\
    \ 1, 0)", "        val arr = arr.sort\n        var max = 0\n        var min =\
    \ 1000\n        var counter = 0\n        for ( i <- 0 until arr.length-1 ) {\n\
    \            if (arr(i) != arr(arr.length-i-1) )\n            {\n            \
    \    max = arr.length\n                min = i\n                counter = 0\n\
    \            }\n            else\n            {\n                counter += 1\n\
    \            }\n        }\n        max = arr.length\n        min = counter\n \
    \       println(max)\n        println(min)\n        println(counter)\n       \
    \ return min", "        var min: Long = 0\n        var max: Long = 0\n\n     \
    \   var i = arr.length - 1\n        var j = arr.length - 1\n\n        while (i\
    \ >= 0) {\n            while (arr(i) != arr(j)) {\n                j -= 1\n  \
    \          }\n\n            if (arr(i) < arr(j)) {\n                min = i +\
    \ 1\n            } else {\n                max = j\n            }\n\n        \
    \    i -= 1\n            j -= 1\n        }\n\n        min + (max - min + 1) /\
    \ 2", "        if (arr.size <= 1) {\n            return 0\n        }\n       \
    \ var l = arr(0)\n        var r = arr(arr.size - 1)\n\n        while(l * 10 +\
    \ r * 10 < arr.size) {\n            var temp = l * 10 + r * 10\n            l\
    \ = arr(temp % arr.size)\n            r = arr(temp / arr.size)\n        }\n  \
    \      r += 1\n\n        if (l * 10 == r * 10) {\n            var l2 = l - 1\n\
    \            var r2 = r + 1\n\n            while(l2 * 10 + r2 * 10 < arr.size)\
    \ {\n                var temp2 = l2 * 10 + r2 * 10\n                l2 = arr(temp2\
    \ % arr.size)\n                r2 = arr(temp2 / arr.size)\n            }\n   \
    \         r2 += 1\n            l2 = l - r2\n            while(l2 * 10 + r2 * 10\
    \ < arr.size) {\n                var temp3 = l2 * 10 + r2 * 10\n             \
    \   l2 = arr(temp3 % arr.size)\n                r2 = arr(temp3 / arr.size)\n \
    \           }\n            l += l2 + 1\n        }\n        if (l * 10 > r * 10)\
    \ {\n            var l2 = l + 1\n            var r2 = r - 1\n\n            while(l2\
    \ * 10 + r2 * 10 < arr.size) {\n                var temp2 = l2 * 10 + r2 * 10\n\
    \                l2 = arr(temp2 % arr.size)\n                r2 = arr(temp2 /\
    \ arr.size)\n            }\n            r2 -= 1\n            l2 = l + r2\n   \
    \         while(l2 * 10 + r2 * 10 < arr.size) {\n                var temp3 = l2\
    \ * 10 + r2 * 10\n                l2 = arr(temp3 % arr.size)\n               \
    \ r2 = arr(temp3 / arr.size)\n            }\n            r += r2 - 1\n       \
    \ }\n        val c = l - r\n        c + 1", "        val min = (arr.length / 2).toInt\n\
    \        var i = min + 1\n        val max = (arr.length / 2).toInt\n        var\
    \ j = max - 1\n        while(i < j){\n            var n = 0\n            if(arr.length\
    \ % 2 == 0){\n                n = arr(i).toLong\n            }\n            else{\n\
    \                n = arr(j).toLong\n            }\n            var x = n\n   \
    \         while(x < 0){\n                x = x * 10 + 1\n            }\n     \
    \       var y = x\n            while(y > 0){\n                y = y / 10\n   \
    \         }\n            if(y == x){\n                i += 1\n               \
    \ j --\n            }\n            else{\n                j --\n            }\n\
    \        }\n        if (arr.length % 2 != 0){\n            return arr(min).toLong\n\
    \        }\n        else{\n            return arr(max).toLong\n        }", " \
    \       val count = arr.filter(x => x % 2 == 0).length\n        val n = arr.length\n\
    \n        var j = n / 2\n\n        var change = 0\n\n        while (j <= n) {\n\
    \            val k = j + j\n            var minDiff = math.max(math.abs(arr(k)\
    \ - arr(n - j)), math.abs(arr(n + j) - arr(n - j)))\n\n            for (i = 1\
    \ until count) {\n                val d = math.abs(arr(k) - arr(n - i))\n    \
    \            if (d == minDiff) break\n                minDiff = math.max(d, minDiff)\n\
    \            }\n\n            change += 1\n            j += minDiff\n        }\n\
    \        change", '        arr.filter( l => l==arr.takeWhile( a=>a==arr.last).reverse
    ).size', "        val arr = arr.sort\n        var i = 0\n        var count = 0\n\
    \        while(i < arr.length) {\n            if(arr(i) == arr[arr.length - 1\
    \ - i])\n                count += 1\n            else { \n                if(count\
    \ == 1)\n                    return arr(i)\n                count = 0\n      \
    \      }\n            i += 1\n        }\n        arr.length", "        val n =\
    \ arr.size\n        if (n == 0) 0\n        else if (n == 1) arr.head\n       \
    \ else arr(n / 2)", "        if(arr.length < 2) 0\n        else {\n          \
    \  var min = arr.head\n            var minIndex = 1\n\n            val middle\
    \ = arr.length / 2\n\n            for (i <- 1 until middle) {\n              \
    \  var temp = arr.head\n                var tempIndex = i\n\n                val\
    \ currentMin = temp\n                val currentMinIndex = tempIndex\n\n     \
    \           if(tempIndex < middle - 1 && currentMin == arr.last){\n          \
    \          temp = arr.head\n                    tempIndex = 1\n              \
    \      val currentMin = temp\n                    val currentMinIndex = tempIndex\n\
    \                }\n\n                if(tempIndex == middle){\n             \
    \       val currentMin = temp\n                    val currentMinIndex = tempIndex\n\
    \                }\n\n                for(tempIndex <- 1 until middle){\n    \
    \                if(tempIndex < middle){\n                        val temp = arr.last\n\
    \                        val tempIndex = middle\n                        if(tempIndex\
    \ == middle){\n                            val temp = arr.last\n             \
    \               val tempIndex = middle\n                        }\n\n        \
    \                if(currentMin != arr.last){\n                            min\
    \ = currentMin\n                            minIndex = currentMinIndex\n     \
    \                   }\n\n                        val currentMin = temp\n     \
    \                   val currentMinIndex = tempIndex\n                    }\n \
    \               }\n            }\n            minIndex\n        }", "        val\
    \ arr = arr.reverse\n        val arrSize = arr.length\n        var i = 0\n   \
    \     var min = Integer.MAX_VALUE\n        var minIdx = 0\n        for (i <- 0\
    \ until arrSize-1) {\n            val idx = i+1\n            val value = arr(idx)\n\
    \            if (value <= arr(arrSize-1)) {\n                if (min == Integer.MAX_VALUE\
    \ || value < min) {\n                    min = value\n                    minIdx\
    \ = idx\n                }\n            }\n        }\n        minIdx", "     \
    \   val len = arr.length\n        val arr = arr ++ ArrayBuffer(arr.last, arr(0))\n\
    \        var index = 0\n        var left = 0\n        var right = (arr.length\
    \ - 1L)\n        var changes = 0\n        var isPalindromic = true\n        while\
    \ (left < right) {\n            if (arr(left) == arr(right)) {\n             \
    \   index = index + 1\n                left = left + 1\n                right\
    \ = right - 1\n            } else {\n                if (arr(left) != arr(right))\
    \ {\n                    isPalindromic = false\n                    break\n  \
    \              }\n                left = left + 1\n                right = right\
    \ - 1\n            }\n        }\n        if (isPalindromic) {\n            changes\
    \ = left * 2\n        }\n        return changes", "        var arr = arr.sortWith(\
    \ (x,y) => x-y)\n        var smallestChange = 0l\n        var p = 0\n        while(p\
    \ < arr.length) {\n            if (arr(p) == arr(arr.length - p - 1)) {\n    \
    \            smallestChange = smallestChange+1\n            } else {\n       \
    \         break\n            }\n            p+=1\n        }\n        smallestChange",
  "        val changes = arr.scanLeft(1l){(a,b)=>\n            val last = a\n    \
    \        val c = b\n            if(last>c || (last==c && a>b)) a+1 else a\n  \
    \      }\n        changes.headOption.getOrElse(0l)", "        // Write your code\
    \ here\n        val s = arr.reverse\n        val len = s.length\n        val arr1\
    \ = Array.fill(len)(0)\n        var count = 1\n        for(i <- 0 until len) {\n\
    \            if(i != 0) {\n                if(s(i) != s(i - 1)) {\n          \
    \          count += 1\n                }\n                arr1(i - 1) = arr(i)\n\
    \            }\n        }\n        return count", "        var count = 1\n   \
    \     val set = mutable.HashSet[Long]()\n        var smallest = 0L\n        for\
    \ (i<-arr.indices){\n            if (arr.get (i) == arr.get(i + 1) && !set.add(i))\
    \ {\n                count += 1\n                if (count > smallest || smallest\
    \ == 0L) {\n                    smallest = count\n                }\n        \
    \    }\n        }\n        smallest", "        val n = arr.size\n        val max\
    \ = Long.MinValue\n        var i = 0\n        while (i < n) {\n            var\
    \ cur = arr(i)\n            while (i < n) {\n                val next  = arr(i+1)\n\
    \                val diff  = cur - next\n                if (diff > max)\n   \
    \                 max = diff\n                i += 2\n            }\n        \
    \    i += 1\n        }\n        max + (if (arr.size == n && arr.head < arr.last)\
    \ 1 else 0)", "        var left = 0\n        var right = arr.length - 1\n    \
    \    while(left < right) {\n            var m = math.min(left, right)\n      \
    \      var j = m\n            while(j > left && arr(j - 1) < arr(m)) {\n     \
    \           j -= 1\n            }\n            var k = m\n            while(k\
    \ > right && arr(k - 1) > arr(m)) {\n                k += 1\n            }\n \
    \           arr(m) <- arr(m)\n            left <- j + 1\n            right <-\
    \ k - 1\n        }\n        arr.takeRight(arr.length).length", "        var i\
    \ = 0\n        var j = 0\n        var ans = 0\n        while(i < arr.size) {\n\
    \            while(j < arr.size && arr(i) == arr(j)) {\n                j += 1\n\
    \            }\n            if(j == arr.size)\n                ans += 1\n    \
    \        j = 0\n            i += 1\n        }\n        if(j == arr.size)\n   \
    \         ans += 1\n        ans", "        var min_changes = 1\n        val arr\
    \ = arr.sortBy(x => x)\n        val len = arr.size\n        for (i<- 0 until len)\
    \ {\n            val low = arr(i)\n            val high = arr[len - i - 1]\n \
    \           if (high < low) {\n                min_changes = min_changes + 1\n\
    \                val new_arr = arr.reverse\n                val len = new_arr.size\n\
    \                for (j <- 0 until len) {\n                    if (new_arr(j)\
    \ < low) {\n                        val tmp = new_arr(j)\n                   \
    \     new_arr(j) = new_arr(len - j)\n                        new_arr(len - j)\
    \ = tmp\n                    }\n                }\n                arr = new_arr\n\
    \            } else {\n                break\n            }\n        }\n     \
    \   min_changes == len ? 0l : min_changes", "      val minSize = 1\n      val\
    \ rev = arr.init.reverse\n      val len = arr.length\n      var current = 0\n\n\
    \      while (current < len && current < minSize) {\n        current += 1\n  \
    \      if (rev.get(current) != rev.get(len - 1)) {\n          minSize = current\
    \ + 1\n        }\n      }\n\n      return minSize", "      val minChange = arr.size\n\
    \      val currentLength = (arr.size)\n      val arrCopy = arr.toList\n      val\
    \ arr2 = arrCopy.reverse\n      val list = new mutable.ListBuffer[Long]()\n  \
    \    val list2 = new mutable.ListBuffer[Long]()\n      var c = 0\n      while\
    \ (c < currentLength && c < minChange) {\n        if (arrCopy(c) != arr2(c)) {\n\
    \          list(c) = arrCopy(c)\n        }\n        list2 += arrCopy(c)\n    \
    \    c += 1\n      }\n      val p1 = new mutable.ListBuffer[Long]()\n      val\
    \ p2 = new mutable.ListBuffer[Long]()\n      val c = 0\n      while (c < currentLength)\
    \ {\n        if (list(c) != list2(c)) {\n          if (list(c) != 0) {\n     \
    \       p1.append(list(c))\n          }\n          if (list2(c) != 0) {\n    \
    \        p2.append(list2(c))\n          }\n        }\n        c += 1\n      }\n\
    \      if (p1.length < p2.length) {\n        minChange = p1.length\n      } else\
    \ if (p1.length > p2.length) {\n        minChange = p2.length\n      }\n     \
    \ minChange", "        var cur = arr(0)\n        var left = 0\n        var right\
    \ = 0\n        while (left < right) {\n            cur = math.min(cur, arr[right])\n\
    \            right -= 1\n            cur = math.min(cur, arr[left])\n        \
    \    left += 1\n        }\n        cur", "        val size = arr.size\n      \
    \  val largest = arr.max\n        var count = 0\n        var previous = 0\n  \
    \      var next = 0\n        for (i<-0 until size) {\n            while (next\
    \ < size) {\n                val currentCount = arr[next] - arr[previous]\n  \
    \              if (currentCount == 1 && current != largest) {\n              \
    \      count += currentCount\n                    break\n                }\n \
    \               next += 1\n            }\n            previous = next\n      \
    \      next = 0\n        }\n        count * largest", "        if (arr.length\
    \ == 0) {\n            return 0;\n        }\n        val startIndex = arr.head\n\
    \        val reversedArr = arr.reverse\n\n        if (reversedArr.head != arr.last)\
    \ throw new ArithmeticException(\"Lists are not equal lengths\")\n        var\
    \ totalChanges = 0\n        var changeIndex = 0\n        var startIndexInReverse\
    \ = 0\n\n        while (reversedArr.nonEmpty) {\n            val currentValue\
    \ = reversedArr.head\n            reversedArr = reversedArr.tail\n\n         \
    \   // move forward\n            val nextValue = reversedArr.head\n          \
    \  reversedArr = reversedArr.tail\n            val nextIndex = reversedArr.head\n\
    \            val nextIndexInReverse = reversedArr.last\n            val nextReversedValue\
    \ = reversedArr.last\n            val nextReversedIndexInReverse = reversedArr.last\n\
    \            val nextReversedValue = reversedArr.last\n            val nextReversedIndexInReverse\
    \ = reversedArr.last\n            val nextReversedValue = reversedArr.last\n \
    \           val nextReversedIndexInReverse = reversedArr.last\n\n            if\
    \ (currentValue == nextValue) {\n                startIndexInReverse = reversedArr.head\n\
    \                changeIndex = startIndexInReverse\n                totalChanges\
    \ += 1\n            }\n\n            val indexOfNextValueInReverse = reversedArr.indexWhere(_\
    \ == nextValue)\n            val indexOfNextValueInReverse = indexOfNextValueInReverse.last\n\
    \            val indexOfNextValueInReverseInReverse = indexOfNextValueInReverse\
    \ - startIndexInReverse - 1\n\n            if (indexOfNextValueInReverseInReverse\
    \ == -1) {\n                val indexOfNextValueInReverseInReverseInReverse =\
    \ indexOfNextValueInReverse - startIndexInReverse\n                if (indexOfNextValueInReverseInReverseInReverse\
    \ == -1) {\n                    // Nothing to do here\n                } else\
    \ if (indexOfNextValueInReverseInReverseInReverse == 0) {\n                  \
    \  // move back one step\n                    reversedArr = reversedArr.tail\n\
    \                    val nextIndexInReverse = reversedArr.head\n             \
    \       val nextIndexInReverseInReverse = reversedArr.last\n                 \
    \   val nextReversedIndexInReverseInReverse = reversedArr.last\n             \
    \       val nextReversedIndexInReverseInReverseInReverse = reversedArr.last\n\
    \                    val nextReversedValue = reversedArr.last\n              \
    \      val nextReversedValueInReverse = reversedArr.last\n                   \
    \ val nextReversedValueInReverseInReverse = reversedArr.", "        def isPalindromic(arr\
    \ : List[Long]) : Boolean = {\n            if (arr.length == 0)\n            \
    \    true\n            else if (arr.head == arr.last)\n                isPalindromic(arr.tail)\n\
    \            else\n                false\n        }\n        def removeElementToMakePalindromic(arr\
    \ : List[Long], removeFromEnd : Int) : List[Long] = {\n            if (arr.length\
    \ == 0)\n                arr\n            else if (arr.head == arr.last)\n   \
    \             removeElementToMakePalindromic(arr.tail, removeFromEnd)\n      \
    \      else if (isPalindromic(arr.tail))\n                removeElementToMakePalindromic(arr.tail,\
    \ (removeFromEnd + 1))\n            else\n                removeElementToMakePalindromic(arr.tail,\
    \ (removeFromEnd + 1))\n        }\n        val minPalindromic = arr.take(1).head\n\
    \        val palindromics = arr.filter(_ != minPalindromic).map(_ - minPalindromic).distinct\n\
    \        val maxPalindromic = arr.last\n        val palindromicsWithoutMin = removeElementToMakePalindromic(arr.filter(_\
    \ != minPalindromic), 1)\n        val palindromicsWithoutMax = removeElementToMakePalindromic(arr.filter(_\
    \ != maxPalindromic), 1)\n        if (arr.length == 0)\n            0\n      \
    \  else if (palindromics.length == 1)\n            palindromicsWithoutMin.sum\n\
    \        else if (palindromics.length == 2)\n            palindromicsWithoutMin.sum\
    \ + palindromicsWithoutMax.sum\n        else\n            smallestChange(palindromicsWithoutMin.sum\
    \ + smallestChange(palindromicsWithoutMax.sum))", "        val arr = arr.sorted\n\
    \        val len = arr.length\n        var i = 0\n        var min = len\n    \
    \    var j = len - 1\n        while(i < j) {\n            val temp = arr(i)\n\
    \            arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n\
    \            j -= 1\n        }\n        val maxIndex = arr.lastIndexOf(0)\n  \
    \      val maxElement = arr(maxIndex)\n        for(i <- 0 until maxIndex) {\n\
    \            val temp = arr(i)\n            arr(i) = arr(maxIndex)\n         \
    \   arr(maxIndex) = temp\n            val curr = maxIndex - i\n            if(arr(curr)\
    \ < arr(curr + 1)) {\n                min = Math.min(min, curr + 1)\n        \
    \    }\n        }\n        arr(maxIndex) = 0l.toLong\n        min.toLong", " \
    \       var i = 0\n        val size = arr.size\n        val arr = new Array[Long](size)\n\
    \        arr.clear()\n        while (i < size) {\n            arr(i) = arr(i).asInstanceOf[Long]\n\
    \            i += 1\n        }\n        val reversedArr = new Array[Long](size)\n\
    \        reversedArr.clear()\n        i = size - 1\n        while (i >= 0) {\n\
    \            reversedArr(i) = arr(i).asInstanceOf[Long]\n            i -= 1\n\
    \        }\n        var changes = 0\n        while (reversedArr.toList != arr.reverse.toList)\
    \ {\n            changes += 1\n            reversedArr.clear()\n            for\
    \ (i = size - 2; i >= 0; i -= 1) {\n                if (arr(i) != arr(i + 1))\
    \ {\n                    reversedArr(i) = arr(i)\n                }\n        \
    \        else {\n                    reversedArr(i) = arr(i + 1)\n           \
    \     }\n            }\n        }\n        changes", "        val list = arr.toList\n\
    \        val stack = ListBuffer.empty[Long]\n        var result = 0\n        val\
    \ reverseStack = ListBuffer.empty[Long]\n        val changed = new mutable.HashSet[Long]\n\
    \        def dfs(index : Int) : Unit = {\n            if (index >= list.size)\
    \ {\n                result += 1\n            } else {\n                val curr\
    \ = list.getOrElse(index, 0)\n                if (curr % 2 == 0) stack.push(curr)\n\
    \                else if (curr % 2 != 0) reverseStack.push(curr)\n           \
    \     if (index == list.size - 1) result += 1\n                else dfs(index\
    \ + 1)\n                if (curr % 2 == 0) stack.pop\n                else if\
    \ (curr % 2 != 0) reverseStack.pop\n            }\n        }\n        dfs(0)\n\
    \        val isPalindromic = stack.toList == reverseStack.toList\n        if (isPalindromic)\
    \ result else 1", "        // Write your code here.\n        var min = -1\n  \
    \      var i = arr.length\n        while (i > 0) {\n            var current =\
    \ arr[i - 1] \n            var previous = arr[i]\n            var changes = 0\n\
    \            if (current > previous)\n                changes = 1\n          \
    \  while (current != previous) {\n                previous = current\n       \
    \         current = arr[i - 1]\n                var i = i - changes\n        \
    \    }\n            min = Math.min(min, changes)\n        }\n        min", " \
    \       var result = 1\n        var stack = mutable.Stack[Long](arr(0))\n    \
    \    var rev = List(arr.last)\n        for (i <- 1 to arr.size) {\n          \
    \  val left = stack.pop()\n            val right = stack.pop()\n            val\
    \ newElement = left * right\n            val oldElement = stack.pop()\n      \
    \      if (newElement == oldElement && newElement != 0) {\n                result\
    \ = result+1\n            }\n            rev ::= newElement\n            stack\
    \ ::= newElement\n        }\n        result", "        arr.sortWith( (a,b) =>\
    \ { if (a>b) a else b })\n        if(arr.isEmpty)\n            return 0\n    \
    \    var num = 0\n        var min = arr(0)\n        for(i <- 1 to arr.length-1){\n\
    \            if(arr(i) != arr(i-1))\n                num += 1\n            else\n\
    \                num -= 1\n            if(num == 0){\n                min = i\n\
    \                break\n            }\n        }\n        min", "        val arr\
    \ = arr.toSet.toList\n        val changeNum = arr.toSet.size\n        val changeSet\
    \ = new mutable.HashSet[Long]\n        changeNum = changeNum - 1\n        val\
    \ arrLength = len(arr)\n        val arrLength = arrLength - 1\n        var i =\
    \ arrLength\n        var change = 0\n        val arrLength = arr.length\n    \
    \    val arrLength = arrLength - 1\n        var j = 0\n        while (i >= 0)\
    \ {\n            if (j < arrLength && arr(i) == arr(arrLength-j)) {\n        \
    \        j = j + 1\n            }\n            val temp = arr(i)\n           \
    \ arr(i) = arr(arrLength-j-1)\n            arr(arrLength-j-1) = temp\n       \
    \     change = change + 1\n            if (change >= changeNum) {\n          \
    \      return change\n            }\n            i = i - 1\n            j = j\
    \ - 1\n        }\n        0", "        var min = Long.MaxValue - 1\n        arr.foreach\
    \ { e =>\n            val count = arr.count(v => v == e) //number of times element\
    \ e occurs in arr\n            if (count > min && count > arr.count(e => e ==\
    \ e))\n                min = count\n        }\n        min", "        val reversed\
    \ = arr.filter(_ != arr.last).reverse\n        reversed.zip(arr).map(x => (x._1\
    \ - x._2).abs).min", "        val a = arr.toList\n        val l = a.length\n \
    \       val b = new Array[Boolean](l)\n        val index = new Array[Long](l)\n\
    \        val r = new Array[Long](l)\n        val x = new Array[Long](l)\n    \
    \    val c = new Array[Long](l)\n        var j = 0\n        var k = 0\n      \
    \  var m = 0\n        var t = 0\n        for (i <- 0 until l) {\n            a(i)\
    \ = a(i).toLong\n            b(i) = true\n            index(i) = i\n         \
    \   r(i) = a(i).reverse\n            c(0) = a(i)\n            x(0) = a(i)\n  \
    \      }\n        for (j <- 0 to l / 2)\n            for (k <- 0 to l / 2 by -1)\n\
    \                if (c(b(k)) && c(b(k + 1))) m(k) = index(b(k))\n        for (m\
    \ <- 0 to l / 2)\n            if (m(k) == index(b(m)))\n                if (x(m)\
    \ != r(m))\n                    for (t <- m(k + 1) + 1 to l / 2)\n           \
    \             if (b(index(b(t))) && r(b(index(b(t)))))\n                     \
    \       if (x(b(t)) != r(b(t))) c += index(b(t))\n                        else\
    \ c += index(b(t))\n        for (x <- 0 to l / 2)\n            if (x(k) == c(b(x)))\n\
    \                if (r(x) != r(b(x))) x += 1\n                else x += 1\n  \
    \      var count = 0\n        for (x <- 0 to l / 2)\n            if (x(k) == index(b(x)))\n\
    \                if (x(k) != r(b(x))) {\n                    count += 1\n    \
    \                x(k) = r(b(x)) // change the element with the smallest index\
    \ to make the list palindromic\n                    x(k) = r(b(x)) // change the\
    \ element with the smallest index to make the list palindromic\n             \
    \   }\n        count", "      var i = arr.length\n      val max1 = Math.max(arr(i-1),\
    \ arr(i))\n      val max2 = Math.max(arr(i-1), arr(i+1))\n      if (max1 < max2)\n\
    \        return max2\n      else\n        return 0", "        var minChange =\
    \ 0\n        val n = arr.size\n        var p = 1\n        var change = 0\n   \
    \     var flag = false\n        while (change < n && minChange < n) {\n      \
    \      if (arr[change] == arr[change-n]) {\n                if (change == 0) {\n\
    \                    minChange = p\n                    p = 1\n              \
    \      change = change + 1\n                }\n                else {\n      \
    \              p += 1\n                    change = change + 1\n             \
    \   }\n            }\n            else {\n                if (change == n-1) {\n\
    \                    minChange = p\n                    change = 0\n         \
    \       }\n                else {\n                    p += 1\n              \
    \      change = change + 1\n                }\n            }\n        }\n    \
    \    if (minChange < n) {\n            minChange = n - minChange\n        }\n\
    \        if (minChange == n) minChange = 0\n        flag = minChange == 0\n  \
    \      minChange", "        val map = mutable.HashMap[Int, Long]()\n        val\
    \ list = arr.toList\n        var p = 0\n        \n        for (i<-1 to (arr.size-1))\n\
    \        {\n            map.put(i, list(i).toLong)\n        }\n        \n    \
    \    for (i <- 0 to (arr.size-1))\n        {\n            for (j <- (arr.size\
    \ - i - 1).toLong to (arr.size - i).toLong)\n            {\n                if\
    \ (map.get(i+j) == map.get(i))\n                {\n                    p += 1\n\
    \                }\n            }\n        }\n        \n        if (arr.size ==\
    \ p)\n        {\n            0\n        }\n        else\n        {\n         \
    \   p\n        }", "        def compare(xs : List[Long], ys : List[Long]) : Boolean\
    \ = {\n            if (xs.head > ys.head) return true\n            if (xs.head\
    \ < ys.head) return false\n            compare(xs.tail, ys.tail)\n        }\n\
    \        var change = 0\n        val len = arr.length\n        for (xs <- arr.drop(len\
    \ - 1)){\n            for (ys <- arr.reverse.drop(len - 1)){\n               \
    \ if (compare(xs, ys)) {\n                    change += 1\n                }\n\
    \            }\n        }\n        change", "        var changes = 0\n       \
    \ var len = arr.length\n        var i = 0\n        var start = 0\n        while\
    \ (i < len) {\n            if (i % 2 == 1) {\n                start += arr(i).toLong\n\
    \                val end = start + arr(i).toLong\n                while (i < len\
    \ && arr(i).toLong < end) {\n                    i += 2\n                }\n \
    \               if (i == len) {\n                    changes += 1\n          \
    \      }\n            }\n            i += 1\n        }\n        if (changes ==\
    \ 0) {\n            return 0\n        }\n        changes - 1", "        val palindromicArr:\
    \ List[Long] = arr.map(arrValue => arrValue * arrValue).toList\n        val reversedArr:\
    \ List[Long] = arr.map(arrValue => arrValue * arrValue).reverse\n        val changedArr:\
    \ List[Long] = reversedArr diff palindromicArr\n        reversedArr.length", " \
    \       var count = (0 until arr.length).map{ i => 0 }.toList\n        var i =\
    \ 0\n        while (i < arr.length) {\n            count += arr(i) - arr(i-1)\n\
    \            i += 1\n        }\n        return count.min", "        val map =\
    \ mutable.LinkedHashMap[Long, Int]()\n        arr.foreach { e =>\n           \
    \ if (map.contains(e)) {\n                map.put(e, map.get(e) + 1)\n       \
    \     } else {\n                map.put(e, 1)\n            }\n        }\n    \
    \    val max = map.max.toInt\n        val result: List[Long] = map.keys.toList.sortWith((x:\
    \ Long) => x < max).toList\n        result.size match {\n            case 0 =>\
    \ 0l\n            case 1 => arr(0l).toLong\n            case n =>\n          \
    \      val first = arr(0l).toLong\n                val last = result.last\n  \
    \              val left = (first - last) match {\n                    case x if\
    \ x > 0 => 0l\n                    case _ => 1l\n                }\n         \
    \       val right = (last - first) match {\n                    case x if x >\
    \ 0 => 1l\n                    case _ => 0l\n                }\n             \
    \   min {\n                    case 0 => 0l\n                    case x if x <\
    \ left + right => x + smallestChange(arr.drop(1))\n                }\n       \
    \ }", "        var p = new mutable.ListBuffer[Long]()\n        var i = 0\n   \
    \     var j = 0\n        var min = Integer.MAX_VALUE\n        // While i < length\
    \ of arr\n        while (i < arr.length) {\n            if (j > 0) \n        \
    \        p.insert(j, arr(i))\n            i += 1\n        }\n        p.reverse()\n\
    \        var j = 0\n        i = p.length\n        while(i-- > 0){\n          \
    \  if (arr(i) != p(j)) {\n                min = Math.min(min, j-i)\n         \
    \   }\n            j += 1\n        }\n        min", "        val list = arr.filter(_\
    \ % 2 == 0).reverse.toList.sortWith(_ < _)\n        val change = list.length *\
    \ 2 - list\n        if (change == 0) 0\n        else list.length * 2 - change",
  "        // Write your solution here\n        val n = arr.length\n        val len\
    \ = arr.foldLeft(0) { (i, a) => i + a.length}\n        if(len < n)\n         \
    \   smallestChange(arr)\n        else\n            if((arr.tail.filter(x => x\
    \ == arr.head).take(len).forall(x => x != arr.head)) && (arr.tail.forall(x =>\
    \ x == arr.head)))\n                0\n            else if((arr.tail.filter(x\
    \ => x == arr.head).take(len).forall(x => x == arr.head)))\n                1\n\
    \            else if((arr.tail.filter(x => x == arr.head).take(len).forall(x =>\
    \ x != arr.head)) && (arr.tail.forall(x => x != arr.head)))\n                smallestChange(arr.tail.filter(x\
    \ => x != arr.head))\n            else\n                smallestChange(arr.tail.filter(x\
    \ => x != arr.head).take(len - 1))", "        // Initialize our best result\n\
    \        var best = 0L;\n\n        // Initialize our best result\n        var\
    \ current = arr[arr.length - 1]\n\n        // Loop from end\n        for (i =\
    \ arr.length - 2; i >= 0; i -= 1) {\n            val value = arr(i);\n\n     \
    \       // Increment current by any value less than current value\n          \
    \  if (current > value) {\n                current += value;\n            } else\
    \ {\n                // If current is equal to value, no changes needed\n    \
    \            if (current == value) {\n                    current = current +\
    \ 1\n                }\n            }\n\n            // If current is greater\
    \ than best, update best\n            if (current > best) {\n                best\
    \ = current;\n            }\n        }\n\n        // Return best value\n     \
    \   return best", "        if (arr.isEmpty) 0\n        else {\n            val\
    \ list1 = arr.tail\n            val list2 = arr.init\n            val list3 =\
    \ arr.tail.reverse\n            val list4 = arr.init.reverse\n\n            val\
    \ list5 = (list1, list2, list3, list4)\n\n            val list6 = list5.foldLeft(0)\
    \ { (acc, tuple) =>\n                val a = tuple._1\n                val b =\
    \ tuple._2\n                val c = tuple._3\n                val d = tuple._4\n\
    \                if (a > b) acc + c else acc + d\n            }\n\n          \
    \  return list6.min * 2\n        }", "        // Write your code here.\n     \
    \   var lenArr = arr.length\n        var result = 0L\n        var tmp = 0\n  \
    \      for(i <- 0 until lenArr){\n            tmp = arr(i)\n            var isPalindrome\
    \ = true\n            for(j <- i+1 until lenArr){\n                if(arr(j) !=\
    \ tmp){\n                    isPalindrome = false\n                }\n       \
    \     }\n            if(isPalindrome){\n                result += 1\n        \
    \    }\n        }\n        result", "       // Write your code here\n        val\
    \ len = arr.size\n        val minChange = len / 2\n        var i = minChange\n\
    \        var j = len - minChange\n\n        // Find the minimum number of changes\
    \ needed.\n        var change = 0\n        for (k <- 1 to len) {\n           \
    \ change += 1\n            i = j\n            j -= 1\n        }\n        // Now\
    \ we have found minimum number of changes.\n        change", "        var i =\
    \ 0\n        var j = 0\n        var k = arr.length\n        var count = 0\n  \
    \      var largest = 0\n        while(i < k && j < k)\n        {\n           \
    \ if(arr(i) == arr(j))\n            {\n                i = i + 1\n           \
    \     j = j + 1\n                count = count + 1\n            }\n          \
    \  else if(arr(i) < arr(j))\n            {\n                j = j + 1\n      \
    \      }\n            else\n            {\n                i = i + 1\n       \
    \     }\n        }\n        while(i < k && j >= k)\n        {\n            if(arr(i)\
    \ == arr(j))\n            {\n                i = i + 1\n                count\
    \ = count + 1\n            }\n            else if(arr(i) < arr(j))\n         \
    \   {\n                largest = arr(i)\n                i = i + 1\n         \
    \   }\n            else\n            {\n                largest = arr(j)\n   \
    \             j = j - 1\n            }\n        }\n        if(largest  == 0)\n\
    \        {\n            return 0\n        }\n        else\n        {\n       \
    \     return count\n        }", "        val n = arr.length\n        val dp =\
    \ Array.ofDim[Long](n+1, n)\n        dp.apply(0, 0) = 0\n\n        for ((i1, i2)\
    \ <- arr.view.zipWithIndex) {\n            val l1 = dp(i1, i1+1)\n           \
    \ val l2 = dp(i1+1, i2)\n            dp(i1+1, i2) = math.min(l1, l2)\n       \
    \ }\n        (dp(n-1, n)).min", "        val n = arr.length\n        val arr =\
    \ arr.sortBy(_.reverse)\n        var res = -1L\n        var i = 0\n        while(i\
    \ < n) {\n            if(arr(i) == arr(n)) {\n                res++\n        \
    \        n -= 1\n                i -= 1\n            }\n            i += 1\n \
    \       }\n        res", "        val n = arr.size\n        val p = new Array[Long](n)\n\
    \        var count = 0\n        for(i <- 0 to (n-1)) {\n            p(i) = arr(i)\n\
    \            if(i == n-1 || arr(i) != arr(i+1)) count = count + 1\n        }\n\
    \        count", "        val arr = arr.toList\n        val length = arr.size\n\
    \        val leftmostChangeIndex = length - 1\n        val rightmostChangeIndex\
    \ = -1\n        var leftmostChangeValue = 0l\n        var rightmostChangeValue\
    \ = 0l\n        var leftmostChangeIsChange = false\n        var rightmostChangeIsChange\
    \ = false\n        var leftmostChangeIsInPlace = false\n        var rightmostChangeIsInPlace\
    \ = false\n        var leftmostChangeIsReadBackwards = false\n        var rightmostChangeIsReadBackwards\
    \ = false\n        \n        // For all pairs of consecutive pairs, see if there\
    \ is any change in the two consecutive elements\n        // If so, make the change\
    \ as minimum as possible and update leftmostChangeIndex and rightmostChangeIndex\n\
    \        // If not, ignore this pair.\n        // If there are more than two consecutive\
    \ pairs, update the leftmostChangeIndex and rightmostChangeIndex\n        // with\
    \ maximum possible pairs.\n        // A pair of consecutive pairs is a valid pair.\n\
    \        for( i <- 0 until length - 2) {\n            val currentLeft = arr(i).toLong\n\
    \            val currentRight = arr(i + 1).toLong\n            if( currentLeft\
    \ != currentRight && !leftmostChangeIsChange) {\n                // If there is\
    \ any change in the current left and current right,\n                // ignore\
    \ the pair.\n                if( currentLeft < currentRight) {\n             \
    \       leftmostChangeIsChange = true\n                    leftmostChangeIndex\
    \ = i\n                    leftmostChangeValue = currentLeft\n               \
    \ } else if( currentLeft > currentRight) {\n                    rightmostChangeIsChange\
    \ = true\n                    rightmostChangeIndex = i + 1\n                 \
    \   rightmostChangeValue = currentRight\n                } else {\n          \
    \          leftmostChangeIsChange = true\n                    leftmostChangeIndex\
    \ = i\n                    leftmostChangeValue = currentRight\n              \
    \  }\n            }\n        }\n\n        // If there is no change in the list\
    \ at all, then return the number of elements that can be changed\n        // without\
    \ changing the list palindromic or not\n        if(leftmostChangeIsChange == false)\
    \ return length\n\n        // If there are only two consecutive pairs and they\
    \ are same, then the list can be made palindromic\n        // If there are more\
    \ than two consecutive pairs, then update the leftmostChangeIndex and rightmostChangeIndex\n\
    \        // with maximum possible pairs.\n        for( i <- 0 until length - 2)\
    \ {\n            val currentLeft = arr(i).toLong\n            val currentRight\
    \ = arr(i + 1).toLong\n            if( currentLeft != currentRight && leftmostChangeIsChange)\
    \ {\n                if( currentLeft < currentRight) {\n                    rightmostChangeIsChange\
    \ = true\n                    rightmostChangeIndex = i + 1\n                 \
    \   rightmostChangeValue = currentRight\n                } else {\n          \
    \          ", "        val len = arr.length\n        val minPalindromic = 0\n\
    \        var changes = 0\n        var left = 0\n        var right = (len-1)\n\
    \        var changeCount = 0\n        while (left<right) {\n            if (arr(left)>arr(right))\
    \ {\n                right--\n                changeCount++\n            } else\
    \ {\n                left++\n                changeCount++\n            }\n  \
    \          if (changeCount > minPalindromic) {\n                minPalindromic\
    \ = changeCount\n            }\n        }\n        minPalindromic", "        if\
    \ (arr.isEmpty) return 0\n        val stack = arr.toStack\n        val min = arr.head\
    \ + arr.tail.last\n        var change = 0\n        while(stack.nonEmpty) {\n \
    \           val x = stack.last\n            stack -= x\n            val y = stack.last\n\
    \            stack -= y\n            val z = stack.last\n            stack -=\
    \ z\n            if (x==y && x==z) change += 1\n            else if (z==y && x==z)\
    \ change -= 1\n            else stack += x\n        }\n        min", "       \
    \ val length = arr.length\n        var minChange = 0l\n        \n        while(length\
    \ > 0) {\n            if(minChange >= length) {\n                minChange = 0l\n\
    \            }\n            val element = arr(minChange)\n            if(element\
    \ == arr(length-1)) {\n                length -= 1\n            } else {\n   \
    \             length += 1\n                minChange += 1\n            }\n   \
    \     }\n        minChange", "        val n = arr.size\n        val m = arr.last\n\
    \        if (n % 2 == 0) {\n            val even1 = arr.take(n/2)\n          \
    \  val even2 = arr.drop(n/2)\n            smallestChange(even1) + smallestChange(even2)\n\
    \        } else {\n            val odd1 = arr.takeRight(n/2).reverse\n       \
    \     val odd2 = arr.dropRight(n/2).reverse\n            smallestChange(odd1)\
    \ + smallestChange(odd2)\n        }", "        var largest = arr.last\n      \
    \  var count = 0\n        for( l <- arr.reverse ) {\n            if(l != largest)\
    \ {\n                if(count == 0) {\n                    count = arr.lastIndexOf(l)\
    \ + 1\n                } else {\n                    count = count\n         \
    \       }\n            }\n            largest = l\n        }\n        count.toLong",
  "        val map = new collection.mutable.HashMap[Long, Long]()\n        arr.foreach(x\
    \ => map.updated(x, map.getOrElse(x, 0) + 1))\n        val minChange = map.minEntry\
    \ match {\n            case None => 0\n            case Some((x, xMin)) => x -\
    \ xMin\n        }\n        minChange", "        if (arr.isEmpty) 0\n        else\
    \ {\n            def findMin(arr : List[Long], acc : Long) : Long = {\n      \
    \          if (arr.isEmpty) acc\n                else {\n                    def\
    \ findMinHelper(arr : List[Long], acc : Long, pos : Int) : Long = {\n        \
    \                if (pos == arr.size) {\n                            acc\n   \
    \                     } else {\n                            def findMinHelperHelper(arr\
    \ : List[Long], acc : Long, pos : Int) : Long = {\n                          \
    \      if (pos == arr.size) {\n                                    acc\n     \
    \                           } else {\n                                    def\
    \ findMinHelperHelperHelper(arr : List[Long], acc : Long, pos : Int) : Long =\
    \ {\n                                        if (pos == arr.size) {\n        \
    \                                    acc\n                                   \
    \     } else {\n                                            val nextMinPos = pos\
    \ + 1\n                                            val nextMaxPos = arr.size -\
    \ 1\n                                            findMinHelperHelperHelper(arr,\
    \ Math.min(acc, arr[nextMinPos]), nextMinPos) + 1\n                          \
    \              }\n                                    }\n                    \
    \                findMinHelperHelperHelper(arr, acc, pos) + 1\n              \
    \                  }\n                            }\n                        \
    \    findMinHelperHelper(arr, acc, pos) + 1\n                        }\n     \
    \               }\n                    findMinHelper(arr, acc, 0)\n          \
    \      }\n            }\n            findMin(arr, 1)\n        }", "        var\
    \ changes = 0\n        var cur = 0\n        var min = Long.MaxValue\n        var\
    \ max = Long.MinValue\n        for(i <- arr.iterator){\n            val curr =\
    \ i\n            val next = arr.last\n            val len = next - curr\n    \
    \        if (cur > len) return\n            if (cur < min){\n                min\
    \ = curr\n            }\n            if (cur > max){\n                max = curr\n\
    \            }\n        }\n        if (max != min){\n            changes = 1\n\
    \        }\n        max - 1", "        // Write your code here\n        val arr\
    \ = arr.sorted\n        var low = 0\n        var high = arr.size - 1\n       \
    \ while(low < high){\n            while(arr[low] == arr[low+1])\n            \
    \    low+=1\n            while(arr[high] == arr[high-1])\n                high-=1\n\
    \            if(low>high)\n                return 0\n            low+=1\n    \
    \        high-=1\n        }\n        arr.size", "        if(arr.length == 1){\n\
    \            return arr(0)\n        }\n        val newArr = arr.sorted\n     \
    \   var flag = 0\n        var count = 0\n        var left = 0\n        var right\
    \ = newArr.length - 1\n        var current: Long = 0\n        while(count <= newArr.length){\n\
    \            current = newArr(flag)\n            while(current != newArr(flag\
    \ + 1)){\n                if(left == right && current == newArr(flag)) {\n   \
    \                 count += 1\n                }else if(left == right && current\
    \ != newArr(flag + 1)){\n                    count -= 1\n                }\n \
    \               flag += flag + 1\n            }\n            flag = 0\n      \
    \      count -= 1\n            flag += flag + 1\n            left += 1\n     \
    \       flag += flag + 1\n            right -= 1\n            flag += flag + 1\n\
    \        }\n        count -= 1\n        newArr.length", "        val newArr =\
    \ arr.map(_.toLong)\n        var newArr2 = newArr.reverse\n        var minNum\
    \ = Long.MaxValue\n        for ( i <- 0 to newArr2.length-1 ; j <- (i+1) to newArr2.length-1\
    \ ) {\n            val tempNewArr2 = newArr2.take(i)\n            val tempNewArr1\
    \ = newArr2.drop(i)\n            val tempNewArr = tempNewArr2.zip(tempNewArr1).map{case\
    \ (a,b) => a + b}\n            val min = tempNewArr.min\n            if ( min\
    \ < minNum ) {\n                minNum = min\n            }\n        }\n     \
    \   minNum", "        val arr1 = arr.toList\n        val arr2 = arr.reverse\n\n\
    \        val diffList = (arr2.length - arr1.length).max(0)\n\n        var start\
    \ = 0\n        var end = diffList\n        var i = 0\n        while (i <= arr1.length)\
    \ {\n            if (arr1(i) == arr2(end - 1)) {\n                end -= 1\n \
    \           } else if (arr1(i) != arr2(end - 1)) {\n                start = i\n\
    \                end = diffList\n                while (i <= arr1.length && arr1(i)\
    \ != arr2(end - 1)) {\n                    i +=1\n                }\n        \
    \        end -= 1\n            }\n            i += 1\n        }\n        arr2.size\
    \ - start", "        val map = new scala.collection.mutable.HashMap[Long, Long]()\n\
    \        arr.foreach { el => map.put(el, el) }\n        val newMap = map.toMap\n\
    \        val reverseMap = newMap.reverse\n        reverseMap.size match {\n  \
    \          case 0 => 0\n            case 1 => 1\n            case _ => {\n   \
    \             val diffCount = reverseMap.size - newMap.size\n                val\
    \ minDiffCount = diffCount.min(arr)\n                minDiffCount.product\n  \
    \          }\n        }", "        val set = arr.foldLeft(Set.empty[Long])((set,\
    \ v) => if (set.add(v)) set else set.union(v))\n        val reverseSet = arr.reverse.foldLeft(Set.empty[Long])((set,\
    \ v) => if (set.add(v)) set else set.union(v))\n        if(set.size == arr.size)\n\
    \            0\n        else set.size", "        val ans = arr.head\n        val\
    \ index = 0\n        while(index < arr.length -1){\n            if(arr(index)\
    \ != arr(index+1)){\n                ans = ans + 1\n            }\n          \
    \  index++\n        }\n        ans", "        if (arr.isEmpty) 0\n        val\
    \ n = arr.size\n        // If n is odd, we need to add one element and reverse\
    \ the list before returning\n        if (n % 2 == 0) (1 + smallestChange(List(rev(arr))))\
    \ % n\n        else (smallestChange(List(arr.reverse, arr.reverse))) // If n is\
    \ even, we simply need to reverse the list twice", "        val n = arr.size\n\
    \        if (n <= 1) 0\n        else smallestChangeHelper(arr, n)", "        val\
    \ leftmost = arr.head\n        val rightmost = arr.last\n        val min = math.min(rightmost-leftmost+1,\
    \ arr.length-1)\n        val set = HashSet[Long]()\n        for (i <- 0 until\
    \ min) {\n            set.add(arr(i))\n        }\n        if (min < arr.length)\
    \ 0 else {\n            var right = 0\n            var left = arr.length\n   \
    \         var change = 0\n            while (left < right) {\n               \
    \ if (set.contains(arr(left))) change = change + 1\n                left = left\
    \ + 1\n            }\n            change = min - change\n            if (change\
    \ < 0) change else change = 0\n        }\n        change", "        val n = arr.length\n\
    \        val m = n/2\n        var i = 0\n        val plist = arr.iterator.toList\n\
    \        plist.reverse foreach (x => plist.insert(i, x))\n        if(plist.size\
    \ < 2) return 0l\n        for(i <- 1 until plist.size) {\n            var j =\
    \ 0\n            val rlist = plist.iterator.toList\n            val xlist = plist.iterator.toList\n\
    \            xlist.reverse.drop(i).take(j).foreach(x => rlist.insert(j, x))\n\
    \            rlist.reverse.take(i).foreach(x => xlist.insert(j, x))\n        \
    \    val temp = xlist\n            val y = rlist\n            val z = temp\n \
    \           if(y.head < z.head) return y.head - z.head\n            if(y.head\
    \ > z.head) return z.head - y.head\n        }\n        return 0l", "        if\
    \ (arr.length < 2) {\n            return 0\n        }\n        val newArr = (arr.head\
    \ / 2).toLong\n        val change = smallestChange(arr.tail)\n        if (newArr\
    \ < change) {\n            change\n        } else {\n            change + smallestChange(newArr.toInt\
    \ - 1)\n        }", "        var n = arr.length\n        var i = 0\n        var\
    \ j = 1\n        var temp = List[Long]()\n        var currentValue = arr(i)\n\n\
    \        while (i < n) {\n            while(j < n && currentValue > arr(j)) {\n\
    \                j+=1\n            }\n            i += 1\n            temp = temp.drop(j+1).concat(currentValue\
    \ - arr(j)).take(j+1).reverse\n            currentValue = arr(i)\n        }\n\
    \        arr.take(i).foldLeft(0) { (acc, x) => acc.min }", "        var n = arr.length\n\
    \        var m = 0\n        var c = 0\n        var k = arr.length\n        while\
    \ (k >= 0 && m == 0) {\n            n -= 1\n            if (n > 0) {\n       \
    \         arr(n) = arr(n)\n                m += 1\n                k -= 1\n  \
    \              c += 1\n            }\n        }\n        var ret = 0\n       \
    \ while (k > 0 && m > 0) {\n            k -= 1\n            m -= 1\n         \
    \   ret += c\n        }\n        ret += m\n        ret", "        val len = arr.length\n\
    \        var smallest = 0\n        val arr = arr.reverse\n        for(i <- 0 to\
    \ arr.length - 1){\n            val currentElement = arr(i)\n            if(currentElement\
    \ == arr[len - 1 - i]){\n                smallest = smallest + 1\n           \
    \ }\n        }\n        smallest", "        val m  = arr.size\n        val n \
    \ = arr.size % 2\n        val left = arr.init\n        val right = arr.tail\n\
    \        var l = 0\n        val r = 0\n        while (l <= (m / 2) ) {\n     \
    \       val mid = (l + r) / 2\n            if ( left > right ) {\n           \
    \     val temp = right\n                right = left\n                left = temp\n\
    \            }\n            if ( left < right ) {\n                val temp =\
    \ left\n                left = right\n                right = temp\n         \
    \   }\n            if( left == right) {\n                if( left == mid ) {\n\
    \                    l++ ;\n                }\n                if ( right == mid\
    \ ) {\n                    r++ ;\n                }\n            }\n        }\n\
    \        ( r - l )", "        val changes = arr.foldRight(List[Long]())(\n   \
    \         (arr, acc) => arr.foldRight(acc.reverse)(\n                (arr, acc)\
    \ => if (acc.head == acc.last) acc + 1 else acc\n            ))\n\n        val\
    \ length = arr.size\n        val result = changes.length\n        if (result >\
    \ length)\n            changes.length\n        else if (result < length)\n   \
    \         result\n        else\n            0", "        var arr = arr\n     \
    \   val maxCount = arr.length - 1\n        // Scan the array once\n        var\
    \ min = maxCount\n        var changes = 0\n        while(arr.nonEmpty) {\n   \
    \         val first = arr.head\n            val second = arr.last\n          \
    \  val third = arr.take(2).last\n            if (first.equals(second) && first.equals(third)\
    \ || second.equals(third)) {\n                arr.remove(first)\n            \
    \    arr.remove(second)\n                arr.remove(third)\n                changes\
    \ += 1\n            }\n            else if(first.equals(second)) {\n         \
    \       arr.remove(first)\n                changes += 1\n            }\n     \
    \       else {\n                arr.remove(second)\n                changes +=\
    \ 1\n            }\n            if(changes > min) {\n                min = changes\n\
    \            }\n        }\n        min", "        val arr = arr.sortBy(x => x)\n\
    \        var count = 0\n        var start = 0\n        while (start < arr.length\
    \ - 1) {\n            if (arr[start] == arr[arr.length - 1 - start]) {\n     \
    \           count += 1\n            } else {\n                count = 0\n    \
    \        }\n            start = start + count\n        }\n        arr.length",
  "        arr.foldLeft((0, List[Long]()))((acc, val) => {\n            val minChange\
    \ = acc._1 + 1\n            val newList = (acc._2 :+ val).reverse\n          \
    \  val isPalendromic = newList == newList.reverse\n            if(isPalendromic)\
    \ minChange else minChange\n        })", "       var ans = 1\n       var len =\
    \ arr.length\n       var maxLen = len\n       var changes = 1\n       var i =\
    \ len - 1\n       while(i >= 0){\n          if((arr(i) != arr(len - 1 - i))  &&\
    \ (arr(i) != (arr[len - 1 - i]))  && (arr(i) != (arr(i) + 1))) {\n           \
    \ ans = ans + 1\n          }\n          else {\n            changes = changes\
    \ + 1\n          }\n          maxLen = maxLen - 1\n          i = i - 1\n     \
    \  }\n       (ans + changes)", "        val newSet = arr.groupBy(x => x % 10).mapValues(x\
    \ => x).mapValues(x => x).map(x => x._2.size).min\n        var count : Long =\
    \ 0\n        for (x <- newSet) {\n            if (x == 2) {\n                count\
    \ += 1\n            }\n        }\n        return count", "        def minSwap(i\
    \ : Long, j : Long, arr : List[Long], result : Long): Long = {\n            //\
    \ base case\n            if (i < 0 || j >= arr.length) return result\n       \
    \     val swap = arr(i)\n            arr(i) = arr(j)\n            arr(j) = swap\n\
    \            minSwap(i + 1, j - 1, arr, result)\n        }\n        minSwap(0,\
    \ 0, arr, arr.size)", "        val maxChanges = arr.map(_.toString.toLong).map\
    \ (x => ArrayBuffer(x.reverse).map(_.toString.toLong).filterNot(_ => x == 0)).flatten.min\n\
    \        arr.map(_.toString.toLong).filterNot(x => x == 0).toString.toLong(maxChanges)",
  "        val size = arr.length\n        val palindromicList = arr.toSet.toList.sorted\n\
    \n        def getMinimumChangeCount(startIndex : Int, endIndex : Int, changeCount\
    \ : Int) : Int\n            = if (startIndex == endIndex) changeCount\n      \
    \      else if (palindromicList.take(startIndex).reverse != palindromicList.drop(endIndex))\
    \ changeCount\n            else getMinimumChangeCount(startIndex + 1, endIndex,\
    \ changeCount + 1)\n\n        getMinimumChangeCount(0, size - 1, 0)", "      \
    \  // Solution using a mutable TreeSet\n        val map = new mutable.TreeSet[Long]()\n\
    \        val mapIter = map.iterator\n        var counter = 0\n        for(x <-\
    \ arr) {\n            if(map.contains(x))\n                mapIter = map.remove(x)\n\
    \            else {\n                counter += 1\n                map += x\n\
    \            }\n        }\n        mapIter.last", "        val lenArr = arr.length\n\
    \        var min = lenArr\n        var cur = 0\n        var next = 0\n       \
    \ while (cur < lenArr) {\n            next += 1\n            val mid = (cur +\
    \ next) / 2 // mid = (cur + next) / 2\n            // val mid = cur + next\n \
    \           val tempArr = arr.take(mid).reverse + arr.drop(mid).reverse\n    \
    \        if (tempArr == arr) min = (mid * 2)\n            else min = (Math.min(min,\
    \ arr.size - mid))\n            cur = mid\n        }\n        require(min != 0)\n\
    \        lenArr * 2", "        var i = 0\n        var min_val = 0l\n        var\
    \ max_val = arr.last\n        while(i < arr.length) {\n            if(max_val\
    \ == arr(i)) {\n                max_val = arr(i)\n            }\n            if(min_val\
    \ > max_val){\n                min_val = max_val\n            }\n            else{\n\
    \                max_val = min_val\n            }\n            i = i + 1\n   \
    \     }\n        return min_val", "        val n = arr.length\n        val m =\
    \ arr.head\n        val count = (0 until n).filter (x => x != m).map (x => 1 until\
    \ n).map (x => x diff m by -1).filter (x => x == 0).sum\n        if (n == 1)\n\
    \            0\n        else if (count < m)\n            -1\n        else\n  \
    \          m", "        var ans = 0\n        var temp = 0l\n        var i = 0\n\
    \        var j = 0\n        var lastIndex = arr.length - 1\n        while (i <\
    \ lastIndex && j < lastIndex) {\n            ans = min(ans, temp + arr(i) - arr(j))\n\
    \            temp = temp + arr(i)\n            i += 1\n            j += 1\n  \
    \      }\n        ans", "        var palindromicLength = 0\n        for(i<- arr.length)\
    \ {\n            val temp = arr(i)\n            for(j<- i until (arr.length))\
    \ {\n                if(arr(j) > temp) {\n                    palindromicLength\
    \ += 1\n                    arr(j) = temp\n                }\n            }\n\
    \        }\n        if(palindromicLength == 1) palindromicLength else\n      \
    \      if(arr.length == palindromicLength) 0\n            else palindromicLength",
  "        var n = arr.length\n        var min = arr.head\n        var ans = 0\n \
    \       while(n > 1) {\n            ans += (arr.head - min)\n            min =\
    \ arr.last\n            n -= 1\n        }\n        ans", "        val result =\
    \ mutable.HashSet[Long]()\n        var index = 0\n        while(index < arr.length)\
    \ {\n            val tmp = arr(index)\n            if(result.contains(tmp)) {\n\
    \                val min = result.iterator\n                        .zip(arr.iterator)\n\
    \                        .takeWhile(t => t._1 < t._2)\n                      \
    \  .map(t => t._2)\n                        .mkString(\"\")\n                if(min\
    \ != arr(index)) {\n                    index = index + 1\n                }\n\
    \                result.clear()\n                result += tmp\n            }\n\
    \            else {\n                result.clear()\n                result +=\
    \ tmp\n            }\n        }\n        if(result.size != arr.length)\n     \
    \       0\n        else\n            result.size", "        val l = arr.reverse\n\
    \        var count = 0\n        for (i<-0 until arr.size) {\n            if (l.forall(x=>x<arr(i)\
    \ && arr(i) != x)) {\n                count += 1\n                if (count >\
    \ 1) return count\n            }\n        }\n        return 0", "        val maxElementsRequired\
    \ = arr.length\n        val maxElementsRequiredToMakePalindromic = maxElementsRequired\
    \ / 2\n        val result = maxElementsRequiredToMakePalindromic\n        val\
    \ changeList = mutable.ListBuffer[Long]()\n        val backwards = new java.util.TreeSet[Long]()\n\
    \        val forwards = new java.util.TreeSet[Long]()\n        val backwardsSetSize\
    \ = backwards.size\n        val forwardsSetSize = forwards.size\n        val maxSetSize\
    \ = backwardsSetSize + forwardsSetSize\n\n        if (backwardsSetSize == 0) {\n\
    \            if (forwardsSetSize == 0) {\n                result = 0\n       \
    \     } else {\n                result = forwardsSetSize - 1\n            }\n\
    \        } else if (forwardsSetSize == 0) {\n            result = backwardsSetSize\
    \ - 1\n        }\n\n        for( i <- 0 until arr.length ) {\n            val\
    \ currentValue = arr(i)\n            if (backwards.contains(currentValue)) {\n\
    \                val index = backwards.indexOf(currentValue)\n               \
    \ val change = maxElementsRequired - index\n                backwards.remove(currentValue)\n\
    \                changeList.add (change.toLong)\n                maxElementsRequired\
    \ -= change.toLong\n            } else {\n                val index = forwards.indexOf(currentValue)\n\
    \                val change = maxElementsRequired - index\n                forwards.remove(currentValue)\n\
    \                changeList.add (change.toLong)\n                maxElementsRequired\
    \ -= change.toLong\n            }\n        }\n        if(changeList.size > 0)\
    \ {\n            result = math.min(changeList.min(), result)\n        }\n    \
    \    result", "        val n = arr.length\n        val nums = arr.reverse.tail.filter(_\
    \ > 0).reverse\n        val palinNums = nums.toList\n        val palinNumsLen\
    \ = palinNums.length\n        val changes = (palinNumsLen - palinNums.lastIndexWhere(_\
    \ == palinNums(palinNumsLen - 1)) ) / n\n        val n = palinNumsLen / 2\n  \
    \      val leftNums = palinNums.take(n)\n        val rightNums = palinNums.drop(n)\n\
    \        val leftChange = smallestChange(leftNums)\n        val rightChange =\
    \ smallestChange(rightNums)\n        val result = leftChange + changes + rightChange\n\
    \        leftChange + changes + rightChange", "        val len = arr.length\n\
    \        val arr2 = arr.toList\n        val len = arr.length\n        val arr2reversed\
    \ = arr2.reverse\n        var count = 0\n        var index = len - 1 \n      \
    \  while(index >=0 && count < len / 2) \n        {\n            if(arr2reversed(index)\
    \ != arr(index)) \n            {\n                count = count + 1\n        \
    \        index = index - 1\n            } else \n            {\n             \
    \   index = index - 1\n            }\n        }\n        if (count < len / 2)\
    \ \n        {\n            count = count + 1\n        }\n        count", "   \
    \     val maxLength = arr.max\n        var changes = mutable.ListBuffer.empty[Int]\n\
    \        var currentMax = 0l\n        var i = 0\n        while(i < maxLength){\n\
    \            currentMax = arr(i)\n            var j = 0\n            while(j <\
    \ i){\n                if(arr(j) < currentMax){\n                    if(changes(0)\
    \ < j-i){\n                        changes.update(0, j)-i\n                  \
    \  }\n                    else{\n                        currentMax = arr(j)\n\
    \                    }\n                }\n                else{\n           \
    \         if(arr(j) == currentMax){\n                        currentMax = arr(j)\n\
    \                    }\n                    else{\n                        if(arr(j)\
    \ > currentMax){\n                            currentMax = arr(j)\n          \
    \              }\n                    }\n                }\n                j+=1\n\
    \            }\n            changes += currentMax - i\n            i+=1\n    \
    \    }\n        changes.length", "        // O(n) time and space\n        var\
    \ i = 0\n        var j = 0\n        while(i < arr.length){\n            if(arr(i).equals(arr(arr.length\
    \ - 1 - i))){\n                i++;\n            } else {\n                j =\
    \ j + 1;\n                if(j >= arr.length - i){\n                    i = j;\n\
    \                    j = 0;\n                }\n            }\n        }\n   \
    \     return j;", "        // Your code here\n        var count = 0\n        for\
    \ (i <- arr.indices){\n            if (arr(i) < arr(arr.length-i-1)) count +=\
    \ 1\n        }\n        if (count > 1) count - 1\n        else {\n           \
    \ val a = arr.sortWith(_ <=> _)\n            if (a(0) != a(a.length-1))\n    \
    \            count\n            else\n                0\n        }", "       \
    \ val palindromics = arr.groupBy(x => x)\n            .map(x => x._2.size).min\n\
    \        val changes = arr.length - palindromics\n        changes * palindromics",
  "        val result = scala.math.min(arr.length, arr.length)\n        var i : Int\
    \ = 0\n        var j : Int = 0\n        val resultList = mutable.ArrayBuffer(arr)\n\
    \        while (i < arr.length) {\n            while (j < arr.length) {\n    \
    \            if (arr(i) == arr(j)) {\n                    resultList.insert(i,\
    \ arr(j))\n                    resultList.insert(j, arr(i))\n                \
    \    resultList.remove(i)\n                    resultList.remove(j)\n        \
    \        }\n                j++\n            }\n            i += 1\n         \
    \   j = 0\n        }\n        resultList.min", "        val palindromicList =\
    \ arr.sliding(2).map(_.map(x => x + x).toSet).toList.sorted\n        palindromicList.takeWhile(x\
    \ => arr.count(_ == x) > 0).reduceLeft(_ + _)", "        val maxSize = arr.size\n\
    \        var smallestChange = 0\n        var newArr: List[Long] = null\n     \
    \   if (arr.isEmpty) {\n            return 0\n        } else {\n            val\
    \ midIndex = arr.size / 2\n            val midVal = arr.head\n            val\
    \ leftPart = arr.drop(midIndex)\n            val rightPart = arr.take(midIndex)\n\
    \            val changeLeft = smallestChange(leftPart)\n            val changeRight\
    \ = smallestChange(rightPart)\n            val maxChange = max(changeLeft, changeRight)\n\
    \            if (maxChange > 0) {\n                val middlePart = if (maxSize\
    \ % 2 == 1) arr.take(maxSize/2) else arr.take(maxSize/2+1).toList\n          \
    \      if (changeLeft == changeRight) {\n                    newArr = middlePart.reverse\n\
    \                    smallestChange = changeLeft\n                } else {\n \
    \                   newArr = middlePart.reverse\n                    smallestChange\
    \ = changeRight\n                }\n            } else {\n                newArr\
    \ = arr\n            }\n        }\n        return smallestChange", '        arr.foldLeft(0l){
    (a,b) => if (b == a || b < a) b else a }', "        // Step 1: Find maximum and\
    \ minimum value\n        var minValue = arr(0)\n        var maxValue = arr(0)\n\
    \        for (i <- 1 to arr.length) {\n            if (arr(i) < minValue)\n  \
    \              minValue = arr(i)\n            if (arr(i) > maxValue)\n       \
    \         maxValue = arr(i)\n        }\n\n        // Step 2: Create empty map\n\
    \        val palindromicMap = new collection.mutable.LinkedHashMap[Long, Long]()\n\
    \n        // Step 3: Put min and max in the map and make them equal\n        palindromicMap.put(minValue,\
    \ maxValue)\n        palindromicMap.put(maxValue, minValue)\n\n        // Step\
    \ 4: Iterate over the list and remove elements from map and map values\n     \
    \   // to remove duplicates\n        for (i <- 0 until arr.length) {\n       \
    \     var key = arr(i)\n            var value = palindromicMap.get(key)\n\n  \
    \          // Step 5: Remove from map\n            if (value != null) {\n    \
    \            palindromicMap.remove(value)\n            }\n\n            // Step\
    \ 6: Remove from map values\n            if (value != null) {\n              \
    \  palindromicMap.put(value, key)\n            }\n        }\n\n        // Step\
    \ 7: Get length of palindromicMap\n        var length : Long = palindromicMap.length\n\
    \n        // Step 8: Check if length is odd\n        if (length % 2 != 0)\n  \
    \          length -= 1\n\n        // Step 9: Return length\n        length", " \
    \       var palindromic = arr.filter(_ % 2 == 0).filter(_ % 2 == 1).filter(_ %\
    \ 2 != 0).reverse\n        val reversed = palindromic.reverse\n        val smallestChange\
    \ = reversed.indexWhere(x => x == palindromic(0))\n        val difference = reversed.length\
    \ - smallestChange\n        if (difference == 0) 0\n        else smallestChange",
  "        val arr2 = arr.toArray\n        val len = arr.length\n        val count\
    \ = new scala.collection.mutable.HashMap[Long, Int]()\n        var change = 0\n\
    \        var count = 0\n        var minChange = 0\n        var index = len - 1\
    \ // to find last index of any element of arr\n        while (index >= 0) {\n\
    \            if (count.contains(arr2[index])) {\n                val value = count.get(arr2[index])\n\
    \                val newCount = value + 1\n                if (newCount > minChange)\
    \ {\n                    minChange = newCount\n                    change = value\n\
    \                }\n            } else {\n                change.value = change.value.toInt\
    \ + 1\n                count += change\n                change = 0\n         \
    \       minChange = count.min\n            }\n            index -= 1\n       \
    \ }\n        minChange", "        val list = arr.sortBy(-_).toList\n        val\
    \ n = list.length\n        val result = new mutable.HashMap[Int, Long]\n     \
    \   var change = 0\n        for(i <- 0 until n)\n            if (list(i) == list(n-1-i)\
    \ || list(i) == list(n-2-i) || list(i) == list(n-3-i) || list(i) == list(n-i-i))\
    \ {\n                result += ((i) -> change)\n                change += 1\n\
    \            }\n        if (list.length == n)\n            result\n        else\n\
    \            smallestChange(list.toList)", "        var min_change = 0\n     \
    \   var min_length = arr.size\n\n        for (i <- arr.indices) {\n          \
    \  var temp = arr(i)\n            var temp2 = arr(i + 1)\n            if (temp\
    \ < temp2) {\n                temp = arr(i + 1)\n            }\n            if\
    \ (temp < temp2) {\n                temp = arr(i)\n            }\n           \
    \ if (temp < temp2) {\n                temp = arr(i + 1)\n            }\n    \
    \        if (temp < temp2) {\n                temp = arr(i)\n            }\n \
    \           if (temp < temp2) {\n                temp = arr(i)\n            }\n\
    \            if (temp < temp2) {\n                temp = arr(i + 1)\n        \
    \    }\n            if (temp < temp2) {\n                temp = arr(i)\n     \
    \       }\n            if (temp < temp2) {\n                temp = arr(i + 1)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i\
    \ + 1)\n            }\n            if (temp < temp2) {\n                temp =\
    \ arr(i)\n            }\n            if (temp < temp2) {\n                temp\
    \ = arr(i + 1)\n            }\n            if (temp < temp2) {\n             \
    \   temp = arr(i)\n            }\n            if (temp < temp2) {\n          \
    \      temp = arr(i + 1)\n            }\n            if (temp < temp2) {\n   \
    \             temp = arr(i)\n            }\n            if (temp < temp2) {\n\
    \                temp = arr(i + 1)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i + 1)\n            }\n            if (temp <\
    \ temp2) {\n                temp = arr(i)\n            }\n            if (temp\
    \ < temp2) {\n                temp = arr(i + 1)\n            }\n            if\
    \ (temp < temp2) {\n                temp = arr(i)\n            }\n           \
    \ if (temp < temp2) {\n                temp = arr(i + 1)\n            }\n    \
    \        if (temp < temp2) {\n                temp = arr(i)\n            }\n \
    \           if (temp < temp2) {\n                temp = arr(i + 1)\n         \
    \   }\n            if (temp < temp2) {\n                temp = arr(i)\n      \
    \      }\n            if (temp < temp2) {\n                temp = arr(i + 1)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i)\n\
    \            }\n            if (temp < temp2) {\n                temp = arr(i\
    \ + 1)\n            }\n            if (temp < temp2) {\n                temp =\
    \ arr(i)\n            }\n            if (temp < temp2) {\n                temp\
    \ = arr(i + 1)\n            }\n            if (temp < temp2) {\n             \
    \   temp = arr(i)\n            }\n            if (temp < temp2) {\n          \
    \      temp = arr(i + 1)\n            }\n            if (temp < temp2) {\n   \
    \             temp = arr(i)\n            }\n            if (temp < temp2) {\n\
    \                temp = arr(i + 1)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i)\n            }\n            if (temp < temp2)\
    \ {\n                temp = arr(i", "        val m = arr.min\n        val n =\
    \ arr.length\n        val r = new Array[Long](m)\n        val diffs = new Array[Int](n)\n\
    \        val start = new Array[Int](m - 1)\n        val end = new Array[Int](1)\n\
    \        val maxLength = (m / 2).toInt\n        var i = 0\n        var j = 0\n\
    \        while(i < n && j < m){\n            diffs(i) = arr(j) - arr(i)\n    \
    \        i += 1\n            j += 1\n        }\n        var max = 0\n        while(i\
    \ < n){\n            if(diffs(i) == 0){\n                i += 1\n            }else{\n\
    \                if(diffs(i) > 0){\n                    while(j < m && diffs(i)\
    \ - arr(j) == 0){\n                        j += 1\n                    }\n   \
    \                 if(j < m){\n                        while(j < m && diffs(i)\
    \ - arr(j) < 0){\n                            j += 1\n                       \
    \ }\n                        if(j >= m){\n                            while(j\
    \ < m && diffs(i) < 0){\n                                j += 1\n            \
    \                }\n                            if(j >= m){\n                \
    \                while(j < m && diffs(i) != 0){\n                            \
    \        j += 1\n                                }\n                         \
    \       if(j >= m){\n                                    val temp = diffs(i)\n\
    \                                    val temp2 = arr(j)\n                    \
    \                val temp3 = diffs(i) - arr(j)\n                             \
    \       if(temp2 == temp3){\n                                        val temp\
    \ = diffs(i)\n                                        val temp2 = arr(j)\n   \
    \                                     val temp3 = diffs(i) - arr(j)\n        \
    \                                val temp4 = diffs(j) - diffs(i)\n           \
    \                             if(temp2 == temp3){\n                          \
    \                  val temp = diffs(i)\n                                     \
    \       val temp2 = arr(j)\n                                            val temp3\
    \ = diffs(i) - arr(j)\n                                            val temp4 =\
    \ diffs(j) - diffs(i)\n                                            val temp5 =\
    \ arr(j) - arr(i)\n                                            if(temp2 == temp3){\n\
    \                                                val temp = diffs(i)\n       \
    \                                         val temp2 = arr(j)\n               \
    \                                 val temp3 = diffs(i) - arr(j)\n            \
    \                                    val temp4 = diffs(j) - diffs(i)\n       \
    \                                         val temp5 = arr(j) - arr(i)\n      \
    \                                          if(temp2 == temp3){\n             \
    \                                       val temp = diffs(i)\n                \
    \                                    val temp2 = arr(j)\n                    \
    \                                val temp3 = diffs(i) - arr(j)\n             \
    \                                       val temp4 = diffs(j) - diffs(i)\n    \
    \                                                val temp5 = arr(j) - arr(i)\n\
    \                                                    val temp6 = arr(i) - arr(j)\n\
    \                                                    if(temp2 == temp3){\n   \
    \                                                     val temp = diff", "    \
    \    val changed = mutable.ListBuffer[Long]()\n        val reversed = arr.map(x\
    \ => reverse(x))\n        for (i <- 0 until arr.length) {\n            if (i ==\
    \ arr.length - 1) {\n                if (arr(i) == arr(0)) {\n               \
    \     changed.add(i)\n                }\n            } else if (arr(i) == arr(i\
    \ + 1)) {\n                val k = reversed.indexOf(arr(i))\n                changed.add(k)\n\
    \            }\n        }\n        changed.min", "        var pal = false\n  \
    \      var count = 0\n        for( i <- arr.indices.reverse ) {\n            if(\
    \ arr(i) == arr(i+1) ) {\n                pal = true\n                count =\
    \ i\n            }\n        }\n        if( !pal ) {\n            count = 0\n \
    \       }\n        \n        return count", "        var i = 0\n        val maxValue\
    \ = arr.foldLeft(arr.head)((m, x) => if (x < m) x else m)\n        var min = maxValue\n\
    \        var minI = 0\n        var minJ = 0\n        var isPalindrome = true\n\
    \        while (i < arr.length) {\n            min = maxValue\n            minI\
    \ = minJ = 0\n            var tmp = arr(i)\n            while (tmp != 0) {\n \
    \               tmp = tmp / 10\n                val digit = tmp.toInt\n      \
    \          val index = digit * 10 + minI\n                if (index >= arr.length)\
    \ break\n                if (arr(index) != digit) {\n                    minJ\
    \ = index\n                    break\n                }\n                minI\
    \ += 1\n                min = Math.min(min, digit + arr(minJ))\n            }\n\
    \            isPalindrome = minI == minJ\n            val change = if (isPalindrome)\
    \ minI-1 else arr.length - minI\n            if (change > arr.length) break\n\
    \            i += 1\n        }\n        min", "        val arrCopy = arr.toBuffer\n\
    \        arrCopy.reverse()\n        val result = 0\n        var index = 0\n  \
    \      while (index < arrCopy.size)\n        {\n            val change = arrCopy(index\
    \ - 1).toLong - arrCopy(index).toLong\n            if (change <= 0)\n        \
    \    {\n                result = result + 1\n            }\n            else\n\
    \            {\n                result = result\n            }\n            index\
    \ = index + 1\n        }\n        return result", "        val arr = arr.sort\n\
    \        val n = arr.length\n        val min = n - 1\n\n        // for case when\
    \ arr is Palindromic\n        if (n == 0 || arr(n-1) == arr(0))\n            0\n\
    \        else\n            1 + smallestChange(arr.take(min).reverse)", "     \
    \   val len = arr.length\n        val maxLen = math.pow(2, len.toDouble)\n   \
    \     val map = mutable.HashMap.empty[Long, Long]\n        var counter = arr(0)\n\
    \        var lenCounter = 1\n        for (i <- 1 until len) {\n            val\
    \ a = counter\n            val b = arr(i)\n            val c = math.pow(b, a)\n\
    \            val lenCounter = math.max(lenCounter, c.toInt)\n            counter\
    \ += a\n            map.put(i, c)\n        }\n\n        val lenMax = math.pow(2,\
    \ lenCounter)\n        val minNum = lenMax - lenMax * map.getOrElse(lenCounter,\
    \ 0L).toInt\n        val minNumPalin = map.getOrElse(lenCounter, 0L).toInt * 2\n\
    \        val maxNumPalin = map.getOrElse(lenCounter, 0L).toInt * 2 + 1\n     \
    \   if (minNum >= minNumPalin && maxNumPalin <= maxLen && lenCounter <= maxLen)\
    \ {\n            return lenCounter\n        } else {\n            0l\n       \
    \ }", "        if(arr.length == 0) 0\n        else if(arr.head.toString.equals(\"\
    -1\")) 0\n        else arr.head + smallestChange(arr.tail)", "        val r =\
    \ arr.size + 1\n        var m = 0\n        var i = 0\n        var j = 0\n    \
    \    for(i <- 0 until arr.size) {\n            for(j <- 0 until arr.size) {\n\
    \                if (i == j) continue\n                if (arr(i) > arr(j)) continue\n\
    \                if (arr(i) < arr(j)) continue\n                if (arr(i) ==\
    \ arr(j)) {\n                    if (i > j) m += 1\n                    if (i\
    \ == arr.size) m += arr.size - j\n                    if (j == arr.size) m +=\
    \ arr.size - i\n                }\n            }\n        }\n        val m = arr.size\
    \ - r\n        if (m < 0) -1\n        else m", "        val nr = arr.length\n\
    \        if (nr == 0)\n            return 0\n        val l = arr.head\n      \
    \  val n = nr - 1\n        val s = n / 2\n        var minChange = 0\n        while\
    \ (l <= r) {\n            val m = s * (s - 1)\n            val j = m + m + 2 *\
    \ m\n            if (arr(j) == arr(j + 1) && arr(j) == l) {\n                minChange\
    \ = j\n            }\n            s -= 1\n            r += 1\n        }\n    \
    \    minChange", "        // first find out whether there is more than one element\
    \ in the list to change\n        val changed = arr.filter(x => x != arr.last).length\
    \ != arr.length\n        // If there is only one element in the list, then there\
    \ is no need to change the elements\n        if (!changed) 0\n        // If there\
    \ are more than one element in the list, we need to change one element to another\
    \ element\n        else arr.take(arr.length - 1).foldLeft(arr.last)(_ + 1) + (arr.last\
    \ * arr.take(arr.length - 1).reverse.foldLeft(arr.last)(_ + 1))", "        arr.sortBy(_.toLong).reverse.foldLeft(0)\
    \ {\n            case (acc,item) => {\n                // Change one item to any\
    \ other item and keep track of how many times we changed\n                // If\
    \ we ever reach the length of the list without changing any item then stop\n \
    \               val curr = acc.toLong\n                acc += if (item == arr[acc.length-1])\
    \ 0 else 1\n                acc\n            }\n        }", "        val pList\
    \ = new mutable.ListBuffer[Long]()\n        val pList = arr.map(elem => (elem\
    \ + arr(arr.lastIndexOf(elem))).toLong)\n        val palindromicList = arr.take(arr.lastIndexOf(arr(arr.lastIndexOf(arr(0))).toLong))\n\
    \        pList.takeWhile(elem => palindromicList.exists(palindrome(elem)))", " \
    \       val arr2 = arr.dropRight(1)\n        val arr1 = arr.dropLeft(1)\n    \
    \    val ans = arr.head\n        if (arr2.length < arr1.length) {\n          \
    \  ans = arr2.head\n        }\n        val arr3 = arr2.zipWithIndex\n        val\
    \ p1 = arr3.takeWhile(_._2 > arr.head).map(_._1).sum\n        val p2 = arr3.takeWhile(_._2\
    \ < arr.head).map(_._1).sum\n        if (p1 < p2) {\n            ans\n       \
    \ } else {\n            ans - p1\n        }", "        var maxCount = 0\n    \
    \    for(i <- 0 until arr.length) {\n            var count = 1\n            for(j\
    \ <- 0 until i) {\n                if(arr(i-j) == arr(i-j+1)) {\n            \
    \        count += 1\n                }\n            }\n            maxCount =\
    \ max(maxCount,count)\n        }\n        maxCount", "        var stack = immutable.Stack.empty[Long]\n\
    \        var min = Long.MaxValue\n        var index = 0\n        var startIndex\
    \ = 0\n        while(index < arr.length) {\n            val n = arr(index)\n \
    \           val start = index\n            val end = (index + 1) % arr.length\n\
    \            val currentIndex = start\n            while(currentIndex < end &&\
    \ index < arr.length) {\n                stack.push(arr(currentIndex))\n     \
    \           currentIndex = (currentIndex + 1) % arr.length\n            }\n  \
    \          stack.reverse()\n            index = end\n            while(index <\
    \ arr.length) {\n                if(stack.isEmpty) {\n                    min\
    \ += 1\n                } else {\n                    val top = stack.pop()\n\
    \                    if(top != n) {\n                        min += 1\n      \
    \                  break\n                    }\n                }\n         \
    \       index += 1\n            }\n        }\n        return min", "        val\
    \ list: mutable.Buffer[Long] = mutable.Buffer.empty\n        var index = 0\n \
    \       var ans = 0\n\n        while (index < arr.length) {\n            val element\
    \ = arr(index)\n            list.+=element\n            index += 1\n\n       \
    \     while (index < arr.length) {\n                if (element == arr(index))\
    \ {\n                    index += 1\n                } else {\n              \
    \      val left = list.last\n                    val right = arr(index)\n    \
    \                if (left != right) {\n                        ans += 1\n    \
    \                    list.pop\n                    }\n                    index\
    \ += 1\n                }\n            }\n        }\n        ans", "        if(arr.isEmpty)\
    \ 0\n        else {\n            val ms = arr.map(x => x*x)\n            val len\
    \ = ms.length\n            var i = 0\n            val m1 = ms\n            val\
    \ m2 = ms.reverse\n\n            while(i < len) {\n                if(ms(i) !=\
    \ m2(i)) {\n                    val next = m1(i + 1)\n                    m1(i)\
    \ = m2(i) = next\n                    i += 2\n                } else {\n     \
    \               i += 1\n                }\n            }\n\n            if(m1(len)\
    \ != m2(len)) {\n                val next = m2(len - 1) + 1\n                m1(len)\
    \ = m2(len) = next\n            }\n\n            m1(0) = m2(0) = 1\n         \
    \   m1.map(x => x*x).sum\n        }", "        val n = arr.size\n        if(n\
    \ == 0) 0\n        else if n % 2 == 0 {\n            val mid = n / 2\n       \
    \     smallestChange(arr.take(mid)).change(mid, mid, arr)\n        } else {\n\
    \            val mid = n / 2\n            smallestChange(arr.take(mid)).change(mid,\
    \ mid+1, arr)\n        }", "        val newArray = arr.toBuffer.toArray.sortWith(compare)\n\
    \        var change = 0\n        val m = newArray.length\n        var i = 0\n\
    \        var j = 0\n        var index = 0\n        while (i<m) {\n           \
    \ if (newArray(i) == newArray(m-1))\n                change = change + 1\n   \
    \         i = i + 1\n        }\n        if (change == 0) {\n            return\
    \ 0\n        } else {\n            change = change-1\n            while (j < change)\
    \ {\n                index = j\n                j = (j+1)%m\n            }\n \
    \           return newArray(index)\n        }", "        def rec(curr : Long,\
    \ min : Long, len : Int) : Long = {\n            if( len == 0)\n             \
    \   min\n            else if(arr[curr].toLong < arr[min].toLong)\n           \
    \     rec(curr+1, min, len-1)\n            else if( arr[curr].toLong == arr[min].toLong\
    \ && min != curr)\n                rec(curr+1, curr, len-1)\n            else\n\
    \                rec(curr+1, min, len-1)\n        }\n        rec(0, -1, arr.size)",
  "        def isPalindromic(palin : Long, element : Long) : Boolean = {\n       \
    \     val rev_palin = element.toString.reverse //To reverse palindrome string.\n\
    \            rev_palin.toCharArray.takeWhile(c => c != palin).forall{c => c !=\
    \ element}\n        }\n        val length = arr.length\n        var countChanges\
    \ = 0\n        var maxCount = -1L\n        val changeArray = arr.foldLeft((List[Long](0l.toLong),\
    \ List[Long](0l.toLong))) {\n            case ((count, changes), element) =>\n\
    \                val isPalin = element.toString.reverse == element.toString\n\
    \                if(count < maxCount && isPalin) count + 1\n                else\
    \ if(count > maxCount && !isPalin) count\n                else (count, changes\
    \ + 1L)\n        }._1\n        val changeList = changeArray._1.reverse\n     \
    \   var maxChange = -1L\n        changeList.foreach { c =>\n            val isPalin\
    \ = isPalindromic(c, changeArray._2)\n            if(isPalin && maxChange < c)\
    \ maxChange = c\n        }\n        if(maxChange < length) countChanges = maxChange\n\
    \        countChanges", "        val palindromicArray = arr.toList\n        val\
    \ maxPalindromicIndex = palindromicArray.indexOf(palindromicArray.last) + palindromicArray.size\
    \ + 1\n        val maxPalindromic = palindromicArray.take(maxPalindromicIndex).toArray\n\
    \        val sumPalindromic = palindromicArray.filter(_ => palindromicArray.indexOf(_)\
    \ == palindromicArray.lastIndexOf(_)).sum\n        maxPalindromicIndex - sumPalindromic",
  "        val minVal = arr.head\n        val maxVal = arr.last\n        val minMax\
    \ = maxVal - minVal\n        val revArr = reverse(arr)\n        var sum = 0\n\
    \        var count = 0\n        for (x <- arr) {\n            if (sum + x == revArr.sum)\
    \ {\n                count += 1\n            }\n            sum = sum + x\n  \
    \      }\n        (count * minMax).min(minVal)", "        val n = arr.length\n\
    \        val resultSet = new mutable.TreeSet[Long]\n        if (arr.isEmpty ||\
    \ arr.length <= 1) {\n            return 0\n        }\n        val pivot = arr(arr.length\
    \ / 2)\n        var i = arr.length - 1\n        var j = arr.length - 1\n     \
    \   while (i >= 0 && j >= 0) {\n            val left = arr(i - 1)\n          \
    \  val right = arr(j)\n            if (left == pivot) {\n                val temp\
    \ = arr(i)\n                arr(i) = right\n                arr(j)= temp\n   \
    \             i -= 1\n                j -= 1\n                resultSet += j\n\
    \            } else {\n                j --\n            }\n        }\n      \
    \  resultSet.min", "        def go(i : Int, l : List[Long]) : Long = i match {\n\
    \            case 0 => l(0)\n            case 1 => l(0)\n            case 2 =>\
    \ l(0)\n            case i => l(i) min l(i - 1)\n        }\n        val len =\
    \ arr.size\n        val maxLen = len - 1 // to handle odd numbered list\n    \
    \    (len + 1) max 0 //to handle even\n        val start = 0\n        val end\
    \ = len - 1\n        var changes = 0\n        while(start < maxLen) {\n      \
    \      val middle = start + (end - start) / 2\n            val middleVal = go(middle,\
    \ arr)\n            if (middleVal == middle) {\n                changes += 1\n\
    \            }\n            end = middle\n            start = middle\n       \
    \ }\n        if (changes == 1) changes += 1\n        changes", "        var len\
    \ = arr.length\n        val count = new scala.collection.mutable.HashMap[Long,\
    \ Long]()\n        var cur :Long = 0\n        var flag = false\n        var index\
    \ = 0\n        while (index < len) {\n            if (count.contains(arr(index)))\
    \ {\n                val curr = count(arr(index))\n                if (curr >\
    \ cur) {\n                    cur = curr\n                    flag = true\n  \
    \              }\n            } else {\n                val curr = 1\n       \
    \         count.put(arr(index), curr)\n            }\n            index = index\
    \ + 1\n        }\n        if (flag == false)\n            return 1\n        else\n\
    \            return cur", "        val m = arr.takeRight(arr.length-1)\n     \
    \   var changes = 0\n        var i = 0\n        while(i < m.length) {\n      \
    \      if(m(m(i)) == m(m.length-i-1) ) {\n                changes += 1;\n    \
    \            i +=1\n            } else {\n                i +=1\n            }\n\
    \        }\n        changes + 1", "        val n = arr.size\n        val minChanges\
    \ = arr match {\n            case Nil => 0\n            case head :: tail => {\n\
    \                val change = smallestChange(tail)\n                val nextMinChange\
    \ = if (head % 2 == 0) n / 2 - change else -change // If the head is even, subtract\
    \ two changes from the next head, otherwise add two\n                smallestChange(tail.take(nextMinChange)\
    \ ++ tail.drop(nextMinChange))\n            }\n        }\n        minChanges",
  "        // Create a stack\n        val stack = mutable.Stack[Long]()\n        arr.foreach{x\
    \ => stack push x}\n        while(stack.nonEmpty) {\n            // Pop and compare\
    \ the current element with the top of the stack\n            val cur = stack.pop()\n\
    \            val top = stack.last\n            if(top == cur){\n             \
    \   // If the current element is equal to the top of the stack, remove it\n  \
    \              stack.pop()\n            }\n            else{\n               \
    \ // If it's greater than the top of the stack, add it to the stack\n        \
    \        if(top < cur){\n                    stack push cur\n                }\n\
    \                // If it's less than the top of the stack, remove it from the\
    \ stack\n                else{\n                    stack.pop()\n            \
    \    }\n            }\n        }\n        // Now check if the stack has any elements,\
    \ and return their number\n        if(stack.nonEmpty){\n            stack.toList.length\n\
    \        }\n        else{\n            0\n        }", "        var i = arr.length\n\
    \        var min = arr(0).toLong\n        var j = arr.length - 1\n        var\
    \ k = arr.length - 1\n        var temp = 0\n\n        while(i >= 0 && j >= 0){\n\
    \            if(arr(i) != arr(k)){\n                temp = arr(i).toLong - arr(k).toLong\n\
    \                if(temp < min){\n                    min = temp\n           \
    \     }\n            }\n            i = i - 1\n            k = k - 1\n       \
    \ }\n        min", "        val listSize = arr.length\n        val reverseList\
    \ = new mutable.ArrayList[Long]()\n        var i = listSize - 1\n        while(i\
    \ >= 0) {\n            reverseList += arr(i)\n            i -= 1\n        }\n\
    \        var sum = 0\n        val minChange = new mutable.Queue[Long]()\n    \
    \    var startIndex = 0\n        var endIndex = listSize\n        if(listSize\
    \ % 2 == 0) {\n            startIndex = (listSize - 1) / 2\n            endIndex\
    \ = listSize / 2\n        } else {\n            startIndex = (listSize - 1) /\
    \ 2\n            endIndex = (listSize + 1) / 2\n        }\n\n        var startElement\
    \ = reverseList(startIndex)\n        var lastElement = reverseList(endIndex)\n\
    \        var lastElementChange = 0\n        val maxLength = math.min(endIndex\
    \ - startIndex, listSize)\n        var currentLength = listSize\n        while(currentLength\
    \ > 0) {\n            val maxElement = reverseList(currentLength - 1)\n      \
    \      if(maxElement == startElement) {\n                if(currentLength == listSize)\
    \ {\n                    minChange += lastElement\n                    lastElement\
    \ = 0l\n                    currentLength = listSize + 1\n                } else\
    \ {\n                    minChange += maxElement\n                    lastElementChange\
    \ = currentLength\n                    currentLength -= 1\n                }\n\
    \            } else {\n                val nextElement = reverseList(currentLength\
    \ + 1)\n                if(nextElement == lastElement) {\n                   \
    \ minChange += nextElement\n                    lastElementChange = currentLength\n\
    \                    currentLength -= 1\n                } else {\n          \
    \          minChange += maxElement\n                    lastElementChange = currentLength\n\
    \                    currentLength -= 1\n                }\n            }\n  \
    \      }\n        if(reverseList.size() < listSize) {\n            val lastElement\
    \ = reverseList(listSize)\n            if(lastElement == startElement) {\n   \
    \             minChange += lastElement\n                lastElementChange = listSize\n\
    \            } else {\n                minChange += lastElement\n            \
    \    lastElementChange = listSize\n            }\n        }\n        while(!minChange.isEmpty)\
    \ {\n            sum += minChange.dequeue\n        }\n        sum", "        val\
    \ n = arr.length\n        val arrSize = arr.size\n        val min = arrSize /\
    \ 2\n        val min = arrSize / 2\n        for (i<-0 to arr.length-1){\n    \
    \        val current = arr(i)\n            if (i % 2 == 0){\n                if\
    \ (current < min)\n                    min = current\n            } else {\n \
    \               if (current > min)\n                    min = current\n      \
    \      }\n        }\n        arr.size - min", "        val n = arr.size\n    \
    \    if (n <= 1)\n            return 0\n        val mid = (n - 1) / 2\n      \
    \  // Reverse the subarray starting at index mid to index mid - 1\n        val\
    \ (rev1, rev2) = arr.splitAt(mid)\n        // Do the same for the subarray starting\
    \ from mid to n - 1\n        val (r1, r2) = rev2.splitAt(n - mid)\n        //\
    \ Now add up the difference between the first half of the reversed subarray\n\
    \        // and the first half of the reversed subarray + the first half of the\
    \ original subarray.\n        // This will be the minimum number of elements needed\
    \ to reverse the subarray.\n        //\n        // For the first half of the reversed\
    \ subarray, reverse the entire list\n        // and add the first half of the\
    \ original list to it. \n        // For the first half of the original subarray,\n\
    \        // reverse the subarray and add the first half of the reversed subarray\
    \ to it.\n        // The difference between the two halves of the reversed subarray\
    \ will \n        // be the minimum number of elements needed to reverse the original\
    \ subarray.\n        // Repeat this procedure for each half of the original array.\n\
    \        //\n        // The answer will be the minimum number of elements needed\
    \ to reverse the\n        // original subarray.\n        // For a more detailed\
    \ explanation see Section 5.2 of \"Intro to Algorithms\" by CLRS or section 5.3\
    \ of \"Intro to Algorithms\" by CLRS in \"Algorithms for Programmers Volume 2\"\
    \ by Bentley.\n        //\n        // Time Complexity: O(n)\n        val m = r1.size\n\
    \        val r = r1.size + r2.size + arr.size\n        (if (r < m)\n         \
    \   r\n        else\n            m) ", "        var arr = arr.toList\n       \
    \ var minChanges = arr.length\n        val maxDiff = arr.tail.diff(arr).toInt\n\
    \        val minDiff = arr.head.diff(arr).toInt\n        minDiff = if (minDiff\
    \ < 0) -minDiff else minDiff\n        val maxDiffInt = maxDiff.toInt\n       \
    \ minChanges = if (minChanges < 0) -minChanges else minChanges\n        while\
    \ (arr.head != arr.tail) {\n            var currentMinDiff = arr.head.diff(arr).toInt\n\
    \            var currentMinChanges = arr.head.diff(arr).toInt\n            currentMinDiff\
    \ = if (currentMinDiff < 0) -currentMinDiff else currentMinDiff\n            currentMinChanges\
    \ = if (currentMinChanges < 0) -currentMinChanges else currentMinChanges\n   \
    \         minDiff = minDiff.min(currentMinDiff)\n            minChanges = minChanges.min(currentMinChanges)\n\
    \            arr = arr.tail\n        }\n        arr.length", "        var minChange\
    \ = arr.length\n        for (i <- 0 until arr.length / 2) {\n            var current\
    \ = 0\n            var start = 0\n            var end = arr.length - 1\n     \
    \       while (start < end) {\n                if (current == arr[start].get)\
    \ current += 1\n                else if (current == arr[end].get) current -= 1\n\
    \                else {\n                    if (current > 0) start++\n      \
    \              else end--\n                }\n            }\n            if (current\
    \ < minChange) minChange = current\n        }\n        minChange", "        def\
    \ smallestChangeHelper(arr: List[Long], arrReverse: List[Long]): Long = {\n  \
    \          if(arr.isEmpty)\n                return 0\n            val newArrReverse\
    \ = arrReverse.head\n            var largest = arr.head\n            for(i <-\
    \ 1 until arr.length)\n                if(arr(i) == largest)\n               \
    \     largest += arrReverse(i)\n            val minChange = smallest + largest\n\
    \            if(smallest > largest)\n                smallestChangeHelper(arr.tail,\
    \ newArrReverse)\n            else\n                smallestChangeHelper(newArrReverse,\
    \ arr)\n        }\n\n        smallestChangeHelper(arr, arr.reverse)", "      \
    \  var sum = 0l\n        var count = 1\n        var index = 0\n        var flag\
    \ = false\n        var temp = arr.head\n\n        while(index < arr.length){\n\
    \            if(arr(index) < temp){\n                temp = arr(index)\n     \
    \       }\n            index = index + 1\n        }\n\n        for(i = 0; i <\
    \ arr.length; i++){\n            if(arr(i) == temp){\n                sum = sum\
    \ + 1l\n            }\n        }\n\n        while(index < arr.length){\n     \
    \       if(arr(index) > temp){\n                temp = arr(index)\n          \
    \  }\n            index = index + 1\n        }\n\n        for(i = 0; i < arr.length;\
    \ i++){\n            if(arr(i) == temp){\n                sum = sum + 1l\n   \
    \         }\n        }\n\n        for(i = 0; i < arr.length; i++){\n         \
    \   if(arr(i) != temp){\n                count = count + 1\n                flag\
    \ = true\n            }\n        }\n\n        if(flag){\n            return 0l\n\
    \        }\n        return sum + count", "        val m = arr.max\n        val\
    \ l = arr.min\n        val diff = m - l - 1\n        if(diff <= 0) {\n       \
    \     return 0\n        }\n        else if(diff < 0) {\n            val n = arr.length\n\
    \            val dl = l - n - 1\n            if(dl <= 0) {\n                return\
    \ 0\n            }\n            else if(dl < 0) {\n                return -1\n\
    \            }\n        }\n        val p = scala.util.Sorting.quickSort(arr.toList).reverse\n\
    \        val s = (p + p).min\n        return Math.abs(s)", "        var change\
    \ = 0\n        for (i <- 0 until arr.length) {\n            val prev = arr.head\n\
    \            val next = arr.last\n            arr.head = next\n            arr.last\
    \ = prev\n            change = Math.min(change, arr.length - 1)\n        }\n \
    \       change", "        val len = arr.size\n        var cur = 0\n        var\
    \ min = Integer.MIN_VALUE\n        var min = len\n        var left = 0\n     \
    \   var right = (len - 1)\n\n        while ( left < right ) {\n            val\
    \ mid = math.floor((left + right) / 2)\n            val leftElem = arr(mid)\n\
    \            val rightElem = arr(len - mid - 1)\n            if (leftElem == rightElem)\
    \ {\n                cur = cur + 1\n                min = Math.min(min, cur)\n\
    \                left = mid + 1\n                right = (len - mid - 1)\n   \
    \         } else if (leftElem < rightElem) {\n                min = Math.min(min,\
    \ cur)\n                left = mid + 1\n            } else {\n               \
    \ right = mid\n            }\n        }\n        min", "        if (arr.length\
    \ == 1) return 0\n        val mn = arr.min\n        var changeCount = 0\n    \
    \    // O(n)\n        for (i <- arr.indices if arr(i) != mn) changeCount++\n \
    \       changeCount", "        var result = arr.head\n        var temp = arr\n\
    \        for (i<-arr.length to 1 by -1){\n            var temp = arr\n       \
    \     temp.foreach{ x=> if(x.toLong<i) temp = temp::(x::temp)}\n            var\
    \ changed = temp\n            if(temp.isEmpty || changed == temp.reverse){\n \
    \               temp = temp.reverse\n                changed = temp\n        \
    \    }\n            result = result + Math.max(temp.length - changed.size, 0)\n\
    \        }\n        result", "        var change = 0\n        var temp = 0\n \
    \       arr.sortWith((x,y) => x.toLong <=> y.toLong)\n        arr.foreach { x\
    \ =>\n            temp = arr.reverse.find(y=> y.toLong == x)\n            if(temp.isDefined\
    \ && temp.toLong != x) {\n                change++\n            }\n        }\n\
    \        change", "        val counts = arr.groupBy(x => x%2==0).mapValues(_.length).filter(_._2\
    \ == arr.length).toSeq\n        counts.length match {\n            case 0 => 0\n\
    \            case 1 => arr(0)\n            case _ => {\n                val reversed\
    \ = arr.foldLeft(List[Long]())((acc, x) => if(acc == List[Long]()) List(x) ::\
    \ acc else acc ::: List(x))\n                val maxCount = reversed.foldLeft(0l)((acc,\
    \ x) => if (acc == 0 || x > reversed(acc)) x else acc)\n                val newCount\
    \ = reversed.foldLeft(1l)((acc, x) => if (acc == 0 || x > reversed(acc)) x + 1\
    \ else acc)\n                maxCount - newCount\n            }\n        }", " \
    \       // Write your code here\n        var min = arr.length\n        var count\
    \ = 0\n        for(i<- arr.length-1 to 0 by -1){\n            count += 1\n   \
    \         if(arr.toList.map(_+1).equals(arr.toList.map(_-1))){\n             \
    \   min = count\n            }\n        }\n        min", "        val len = arr.length\n\
    \        if(len == 1) 0\n        else if(len == 2) 1\n        else {\n       \
    \     val arr1 = arr.takeRight(len/2)\n            val arr2 = arr.drop(len/2)\n\
    \            val p1 = smallestChange(arr1)\n            val p2 = smallestChange(arr2)\n\
    \            if(p1 < p2) p1 else p2\n        }", "        if(arr.isEmpty) 0\n\
    \        else if(arr.head.toString == arr.tail.head.toString) arr.size\n     \
    \   else if(arr.head.toLong == arr.tail.head.toLong) arr.size\n        else smallestChange(arr.tail).min(arr.head.toLong)",
  "        if (arr.isEmpty) {\n            return 0\n        }\n\n        val result\
    \ = arr.foldLeft(arr.size - 1){\n            (count, cur) => count\n        }\n\
    \n        val reversed = arr.reverse\n        val isPalindrome = reversed == arr\n\
    \        if (reversed.size < arr.size && !isPalindrome) {\n            return\
    \ 0\n        }\n\n        val changes = arr.size - 1\n        (result - changes,\
    \ changes)", "        val m = arr.foldLeft(arr.head) { (i, x) => if (x.compareTo(i)\
    \ < 0) x else i }\n        val n = arr.foldRight(arr.head) { (i, x) => if (x.compareTo(i)\
    \ < 0) x else i }\n        val sum = arr.foldLeft(arr.head + 1) { (i, x) => if\
    \ (x.compareTo(i) < 0) x else i }\n        val len = len - 1 // -1 because the\
    \ first element in the list has already been changed to match it\n        val\
    \ diff = (m * n - sum) / len\n        diff + arr.size", "        def f(n : Long,\
    \ list : List[Long]) : List[Long] = list match {\n            case x :: xs if\
    \ (x != n) => x :: f(n, xs)\n            case x :: xs => x :: xs\n           \
    \ case Nil => Nil\n        }\n        val n = arr(arr.length-1)\n        if (arr.length\
    \ == 1) n\n        else {\n            val left = f(arr(0), arr :: Nil)\n    \
    \        val right = f(n - arr(arr.length-1), arr.reverse)\n            arr.length\
    \ - left.length + right.length\n        }", "        val len = arr.length\n  \
    \      var count = 1\n        val m = new mutable.HashMap[Long, Long]()\n    \
    \    for (i <- 1 to len) {\n            if (m.contains(arr(i))) {\n          \
    \      count = count + 1\n            } else {\n                m.put(arr(i),\
    \ count)\n                count = count + 1\n            }\n        }\n\n    \
    \    var minCount = count\n        var minChange = 0\n        for (i <- 1 to len)\
    \ {\n            val currentCount = m.get(arr(i))\n            if (currentCount\
    \ > minCount) {\n                minCount = currentCount\n                minChange\
    \ = arr(i)\n            }\n        }\n        minChange", "        // Solution\
    \ using dynamic programming\n        // Using a mutable matrix to store the current\
    \ min number of elements that can be changed to make the list palindromic\n  \
    \      val m = arr.length\n        val n = arr.head\n        val p = new Array[List[Long]](m)\n\
    \        var i = 1\n        var j = 0\n        while (i <= m-1) {\n          \
    \  if (i == j) {\n                // For the first element in the array\n    \
    \            p(i) = n\n                i += 1\n            }\n            else\
    \ if (arr[i - 1] != arr[j]) {\n                // If the element at i doesn't\
    \ match the element at j\n                // then we need to change one element\n\
    \                p(i) = min(arr(i), arr(j))\n                i += 1\n        \
    \    }\n            else {\n                // If the element at i matches the\
    \ element at j then\n                // we need to change two elements\n     \
    \           p(i) = min(arr(i), arr(j))\n                j += 1\n            }\n\
    \        }\n        p(0)", "        val arr = arr.sortWith(_ < _)\n        var\
    \ counter = 0\n        var j = 0\n        var i = 0\n        while(j < arr.length){\n\
    \            while(j >= 0 && arr(i) == arr(i+1)){\n                j -= 1\n  \
    \              i += 1\n            }\n            if(j >= 0){\n              \
    \  counter += j\n                j = 0\n            }\n        }\n        counter",
  "        val n = arr.size\n        val m = 2 * arr.size\n        val p = m / 2\n\
    \n        val l = new Array[Long](m)\n\n        for (i <- 0 until p)\n       \
    \     l(i) = arr(i)\n\n        for ((i <- 0 until m)) {\n            val j = i\
    \ + 1\n            val k = j - 1\n            if (l(i) != arr(k))\n          \
    \      l(i) = arr(k)\n        }\n\n        val sumOf2 = 0\n        for (i <- 0\
    \ until p) {\n            sumOf2 = sumOf2 + l(i) * l(i)\n        }\n\n       \
    \ val sumOf1 = n - sumOf2\n        return sumOf1", "       //Sort descending order\
    \ and reverse the array \n       //and remove duplicate items from the reversed\
    \ array\n       arr.sortWith(_>_).reverse.toSet.toList.distinct", '        arr.foldLeft(0)(_+arr.reverse
    match { case a :: b => smallestChange(b diff a) })', "        val l = arr.size\n\
    \        val l = arr.min\n        val l = arr.max\n        val l = (l / 2).toInt\n\
    \        val l = arr.min\n        val l = arr.max\n        val l = (l / 2).toInt\n\
    \        val l = arr.min\n        val l = arr.max\n        val l = arr.size\n\
    \        val l = arr.min\n        val l = arr.max\n        val l = arr.min\n \
    \       val l = arr.max\n        val l = arr.min\n        val l = arr.max\n  \
    \      val l = arr.min\n        val l = arr.max\n        val l = arr.min\n   \
    \     val l = arr.max\n        val l = arr.min\n        val l = arr.max\n    \
    \    val l = arr.min\n        val l = arr.max\n        val l = arr.min\n     \
    \   val l = arr.max\n        val l = arr.min\n        val l = arr.max\n      \
    \  val l = arr.min\n        val l = arr.max\n        val l = arr.min\n       \
    \ val l = arr.max\n        val l = arr.min\n        val l = arr.max\n        val\
    \ l = arr.min\n        val l = arr.max\n        val l = arr.min\n        val l\
    \ = arr.max\n        val l = arr.min\n        val l = arr.max\n        val l =\
    \ arr.min\n        val l = arr.max\n        val l = arr.min\n        val l = arr.max\n\
    \        val l = arr.min\n        val l = arr.max\n        val l = arr.min\n \
    \       val l = arr.max\n        val l = arr.min\n        val l = arr.max\n  \
    \      val l = arr.min\n        val l = arr.max\n        val l = arr.min\n   \
    \     val l = arr.max\n        val l = arr.min\n        val l = arr.max\n    \
    \    val l = arr.min\n        val l = arr.max\n        val l = arr.min\n     \
    \   val l = arr.max\n        val l = arr.min\n        val l = arr.max\n      \
    \  val l = arr.min\n        val l = arr.max\n        val l = arr.min\n       \
    \ val l = arr.max\n        val l = arr.min\n        val l = arr.max\n        val\
    \ l = arr.min\n        val l = arr.max\n        val l = arr.min\n        val l\
    \ = arr.max\n        val l = arr.min\n        val l = arr.max\n        val l =\
    \ arr.min\n        val l = arr.max\n        val l = arr.min\n        val l = arr.max\n\
    \        val l = arr.min\n        val l = arr.max\n        val l = arr.min\n \
    \       val l = arr.max\n        val l = arr.min\n        val l = arr.max\n",
  "        // Write your code here.\n        val maxLen = arr.length\n        val\
    \ stack = mutable.Stack[Long]()\n        val visited = mutable.HashSet[Long]()\n\
    \        val changed = mutable.HashSet[Long]()\n        for (i<- 0 until maxLen){\n\
    \            if (visited(i)){\n                stack.pop()\n                visited(i)\n\
    \            }\n            else if (stack.isEmpty || arr(i) != stack.pop()){\n\
    \                stack.push(arr(i))\n                visited.add(arr(i))\n   \
    \             changed.add(arr(i))\n            }\n        }\n        if (!stack.isEmpty)\
    \ changed(stack.pop())\n        if (stack.isEmpty) changed(0)\n        changed.size",
  "        val len = arr.length\n        var left = 0\n        var right = 0\n\n \
    \       while(left < len) {\n            right = len - left\n            if(right\
    \ > 1) {\n                val mid = left + (right >> 1)\n                if(arr.tail.tail.tail.forall(a\
    \ => a == arr.tail.last) &&  arr.tail.forall(a => a == arr.last)) {\n        \
    \            left += right\n                    right = mid\n                \
    \    if(left > len) {\n                        left = 0\n                    }\n\
    \                } else {\n                    right = mid - 1\n             \
    \   }\n            } else {\n                if(arr.tail.forall(a => a == arr.last))\
    \ {\n                    left += 1;\n                }\n            }\n      \
    \  }\n        if(left > 0) {\n            left\n        } else {\n           \
    \ 0\n        }", "        var ans = ListBuffer.empty[Long]\n        arr.foreach\
    \ { x =>\n            val reverse = arr.reverse\n            val len = arr.size\n\
    \            var max = 0\n            var i = 0\n            for (i<len/2 ; i\
    \ <len-i; i++ ) {\n                if (x>reverse(i)) {\n                    max\
    \ = i\n                    break;\n                }\n            }\n        \
    \    ans += (arr(max).toLong)\n        }\n        ans.min", "        // write\
    \ your code here\n        val arr = arr.reverse\n        if(arr.isEmpty) {\n \
    \           return 0\n        }\n        var count = 0\n        val arr = arr.map(x\
    \ => (x % 2) == 0)\n        var i = 0\n        while(i < arr.length) {\n     \
    \       if(arr(i) == arr(i)) {\n                count = count+1\n            \
    \    i = i + 1\n            } else {\n                i = i + 1\n            }\n\
    \        }\n        return count", "        // Convert to a mutable list, then\
    \ sort it and reverse it\n        val arr2 = arr.toList.sortBy(x => x).reverse\n\
    \n        // Keep a record of the last and current value\n        val last = 0\n\
    \        val current = 0\n        var currentIndex = 0\n        var palindromicIndex\
    \ = 0\n\n        // The smallest change is 0 for the whole list\n        val smallestChange\
    \ = 0l\n\n        // Go through each element in the list\n        for (i <- 0\
    \ until arr2.length) {\n            // If this element is the same as the previous\
    \ element\n            if (arr2(i) == last) {\n                current += 1\n\
    \                // Update the smallestChange if this is the smallest change\n\
    \                if (current == smallestChange) {\n                    palindromicIndex\
    \ = i\n                }\n            } else {\n                // Update last,\
    \ current and smallestChange values\n                last = arr2(i)\n        \
    \        current = 1\n                smallestChange = current\n            }\n\
    \            // Update the current index\n            currentIndex += 1\n    \
    \    }\n\n        // If we have no change in the smallest change\n        if (currentIndex\
    \ == 0) {\n            smallestChange = 0\n        } else {\n            smallestChange\
    \ = smallestChange - 1\n        }\n\n        // Return the smallest change\n \
    \       palindromicIndex", "        var len = arr.length\n        var mid = 0\n\
    \        var cur = 0\n        var flag = 0\n\n        while (cur < len) {\n  \
    \          while (cur < len && flag == 1) {\n                mid = cur\n     \
    \           cur += 1\n                if (arr[mid] == arr[cur]) flag = 0\n   \
    \             else flag = 1\n            }\n\n            if (cur < len) cur +=\
    \ 1\n            else return mid\n        }\n        return 0", "        var stack\
    \ = new Stack[Long]()\n        var low = 0\n        var high = arr.length - 1\n\
    \        while (low < high) {\n            if (arr[low] == arr[high]) {\n    \
    \            low += 1\n                high -= 1\n            } else if (arr[low]\
    \ > arr[high]) {\n                stack.push(arr[low])\n                low +=\
    \ 1\n            } else {\n                stack.push(arr[high])\n           \
    \     high -= 1\n            }\n        }\n        val len = arr.length\n    \
    \    var counter = 0\n        while (stack.size > 0)\n            counter += 1\n\
    \        return counter", "        val arrToAns  = arr.toList.toArray.sortBy(_._2).reverse.zipWithIndex\n\
    \        val ansIndex = arrToAns.toList.head._2\n        val index    = arrToAns.toList.last._2\n\
    \        val minCount = (ansIndex - index) / 2\n\n        var count = 0\n    \
    \    for(i <- 0 until arr.length){\n            val newIndex = arr.length - count\
    \ - 1 - (i + 1)\n            val newCount = arr.length - count - 1 - i\n     \
    \       if(newIndex < 0){\n                newIndex = newIndex + newCount\n  \
    \          }\n            if(newIndex > arr.length){\n                newIndex\
    \ = newIndex - newCount\n            }\n            if(newIndex < 0){\n      \
    \          newIndex = newIndex + newCount\n            }\n            if(newIndex\
    \ > arr.length){\n                newIndex = newIndex - newCount\n           \
    \ }\n\n            if((arr(i).toLong - arr[newIndex].toLong) < (arr(i).toLong\
    \ - arr[newIndex].toLong)){\n                count = count + 1\n            }\n\
    \        }\n        arr.length.toLong - count * 2", "        val map = mutable.LinkedHashMap[Long,\
    \ Long]()\n        val arr = arr.toList\n        for( i <- arr.indices.reverse;\
    \ e <- arr(i)) map += (e -> arr(i))\n        // Now map holds the palindromic\
    \ array\n        // Now traverse this map and find the minimum number of changes:\n\
    \        map.toSeq.sortBy(_._1).reverse.headOption.map { case (key, value) =>\n\
    \            if (value == arr.last) 0 else {\n                val index = value\
    \ - 1\n                val min = index\n                var prevMin = index -\
    \ 1\n                for (e <- arr.indices) {\n                    if (e - prevMin\
    \ == index)\n                        min++\n                    else if (e - prevMin\
    \ > index)\n                        break\n                    prevMin = e\n \
    \               }\n                min\n            }\n        }.getOrElse(0)",
  "        val n = arr.length\n        val d = n / 2\n        val m = n / 2\n    \
    \    var x = arr[m - 1]\n        var y = arr[m]\n\n        var changes = 0\n \
    \       while(m > 0 && d > 0 && x > y ){\n            x = y\n            y = arr[m-1]\n\
    \            arr(m-1) = arr[m]\n            arr(m) = x\n            m -= 1\n \
    \           d -= 1\n            changes +=1\n        }\n\n        if(changes >\
    \ 0){\n            return changes - 1\n        }\n        return 0", "       \
    \ // Create hash map to store all elements with their index\n        // And then\
    \ iterate to create list of elements that needs to be changed\n        var hashMap\
    \ : mutable.HashMap[Long, Int] = mutable.HashMap[Long, Int]()\n        for (i\
    \ <- 0 until arr.length) {\n            if (i % 2 == 0) {\n                hashMap.update(arr(i),\
    \ hashMap.getOrElse(arr(i), 0) + 1)\n            } else {\n                hashMap.update(arr(i),\
    \ hashMap.getOrElse(arr(i), 0) - 1)\n            }\n        }\n        \n    \
    \    // Compare all elements with hashMap\n        // If hashMap has more than\
    \ half elements that need to be changed, return half of them\n        // If hashMap\
    \ has less than half elements that need to be changed, return half of them\n \
    \       // If hashMap has exactly the same elements that need to be changed, return\
    \ 0\n        var result : Long = 0\n        for (i <- hashMap) {\n           \
    \ if (hashMap(i) > arr.length / 2) {\n                result = hashMap(i)\n  \
    \          } else if (hashMap(i) < arr.length / 2) {\n                result =\
    \ hashMap(i)\n            }\n        }\n        return result", "        var min\
    \ = Integer.MAX_VALUE\n        var min = arr(0)\n        var minIndex = -1\n \
    \       for(i <- arr.indices) {\n            if(arr(i) == arr(arr.length - 1 -\
    \ i)) {\n                val temp = arr(arr.length - i - 1)\n                arr(arr.length\
    \ - i - 1) = arr(i)\n                arr(i) = temp\n                min = Math.min(arr(i),\
    \ min)\n                if(min != Integer.MAX_VALUE && minIndex == -1) {\n   \
    \                 minIndex = i\n                }\n            }\n        }\n\
    \        min", "      var len = arr.size\n      if(len == 1) return arr(0)\n \
    \     if(len == 0) return 0l\n      var maxP = 0l\n      var numChanges = 0\n\
    \      while(len > 0) {\n        len -= 1\n        if(arr(len) > arr(len - 1))\
    \ maxP += 1\n        if(arr(len) < arr(len - 1)) numChanges += 1\n      }\n  \
    \    if(numChanges == 0) {\n        if(maxP < 2) maxP = 0\n        else maxP =\
    \ 2\n      }\n      else maxP = maxP / 2\n      if(maxP < 1) maxP = 0\n      else\
    \ maxP = 1\n      return maxP", "        val arr = arr.reverse\n        var minChange\
    \ = 0L\n        var left = 0\n        var right = 0\n        for (i <- arr.indices)\
    \ {\n            val next = arr(i)\n            if (next < arr[left]) {\n    \
    \            left = i\n            }\n            if (next > arr[right]) {\n \
    \               right = i\n            }\n        }\n        if (right - left\
    \ + 1 > minChange) {\n            minChange = right - left + 1\n        }\n  \
    \      left", "        val m = arr.length\n        val n = arr.head\n        val\
    \ set = Set[Long]().toSet\n        var min = math.min(m, n)\n        for(i <-\
    \ m until n-1) {\n            if(arr(i) == arr(i + 1)) {\n                if(arr(i)\
    \ != 0) {\n                    min += 1\n                    arr(i) = -1\n   \
    \             }\n            } else {\n                val b = set(arr(i))\n \
    \               if(arr(i) != 0 && b != -1) {\n                    min += 1\n \
    \                   arr(i) = b\n                }\n                val c = set(arr(i\
    \ + 1))\n                if(arr(i) != 0 && c != -1) {\n                    min\
    \ += 1\n                    arr(i + 1) = c\n                }\n            }\n\
    \        }\n        min"]
stop_tokens:
- "\n    }\n"
