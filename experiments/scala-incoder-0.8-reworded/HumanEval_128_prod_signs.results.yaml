language: scala
name: HumanEval_128_prod_signs
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft((1l,\
    \ 1l))((accVal, currVal) => {\n            // Multiply currVal\n            (accVal\
    \ * currVal, // Multiply currVal\n            accVal + currVal) // Add currVal\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvo0tv75a.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            (accVal * currVal, \e[34m// Multiply currVal\e\
    [0m\n\e[31m\e[31m   |\e[0m             ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue * is\
    \ not a member of (Long, Long), but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvo0tv75a.scala:19:19 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            accVal + currVal) \e[34m// Add currVal\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of (Long, Long), but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.foldLeft((0l,0l))\
    \ {\n            case ((sumOfSigns, productOfSigns), v) =>\n                if\
    \ (v > 0) (sumOfSigns + 1l, v) else (sumOfSigns - v, v * -1)\n        }\n    \
    \    signs._1 / (signs._2)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy6_xsf6f.scala:20:8\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m        signs._1 / (signs._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \  Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013258
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.map(x => x * x).sum\n        val signs = arr.map((x) => math.signum(x)).sum\n\
    \        Option((product * signs))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplkq2f1m7.scala:21)\n\tat Problem.main(tmplkq2f1m7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      arr.foldLeft(0L)\
    \ {\n        case (acc, val) => (if (val < 0) -val else val) * acc }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpnwflg4_s.scala:17:19 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mcase\e[0m (acc, \e[33mval\e[0m) => (\e\
    [33mif\e[0m (\e[33mval\e[0m < \e[31m0\e[0m) -\e[33mval\e[0m \e[33melse\e[0m \e\
    [33mval\e[0m) * acc }\n\e[31m\e[31m   |\e[0m                   ^^^\e[0m\n\e[31m\
    \   |\e[0m                   pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmpnwflg4_s.scala:17:32 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mcase\e[0m (acc, \e[33mval\e[0m) => (\e\
    [33mif\e[0m (\e[33mval\e[0m < \e[31m0\e[0m) -\e[33mval\e[0m \e[33melse\e[0m \e\
    [33mval\e[0m) * acc }\n\e[31m\e[31m   |\e[0m                                ^^^\e\
    [0m\n\e[31m   |\e[0m                                expression expected but \e\
    [31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnwflg4_s.scala:17:42\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mcase\e[0m\
    \ (acc, \e[33mval\e[0m) => (\e[33mif\e[0m (\e[33mval\e[0m < \e[31m0\e[0m) -\e\
    [33mval\e[0m \e[33melse\e[0m \e[33mval\e[0m) * acc }\n\e[31m\e[31m   |\e[0m  \
    \                                        ^^^\e[0m\n\e[31m   |\e[0m           \
    \                               ')' expected, but 'val' found\n3 errors found\n"
  stdout: ''
  timestamp: 1660013251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var product =\
    \ 1\n        var sumMagnitudes = 0l\n        for (el <- arr) {\n            sumMagnitudes\
    \ += Math.pow(el, product)\n            product *= el\n        }\n        if (arr.isEmpty)\
    \ None else Some(sumMagnitudes)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0jvyrhpt.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            sumMagnitudes += Math.pow(el, product)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \    value += is not a member of Long - did you mean Long.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp0jvyrhpt.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            product *= el\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member\
    \ of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def product(x\
    \ : Long, y : Long) : Long = {\n            if (x>0) x*y else y*x\n        }\n\
    \        val mags = arr.map(x => abs(x))\n        mags.foldLeft(0l) {\n      \
    \      case (acc, x) => acc + product(x, 1)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpac61h230.scala:20:26\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        mags.foldLeft(\e[31m0l\e\
    [0m) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:   \
    \ Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m21 |\e[0m       \
    \     \e[33mcase\e[0m (acc, x) => acc + product(x, \e[31m1\e[0m)\n\e[31m22 |\e\
    [0m        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013258
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sign : Long\
    \ = 0\n        var maxSign : Long = 0\n        arr.foreach{x =>\n            sign\
    \ = math.signum(x)\n            if(sign == -1)\n                maxSign = math.max(x,maxSign)\n\
    \            else if(sign == 0)\n                maxSign = math.max(maxSign,x)\n\
    \        }\n        Some(maxSign*arr.sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8i6k5nz_.scala:28)\n\tat Problem.main(tmp8i6k5nz_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.toIterator.flatMap\
    \ { x=>\n            val sign = x.getSign\n            val mag = x.toDouble\n\
    \            if(mag==0.0)\n            None\n            else\n            Some((sign\
    \ * mag))\n        }.reduceLeftOption(x=>x*x).map(x=>x.toLong)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4v6mut46.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36msign\e[0m = x.getSign\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                     value getSign is not a member of Long\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmp4v6mut46.scala:23:28 ---------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        }.reduceLeftOption(x=>x*x).map(x=>x.toLong)\n\e[31m\e\
    [31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                  Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4v6mut46.scala:23:44 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        }.reduceLeftOption(x=>x*x).map(x=>x.toLong)\n\e[31m\e\
    [31m   |\e[0m                                          ^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toLong is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = mutable.Set[Int]()\n\
    \        val magnitudes = mutable.Map[Long, Long]()\n        val products = mutable.Map[Long,\
    \ Long]()\n\n        arr.foreach{ i =>\n            signs += i\n            magnitudes(i)\
    \ = i\n            products(i) = i\n        }\n\n        magnitudes.foldLeft(0l)\
    \ { (product, magnitude) => product * magnitude }\n        signs.foldLeft(0l)\
    \ { (product, sign) => product * sign }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0nw8inj0.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = mutable.Set[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0nw8inj0.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mmagnitudes\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0nw8inj0.scala:18:23\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mproducts\e[0m = mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None else Some(arr.map(_.abs) * arr.product)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzsfy0bo9.scala:16:55 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (arr.isEmpty) None \e[33melse\e\
    [0m Some(arr.map(_.abs) * arr.product)\n\e[31m\e[31m   |\e[0m                \
    \                        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue * is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def checkMag(x\
    \ : Long) : Int = {\n            if (x != 0) return 1\n            else if (x\
    \ < 0) return -1\n            else return 0\n        }\n        arr.foldLeft((0,\
    \ arr(0).toLong))((acc, x) => {\n            (checkMag(x) * acc(1), x)\n     \
    \   })\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_xdu27ek.scala:22:13\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            (checkMag(x) * acc(\e\
    [31m1\e[0m), x)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013257
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(_.abs).sum\n\
    \        var signs = arr.map(_.signum).sum\n        if (signs == 0) {\n      \
    \      Some(m * arr.last)\n        } else {\n            signs = arr.map(_.signum).sum\n\
    \            if (signs != 0) {\n                Some((arr.takeWhile(_ > 0).last)\
    \ * m)\n            } else {\n                None\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9wnu7x25.scala:30)\n\tat Problem.main(tmp9wnu7x25.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0L\n\
    \        var mag = 0\n        var sign = 1\n\n        for(num <- arr) {\n    \
    \        mag += num\n            if(num > 0) {\n                sign += num\n\
    \            } else {\n                sign *= -1\n            }\n           \
    \ sum += mag\n        }\n        Some(sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjzj6bqtu.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            mag += num\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int\
    \ - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjzj6bqtu.scala:23:21\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                sign += num\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \     value += is not a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum: Option[Long]\
    \ = Option.empty[Long]\n        var product: Option[Long] = Option.empty[Long]\n\
    \        var sign: Option[Long] = Option.empty[Long]\n        for (v <- arr)\n\
    \            if (v > 0)\n                sum = sum.map(s => v + s)\n         \
    \   else\n                product = product.map(p => v * p)\n            sign\
    \ = sign.map(s => if ((v > 0) || (v < 0)) 1 else -1)\n        val sum = sum.getOrElse(0)\n\
    \        val product = product.getOrElse(1)\n        val sign = sign.getOrElse(0)\n\
    \        Option(sum*product*sign)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoktlwdhr.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = sum.getOrElse(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msum is already defined as \e[33mvariable\e[0m \e[35msum\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoktlwdhr.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = product.getOrElse(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mproduct is already defined as \e[33mvariable\e[0m \e[35mproduct\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpoktlwdhr.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msign\e[0m = sign.getOrElse(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msign is already defined as \e[33mvariable\e[0m \e[35msign\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpoktlwdhr.scala:28:18 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        Option(sum*product*sign)\n\e[31m\e[31m   |\e[0m               ^^^^\e\
    [0m\n\e[31m   |\e[0mvalue * is not a member of Option[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty)\
    \ None\n      else {\n        var sum = 0\n        var sign = 1\n        for (i\
    \ <- arr.indices)\n          sum += arr(i) * sign\n          sign *= arr.signum\n\
    \        Some(sum)\n      }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_28814a_.scala:21:14 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m          sum += arr(i) * sign\n\e[31m\e[31m   |\e[0m\
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a member of Int\
    \ - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_28814a_.scala:22:15\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m          sign *= arr.signum\n\
    \e[31m\e[31m   |\e[0m          ^^^^^^^\e[0m\n\e[31m   |\e[0m          value *=\
    \ is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp_28814a_.scala:22:22 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m          sign *= arr.signum\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue signum is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def productSigns(x\
    \ : Long) : Long = {\n            val y = if (x < 0) -1 else if (x < 1) 1 else\
    \ 0\n            x * y\n        }\n        arr.foldLeft(1l)((x, acc) => (x * acc)\
    \ + productSigns(x))\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmgz16odv.scala:20:24\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        arr.foldLeft(\e[31m1l\e\
    [0m)((\e[36mx\e[0m, \e[36macc\e[0m) => (x * acc) + productSigns(x))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013258
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var res = 0.toLong\n\
    \        var sign = 1\n\n        for (i <- arr) {\n            res *= i\n    \
    \        sign += arr(i) * sign\n        }\n        if (sign == 0) return None\n\
    \        else Some(res) \n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo93um6vg.scala:21:17 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            sign += arr(i) * sign\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo93um6vg.scala:21:24\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            sign += arr(i) *\
    \ sign\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m \
    \                       Found:    (i : Long)\n\e[31m   |\e[0m                \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else arr.head * prodSigns(arr.tail.map { sign =>\n           \
    \ sign * math.signum(arr.get)\n        }.toList)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4bqhncl8.scala:18:35 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            sign * math.signum(arr.get)\n\e[31m\e[31m\
    \   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \  value get is not a member of List[Long] - did you mean arr.seq?\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp4bqhncl8.scala:17:22 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m arr.head * prodSigns(arr.tail.map\
    \ { sign =>\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments (Option[Long])\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val mags = arr.map(math.abs).sum\n\
    \        val signs = arr.map(x => math.signum(x)).sum\n        mags * signs\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4am7wozq.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        mags * signs\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\
    \e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013258
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None else Some(arr.map(i => i.abs * i.signum).toList.sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0efd_ka6.scala:19)\n\tat Problem.main(tmp0efd_ka6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Use a mutable\
    \ to store the result because we don't want to return it until the function is\
    \ done\n        val result = mutable.Map[Long, Long]()\n        arr.foreach(x\
    \ => {\n            if (x < 0)\n            result.update(x, -x)\n           \
    \ else if (x == 0)\n            result.update(x, 0l)\n            else if (x >\
    \ 0)\n            result.update(x, x * x)\n        })\n        // Return the result\
    \ when it is ready, else return None\n        if (result.size > 0) Some(result.values.sum)\
    \ else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp29r5qfia.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      arr.foldLeft((0L):\
    \ Long) {\n        case ((sum, product), element) => {\n          val sign = if\
    \ (element >= 0) 1 else -1\n          (sum + element * sign, product * sign)\n\
    \        }\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4f7kci8m.scala:19:15 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m          (sum + element * sign, product * sign)\n\e\
    [31m\e[31m   |\e[0m           ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of Any, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4f7kci8m.scala:19:41 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m          (sum + element * sign, product * sign)\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue * is not a member of Any, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660013261
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.flatMap {\
    \ x =>\n            val sign = if (x % 2 == 0) -1 else 1\n            List(x.toLong,\
    \ sign.toLong, x.toLong * sign.toLong).zipWithIndex.flatMap {\n              \
    \  case ((x, y), idx) => (if (idx == 0) Some(y) else None)\n            }\n  \
    \      }\n        .map(_.product)\n        .sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdlsb6xsp.scala:22:15 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        .map(_.product)\n\e[31m\e[31m   |\e[0m      \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value product is not a member\
    \ of Any\n\e[31m\e[31m-- Error: /tmp/tmpdlsb6xsp.scala:23:12 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        .sum\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\
    \e[31m   |\e[0m          No implicit Ordering defined for B\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m          where:    B is a type variable with constraint <: Option[Long]\n\
    \e[31m   |\e[0m          .\n2 errors found\n"
  stdout: ''
  timestamp: 1660013260
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None else Some(arr.map(x => (x*x).abs).sum)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoegnca68.scala:19)\n\tat Problem.main(tmpoegnca68.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val (a, b, c,\
    \ d) = arr.toList\n        val signs = if (a > 0) List(1, -1) else if (b > 0)\
    \ List(-1, 1) else List(0, 1)\n        val product = signs.foldLeft(0l)(_ * _)\n\
    \        Some(product*a)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptutjjrol.scala:17:26 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = \e[33mif\e\
    [0m (a > \e[31m0\e[0m) List(\e[31m1\e[0m, -\e[31m1\e[0m) \e[33melse\e[0m \e[33mif\e\
    [0m (b > \e[31m0\e[0m) List(-\e[31m1\e[0m, \e[31m1\e[0m) \e[33melse\e[0m List(\e\
    [31m0\e[0m, \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                        ^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of Any, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptutjjrol.scala:17:54 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = \e[33mif\e[0m (a\
    \ > \e[31m0\e[0m) List(\e[31m1\e[0m, -\e[31m1\e[0m) \e[33melse\e[0m \e[33mif\e\
    [0m (b > \e[31m0\e[0m) List(-\e[31m1\e[0m, \e[31m1\e[0m) \e[33melse\e[0m List(\e\
    [31m0\e[0m, \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                             \
    \                       ^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of Any,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmptutjjrol.scala:19:20 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        Some(product*a)\n\e[31m\e[31m   |\e[0m      \
    \       ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e\
    [31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m \
    \  |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((a : Any))\n3 errors found\n"
  stdout: ''
  timestamp: 1660013275
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val ms = arr.map{\
    \ x => math.abs(x) * math.signum(x) }\n        if (ms.toList.size == arr.size)\n\
    \            return Some(ms.reduceLeft((x,y) => x*y))\n        else\n        \
    \    None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6nhvi3i1.scala:23)\n\tat Problem.main(tmp6nhvi3i1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val product =\
    \ arr.foldLeft(1l)((x,y) => x * y)\n        val sum = (arr.map(x => x.toLong)\
    \ reduce (x:Long => x + y)).toLong\n        (product, sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpan2rvkcl.scala:17:62 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = (arr.map(\e[36mx\e\
    [0m => x.toLong) reduce (x:\e[35mLong\e[0m => \e[35mx\e[0m \e[35m+\e[0m \e[35my\e\
    [0m)).toLong\n\e[31m\e[31m   |\e[0m                                          \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \                      Not found: type +\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpan2rvkcl.scala:17:50 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = (arr.map(\e[36mx\e\
    [0m => x.toLong) reduce (x:\e[35mLong\e[0m => \e[35mx\e[0m \e[35m+\e[0m \e[35my\e\
    [0m)).toLong\n\e[31m\e[31m   |\e[0m                                          \
    \        ^\e[0m\n\e[31m   |\e[0m                                             \
    \     Not found: x\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpan2rvkcl.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        (product, sum)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (Long,\
    \ Long)\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(_.signum).distinct\
    \ //distinct returns only unique elements\n        val products = arr.map(_.abs)\
    \ //abs returns absolute value of the element\n        val product = products.reduce((a,b)\
    \ => a * b) //reduce calculates product of elements of an array\n        val result\
    \ = signs.map(_ => product * sign.apply(_)) //map creates a new array based on\
    \ values of original array\n        if (result.isEmpty) None else Some(result.sum)\
    \ //sum returns the sum of elements of an array\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpy8ulx8rq.scala:19:57 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = signs.map(_\
    \ => product * sign.apply(_)) \e[34m//map creates a new array based on values\
    \ of original array\e[0m\n\e[31m\e[31m   |\e[0m                              \
    \                           ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$4 of expanded function:\n\e[31m   |\e[0m   _$4 => product * sign.apply(_$4).\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy8ulx8rq.scala:19:46 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = signs.map(_\
    \ => product * sign.apply(_)) \e[34m//map creates a new array based on values\
    \ of original array\e[0m\n\e[31m\e[31m   |\e[0m                              \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \            Not found: sign\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpy8ulx8rq.scala:20:53\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mif\e[0m (result.isEmpty) None \e[33melse\e[0m Some(result.sum) \e[34m//sum\
    \ returns the sum of elements of an array\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                                             ^\e[0m\n\e[31m   |\e[0m        \
    \                           No implicit Ordering defined for Any.\n3 errors found\n"
  stdout: ''
  timestamp: 1660013279
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.map {\n \
    \           case i if i < 0l || i > 0 => 0l\n            case i if i <= 0l =>\
    \ 1l\n            case i => -1l\n        }.sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmwow89qw.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.map {\n\e[31m\e\
    [31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e\
    [0m        Required: Option[Long]\n\e[31m17 |\e[0m            \e[33mcase\e[0m\
    \ i \e[33mif\e[0m i < \e[31m0l\e[0m || i > \e[31m0\e[0m => \e[31m0l\e[0m\n\e[31m18\
    \ |\e[0m            \e[33mcase\e[0m i \e[33mif\e[0m i <= \e[31m0l\e[0m => \e[31m1l\e\
    [0m\n\e[31m19 |\e[0m            \e[33mcase\e[0m i => -\e[31m1l\e[0m\n\e[31m20\
    \ |\e[0m        }.sum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013277
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Return None\
    \ if the list is empty or contains only 0 or -1.\n        if (arr.isEmpty) None\n\
    \        else if (arr.map(_.signum).contains(0)) Some(-arr.reduce(_ * _))\n  \
    \      else if (arr.map(_.signum).contains(-1)) Some(arr.reduce(_ * _))\n    \
    \    else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppli68ek2.scala:23)\n\tat Problem.main(tmppli68ek2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft(0l)\
    \ { (acc, x) => acc + x.abs }\n            .fold(1l)(_ * -1)\n            .fold(1l)(_\
    \ * 0)\n            .filter(x => x < 0)\n            .map(x=>x.toInt)\n      \
    \      .map(x => x.toLong)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf9tn6q6e.scala:17:13 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.foldLeft(\e[31m0l\e[0m) { (\e[36macc\e[0m,\
    \ \e[36mx\e[0m) => acc + x.abs }\n\e[31m17 |\e[0m            .fold(\e[31m1l\e\
    [0m)(_ * -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m\
    \        value fold is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660013278
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.groupBy(x\
    \ => x).mapValues(_.length) match {\n            case (x , size) => Some(x.map(_*size).sum)\n\
    \            case (_ , size) => None\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzcmzpl6m.scala:17:38 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m (x , size) => Some(x.map(_*size).sum)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                    value map is not a member of Any\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013279
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val products\
    \ = arr.map(i => i*(i<0L) ? 0L : (i<0L ? 1L : -1L))\n        products.foldLeft(0L){\n\
    \            case (acc, i) =>\n                acc + (math.abs(i))*(i<0L ? 1L\
    \ : -1L)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgjmtoq7k.scala:16:63 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mproducts\e[0m = arr.map(\e\
    [36mi\e[0m => i*(i<\e[31m0L\e[0m) ? \e[31m0L\e[0m : (\e[35mi<\e[31m0L\e[0m \e\
    [35m?\e[0m \e[31m1L\e[0m : -\e[31m1L\e[0m))\n\e[31m\e[31m   |\e[0m           \
    \                                                    ^\e[0m\n\e[31m   |\e[0m \
    \                                            ')' expected, but ':' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgjmtoq7k.scala:16:54 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mproducts\e[0m = arr.map(\e\
    [36mi\e[0m => i*(i<\e[31m0L\e[0m) ? \e[31m0L\e[0m : (\e[35mi<\e[31m0L\e[0m \e\
    [35m?\e[0m \e[31m1L\e[0m : -\e[31m1L\e[0m))\n\e[31m\e[31m   |\e[0m           \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                            Not found: type <\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpgjmtoq7k.scala:16:45 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mproducts\e[0m = arr.map(\e\
    [36mi\e[0m => i*(i<\e[31m0L\e[0m) ? \e[31m0L\e[0m : (\e[35mi<\e[31m0L\e[0m \e\
    [35m?\e[0m \e[31m1L\e[0m : -\e[31m1L\e[0m))\n\e[31m\e[31m   |\e[0m           \
    \                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                   value ? is not a member of Boolean\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgjmtoq7k.scala:19:38 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m                acc + (math.abs(i))*(i<\e[31m0L\e[0m ? \e\
    [31m1L\e[0m : -\e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m                         \
    \            ^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of Nothing, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m\
    \   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m\
    \   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Cha"
  stdout: ''
  timestamp: 1660013281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      arr\n         \
    \ .foldLeft(0l){ (total, v) =>\n            val sign = (if (v < 0) -1 else 1)\n\
    \            total + sign * abs(v)\n          }\n          .map(i => i match {\n\
    \            case 0 => 0l\n            case -1 => -1l\n            case 1 => 1l\n\
    \            case _ => i\n          })\n          .find(i => i > 0l)\n       \
    \   .map(i => i match {\n            case 0 => 0l\n            case -1 => -1l\n\
    \            case 1 => 1l\n            case _ => i\n          })\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj_8_pxtn.scala:21:11 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m      arr\n\e[31m17 |\e[0m          .foldLeft(\e[31m0l\e\
    [0m){ (\e[36mtotal\e[0m, \e[36mv\e[0m) =>\n\e[31m18 |\e[0m            \e[33mval\e\
    [0m \e[36msign\e[0m = (\e[33mif\e[0m (v < \e[31m0\e[0m) -\e[31m1\e[0m \e[33melse\e\
    [0m \e[31m1\e[0m)\n\e[31m19 |\e[0m            total + sign * abs(v)\n\e[31m20\
    \ |\e[0m          }\n\e[31m21 |\e[0m          .map(\e[36mi\e[0m => i \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m      ^\e[0m\n\e[31m   |\e[0m      value map is not\
    \ a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660013279
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.foldLeft(1l){(x,\
    \ y) => x * y}.abs.toLong\n        val res = arr.foldLeft(0l){(x, y) => x * y\
    \ + y}\n        val signs = arr.filter(_ > 0).toInt\n        Some(m * signs *\
    \ ((-1 * res).toLong % 4))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp95qwgf4i.scala:18:38 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = arr.filter(_\
    \ > \e[31m0\e[0m).toInt\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toInt is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660013282
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val list = new\
    \ scala.collection.mutable.ListBuffer[Long]()\n        var prod = 1\n        var\
    \ sign = 1\n        for (i <- arr) {\n            var mult = 1l\n            var\
    \ temp = i\n            while (temp != 0l) {\n                if (temp < 0) {\n\
    \                    temp = temp * sign\n                } else {\n          \
    \          temp = -temp * sign\n                }\n                mult = mult*sign\n\
    \            }\n            list += mult\n            sign = sign*(-1)\n     \
    \       prod = prod*sign\n        }\n        if (list.nonEmpty)\n            Some(list.sum)\n\
    \        else\n            None\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660013287
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n       // return None\
    \ for the empty list\n       if (arr.isEmpty)\n          return None\n       var\
    \ sign = arr.head\n       var product = 1\n       var result = 0\n       for (i\
    \ <- 1 to arr.length - 1)\n          result += sign * (arr(i) * product)\n   \
    \    Some(result)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmg_n6hsa.scala:23:17 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m          result += sign * (arr(i) * product)\n\e[31m\e\
    [31m   |\e[0m          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not\
    \ a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val nums = arr.map(_.toInt)\n        val signs = nums.map(_.signum).toList\n\
    \        val product = signs.reduce((x,y) => x*y)\n        val magnitudes = nums.map(_.abs)\
    \ / product\n        magnitudes.sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsmui8yr9.scala:20:41 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmagnitudes\e[0m = nums.map(_.abs)\
    \ / product\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue / is not a member of List[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else arr.fold(List.empty[Long], (acc, ele) => {\n            val\
    \ s = math.signum(ele);\n            acc(acc.length) match {\n               \
    \ case Nil => Some(ele.toLong * s)\n                case _ => Some(acc.getOrElse(acc.length\
    \ + 1, ele.toLong) * s)\n            }\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp3ab1no_g.scala:17:41 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m arr.fold(List.empty[Long], (acc,\
    \ ele) => {\n\e[31m\e[31m   |\e[0m                                         ^^^\e\
    [0m\n\e[31m   |\e[0m                        Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                        I could not infer the type of the\
    \ parameter acc.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp3ab1no_g.scala:17:46\
    \ -----------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e\
    [0m arr.fold(List.empty[Long], (acc, ele) => {\n\e[31m\e[31m   |\e[0m        \
    \                                      ^^^\e[0m\n\e[31m   |\e[0m             \
    \           Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m         \
    \               I could not infer the type of the parameter ele.\n2 errors found\n"
  stdout: ''
  timestamp: 1660013276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.map(x =>\
    \ x.abs * (if (x < 0l) -1l else 1l)).sum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpasu_c3w4.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.map(\e[36mx\e[0m\
    \ => x.abs * (\e[33mif\e[0m (x < \e[31m0l\e[0m) -\e[31m1l\e[0m \e[33melse\e[0m\
    \ \e[31m1l\e[0m)).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var prod = 1\n\
    \        var sign = 0\n        for (i <- arr) {\n            sign *= i\n     \
    \       prod *= i\n        }\n        if (prod <= 0) None else Some(sign)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp82ghbwe7.scala:19:17 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            sign *= i\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Int\
    \ - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp82ghbwe7.scala:20:17\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            prod *= i\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ *= is not a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldRight(0)\
    \ {\n        case (curSum, elem) =>\n            var newSum = curSum\n       \
    \     var sign = 1\n            while (sign == 1 && elem != 0) {\n           \
    \     newSum = newSum + elem\n                elem = elem - 1\n              \
    \  sign = math.signum(elem) match {\n                    case 0 => sign = 0\n\
    \                    case -1 => sign = 1\n                    case 1 => sign =\
    \ -1\n                }\n            }\n            newSum\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpgn3flf99.scala:22:21 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                elem = elem - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \     Reassignment to val elem\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgn3flf99.scala:24:35 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                    \e[33mcase\e[0m \e[31m0\e[0m => sign = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    Unit\n\e[31m   |\e[0m             \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgn3flf99.scala:25:36 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                    \e[33mcase\e[0m -\e[31m1\e[0m => sign = \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               Found:    Unit\n\e[31m   |\e[0m     \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpgn3flf99.scala:26:35 --------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m                    \e[33mcase\e[0m \e[31m1\e[0m => sign =\
    \ -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    Unit\n\e[31m   |\e\
    [0m                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpgn3flf99.scala:29:12 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            newSum\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (newSum : Long)\n\e[31m  \
    \ |\e[0m            Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660013283
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        }\n        val a = arr.map(x => if(x == 0) 1 else\
    \ if (x == -1l) -1 else 0)\n        var product = 0l\n        var sum = 0l\n \
    \       for (i<- 0 until a.length) {\n            product *= a(i).toLong\n   \
    \         sum += a(i).toLong\n        }\n        Some(sum * product)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_060hhm4.scala:29)\n\tat Problem.main(tmp_060hhm4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Your code\
    \ goes here\n        return Option(arr).fold( _ => None\n            , list =>\
    \ list.foldLeft((0l, 0l, 0l))((acc, element) => {\n                val (x, y,\
    \ z) = acc match {\n                    case (Some(left), Some(right), Some(sign))\
    \ => (left * sign, right * sign, sign)\n                    case _ => (element,\
    \ element, 1) // If no sign is given, default to 1\n                }\n      \
    \          (x + (element * sign), y + (element * sign), z + (element * sign))\n\
    \            })\n        )\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpjatwflp2.scala:17:33 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mreturn\e[0m Option(arr).fold( _ => None\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 =>\
    \ None.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpjatwflp2.scala:18:14 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            , list => list.foldLeft((\e[31m0l\e[0m, \e\
    [31m0l\e[0m, \e[31m0l\e[0m))((acc, element) => {\n\e[31m\e[31m   |\e[0m      \
    \        ^^^^\e[0m\n\e[31m   |\e[0m              Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m              I could not infer the type of the parameter\
    \ list.\n2 errors found\n"
  stdout: ''
  timestamp: 1660013278
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\n\
    \            None\n        else {\n            val magnitude = arr.map(n => math.abs(n)).sum\n\
    \            val product = arr.map(n => math.signum(n) * n).sum\n            Some(product\
    \ * magnitude)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw3owpftx.scala:25)\n\tat Problem.main(tmpw3owpftx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013286
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(\
    \ v => if (v >= 0) 1 else 0)\n        if (signs.sum == 1 || signs.sum == -1)\n\
    \            Some(signs.product)\n        else\n            None\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp40_f_yzf.scala:23)\n\tat Problem.main(tmp40_f_yzf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013285
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // find all the\
    \ positives\n        val positives = arr.filter(_ > 0)\n\n        // find all\
    \ the negatives\n        val negatives = arr.filter(_ < 0)\n\n        // all signs\n\
    \        val signs = arr.filter(_ >= 0)\n\n        // product of all signs\n \
    \       val product = signs.reduceLeft(_ * _)\n\n        // if all signs are positive,\
    \ then the product is positive\n        if (product.isInstanceOf[Int]) {\n   \
    \         Some(product.asInstanceOf[Int])\n        } else if (product.isInstanceOf[Long])\
    \ {\n            Some(product.asInstanceOf[Long])\n        } else {\n        \
    \    None\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpguxfwiya.scala:38)\n\tat Problem.main(tmpguxfwiya.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.map(x =>\
    \ (x >>> 31).toInt).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5oyft4xe.scala:16:8\
    \ ---------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.map(\e[36mx\e[0m\
    \ => (x >>> \e[31m31\e[0m).toInt).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Int\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013295
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0l\n\
    \        var sign = 0l\n        for (i <- arr) {\n            val sign = i.toInt\
    \ % 2\n            sum += sign * math.abs(i)\n        }\n        Some(sum * arr.sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzzu8q9vk.scala:25)\n\tat Problem.main(tmpzzu8q9vk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013299
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val list = arr.toList\n\
    \        val result  = list.foldLeft(0L) { (a, b) =>\n          val c = a.toLong\
    \ * b.toLong\n          val s = math.signum(c)\n          s match {\n        \
    \    case 0 => a + 1L\n            case 1 => b + 2L\n            case -1 => b\
    \ + 2L\n            case _ => b + 3L\n          }\n        }\n        Option(result.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe6xnu2tu.scala:30)\n\tat Problem.main(tmpe6xnu2tu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013299
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\n\
    \            Some(0)\n        val m = arr.head\n        var s = Long.MinValue\n\
    \        var p = 1\n        for(x <- arr ++ arr.tail) {\n            s = x * p\n\
    \            if(x == m)\n                Some(s)\n            p = p * -1\n   \
    \     }\n        None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0a45v2aa.scala:30)\n\tat Problem.main(tmp0a45v2aa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n       if (!arr.isEmpty)\
    \ {\n           var prod = arr.head.abs()\n           var signs = arr.reduce {\
    \ case (sign, next) => (next.abs * sign) }\n           Some(signs * prod)\n  \
    \     }\n       else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp6gkugjvx.scala:17:31 -----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m           \e[33mvar\e[0m \e[36mprod\e[0m = arr.head.abs()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mclass\e[0m \e[35mRichLong\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val m = arr.head\n      \
    \      var sum = 0\n            var product = 1\n            for (i <- arr ) {\n\
    \                if ( i != 0) {\n                    product = product * (i.toLong)\n\
    \                }\n                sum += math.abs(i)\n            }\n      \
    \      if (m == 0) {\n                Some(sum)\n            }\n            else\
    \ {\n                Some(sum * math.abs(m))\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpibhaxwvv.scala:24:30\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    product =\
    \ product * (i.toLong)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Found:    Long\n\e[31m   |\e\
    [0m                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpibhaxwvv.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                sum += math.abs(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not\
    \ a member of Int - did you mean Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val result = (1 to arr.size).foldLeft(0l)\
    \ {\n                case (acc, i) => acc + arr(i)*sign(arr(i))\n            }\n\
    \            if (result==0l) {\n                None\n            } else Some(result)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgyzylgrd.scala:20:46 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m (acc, i) => acc + arr(i)*sign(arr(i))\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Not found: sign\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft(0l){\n\
    \            (a,i) =>\n                if (i.toLong > 0l) {\n                \
    \    a * i\n                } else {\n                    scala.math.sign(i) *\
    \ a\n                }\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1by98t1e.scala:21:31 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    scala.math.sign(i) * a\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue sign\
    \ is not a member of math, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660013300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val result =\
    \ mutable.Map.empty[Long, Long]\n        arr.foreach { i =>\n            val sign\
    \ = Math.signum(i)\n            val magnitude = i * sign\n            if (result.contains(magnitude))\n\
    \                result(magnitude)\n            else {\n                result\
    \ += magnitude -> sign\n            }\n        }\n        val sum = result.values.sum\n\
    \        if (sum == 0)\n            None\n        else\n            Some(sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcq0xai99.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.Map.empty[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013294
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val m = arr.max\n       \
    \     val n = arr.min\n            val product = arr.foldLeft(1l) { (a, v) =>\
    \ a * (Math.signum(v) * v) + Math.signum(v) * Math.signum(a) }\n            Some((product\
    \ * m - n) / (product * m))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_jpnqhu.scala:21:55\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e\
    [36mproduct\e[0m = arr.foldLeft(\e[31m1l\e[0m) { (\e[36ma\e[0m, \e[36mv\e[0m)\
    \ => a * (Math.signum(v) * v) + Math.signum(v) * Math.signum(a) }\n\e[31m\e[31m\
    \   |\e[0m                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Float\n\e[31m   |\e[0m                                                  \
    \     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013299
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var prod = 0l\n\
    \        var sign = 0l\n        arr.foreach {x => \n            prod *= x\n  \
    \          sign *= (x & 1)\n        }\n        if(arr.isEmpty) None else Some((prod\
    \ + sign).abs)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcpok6vpg.scala:25)\n\tat Problem.main(tmpcpok6vpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else arr.map(_.signum).sum.toLong * prod(arr.map(_._2))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpizofff43.scala:17:44 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m arr.map(_.signum).sum.toLong\
    \ * prod(arr.map(_._2))\n\e[31m\e[31m   |\e[0m                               \
    \             ^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \       Not found: prod\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpizofff43.scala:17:59\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m arr.map(_.signum).sum.toLong\
    \ * prod(arr.map(_._2))\n\e[31m\e[31m   |\e[0m                               \
    \                          ^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                value _2 is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660013300
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val signs = arr.map(_ < 0\
    \ ? -1 : 1).toArray\n            val mags = arr.map(math.pow(_, 2)).toArray\n\
    \            Some(mags.foldLeft(0l)(_ + _ * signs.sum))\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6fcbe829.scala:19:38 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36msigns\e[0m = arr.map(_\
    \ < \e[31m0\e[0m ? -\e[31m1\e[0m : \e[31m1\e[0m).toArray\n\e[31m\e[31m   |\e[0m\
    \                                    ^^^\e[0m\n\e[31m   |\e[0m               \
    \                     value ? is not a member of Int\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp6fcbe829.scala:21:35 --------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            Some(mags.foldLeft(\e[31m0l\e[0m)(_ + _ * signs.sum))\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                   Found:    Double\n\e[31m   |\e\
    [0m                                   Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013301
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val sum = arr.reduce(_\
    \ * _)\n        val max = arr.max\n        Some(arr.filter(_ > 0).map(n => sum\
    \ * n.abs).max + max.abs)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn5uy0xel.scala:21)\n\tat Problem.main(tmpn5uy0xel.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        require(arr.nonEmpty)\n\
    \        var magSum = 0L\n        for(n <- arr) magSum += n.abs()\n        val\
    \ sign = 1\n        val product = arr.map(n => n.abs())\n            .foldLeft(1L)\
    \ { (sum, elem) => sum * sign }\n        magSum * product\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpndi5if8x.scala:18:29 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m(n <- arr) magSum += n.abs()\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \           value += is not a member of Long - did you mean Long.!=?\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpndi5if8x.scala:18:34 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m(n <- arr) magSum += n.abs()\n\e\
    [31m\e[31m   |\e[0m                                ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mclass\e[0m \e[35mRichLong\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpndi5if8x.scala:20:37 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mproduct\e[0m = arr.map(\e[36mn\e[0m => n.abs())\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                   \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mclass\e[0m \e\
    [35mRichLong\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpndi5if8x.scala:22:8 ---------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        magSum * product\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else {\n            // Initialize sign as 0 for each element in\
    \ the list\n            var sign = List.fill(arr.length)(0)\n            // Update\
    \ sign for each element in the list\n            arr.foreach( x => sign = sign\
    \ * (x <=> 0))\n            // Sum all magnitudes multiplied by sign\n       \
    \     val sum = sign.sum\n            // Divide magnitude by sign and multiply\
    \ by product of all signs\n            val product = sign.map(_ => x/sum).product\n\
    \            Some(arr.map(_*product).sum)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqynbnl46.scala:21:42 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            arr.foreach( \e[36mx\e[0m => sign = sign\
    \ * (x <=> \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                             \
    \        ^^^^^^\e[0m\n\e[31m   |\e[0mvalue * is not a member of List[Int], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpqynbnl46.scala:21:47 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            arr.foreach( \e[36mx\e[0m => sign = sign\
    \ * (x <=> \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                             \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                  value <=> is not\
    \ a member of Long - did you mean x.<=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpqynbnl46.scala:25:40 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m            \e[33mval\e[0m \e[36mproduct\e[0m = sign.map(_ => x/sum).product\n\
    \e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m  \
    \ |\e[0m                                        Not found: x\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpqynbnl46.scala:25:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mproduct\e[0m = sign.map(_\
    \ => x/sum).product\n\e[31m\e[31m   |\e[0m                                   \
    \                   ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e\
    [33mobject\e[0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m and \e[33mobject\e[0m \e[35mIntIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m match type Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35mproduct\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660013305
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      var sum = 0\n \
    \     var prod = 1\n\n      for(x <- arr) {\n        sum += math.abs(x)\n    \
    \    prod *= math.sign(x)\n      }\n\n      Some(math.pow(sum, prod))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4z388gog.scala:20:12 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        sum += math.abs(x)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member of Int - did\
    \ you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4z388gog.scala:21:13\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        prod *= math.sign(x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^\e[0m\n\e[31m   |\e[0m        value *= is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp4z388gog.scala:21:21 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        prod *= math.sign(x)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue sign is not a member of math, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp4z388gog.scala:24:19 --------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m      Some(math.pow(sum, prod))\n\e[31m\e[31m   |\e[0m   \
    \        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           Found:    Double\n\
    \e[31m   |\e[0m           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var product =\
    \ arr(0) * arr(0)\n        var sign = arr(0)\n        val arr = arr.drop(1).map(\
    \ x => x * sign ).take(arr.size)\n        arr.foreach( (x ) => product = product\
    \ + x )\n        Option(product)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpd8686lji.scala:18:18 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e\
    [0m).map( \e[36mx\e[0m => x * sign ).take(arr.size)\n\e[31m\e[31m   |\e[0m   \
    \               ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013297
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val prod = arr.foldLeft(1l,\
    \ -1l) {\n            case (acc: Long, num: Long) => num * acc\n        }\n  \
    \      arr.map(num => math.signum(num) * num * prod).sum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7a9h7qzn.scala:17:43\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m (acc:\
    \ Long, num: Long) => num * acc\n\e[31m\e[31m   |\e[0m                       \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \                Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmp7a9h7qzn.scala:19:46 -----------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        arr.map(\e[36mnum\e[0m => math.signum(num) * num *\
    \ prod).sum\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((prod : (Long, Long)))\n\e[31m\e[31m-- Error: /tmp/tmp7a9h7qzn.scala:19:57\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \ arr.map(\e[36mnum\e[0m => math.signum(num) * num * prod).sum\n\e[31m\e[31m \
    \  |\e[0m                                                         ^\e[0m\n\e[31m\
    \   |\e[0m          No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m          where:    B is a type variable with constraint <: Option[Long]\n\
    \e[31m   |\e[0m          .\n3 errors found\n"
  stdout: ''
  timestamp: 1660013306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft((0l,\
    \ 1l, -1l))((acc, el) => {\n            val a = acc._1 * el\n            val b\
    \ = acc._2 * el\n            val c = acc._3 * el\n            val newAcc = (a,\
    \ b, c)\n            val sign = if (a > 0) 1 else if (a < 0) -1 else 0\n     \
    \       (newAcc._1, newAcc._2, newAcc._3 + sign)\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4jd5mna6.scala:16:35\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.foldLeft((\e[31m0l\e\
    [0m, \e[31m1l\e[0m, -\e[31m1l\e[0m))((\e[36macc\e[0m, \e[36mel\e[0m) => {\n\e\
    [31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    (Long, Long,\
    \ Long)\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m17 |\e[0m      \
    \      \e[33mval\e[0m \e[36ma\e[0m = acc._1 * el\n\e[31m18 |\e[0m            \e\
    [33mval\e[0m \e[36mb\e[0m = acc._2 * el\n\e[31m19 |\e[0m            \e[33mval\e\
    [0m \e[36mc\e[0m = acc._3 * el\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mnewAcc\e\
    [0m = (a, b, c)\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36msign\e[0m = \e\
    [33mif\e[0m (a > \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (a <\
    \ \e[31m0\e[0m) -\e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m22 |\e[0m  \
    \          (newAcc._1, newAcc._2, newAcc._3 + sign)\n\e[31m23 |\e[0m        })\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013306
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val res = arr.foldLeft(Option(0.0)){\
    \ case (sum, item) => if (item > 0) sum + math.abs(item) else sum }\n        if\
    \ (res.isDefined) Some(res.get)\n        else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzbrmcz_8.scala:16:83 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = arr.foldLeft(Option(\e\
    [31m0.0\e[0m)){ \e[33mcase\e[0m (sum, item) => \e[33mif\e[0m (item > \e[31m0\e\
    [0m) sum + math.abs(item) \e[33melse\e[0m sum }\n\e[31m\e[31m   |\e[0m       \
    \                                                                        ^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of Option[Double], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpzbrmcz_8.scala:17:36 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (res.isDefined) Some(res.get)\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Found:    Double\n\e[31m   |\e[0m         \
    \                       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var max = 0\n\
    \        var sum = 0\n        var sign = 1\n        for (x <- arr)\n         \
    \   max += x\n            sum += sign * x\n            sign *= -1\n        if\
    \ (arr.isEmpty)\n            None\n        else {\n            Some(Math.pow(Math.signum(max),\
    \ sum))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3bv_y4mc.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            max += x\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Int -\
    \ did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3bv_y4mc.scala:21:16\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            sum += sign *\
    \ x\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ value += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3bv_y4mc.scala:26:25 --------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            Some(Math.pow(Math.signum(max), sum))\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 Found:    Double\n\e[31m   |\e[0m                 Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.foldLeft((0.0,0.0))\
    \ {\n            (acc,elem) => {\n                val a = acc._1+elem.abs\n  \
    \              val b = acc._2+elem.signum*elem.abs\n                (Some(Math.min(a,b)),Math.max(a,b))\n\
    \            }\n        }\n        arr.find(x => x.abs == m._1 && x.signum ==\
    \ m._2).map(x => x.abs*x.signum)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaoo8m7hz.scala:20:21\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                (Some(Math.min(a,b)),Math.max(a,b))\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                 Found:    \e[1m\e[31mSome\e[0m\e[1m\e[31m[\e[0mDouble\e[1m\e\
    [31m]\e[0m\n\e[31m   |\e[0m                 Required: Double\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013313
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val ms = arr.map\
    \ { case x => math.abs(x) }\n        if (ms.isEmpty) {\n            None\n   \
    \     } else {\n            val signs = ms.map(x => (x >>> 31) != 0)\n       \
    \     val prod = signs.reduceLeft(_ * _)\n            Some(math.abs(prod))\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprdj_86uh.scala:21:42 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mprod\e[0m = signs.reduceLeft(_\
    \ * _)\n\e[31m\e[31m   |\e[0m                                        ^^^\e[0m\n\
    \e[31m   |\e[0mvalue * is not a member of Boolean, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmprdj_86uh.scala:22:22 -----------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            Some(math.abs(prod))\n\e[31m\e[31m   |\e[0m  \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments ((prod : Boolean))\n2 errors found\n"
  stdout: ''
  timestamp: 1660013314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        require(arr.nonEmpty)\n\
    \        var sum = 0\n        for (x <- arr) {\n            val sign = if (x %\
    \ 2 == 0) 1 else -1\n            sum += sign * x\n        }\n        if (sum >\
    \ 0)\n            Some(sum)\n        else\n            None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkc0tm_0b.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            sum += sign * x\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013314
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ return None\n        val arr = arr.map(x => math.abs(x))\n        val min =\
    \ math.min(arr.toArray: _*)\n        val max = math.max(arr.toArray: _*)\n   \
    \     val minSign = min * arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n\
    \        val maxSign = max * arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0)\n        val minMax = minSign.zip(maxSign)\n        if (minMax.forall(x =>\
    \ x._1 == 0)) None\n        else Some(minMax.foldLeft(0)((x, y) => x + y * y._1))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp87qtvn8e.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(\e[36mx\e\
    [0m => math.abs(x))\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e\
    [0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None else arr.map(n => (sign(n), n * product(sign(n)))) \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjlnge9he.scala:16:49 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (arr.isEmpty) None \e[33melse\e\
    [0m arr.map(\e[36mn\e[0m => (sign(n), n * product(sign(n)))) \n\e[31m\e[31m  \
    \ |\e[0m                                                 ^^^^\e[0m\n\e[31m   |\e\
    [0m                                                 Not found: sign\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjlnge9he.scala:16:62 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (arr.isEmpty) None \e[33melse\e\
    [0m arr.map(\e[36mn\e[0m => (sign(n), n * product(sign(n)))) \n\e[31m\e[31m  \
    \ |\e[0m                                                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      Not\
    \ found: product\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjlnge9he.scala:16:70\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ None \e[33melse\e[0m arr.map(\e[36mn\e[0m => (sign(n), n * product(sign(n))))\
    \ \n\e[31m\e[31m   |\e[0m                                                    \
    \                  ^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                         Not found: sign\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013312
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val positives\
    \ = arr.filter(_.toLong > 0).toList\n        if (positives.isEmpty) None\n   \
    \     else {\n            val signs = arr.map(x => math.signum(x)).toList\n  \
    \          val muls = arr.map(x => x * signs.sum).toList\n            val mag\
    \ = muls.map(x => math.abs(x)).reduce(_ + _)\n            mag match {\n      \
    \          case x if x > 0l => Some(mag)\n                case x if x == 0l =>\
    \ None\n                case _ => None\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3rur4ecy.scala:30)\n\tat Problem.main(tmp3rur4ecy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013324
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(x\
    \ => x * abs(x)).reduce((a, b) => abs(a) * abs(b)) match {\n            case 0\
    \ => None\n            case _ => Some(m)\n        }\n        m match {\n     \
    \       case Some(m) =>\n                if (m > 0) Some(-1 * m)\n           \
    \     else if (m < 0) Some(-1 * m)\n                else None\n            case\
    \ None => None\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprw_m_60h.scala:18:27 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m _ => Some(m)\n\e[31m\e[31m\
    \   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m                 \
    \          Recursive \e[33mvalue\e[0m \e[35mm\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmprw_m_60h.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mif\e[0m (m > \e[31m0\e[0m) Some(-\e\
    [31m1\e[0m * m)\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e\
    [0mvalue > is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprw_m_60h.scala:23:27\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33melse\e\
    [0m \e[33mif\e[0m (m < \e[31m0\e[0m) Some(-\e[31m1\e[0m * m)\n\e[31m\e[31m   |\e\
    [0m                         ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of\
    \ Nothing, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import concurrent.duration.Dea"
  stdout: ''
  timestamp: 1660013321
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      def prod(x : Long,\
    \ y : Long) : Long = {\n        if(x == 0) 1\n        else if(x == -1) -1\n  \
    \      else y*x\n      }\n      def magnitude(x : Long) : Long = {\n        if(x\
    \ == 0) 0\n        else x*abs(x)\n      }\n      val products = arr.map(x => prod(x,\
    \ x)).sum\n      if((products == 0)\n          || (products == Long.MaxValue))\n\
    \        None\n      else\n        Some(products.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwu6iznh4.scala:33)\n\tat Problem.main(tmpwu6iznh4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013323
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty\
    \ || arr.forall(_.isNegligible) || (arr.forall(_.isZero)))\n            None\n\
    \        else\n            Some(arr.foldLeft(0l) {\n                case (acc,\
    \ elem) => acc + elem * if (elem.isNegligible) -1 else 1 })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl7v97hb1.scala:20:49 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m (acc, elem) => acc +\
    \ elem * \e[33mif\e[0m (elem.isNegligible) -\e[31m1\e[0m \e[33melse\e[0m \e[31m1\e\
    [0m })\n\e[31m\e[31m   |\e[0m                                                \
    \ ^^\e[0m\n\e[31m   |\e[0m                                        expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpl7v97hb1.scala:16:40 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mif\e[0m (arr.isEmpty || arr.forall(_.isNegligible) || (arr.forall(_.isZero)))\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              value isNegligible is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl7v97hb1.scala:16:71\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (arr.isEmpty\
    \ || arr.forall(_.isNegligible) || (arr.forall(_.isZero)))\n\e[31m\e[31m   |\e\
    [0m                                                                     ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value isZero is not a\
    \ member of Long\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpl7v97hb1.scala:20:47\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e\
    [0m (acc, elem) => acc + elem * \e[33mif\e[0m (elem.isNegligible) -\e[31m1\e[0m\
    \ \e[33melse\e[0m \e[31m1\e[0m })\n\e[31m\e[31m   |\e[0m                     \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments (Null)\n4 errors found\n"
  stdout: ''
  timestamp: 1660013321
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => (x%2l))\n        if(signs.isEmpty) None else Some(signs.sum * signs.map(x\
    \ => if (x>0) -1l else 1l).product)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpffco_c83.scala:20)\n\tat Problem.main(tmpffco_c83.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0L\n\
    \        var product = 1L\n        for (i <- arr) {\n            sum += i\n  \
    \          product *= if (i < 0) -1 else 1\n        }\n        if (arr.isEmpty)\
    \ {\n            Some(sum)\n        }\n        else {\n            Some(sum *\
    \ product)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmppno8crdv.scala:20:23 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            product *= \e[33mif\e[0m (i < \e[31m0\e[0m)\
    \ -\e[31m1\e[0m \e[33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m          \
    \             ^^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmppno8crdv.scala:20:20 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m            product *= \e[33mif\e[0m (i < \e[31m0\e[0m) -\e[31m1\e[0m \e[33melse\e\
    [0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m            value *= is not a member of Long - did you mean Long.!=?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var product =\
    \ 1\n        for (i <- arr) {\n            product *= i\n            val sign\
    \ = if (i < 0) -1 else 1\n            val sum = i*sign\n            val mag =\
    \ math.abs(sum)\n            if (mag > product) product = mag\n        }\n   \
    \     Some(product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpq3aoouuh.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            product *= i\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of\
    \ Int - did you mean Int.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq3aoouuh.scala:22:41\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (mag\
    \ > product) product = mag\n\e[31m\e[31m   |\e[0m                            \
    \             ^^^\e[0m\n\e[31m   |\e[0m                                      \
    \   Found:    (mag : Long)\n\e[31m   |\e[0m                                  \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013322
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val result =\
    \ arr.foldLeft(1l) {\n            case (acc, elem) => math.abs(elem - acc) * math.signum(elem)\n\
    \        }\n        if (result < 1l) {\n            Some(result)\n        } else\
    \ {\n            None\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdko541jb.scala:26)\n\tat Problem.main(tmpdko541jb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013324
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ {\n            None\n        } else {\n            var result : Long = 0l\n\
    \            arr.foreach {\n                e => result += 1l*math.signum(e)\n\
    \            }\n            Some(result)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpstq23h9q.scala:27)\n\tat Problem.main(tmpstq23h9q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => x match {\n            case 0 => 0\n            case x => -1\n        })\n\
    \        val signsSum = signs.sum\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.product\n        magnitudes.map(x => x * signsSum\
    \ * product)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2xuaezej.scala:23:22\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        magnitudes.map(\e[36mx\e\
    [0m => x * signsSum * product)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31mList\e[0m[Long]\n\e[31m   |\e\
    [0m        Required: \e[1m\e[32mOption\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val res = arr.foldLeft[List[Long]](0)(_\
    \ + _ * arr.map(_ => 1).toList.flatten.product)\n        res match {\n       \
    \     case 0 => None\n            case _ => Some(res)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4p6kj3j.scala:16:43\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m = arr.foldLeft[\e[35mList\e[0m[\e[35mLong\e[0m]](\e[31m0\e[0m)(_ + _ * arr.map(_\
    \ => \e[31m1\e[0m).toList.flatten.product)\n\e[31m\e[31m   |\e[0m            \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                     Found:    (\e[31m0\e[0m : Int)\n\e[31m   |\e[0m        \
    \                                   Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpp4p6kj3j.scala:16:48 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = arr.foldLeft[\e\
    [35mList\e[0m[\e[35mLong\e[0m]](\e[31m0\e[0m)(_ + _ * arr.map(_ => \e[31m1\e[0m).toList.flatten.product)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^\e[0m\n\e\
    [31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpp4p6kj3j.scala:16:84 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = arr.foldLeft[\e[35mList\e\
    [0m[\e[35mLong\e[0m]](\e[31m0\e[0m)(_ + _ * arr.map(_ => \e[31m1\e[0m).toList.flatten.product)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^\e[0m\n\e[31m   |\e[0mno given instance of type\
    \ Int => IterableOnce[B] was found for parameter toIterableOnce of \e[33mmethod\e\
    [0m \e[35mflatten\e[0m in \e[33mtrait\e[0m \e[35mStrictOptimizedIterableOps\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type variable\n\e[31m\e\
    [31m-- Error: /tmp/tmpp4p6kj3j.scala:18:17 -----------------------------------------\e\
    [0m\e"
  stdout: ''
  timestamp: 1660013328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\
    \ goes here\n        var prod = 0\n        var signs = 1\n        arr.foreach{x\
    \ => prod+=x*signs; }\n        if (prod < 0)\n            Some(-1 * prod)\n  \
    \      else\n            Some(prod)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzi_wndhr.scala:19:29 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        arr.foreach{\e[36mx\e[0m => prod+=x*signs; }\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \               value += is not a member of Int - did you mean Int.!=?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = mutable.ListBuffer[Long]()\n\
    \        arr.foreach {\n            l => {\n                signs.append(if (l\
    \ < 0) 1 else -1)\n            }\n        }\n        if (arr.isEmpty) None else\
    \ Some(arr(0) * arr.fold(1l) { (sum, num) => sum * sum })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpogpqag1x.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013321
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def prodSignHelper(arr:\
    \ Array[Long], sign: Long, start: Int, end: Int): Long = {\n            if (start\
    \ == end)\n                sign * arr(start)\n            else if (arr(start)\
    \ * sign > 0)\n                prodSignHelper(arr, sign * arr(start), start+1,\
    \ end)\n            else\n                prodSignHelper(arr, sign * arr(start),\
    \ start, start+1)\n        }\n        if (arr.isEmpty)\n            None\n   \
    \     else\n            Some(prodSignHelper(arr, 1l, 0, arr.length))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa9a3v5zl.scala:27:32\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            Some(prodSignHelper(arr,\
    \ \e[31m1l\e[0m, \e[31m0\e[0m, arr.length))\n\e[31m\e[31m   |\e[0m           \
    \                     ^^^\e[0m\n\e[31m   |\e[0m                              \
    \  Found:    (arr : List[Long])\n\e[31m   |\e[0m                             \
    \   Required: Array[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None else {\n            var sum = 0\n            var sign = 1\n           \
    \ for (i <- arr.indices) {\n                sum += arr.apply(i)*sign\n       \
    \         sign *= -1\n            }\n            Some(sum)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuhfggggw.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                sum += arr.apply(i)*sign\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013326
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else {\n            val signs = arr.map(_ % 2 == 1).toArray\n\
    \            val signsProd = signs.foldLeft(1l)(_ * _)\n            val signsMag\
    \ = signs.foldLeft(1l)(_ + _)\n            val magnitude = signsMag * arr.sum\n\
    \            Some(magnitude)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp1vr9wops.scala:19:49 -----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36msignsProd\e[0m = signs.foldLeft(\e\
    [31m1l\e[0m)(_ * _)\n\e[31m\e[31m   |\e[0m                                   \
    \            ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e\
    [31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m \
    \  |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((_$3 : Boolean))\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmp1vr9wops.scala:20:48 -----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33mval\e[0m \e[36msignsMag\e[0m = signs.foldLeft(\e[31m1l\e\
    [0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                           \
    \   ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0m (x: String): String\n\e[31m   |\e[0mmatch arguments ((_$5 : Boolean))\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013325
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var ret = 0l\n\
    \        var product = 1l\n        var sum = 0l\n\n        arr match {\n     \
    \       case Nil => None\n            case head :: tail => head match {\n    \
    \            case x if x > 0 =>\n                    val sign = math.signum(x)\n\
    \                    val productSign = sign * product\n                    val\
    \ newSum = sum + sign\n                    ret ++= sign * productSign\n      \
    \              product *= sign\n                    sum = newSum\n           \
    \     case x if x < 0 =>\n                    val sign = math.signum(-x)\n   \
    \                 val productSign = sign * product\n                    val newSum\
    \ = sum + sign\n                    ret ++= sign * productSign\n             \
    \       product *= sign\n                    sum = newSum\n                case\
    \ _ =>\n                }\n            }\n        }\n        Some(ret)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_hp6i2e9.scala:54:0 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m}\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0meof expected,\
    \ but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_hp6i2e9.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    ret ++=\
    \ sign * productSign\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    value ++= is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp_hp6i2e9.scala:29:24 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    sum = newSum\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    Unit\n\e[31m   |\e[0m                    Required: Option[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_hp6i2e9.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    ret ++= sign * productSign\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \     value ++= is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_hp6i2e9.scala:36:24 --------------------\e[0m\e[0m\n\e[31m36 |\e[0m\
    \                    sum = newSum\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    Unit\n\e[31m   |\e[0m      \
    \              Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp_hp6i2e9.scala:37:23 --------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                \e[33mcase\e[0m _ =>\n\e[31m\e[31m   |\e[0m\
    \                       ^^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    Unit\n\e[31m   |\e[0m                       Required: Option[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_hp6i2e9.scala:41:13 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        Some(ret)\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1660013334
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\n\
    \            None\n        else {\n            val (n, b) = arr.span(_.isSigned)\n\
    \            val v = b.foldLeft(1L)((n1, b) => b * n1)\n            val r : Long\
    \ = n * v\n            Some(r)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn_goet1l.scala:19:36 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m (n, b) = arr.span(_.isSigned)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  value isSigned is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn_goet1l.scala:21:29 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m : \e[35mLong\e\
    [0m = n * v\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue * is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660013333
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0)\n            None\n        else if (arr.length == 1)\n            Some(arr(0)\
    \ * prod(arr))\n        else\n            Some(arr(0).map(x => x * prod(arr.drop(1)))\n\
    \                    .foldLeft(0l){ (a,b) => a + b })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjvpoifv9.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            Some(arr(\e[31m0\e[0m) * prod(arr))\n\e[31m\e\
    [31m   |\e[0m                          ^^^^\e[0m\n\e[31m   |\e[0m            \
    \              Not found: prod\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpjvpoifv9.scala:21:24 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m            Some(arr(\e[31m0\e[0m).map(\e[36mx\e[0m => x * prod(arr.drop(\e\
    [31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                 value map is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660013330
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val result =\
    \ new mutable.HashMap[Long, Int]()\n        for (i <- arr) {\n            val\
    \ x = math.abs(i)\n            val sign = if (x >= 0) 1 else -1\n            result.getOrElse(x,\
    \ 0)\n            result.put(sign * x, result.getOrElse(x, 0) + sign * sign)\n\
    \        }\n\n        if (result.size > 0) {\n            Some(result.getOrElse(arr.max,\
    \ 0))\n        } else {\n            None\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbqvovr4f.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013328
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft((0l,\
    \ 0l)) {\n            case ((p, 0), x) => if x > 0 => (p, x + 1l) else (p, x -\
    \ 1l)\n            case ((p, 0), x) => if (p * x == 0) None\n            else\
    \ Some(p * x)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpyt_ksot9.scala:17:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m ((p, \e[31m0\e[0m), x) =>\
    \ \e[33mif\e[0m x > \e[31m0\e[0m => (p, x + \e[31m1l\e[0m) \e[33melse\e[0m (p,\
    \ x - \e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m                                  \
    \ ^^^^^\e[0m\n\e[31m   |\e[0m                                   not a legal formal\
    \ parameter\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyt_ksot9.scala:17:56\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e\
    [0m ((p, \e[31m0\e[0m), x) => \e[33mif\e[0m x > \e[31m0\e[0m => (p, x + \e[31m1l\e\
    [0m) \e[33melse\e[0m (p, x - \e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \                                             ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                  'then' expected, but 'else' found\n\e[33m\e\
    [33m-- [E129] Potential Issue Warning: /tmp/tmpyt_ksot9.scala:20:8 -----------------\e\
    [0m\e[0m\n\e[33m17 |\e[0m            \e[33mcase\e[0m ((p, \e[31m0\e[0m), x) =>\
    \ \e[33mif\e[0m x > \e[31m0\e[0m => (p, x + \e[31m1l\e[0m) \e[33melse\e[0m (p,\
    \ x - \e[31m1l\e[0m)\n\e[33m18 |\e[0m            \e[33mcase\e[0m ((p, \e[31m0\e\
    [0m), x) => \e[33mif\e[0m (p * x == \e[31m0\e[0m) None\n\e[33m19 |\e[0m      \
    \      \e[33melse\e[0m Some(p * x)\n\e[33m20 |\e[0m        }\n\e[33m\e[33m   |\e\
    [0m                                                                        ^\e\
    [0m\n\e[33m   |\e[0mA pure expression does nothing in statement position; you\
    \ may be omitting necessary parentheses\n\e[33m   |\e[0m\n\e[33m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 warning found\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013329
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr match {\n\
    \            case Nil => None\n            case head :: tail =>\n            \
    \    var res = head\n                for (i <- tail) {\n                    res\
    \ = math.signum(i) * res\n                }\n                Some(res)\n     \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb0ivxk0u.scala:27)\n\tat Problem.main(tmpb0ivxk0u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val (n, v) =\
    \ arr.head.toLong, arr.tail.foldLeft((0l, 0l))((t, n) => (n.abs * t.abs, t.abs\
    \ * t.abs * n))\n        if (v > 0) Some(n) else None\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmppq9ax_rg.scala:16:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m (n, v) = arr.head.toLong, arr.tail.foldLeft((\e\
    [31m0l\e[0m, \e[31m0l\e[0m))((t, n) => (n.abs * t.abs, t.abs * t.abs * n))\n\e\
    [31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but ',' found\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmppq9ax_rg.scala:17:14 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (v > \e[31m0\e[0m) Some(n) \e[33melse\e\
    [0m None\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0mvalue > is\
    \ not a member of Any, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppq9ax_rg.scala:17:24 --------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (v > \e[31m0\e[0m) Some(n) \e[33melse\e\
    [0m None\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Found:    (n : Any)\n\e[31m   |\e[0m                \
    \        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013338
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else {\n            var sum = 0\n            var product = 1\n\
    \            var sign = 1\n\n            for ( i <- arr ) {\n                if(i\
    \ > 0) sign = 1\n                else if(i < 0) sign = -1\n                else\
    \ sign = 0\n\n                sum = (sum * sign) + i\n                product\
    \ *= sign\n            }\n\n            Some(sum*product)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpagvnfei7.scala:27:22\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                sum = (sum *\
    \ sign) + i\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m         \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013341
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      val sumMag = arr.map\
    \ { elem => elem.abs }\n      val signs = arr.map { elem => math.signum(elem)\
    \ }\n      val signProd = signs.product + signs.sum\n      val productMag = arr.map(_.abs).sum\n\
    \      sumMag.zip(signProd).map { case (sum, sign) => sign * math.pow(sum, productMag)\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkya_wqwd.scala:20:17\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m      sumMag.zip(signProd).map\
    \ { \e[33mcase\e[0m (sum, sign) => sign * math.pow(sum, productMag) }\n\e[31m\e\
    [31m   |\e[0m                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:\
    \    (signProd : Long)\n\e[31m   |\e[0m                 Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkya_wqwd.scala:20:58\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m      sumMag.zip(signProd).map\
    \ { \e[33mcase\e[0m (sum, sign) => sign * math.pow(sum, productMag) }\n\e[31m\e\
    [31m   |\e[0m                                                     ^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue * is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import concurrent.duration.pairIntToDuration\n\e[31m   |\e[0m\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660013344
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val list = arr.toList\n\
    \        val product = 1l\n        var sum : Long = 0\n        for (i <- list)\
    \ {\n            sum += i * Math.sign(i)\n            product *= Math.sign(i)\n\
    \        }\n        if (list.isEmpty) None else Some(sum * product)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4wh0qyp0.scala:20:16 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            sum += i * Math.sign(i)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Long - did you mean Long.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4wh0qyp0.scala:20:28\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m            sum += i * Math.sign(i)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ sign is not a member of object Math, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4wh0qyp0.scala:21:20\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            product *= Math.sign(i)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ *= is not a member of Long - did you mean product.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4wh0qyp0.scala:21:28 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            product *= Math.sign(i)\n\e[31m\e[31m   |\e[0m\
    \                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue sign is not a member\
    \ of object Math, but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013346
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None \n        } else {\n            val arr2 = arr.map { x =>\
    \ (x * x.abs).abs }\n            val sum2 = arr2.sum\n            val signs =\
    \ arr2.map(x => if (x < 0) -1 else 1)\n            val product = signs.reduce(_\
    \ * _)\n            Some(sum2 * product)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7zh7w9k3.scala:27)\n\tat Problem.main(tmp7zh7w9k3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\n\
    \            None \n        else\n            arr.foldLeft(0l){ case (i, x) =>\
    \ (i % 2 == 0) ? i * x : (-i * x) }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5atb6too.scala:19:75 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            arr.foldLeft(\e[31m0l\e[0m){ \e[33mcase\e\
    [0m (i, x) => (i % \e[31m2\e[0m == \e[31m0\e[0m) ? i * x : (\e[35m-i\e[0m \e[35m*\e\
    [0m \e[35mx\e[0m) }\n\e[31m\e[31m   |\e[0m                                   \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                      an identifier expected, but ')' found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5atb6too.scala:19:58 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m            arr.foldLeft(\e[31m0l\e[0m){ \e[33mcase\e[0m (i,\
    \ x) => (i % \e[31m2\e[0m == \e[31m0\e[0m) ? i * x : (\e[35m-i\e[0m \e[35m*\e\
    [0m \e[35mx\e[0m) }\n\e[31m\e[31m   |\e[0m                                   \
    \          ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \        value ? is not a member of Boolean\n2 errors found\n"
  stdout: ''
  timestamp: 1660013342
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val arrM = arr.map(_.abs)\n\
    \        val arrP = arr.map(_.signum)\n        val arrM1 = arrM.foldLeft(arrM)(\
    \ (a,b) => a #:: b )\n        val arrP1 = arrP.foldLeft(arrP)( (a,b) => a #::\
    \ b )\n        val arrP2 = arrP.foldRight(arrP1)( (a,b) => b #:: a )\n       \
    \ val arrP3 = arrP2.foldLeft(arrP2)( (a,b) => b #:: a )\n        val arrM2 = arrM1.foldLeft(arrM1)(\
    \ (a,b) => a #:: b )\n        arrM2.foldLeft(arrM2)( (a,b) => a #:: b )\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgzc61kfy.scala:18:52 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36marrM1\e[0m = arrM.foldLeft(arrM)(\
    \ (\e[36ma\e[0m,\e[36mb\e[0m) => a #:: b )\n\e[31m\e[31m   |\e[0m            \
    \                                        ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                              value #:: is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgzc61kfy.scala:19:52 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36marrP1\e[0m = arrP.foldLeft(arrP)(\
    \ (\e[36ma\e[0m,\e[36mb\e[0m) => a #:: b )\n\e[31m\e[31m   |\e[0m            \
    \                                        ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                               value #:: is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgzc61kfy.scala:20:54 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36marrP2\e[0m = arrP.foldRight(arrP1)(\
    \ (\e[36ma\e[0m,\e[36mb\e[0m) => b #:: a )\n\e[31m\e[31m   |\e[0m            \
    \                                          ^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                 value #:: is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgzc61kfy.scala:21:54 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36marrP3\e[0m = arrP2.foldLeft(arrP2)(\
    \ (\e[36ma\e[0m,\e[36mb\e[0m) => b #:: a )\n\e[31m\e[31m   |\e[0m            \
    \                                          ^^^^^\e[0m\n\e[31m   |\e[0m       \
    \      value #:: is not a member of List[Int] - did you mean a.::?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgzc61kfy.scala:22:54 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marrM2\e[0m = arrM1.foldLeft(arrM1)(\
    \ (\e[36ma\e[0m,\e[36mb\e[0m) => a #:: b )\n\e[31m\e[31m   |\e[0m            \
    \                                          ^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                value #:: is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpgzc61kfy.scala:23:42 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        arrM2.foldLeft(arrM2)( (\e[36ma\e[0m,\e[36mb\e\
    [0m)"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def prodSigns(arr\
    \ : List[Long]) : Option[Long] = {\n            if (arr.isEmpty) {\n         \
    \       None\n            } else {\n                val first = arr.head\n   \
    \             val rest = arr.tail\n                Some(first * rest.getOrElse(0.0)\
    \ * sign(rest))\n            }\n        }\n        prodSigns(arr)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpee3sjgzq.scala:22:34 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                Some(first * rest.getOrElse(\e[31m0.0\e\
    [0m) * sign(rest))\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value getOrElse is not a member\
    \ of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1660013345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None else arr.foldLeft(0l){\n            case (x, y) => if (y < 0) x else x\
    \ * y\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjw6pp59x.scala:16:51\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ None \e[33melse\e[0m arr.foldLeft(\e[31m0l\e[0m){\n\e[31m\e[31m   |\e[0m   \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \              Found:    Long\n\e[31m   |\e[0m                               \
    \    Required: Option[Long]\n\e[31m17 |\e[0m            \e[33mcase\e[0m (x, y)\
    \ => \e[33mif\e[0m (y < \e[31m0\e[0m) x \e[33melse\e[0m x * y\n\e[31m18 |\e[0m\
    \        }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013346
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(abs).sum\n\
    \        val signs = arr.map(x => if(x<0) -1 else if(x>0) 1 else 0)\n        val\
    \ p = signs.filter(_ > 0).product\n        if(m == 0) None else Some(m + p)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprbliz39s.scala:22)\n\tat Problem.main(tmprbliz39s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013350
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.foldLeft(Long.MaxValue)\
    \ { case (m, e) =>\n            if (e < 0) {\n                m + e.signum\n \
    \           } else {\n                m * e.signum\n            }\n        }\n\
    \        Some(m)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1ehok271.scala:26)\n\tat Problem.main(tmp1ehok271.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013350
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0\n\
    \        var sign = 1\n        val count = arr.length\n        for (i <- 0 until\
    \ count) {\n            var a = arr(i)\n            if (a < 0)\n             \
    \   a = -a;\n            sum += a * sign\n            sign *= -1\n        }\n\
    \        if (count == 0)\n            Some(0)\n        else\n            Some(sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwnjmjxwo.scala:23:16 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            sum += a * sign\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val result =\
    \ new mutable.ListBuffer[Long]()\n        for (i <- 0 until arr.length)\n    \
    \        result.append(arr(i) * signs(arr(i)))\n        if (result.isEmpty) None\n\
    \        else result.headOption\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjtdpzo2.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013340
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var m = 0.0\n\
    \        var sign = 1\n        var product = 1.0\n        val size = arr.size\n\
    \        var sum = 0.0\n        for(i <- 0 until size) {\n            sum += sign*arr(i)\n\
    \            sign = -sign\n            m*=sign\n            product*=sign\n  \
    \      }\n        if(arr.isEmpty) None\n        else if(sum == 0) Some(0)\n  \
    \      else {\n            Some(arr(0).toLong*product)\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyy3gy3d4.scala:30:17\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            Some(arr(\e[31m0\e\
    [0m).toLong*product)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    Double\n\e[31m   |\e[0m       \
    \          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013347
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft(0l)\
    \ { (sum, e) =>\n            if (e < 0l) None\n            else Some((sum * sign(e))\
    \ % 1L)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbnxo_nvz.scala:17:24\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mif\e[0m (e\
    \ < \e[31m0l\e[0m) None\n\e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\
    \e[31m   |\e[0m                        Found:    None.type\n\e[31m   |\e[0m  \
    \                      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbnxo_nvz.scala:18:29 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            \e[33melse\e[0m Some((sum * sign(e)) % \e[31m1L\e\
    [0m)\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: sign\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var ans = 0\n            var sign = 1\n  \
    \          for (x: Long <- arr) {\n                ans = ans * sign * x\n    \
    \            sign *= -1\n            }\n            Some(ans)\n        }\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9eewg533.scala:21:22\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                ans = ans * sign\
    \ * x\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Found:    Long\n\e[31m   |\e[0m              \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013348
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.map(n\
    \ => math.abs(n)).max\n        if(m == 0l) None\n        else{\n            val\
    \ positives = arr.map(n => if(n < 0l) 0 else 1)\n            val negatives = arr.map(n\
    \ => if(n < 0l) 1l else -1)\n            val signs = positives :: negatives ::\
    \ Nil\n            val prods = positives.zip(negatives).map(x => x.product).sum\n\
    \            val prod = if(prods.isNaN) 0l else prods\n            val res = signs.map(n\
    \ => signs.map(s => n*s).sum).map(s => signs.reduce(_ * s))\n            Some(m.toLong\
    \ * prod.toLong * res.sum)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzl6crdwy.scala:22:60 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mprods\e[0m = positives.zip(negatives).map(\e\
    [36mx\e[0m => x.product).sum\n\e[31m\e[31m   |\e[0m                          \
    \                                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \               value product is not a member of (Int, Long)\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpzl6crdwy.scala:22:72 -----------------------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mprods\e[0m = positives.zip(negatives).map(\e\
    [36mx\e[0m => x.product).sum\n\e[31m\e[31m   |\e[0m                          \
    \                                              ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mIntIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mShortIsIntegral\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzl6crdwy.scala:24:53 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = signs.map(\e\
    [36mn\e[0m => signs.map(\e[36ms\e[0m => n*s).sum).map(\e[36ms\e[0m => signs.reduce(_\
    \ * s))\n\e[31m\e[31m   |\e[0m                                               \
    \     ^^\e[0m\n\e[31m   |\e[0mvalue * is not a member of List[Long | Int], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpzl6crdwy.scala:24:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = signs.map(\e\
    [36mn\e[0m => signs.map(\e[36ms\e[0m => n*s).sum).map(\e[36ms\e[0m => signs.reduce(_\
    \ * s))\n\e[31m\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1660013352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val list = arr.toList\n            var res\
    \ = 1L\n            list.foreach { elem =>\n                res *= elem\n    \
    \        }\n            Some(res * Math.signum(list.last))\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb7mu35c0.scala:23:17\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            Some(res * Math.signum(list.last))\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                 Found:    Float\n\e[31m   |\e[0m                 Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013349
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val sum = arr.foldLeft(0L)\
    \ {\n          case (acc, i) => acc + (i.toLong * math.signum(i))\n        }\n\
    \        val product = arr.foldLeft(1L) {\n          case (acc, i) => acc + (i.toLong\
    \ * math.signum(i))\n        }\n        if (sum == product) Some(product)\n  \
    \      else None\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoxss9sv2.scala:26)\n\tat Problem.main(tmpoxss9sv2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013354
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Write your\
    \ code here\n        var sum = 0l\n        arr.foreach {\n            a => sum\
    \ += a * a * a\n        }\n        val numNegative = arr.count(a => a < 0)\n \
    \       val numZero = arr.count(a => a == 0)\n        val numPositive = arr.count(a\
    \ => a > 0)\n        val product = numNegative * numZero - numPositive\n     \
    \   if(product < 0) {\n            Some(sum)\n        } else if(product == 0)\
    \ {\n            Some(0)\n        } else if(numPositive > 0) {\n            Some(sum\
    \ / product)\n        } else {\n            None\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp9v5dsu0.scala:36)\n\tat Problem.main(tmpp9v5dsu0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013355
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var sum = 0l\n            var product = 0l\n\
    \            for (i <- arr) {\n                sum += i\n            }\n     \
    \       var sign = if (sum > 0) -1 else 1\n            for (i <- arr) {\n    \
    \            product *= i\n                product *= sign\n            }\n  \
    \          Some(product)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpotvznll3.scala:32)\n\tat Problem.main(tmpotvznll3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013358
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var result =\
    \ 1\n        val arr1 = arr.toArray\n        for (i <- 0 until arr.size) {\n \
    \           val mag = math.abs(arr1(i))\n            val prod = if (mag < 0) -1\
    \ else 1\n            result *= mag\n            if (arr1(i) < 0) result *= -1\n\
    \        }\n        Option(result)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpri0oamkf.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            result *= mag\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of\
    \ Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var prod = 0l\n\
    \        var sign = 1\n        arr.foreach {\n            case el : Long =>\n\
    \                prod *= el\n                if (el < 0) sign *= -1\n        }\n\
    \        val result = if (prod == 0) None else Some(prod * (sign * Math.signum(prod)))\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx64pt0pp.scala:24:15\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : Option[Float])\n\e[31m   |\e[0m               Required:\
    \ Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013359
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft[Option[Long]](None){\n\
    \            case (Some(sign),num) => Some(sign*num.abs)\n            case (None,_)\
    \ => None\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphrpymxvj.scala:22)\n\tat Problem.main(tmphrpymxvj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013363
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty)\
    \ None\n      else {\n        val x = arr.head\n        val magSum = arr.map(x\
    \ => math.abs(x)).sum\n        var sum = magSum\n        var sign = 1\n      \
    \  for (i <- arr.tail) {\n          val p = sign * i\n          sum = math.abs(sum)\
    \ + math.abs(p)\n          sign = if (p > 0) -1 else 1\n        }\n        Some(math.abs(sum)\
    \ * sign)\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3k301i0q.scala:31)\n\tat Problem.main(tmp3k301i0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013364
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft((0l,0l))\
    \ { (val, x) =>\n            val sign = if (x < 0) -1 else 1\n            val\
    \ (mag, prod) =\n                if (x == 0) (Some(0l), val._1*sign)\n       \
    \         else if (x < 0) (Some(abs(x)), val._2*sign)\n                else (Some(abs(x)),\
    \ val._1*sign)\n            mag -> prod\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpslw5u7le.scala:16:33 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.foldLeft((\e[31m0l\e[0m,\e[31m0l\e[0m)) {\
    \ (\e[33mval\e[0m, \e[36mx\e[0m) =>\n\e[31m\e[31m   |\e[0m                   \
    \              ^^^\e[0m\n\e[31m   |\e[0m                                 expression\
    \ expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpslw5u7le.scala:19:39 ---------------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m                \e[33mif\e[0m (x == \e[31m0\e[0m) (Some(\e[31m0l\e[0m),\
    \ \e[33mval\e[0m._1*sign)\n\e[31m\e[31m   |\e[0m                             \
    \          ^^^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpslw5u7le.scala:20:47 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (x < \e[31m0\e[0m) (Some(abs(x)),\
    \ \e[33mval\e[0m._2*sign)\n\e[31m\e[31m   |\e[0m                             \
    \                  ^^^\e[0m\n\e[31m   |\e[0m                                 \
    \      expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpslw5u7le.scala:21:36 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33melse\e[0m (Some(abs(x)), \e[33mval\e\
    [0m._1*sign)\n\e[31m\e[31m   |\e[0m                                    ^^^\e[0m\n\
    \e[31m   |\e[0m                                    expression expected but \e\
    [31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013357
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val m = arr.size\n\
    \        val s = arr.map(x => if (x>=0) 1 else -1)\n        val v = s.reduce(_*_)\n\
    \        if (m == 0) None else Some(math.abs(v).toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0im547q0.scala:22)\n\tat Problem.main(tmp0im547q0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foreach{i\
    \ =>\n            val mult = i.signum\n            i <- -mult\n            mult\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp57tirffx.scala:18:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            i <- -mult\n\e[31m\e[31m   |\e[0m       \
    \       ^^\e[0m\n\e[31m   |\e[0m              end of statement expected but '<-'\
    \ found\n\e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmp57tirffx.scala:18:12\
    \ ----------------\e[0m\e[0m\n\e[33m18 |\e[0m            i <- -mult\n\e[33m\e\
    [33m   |\e[0m            ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660013359
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ {\n            None\n        }\n        val res = []\n        var sign = 1\n\
    \        for(v <- arr) {\n            val mag = math.abs(v)\n            res +=\
    \ mag * sign\n            sign *= sign\n        }\n        if(res.length == 1)\
    \ res.head else res\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphw5hiral.scala:19:19 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   an identifier\
    \ expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphw5hiral.scala:20:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m\
    \ \e[36msign\e[0m = \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m^^^\e[0m\n\e[31m   |\e\
    [0m'=>' expected, but 'end of statement' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmphw5hiral.scala:23:16 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            res += mag * sign\n\e[31m\e[31m   |\e[0m            ^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Null - did you mean\
    \ res.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphw5hiral.scala:26:15\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m(res.length\
    \ == \e[31m1\e[0m) res.head \e[33melse\e[0m res\n\e[31m\e[31m   |\e[0m       \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue length is not a member of Null, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToScala.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import concurrent.duration.pairIntToDuration\n\
    \e[31m   |\e[0m  import concurrent.duration.pairLongToDuration\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphw5hiral.scala:26:32 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m(res.length == \e[31m1\e[0m) res.head\
    \ \e[33melse\e[0m res\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660013368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0\n\
    \        var sign = 1\n        arr.foreach {\n            n => {\n           \
    \     sum = math.abs(sum) + math.signum(n) * sign * n\n                sign =\
    \ -sign\n            }\n        }\n        Some(sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2dtyvbnr.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m                sum = math.abs(sum)\
    \ + math.signum(n) * sign * n\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m    \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013365
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val ret = arr.foldLeft(0l){\
    \ (acc, n) => acc * sign(n) }\n        val sum = arr.sum\n        if (sum > 0l)\
    \ {\n            Some(ret)\n        }\n        else {\n            None\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoog0xtx1.scala:16:54 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mret\e[0m = arr.foldLeft(\e\
    [31m0l\e[0m){ (\e[36macc\e[0m, \e[36mn\e[0m) => acc * sign(n) }\n\e[31m\e[31m\
    \   |\e[0m                                                      ^^^^\e[0m\n\e\
    [31m   |\e[0m                                                      Not found:\
    \ sign\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013360
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val products\
    \ = arr.map(_.toLong).filter(_ > 0).toList\n        val signs = arr.map(_.toLong).filter(_\
    \ < 0).toList\n        products.map(prod => (prod * signs.sum).toInt).reduceLeft(_\
    \ + _)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6kemrviq.scala:18:65\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        products.map(\e[36mprod\e\
    [0m => (prod * signs.sum).toInt).reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Found:    Int\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013366
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // Step 1: find\
    \ the total product of all the signs\n        var product = 1\n        arr.foreach\
    \ { x =>\n            product *= x\n        }\n\n        // Step 2: if the total\
    \ product of all the signs is positive,\n        // return sum of the magnitudes\
    \ of all numbers in the list,\n        // otherwise return None\n        arr.filter(x\
    \ => x < 0).map(x => x * product).map(Math.abs).sum.toOption\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx8m3inp2.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            product *= x\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of\
    \ Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx8m3inp2.scala:25:71\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        arr.filter(\e[36mx\e\
    [0m => x < \e[31m0\e[0m).map(\e[36mx\e[0m => x * product).map(Math.abs).sum.toOption\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value toOption is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660013368
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var product =\
    \ 1l\n        for (i <- arr) {\n            product *= i\n        }\n        val\
    \ positives = arr.filter(_ > 0l).sum\n        val negatives = arr.filter(_ < 0l).sum\n\
    \        Some((positives * product) - (negatives * product))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp98j36t59.scala:25)\n\tat Problem.main(tmp98j36t59.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None else {\n            def product(x : Long, y: Long) : Long = {\n       \
    \         val prod = x * y\n                val mag = math.sqrt(prod)\n      \
    \          if (mag != 0) {\n                    mag\n                } else {\n\
    \                    mag\n                }\n            }\n            val signs\
    \ = arr.map(x => x % 2).filter(x => x % 2 == 1)\n            val mags = arr.map(x\
    \ => math.sqrt(x))\n            val magnitudes = mags.filter(x => x != 0)\n  \
    \          val products = signs.map{x => magnitudes.map(x => product(x, x))}\n\
    \            products.reduceLeft(x => x.reduceLeft((a, b) => a + b))\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4bjp3p8d.scala:21:20\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                    mag\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m                   \
    \ Found:    (mag : Double)\n\e[31m   |\e[0m                    Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4bjp3p8d.scala:23:20\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                    mag\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m                   \
    \ Found:    (mag : Double)\n\e[31m   |\e[0m                    Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4bjp3p8d.scala:29:70\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e\
    [36mproducts\e[0m = signs.map{\e[36mx\e[0m => magnitudes.map(\e[36mx\e[0m => product(x,\
    \ x))}\n\e[31m\e[31m   |\e[0m                                                \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \                   Found:    (x : Double)\n\e[31m   |\e[0m                  \
    \                                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp4bjp3p8d.scala:29:73 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mproducts\e[0m = signs.map{\e\
    [36mx\e[0m => magnitudes.map(\e[36mx\e[0m => product(x, x))}\n\e[31m\e[31m   |\e\
    [0m                                                                         ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (x : Double)\n\e[31m   |\e[0m                                            \
    \      Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp4bjp3p8d.scala:30:34\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            products.reduceLeft(\e\
    [36m"
  stdout: ''
  timestamp: 1660013369
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None else Some(arr.map(_.abs).product)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr5ozupqv.scala:19)\n\tat Problem.main(tmpr5ozupqv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.map(x =>\
    \ if (x == 0) 1\n        else if (x == -1) -1\n        else 0)\n            .sum\n\
    \            .map(math.abs)\n            .product\n            .toOption\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_r7c7x0t.scala:20:13 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.map(\e[36mx\e[0m => \e[33mif\e[0m (x == \e\
    [31m0\e[0m) \e[31m1\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m\
    \ (x == -\e[31m1\e[0m) -\e[31m1\e[0m\n\e[31m18 |\e[0m        \e[33melse\e[0m \e\
    [31m0\e[0m)\n\e[31m19 |\e[0m            .sum\n\e[31m20 |\e[0m            .map(math.abs)\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        value map is not a\
    \ member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660013368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val l1 = arr.map(_.toDouble).toList\n\
    \        var r : List[Double] = Nil\n        var sum : Double = 0.0\n        for\
    \ (i <- l1 ) {\n            sum = sum + i\n            r = r :+ i\n        }\n\
    \        val n = arr.length\n        if(n > 0) {\n            var sign = l1.foldLeft(0.0)\
    \ { (acc, i) =>\n                if (i > 0) {\n                    acc += math.signum(i)\n\
    \                }\n                acc\n            }\n            if (sign >\
    \ 0) {\n                Some(sum * math.pow(-1, sign))\n            }\n      \
    \  }\n        else if(n === 0) {\n            None\n        }\n        else {\n\
    \            None\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx03v_3bl.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    acc += math.signum(i)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m               value\
    \ += is not a member of Double - did you mean acc.!=?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpx03v_3bl.scala:31:12 --------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m            \e[33mif\e[0m (sign > \e[31m0\e[0m) {\n\e[31m\e[31m\
    \   |\e[0m            ^\e[0m\n\e[31m   |\e[0m            Found:    Unit\n\e[31m\
    \   |\e[0m            Required: Option[Long]\n\e[31m   |\e[0m            Maybe\
    \ you are missing an else part for the conditional?\n\e[31m32 |\e[0m         \
    \       Some(sum * math.pow(-\e[31m1\e[0m, sign))\n\e[31m33 |\e[0m           \
    \ }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx03v_3bl.scala:35:18\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m(n === \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^\e\
    [0m\n\e[31m   |\e[0m                value === is not a member of Int - did you\
    \ mean n.==?\n3 errors found\n"
  stdout: ''
  timestamp: 1660013370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty)\
    \ None\n      else {\n        val prod = 0\n        val sign = 1\n        for\
    \ (n <- arr) {\n          prod *= sign\n          prod += n.toLong\n         \
    \ sign *= -1\n        }\n        Some(prod)\n      }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps2xeosj7.scala:21:15 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m          prod *= sign\n\e[31m\e[31m   |\e[0m       \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m          value *= is not a member of Int - did\
    \ you mean prod.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps2xeosj7.scala:22:15\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m          prod += n.toLong\n\
    \e[31m\e[31m   |\e[0m          ^^^^^^^\e[0m\n\e[31m   |\e[0m          value +=\
    \ is not a member of Int - did you mean prod.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmps2xeosj7.scala:23:15 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m          sign *= -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m          ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m          value *= is not a member of Int - did you mean sign.!=?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            var i = 0\n            var sum = 0\n     \
    \       var sign = 1\n            while (i < arr.length) {\n                sum\
    \ += sign * arr(i)\n                i += 1\n                sign *= -1\n     \
    \       }\n            Some(sum)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr8xkfb5q.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                sum += sign * arr(i)\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is\
    \ not a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013370
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val sumOfMag\
    \ = arr.foldLeft(0l){ case (sum, el) => (sum + el*el) }\n        val signs = arr.map(\
    \ x => if (x == sumOfMag) 1\n        \telse (if (x > (sumOfMag/2)) -1\n      \
    \          else 0)) \n        val product = signs.foldLeft(1l){ case (prod, x)\
    \ => prod*x }\n        Some(product.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmd8ubqhu.scala:24)\n\tat Problem.main(tmpmd8ubqhu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013377
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldRight(Option(0l))((a,\
    \ b) => a.map(_*b).getOrElse(0))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd4kc75si.scala:16:46 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.foldRight(Option(\e[31m0l\e[0m))((\e[36ma\e\
    [0m, \e[36mb\e[0m) => a.map(_*b).getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                            ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                    value map is not a member of Long\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if (arr.isEmpty\
    \ || arr.size == 1) {\n          None\n      } else {\n        val arr = arr.map(_.abs)\n\
    \        val m1 = arr.map { x => x*x }.reduce(_+_)\n        val m2 = arr.map(x\
    \ => x*x*(x>=0).sign).reduce(_+_)\n        m1 >= m2 ? Some(m1) else None\n   \
    \   }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpxu8pq7do.scala:22:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        m1 >= m2 ? Some(m1) \e[33melse\e[0m None\n\e\
    [31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                        end of statement expected but 'else' found\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpxu8pq7do.scala:19:18 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(_.abs)\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013370
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.map(x =>\
    \ x.abs).foldLeft((0l,0l))((x,y) => if (x>y) (x+y, x*y) else (y+x, y*x))\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo1nfu4jz.scala:16:60 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.map(\e[36mx\e[0m => x.abs).foldLeft((\e[31m0l\e\
    [0m,\e[31m0l\e[0m))((\e[36mx\e[0m,\e[36my\e[0m) => \e[33mif\e[0m (x>y) (x+y, x*y)\
    \ \e[33melse\e[0m (y+x, y*x))\n\e[31m\e[31m   |\e[0m                         \
    \                                  ^^\e[0m\n\e[31m   |\e[0mvalue > is not a member\
    \ of (Long, Long), but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo1nfu4jz.scala:16:66 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.map(\e[36mx\e[0m => x.abs).foldLeft((\e[31m0l\e\
    [0m,\e[31m0l\e[0m))((\e[36mx\e[0m,\e[36my\e[0m) => \e[33mif\e[0m (x>y) (x+y, x*y)\
    \ \e[33melse\e[0m (y+x, y*x))\n\e[31m\e[31m   |\e[0m                         \
    \                                        ^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of (Long, Long), but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpo1nfu4jz.scala:16:71 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.map(\e[36mx\e[0m => x.abs).foldLeft((\e[31m0l\e\
    [0m,\e[31m0l\e[0m))((\e[36mx\e[0m,\e[36my\e[0m) => \e[33mif\e[0m (x>y) (x+y, x*y)\
    \ \e[33melse\e[0m (y+x, y*x))\n\e[31m\e[31m   |\e[0m                         \
    \                                             ^^\e[0m\n\e[31m   |\e[0mvalue *\
    \ is not a member of (Long, Long), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660013381
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val positives\
    \ = arr.filter(_ > 0l).map(_ * -1).toList\n        val negatives = arr.filter(_\
    \ < 0l).map(_ * -1).toList\n        if (positives.isEmpty) None\n        if (negatives.isEmpty)\
    \ None\n        if (positives.size + negatives.size < arr.size) {\n          \
    \  if (positives.size == 0) None\n            if (negatives.size == 0) None\n\
    \            Some(positives.foldLeft(1l)(_ * _))\n        } else {\n         \
    \   None\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc0r5a2rp.scala:29)\n\tat Problem.main(tmpc0r5a2rp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else if(arr.head.isNull || arr.tail.isEmpty) None\n        else\
    \ {\n            val res = []\n            val sum = arr.sum\n            val\
    \ signs = arr.map { elem => (elem > 0 ? 1 : elem < 0 ? -1 : 0).toLong }\n    \
    \        val product = signs.foldLeft(1L)(_*_)\n            val productAndSum\
    \ = product + sum\n\n            arr.head -> productAndSum\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuvg529lc.scala:19:23 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = []\n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     an identifier expected, but ']' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpuvg529lc.scala:20:0 ----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m            \e[33mval\e[0m \e[36msum\e[0m = arr.sum\n\e[31m\e[31m   |\e\
    [0m^^^\e[0m\n\e[31m   |\e[0m'=>' expected, but 'end of statement' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpuvg529lc.scala:21:72 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36msigns\e[0m = arr.map\
    \ { \e[36melem\e[0m => (elem > \e[31m0\e[0m ? \e[31m1\e[0m : \e[35melem\e[0m \e\
    [35m<\e[0m \e[31m0\e[0m \e[35m?\e[0m -\e[31m1\e[0m : \e[31m0\e[0m).toLong }\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \      ')' expected, but ':' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuvg529lc.scala:17:25\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m(arr.head.isNull || arr.tail.isEmpty) None\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value isNull\
    \ is not a member of Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuvg529lc.scala:21:63\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m\
    \ \e[36msigns\e[0m = arr.map { \e[36melem\e[0m => (elem > \e[31m0\e[0m ? \e[31m1\e\
    [0m : \e[35melem\e[0m \e[35m<\e[0m \e[31m0\e[0m \e[35m?\e[0m -\e[31m1\e[0m : \e\
    [31m0\e[0m).toLong }\n\e[31m\e[31m   |\e[0m                                  \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                               Not found: type <\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpuvg529lc.scala:21:52 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36msigns\e[0m = arr.map\
    \ { \e[36melem\e[0m => (el"
  stdout: ''
  timestamp: 1660013381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else {\n            var magnitude = 0l\n            var sign =\
    \ 1\n            var result = 0l\n            var newArr : List[Long] = arr.reverse.map(x\
    \ => {\n                var m = math.abs(x)\n                var s = sign * math.signum(x)\n\
    \                result += (sign * m) * s\n                sign = -s\n       \
    \         magnitude += m\n                sign = 1\n                val s = sign\
    \ * math.signum(x)\n                (m, s)\n            }).toList\n          \
    \  for(a <- newArr) if(a._2 != 0) result += a._1 * a._2\n            result.max(magnitude)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp05m1d9i6.scala:28:20 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[36ms\e[0m = sign *\
    \ math.signum(x)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ms is already defined as \e[33mvariable\e[0m \e[35ms\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp05m1d9i6.scala:25:23 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                sign = -s\n\e[31m\e[31m   |\e[0m                     \
    \  ^^\e[0m\n\e[31m   |\e[0m                       Found:    Long\n\e[31m   |\e\
    [0m                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp05m1d9i6.scala:31:34 ------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m(a <- newArr) \e[33mif\e[0m(a._2\
    \ != \e[31m0\e[0m) result += a._1 * a._2\n\e[31m\e[31m   |\e[0m              \
    \                  ^^^^\e[0m\n\e[31m   |\e[0m                                value\
    \ _2 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp05m1d9i6.scala:31:50\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m(a\
    \ <- newArr) \e[33mif\e[0m(a._2 != \e[31m0\e[0m) result += a._1 * a._2\n\e[31m\e\
    [31m   |\e[0m                                           ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value += is not a member of Long - did you mean Long.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp05m1d9i6.scala:31:55 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mfor\e[0m(a <- newArr) \e[33mif\e[0m(a._2\
    \ != \e[31m0\e[0m) result += a._1 * a._2\n\e[31m\e[31m   |\e[0m              \
    \                                       ^^^^\e[0m\n\e[31m   |\e[0m           \
    \                             value _1 is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp05m1d9i6.scala:32:22 --------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            result.max(magnitude)\n\e[31m\e[31m   |\e\
    [0m     "
  stdout: ''
  timestamp: 1660013383
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.map { x =>\n\
    \            val signs = if (x < 0) 1 else -1\n            math.abs(x) * signs\n\
    \        }.reduceLeft(_ * _)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe41ml8mz.scala:19:20\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.map { \e[36mx\e[0m\
    \ =>\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36msigns\e[0m = \e[33mif\e\
    [0m (x < \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m -\e[31m1\e[0m\n\e[31m18 |\e\
    [0m            math.abs(x) * signs\n\e[31m19 |\e[0m        }.reduceLeft(_ * _)\n\
    \e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e\
    [31m   |\e[0m        Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // If list is\
    \ empty, we return None\n        if (arr.isEmpty) {\n            Some(None)\n\
    \        }\n        // Otherwise, multiply every element by -1\n        else {\n\
    \            val productOfSigns = arr.map {x => x * -1}\n            val sumOfMagnitudes\
    \ = productOfSigns.map{x => math.abs(x)}\n            Some(arr.head.product) *\n\
    \                sumOfMagnitudes.sum\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqo1i2ol_.scala:18:17\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m            Some(None)\n\e[31m\e\
    [31m   |\e[0m                 ^^^^\e[0m\n\e[31m   |\e[0m                 Found:\
    \    None.type\n\e[31m   |\e[0m                 Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpqo1i2ol_.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            Some(arr.head.product) *\n\e[31m\e[31m  \
    \ |\e[0m                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \   value product is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660013384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None else {\n            var product = 0\n            for(i <- arr.length) {\n\
    \                product += (math.signum(arr(i))) * (math.signum(arr(i)))\n  \
    \          }\n            Some(product)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxp4vq6cr.scala:18:21 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mfor\e[0m(i <- arr.length) {\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \          value foreach is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660013384
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val minMag :\
    \ Long = arr.foldLeft(0l)(_+_)\n        val signs : mutable.ListBuffer[Int] =\
    \ mutable.ListBuffer.empty\n        val signsMap : Map[Long,Int] = arr\n     \
    \       .groupBy(_ % minMag)\n            .mapValues(_.length.toInt)\n       \
    \     .mapValues(_.toInt)\n            .mapValues(_.product)\n\n        arr.foreach{\n\
    \            x => {\n                signsMap(x.toLong) match {\n            \
    \        case 0 => signs += 0\n                    case 1 => signs += 1\n    \
    \                case -1 => signs += -1\n                }\n            }\n  \
    \      }\n        if (signs.isEmpty) None\n        else signs.sum\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphhmckv9m.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m : mutable.ListBuffer[\e\
    [35mInt\e[0m] = mutable.ListBuffer.empty\n\e[31m\e[31m   |\e[0m              \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphhmckv9m.scala:17:46\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36msigns\e[0m : mutable.ListBuffer[\e[35mInt\e[0m] = mutable.ListBuffer.empty\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphhmckv9m.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            .mapValues(_.product)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                     value product is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1660013387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // your code\n\
    \        val len = arr.length\n        val signs = mutable.ArrayBuffer(1, 0, -1)\n\
    \        val totalSigns = mutable.ArrayBuffer(0)\n        for(i <- 0 until len){\n\
    \            val current = arr(i)\n            totalSigns(0) = totalSigns(0) +\
    \ signs(0) * current\n            signs(1) = signs(1) * (current < 0)\n      \
    \      signs(2) = signs(2) * (current > 0)\n        }\n        val product = totalSigns.sum\n\
    \        Some(product * ((-1 * signs.toArray.sum) / arr.size))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw3_xud1_.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = mutable.ArrayBuffer(\e\
    [31m1\e[0m, \e[31m0\e[0m, -\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m              \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw3_xud1_.scala:19:25\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mtotalSigns\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013381
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sign = arr.foldLeft(0)(_*_.toInt)\n\
    \        var ret: Long = arr.foldLeft(0)(_+_*sign)\n        if(arr.size == 0)\
    \ None // None means there is no element in list\n        else Some(ret)\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp76ip5r6s.scala:17:40\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mvar\e[0m \e[36mret\e\
    [0m: \e[35mLong\e[0m = arr.foldLeft(\e[31m0\e[0m)(_+_*sign)\n\e[31m\e[31m   |\e\
    [0m                                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                    Found:    Long\n\e[31m   |\e[0m         \
    \                               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        require(!arr.isEmpty)\n\
    \        var sum = arr.sum\n        arr.map(x => sum += math.signum(x) * math.pow(math.abs(x),\
    \ 2))\n        if(sum == 0) {\n            Some(0l)\n        } else {\n      \
    \      Some(arr.map(x => math.signum(x) * math.pow(math.abs(x), 2)).sum)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp51_j14l0.scala:18:25 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        arr.map(\e[36mx\e[0m => sum += math.signum(x)\
    \ * math.pow(math.abs(x), \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m              \
    \       ^^^^^^\e[0m\n\e[31m   |\e[0m                value += is not a member of\
    \ Long - did you mean Long.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp51_j14l0.scala:22:17\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            Some(arr.map(\e[36mx\e\
    [0m => math.signum(x) * math.pow(math.abs(x), \e[31m2\e[0m)).sum)\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                 Found:    Double\n\e[31m   |\e[0m       \
    \          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013389
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val mags = arr.map(x\
    \ => abs(x))\n        val signs = arr.map(x => (x == 0 || x == -1) ? -1 : 1)\n\
    \        mags.zip(signs).fold(Some(0l), (x, y) => Some(x.abs*y))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnx31ycly.scala:17:53 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = arr.map(\e\
    [36mx\e[0m => (x == \e[31m0\e[0m || x == -\e[31m1\e[0m) ? -\e[31m1\e[0m : \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value ? is not a member of\
    \ Boolean\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpnx31ycly.scala:18:40 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        mags.zip(signs).fold(Some(\e[31m0l\e[0m), (\e\
    [36mx\e[0m, \e[36my\e[0m) => Some(x.abs*y))\n\e[31m\e[31m   |\e[0m           \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \  Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                  \
    \        I could not infer the type of the parameter x.\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmpnx31ycly.scala:18:43 -----------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        mags.zip(signs).fold(Some(\e[31m0l\e[0m), (\e[36mx\e\
    [0m, \e[36my\e[0m) => Some(x.abs*y))\n\e[31m\e[31m   |\e[0m                  \
    \                         ^\e[0m\n\e[31m   |\e[0m                          Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          I\
    \ could not infer the type of the parameter y.\n3 errors found\n"
  stdout: ''
  timestamp: 1660013389
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val sum = arr.sum\n\
    \        if(arr.isEmpty) None\n        else {\n            val product = arr.map(x\
    \ => x*x).product\n            val signs = arr.map(x => if(x < 0) -1 else 1).product\n\
    \            Some(sum * signs * product)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpx4o31gzb.scala:25)\n\tat Problem.main(tmpx4o31gzb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\n\
    \            None\n        else if (arr.isEmpty || arr.length == 1)\n        \
    \    Some(arr(0) * Math.signum(arr(0)))\n        else {\n            var mag :\
    \ Long = 0l\n            var sign = arr(0)\n            val rem = arr.drop(1)\n\
    \            for (i <- 0 until rem.length) {\n                mag = mag + rem(i)\
    \ * Math.signum(sign)\n                sign = sign * arr(i)\n            }\n \
    \           Some(mag)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcnl9v9qt.scala:19:17\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            Some(arr(\e[31m0\e\
    [0m) * Math.signum(arr(\e[31m0\e[0m)))\n\e[31m\e[31m   |\e[0m                \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 Found:  \
    \  Float\n\e[31m   |\e[0m                 Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcnl9v9qt.scala:25:22 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                mag = mag + rem(i) * Math.signum(sign)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    Float\n\e[31m   |\e[0m   \
    \                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldRight(0.0l)\
    \ { (sum, element) =>\n            val sign = if (element > 0) 1 else -1\n   \
    \         math.abs(sum * sign)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp20xvyyhf.scala:16:22 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        arr.foldRight(0.0l) { (\e[36msum\e[0m, \e[36melement\e\
    [0m) =>\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m  \
    \                    Invalid literal number\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp20xvyyhf.scala:17:35 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m            \e[33mval\e[0m \e[36msign\e[0m = \e[33mif\e[0m (element > \e[31m0\e\
    [0m) \e[31m1\e[0m \e[33melse\e[0m -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of\
    \ Null, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m  import math.BigInt.javaBigInteger2bigInt\n\e[31m   |\e[0m  import math.Numeric.BigDecimalAsIfIntegral.mkOrderingOps\n\
    \e[31m   |\e[0m  import math.Numeric.BigDecimalIsFractional.mkOrderingOps\n\e\
    [31m   |\e[0m  import math.Numeric.BigIntIsIntegral.mkOrderingOps\n\e[31m   |\e\
    [0m  import math.Ordering.BigDecimal.mkOrderingOps\n\e[31m   |\e[0m  import math.Ordering.BigInt.mkOrderingOps\n\
    \e[31m   |\e[0m  import math.Ordering.String.mkOrderingOps\n\e[31m   |\e[0m  import\
    \ math.Ordering.Symbol.mkOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp20xvyyhf.scala:18:20 --------------------\e[0m\e[0m\n\
    \e[31m18 |\e[0m            math.abs(sum * sign)\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    Long\n\e\
    [31m   |\e[0m            Required: Null\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013391
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else if(arr.size == 1) Some(arr(0)*signs(arr(0)))\n        else\
    \ {\n            var res = 1\n            for(i <- arr.indices)\n            \
    \    res = res * signs(i) * signs(arr(i))\n            Some(res)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv61lg09x.scala:17:43 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(arr.size == \e\
    [31m1\e[0m) Some(arr(\e[31m0\e[0m)*signs(arr(\e[31m0\e[0m)))\n\e[31m\e[31m   |\e\
    [0m                                           ^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                       Not found: signs\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpv61lg09x.scala:21:28 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                res = res * signs(i) * signs(arr(i))\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^\e[0m\n\e[31m   |\e[0m \
    \                           Not found: signs\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013385
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val list = new\
    \ mutable.ListBuffer[Int]()\n        val m = arr.size\n        for ( i <- 0 until\
    \ m ) list.+=( if ( arr(i) * arr(i) > 0 ) 1 else 0 )\n        list.foldLeft(1L)(\
    \ _ * _ )\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3lf83mv7.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else {\n            var sum = 0\n            var product = 1\n\
    \            arr.foreach( e => {\n                sum = sum + math.abs(e)\n  \
    \              product = product * math.signum(e)\n            })\n          \
    \  Some(sum * product)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwypjamd5.scala:21:22\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m                sum = sum + math.abs(e)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Found:    Long\n\e[31m   |\e[0m                     \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwypjamd5.scala:22:26\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m                product = product\
    \ * math.signum(e)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Long\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.filter(x\
    \ => x >= 0) match {\n            case Nil => None\n            case head :: tail\
    \ => Some(math.abs(head * prodSigns(tail)))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpli8gwm92.scala:18:52 -----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m head :: tail => Some(math.abs(head\
    \ * prodSigns(tail)))\n\e[31m\e[31m   |\e[0m                                 \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments (Option[Long])\n1 error found\n"
  stdout: ''
  timestamp: 1660013388
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft(Option.empty[Long]){\n\
    \            (acc, val) =>\n                acc match {\n                case\
    \ Some(sign) =>\n                    val newSign = if (val == 0) -1 else if (val\
    \ > 0) 1 else 0\n                    val tmpSign = sign * newSign\n          \
    \          Some(tmpSign)\n                case None =>\n                    acc\
    \ :+ val\n                }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpn201l_br.scala:17:18 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            (\e[36macc\e[0m, \e[33mval\e[0m) =>\n\e[31m\e\
    [31m   |\e[0m                  ^^^\e[0m\n\e[31m   |\e[0m                  expression\
    \ expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpn201l_br.scala:20:38 ---------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m                    \e[33mval\e[0m \e[36mnewSign\e[0m = \e[33mif\e[0m\
    \ (\e[33mval\e[0m == \e[31m0\e[0m) -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m\
    \ (\e[33mval\e[0m > \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m                                      ^^^\e[0m\n\e[31m   |\e\
    [0m                                      expression expected but \e[31mval\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpn201l_br.scala:20:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m                    \e\
    [33mval\e[0m \e[36mnewSign\e[0m = \e[33mif\e[0m (\e[33mval\e[0m == \e[31m0\e[0m)\
    \ -\e[31m1\e[0m \e[33melse\e[0m \e[33mif\e[0m (\e[33mval\e[0m > \e[31m0\e[0m)\
    \ \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m           \
    \                                                 ^^^\e[0m\n\e[31m   |\e[0m  \
    \                                     expression expected but \e[31mval\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpn201l_br.scala:24:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    acc\
    \ :+ \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\
    \e[31m   |\e[0m                           expression expected but \e[31mval\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn201l_br.scala:24:24\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    acc :+\
    \ \e[33mval\e[0m\n\e[31m\e[31m   |\e[0m           "
  stdout: ''
  timestamp: 1660013392
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val set = new\
    \ mutable.HashSet[Int]()\n        for( i <- 0 until arr.length){\n           \
    \ if(arr.contains( arr(i)))\n                set.add( arr(i).signum)\n       \
    \ }\n        if(set.size == 0){\n            None\n        }else{\n          \
    \  val product = set.product\n            Some(product)\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_9ry3iud.scala:16:22 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mset\e[0m = \e[33mnew\e[0m\
    \ mutable.HashSet[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013389
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val nums = arr.toList\n\
    \        if (nums.isEmpty) None\n        else {\n            val result = nums.foldLeft(0l){case\
    \ (sum, num) =>\n                val sign = if (num > 0) 1\n                 \
    \   else if (num < 0) -1\n                    else 0\n                sum * sign\n\
    \            }\n            if (result == 0l) None\n            else  Some(result)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxc441l0o.scala:30)\n\tat Problem.main(tmpxc441l0o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val ls = arr.toList.sort\n\
    \        val sumOfMags = ls.map(math.pow(_,2)).sum\n        val signs = ls.map(x\
    \ => if (x>0) -1 else if (x<0) 1 else 0)\n        signs.product\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphrox9lm1.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mls\e[0m = arr.toList.sort\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ sort is not a member of List[Long] - did you mean List[Long].sortBy?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val ret = arr\
    \ match {\n            case Nil => None\n            case head :: tail =>\n  \
    \              val mag = magnitude(head)\n                val sign = signOf(head)\n\
    \                mag match {\n                    case None => Some(head * sign)\n\
    \                    case Some(mag) => mag match {\n                        case\
    \ None => Some(head * sign)\n                        case Some(mul) =>\n     \
    \                       val signProd = sign * mul\n                          \
    \  Some(head * signProd match {\n                                case -1 => signProd\
    \ * (mag + signProd)\n                                case _ => signProd * mag\n\
    \                            })\n                    }\n                }\n  \
    \      }\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe41aqcxh.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e[0m \e[36mmag\e[0m = magnitude(head)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Not found: magnitude\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpe41aqcxh.scala:20:27 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mval\e[0m \e[36msign\e[0m = signOf(head)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          Not found: signOf\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val arr = arr.toList\n\
    \        if (arr.isEmpty) None\n        else arr.map(_.abs) -> arr.map(_.signum)\
    \ -> arr.map(x => (x * arr.map(y => y*y)).toList)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3e6r_olq.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        require(!arr.isEmpty)\n\
    \        val signs = arr.map(_ sign)\n        val signsLen = signs.length\n  \
    \      var sum = 0\n        var prod = 1\n        for (i<- 0 until signsLen) {\n\
    \            sum += signs(i)\n            prod *= (1 -signs(i))\n        }\n \
    \       if (arr.isEmpty)\n            None\n        else Some((sum.toLong * prod).toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpi03fodci.scala:17:34 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = arr.map(_ sign)\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                  expression expected but \e[31m')'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi03fodci.scala:22:16\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            sum += signs(i)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpi03fodci.scala:23:17 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m            prod *= (\e[31m1\e[0m -signs(i))\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member\
    \ of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpi03fodci.scala:23:23\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            prod *= (\e[31m1\e\
    [0m -signs(i))\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0m (x: Char): Int\n\e[31m   |\e[0m\
    \ (x: Short): Int\n\e[31m   |\e[0m (x: Byte): Int\n\e[31m   |\e[0mall match arguments\
    \ (Nothing)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      if(arr.isEmpty)\
    \ {\n        None\n      } else {\n        val magnitudes = arr.map(math.abs(_)).toArray\n\
    \        val signs = arr.map(_.signum).toArray\n        val result = magnitudes.map(math.pow(10,\
    \ magnitudes.length)).product * signs\n        Some(result)\n      }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdfd37jja.scala:21:44\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = magnitudes.map(math.pow(\e[31m10\e[0m, magnitudes.length)).product * signs\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    Double\n\e[31m\
    \   |\e[0m                                    Required: Long => Any\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpdfd37jja.scala:21:68 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = magnitudes.map(math.pow(\e\
    [31m10\e[0m, magnitudes.length)).product * signs\n\e[31m\e[31m   |\e[0m      \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1660013404
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0\n\
    \        var product = 0\n        arr.foreach { x =>\n            sum = math.signum(x)\
    \ * sum\n            product = math.signum(x) * product\n        }\n        Some(math.abs(product)\
    \ * sum)\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuzfz6nem.scala:19:18\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            sum = math.signum(x)\
    \ * sum\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                  Found:    Long\n\e[31m   |\e[0m               \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuzfz6nem.scala:20:22\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            product = math.signum(x)\
    \ * product\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    Long\n\e[31m   |\e[0m    \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013404
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\
    \ None\n        else {\n            val m = arr.map(math.abs).map(math.signum).sum\n\
    \            val n = arr.size\n            val s = arr.map(x => if(math.signum(x)\
    \ > 0) 1 else 0).sum\n            val product = math.signum(m) * math.signum(n)\
    \ * math.signum(s)\n            val sign = (m * n * s) == 0 ? 0 : m * n * s\n\
    \            Some(product * sign)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptn0zdk8w.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36msign\e[0m = (m * n *\
    \ s) == \e[31m0\e[0m ? \e[31m0\e[0m : \e[35mm\e[0m \e[35m*\e[0m \e[35mn\e[0m \e\
    [35m*\e[0m \e[35ms\e[0m\n\e[31m\e[31m   |\e[0m                               \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \                    Not found: type *\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmptn0zdk8w.scala:22:40 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36msign\e[0m = (m * n * s) ==\
    \ \e[31m0\e[0m ? \e[31m0\e[0m : \e[35mm\e[0m \e[35m*\e[0m \e[35mn\e[0m \e[35m*\e\
    [0m \e[35ms\e[0m\n\e[31m\e[31m   |\e[0m                                      ^^^\e\
    [0m\n\e[31m   |\e[0m                                      value ? is not a member\
    \ of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1660013403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            var total = 0l\n        \
    \    var sign = 1\n            var i = -1\n            var product = 1l\n    \
    \        val lenArr = arr.length\n\n            while (i < lenArr) {\n       \
    \         val num = arr(i)\n                total += num\n                sign\
    \ *= if (num < 0) -1 else 1\n                product = num * product\n       \
    \         i += 1\n            }\n            val signOfTotal = sign * total\n\
    \            Some(signOfTotal * product)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpntym__iq.scala:28:24 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                sign *= \e[33mif\e[0m (num < \e[31m0\e\
    [0m) -\e[31m1\e[0m \e[33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                 ^^\e[0m\n\e[31m   |\e[0m                        expression expected\
    \ but \e[31mif\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpntym__iq.scala:28:21 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m                sign *= \e[33mif\e[0m (num < \e[31m0\e[0m) -\e[31m1\e[0m \e\
    [33melse\e[0m \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value *= is not a member of Int - did you mean\
    \ Int.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660013403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val arr = arr.map(x => x.toLong).toList\n\
    \            var m = scala.math.abs(arr(0));\n            var product = arr(0)\n\
    \            for (i <- 0 until arr.size) {\n                val sign = scala.math.signum(arr(i));\n\
    \                product *= sign\n                m += sign * scala.math.abs(arr(i))\n\
    \            }\n            Some(m)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmps6xf5p15.scala:18:22 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013399
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var product =\
    \ 1\n        var result = 0\n        arr.foreach {\n            i =>\n       \
    \         product *= i\n                if (product >= 0)\n                  \
    \  result += product\n                product = 1\n        }\n        if (product\
    \ > 0)\n            result += product\n        if (result > 0)\n            Some(result)\n\
    \        else\n            None\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc6g4odfd.scala:20:24 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                product *= i\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value *= is not\
    \ a member of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013406
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft(Option.empty[Long])\
    \ { (acc, curr) =>\n            var res = curr\n            acc match {\n    \
    \            case Some(sign) =>\n                    res = (sign * res.getOrElse(0l))\n\
    \                case _ =>\n            }\n            acc\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfsme5j7y.scala:20:38 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    res = (sign * res.getOrElse(\e[31m0l\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 value getOrElse is not a\
    \ member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660013406
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // init signs\n\
    \        var sign = 1l\n        var signs  = arr.filter(_ < 0).toList.map(sign)\n\
    \        // find products\n        val prod  = arr.filter(_ > 0).toList.map(sign\
    \ * _)\n        // sum signs\n        signs = signs.sum\n\n        // return magnitudes\n\
    \        Some(prod.map(abs).sum / signs)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpotjpev7c.scala:18:50\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mvar\e[0m \e[36msigns\e\
    [0m  = arr.filter(_ < \e[31m0\e[0m).toList.map(sign)\n\e[31m\e[31m   |\e[0m  \
    \                                                ^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                               Found:    (sign : Long)\n\e[31m\
    \   |\e[0m                                                 Required: Long => Any\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpotjpev7c.scala:22:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        signs = signs.sum\n\e[31m\e[31m   |\e[0m    \
    \                     ^\e[0m\n\e[31m   |\e[0m         No implicit Ordering defined\
    \ for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         where:    B is a type variable\
    \ with constraint <: List[Nothing]\n\e[31m   |\e[0m         .\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpotjpev7c.scala:25:31 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        Some(prod.map(abs).sum / signs)\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m/\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m\
    \   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m\
    \ (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((signs : List[Nothing]))\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660013410
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val sum = 0\n\
    \        var i = 1\n        while (i < arr.length) {\n            sum += abs(arr(i))\
    \ * (-1)\n            i += 2\n        }\n        if (arr.isEmpty) None else Some(sum)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzuuda6ff.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            sum += abs(arr(i)) * (-\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013408
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else Some(arr.map(x => (x*arr.signum).abs).sum)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzf388rc3.scala:17:38 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33melse\e[0m Some(arr.map(x => (x*arr.signum).abs).sum)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue signum is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660013411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = mutable.ArrayBuffer[Long]()\n\
    \        arr.foreach { x => signs += (if (x == 0) 1 else if (x == -1) 0 else 0l)\
    \ }\n        signs.foldLeft(0l) { case (x, y) => (x * y) + x }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvd__f2x8.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36msigns\e[0m = mutable.ArrayBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013402
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft(1L){case\
    \ (acc, n) => n.toLong * acc}\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgr3hv0ov.scala:16:24\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.foldLeft(\e[31m1L\e\
    [0m){\e[33mcase\e[0m (acc, n) => n.toLong * acc}\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013411
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var magnitude\
    \ = 0l\n        var sign = 1\n        var product = 1\n        for (x <- arr)\
    \ {\n            magnitude += x * sign\n            sign *= 1\n            product\
    \ *= sign\n        }\n        if (product != 1l) None else Some(magnitude)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb2wber2v.scala:27)\n\tat Problem.main(tmpb2wber2v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013414
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      var product = 0\n\
    \      var sign = 0\n      for (x<-arr) {\n        sign = if (x < 0) -1 else if\
    \ (x > 0) 1 else 0\n        product = product * sign\n      }\n      if (arr.size\
    \ == 0) None\n      else {\n        Some(product)\n      }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphhwzfsbd.scala:28)\n\tat Problem.main(tmphhwzfsbd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val nums = arr.toSet.flatMap(_\
    \ * arr.map(_.signum))\n        if (nums.isEmpty) None\n        else {\n     \
    \       val rem = nums.takeWhile(_ < 0) // [-4, -2, 2, 2], take all negative numbers\
    \ in the array and subtract them from the set\n            val (m, n) = rem //\
    \ m = 4, n = -1\n            if (n == 0) Some(m * nums.count(_ == -1)) // the\
    \ product of any number multiplied by its sign must be equal to number of -1s\
    \ in the array\n            else {\n                val (i, j) = (nums.size -\
    \ 1, nums.last) // i=2, j=1\n                if (rem == 1) Some(m * nums.count(_\
    \ == i)) // if the product of any number multiplied by its sign and number of\
    \ -1s is equal to number in the array then we found a valid answer to the original\
    \ problem\n                else {\n                    val a = nums(i) * (1 -\
    \ n) // a = 4, n = -1\n                    val b = nums(j) * n // b = -2, n =\
    \ 1\n                    if (a > b) Some(m * a) // if the product of a and b is\
    \ greater then we found a valid answer to the original problem\n             \
    \       else Some(m * b) // otherwise, the product of a and b must be lesser than\
    \ the product of b and n\n                }\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpycbzdmfs.scala:16:39 -----------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnums\e[0m = arr.toSet.flatMap(_\
    \ * arr.map(_.signum))\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x:\
    \ Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\
    \e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e\
    [0mmatch arguments (List[Int])\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycbzdmfs.scala:19:39\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m\
    \ \e[36mrem\e[0m = nums.takeWhile(_ < \e[31m0\e[0m) \e[34m// [-4, -2, 2, 2], take\
    \ all negative numbers in the array and subtract them from the set\e[0m\n\e[31m\e\
    [31m   |\e[0m                                     ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m \
    \ import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m\
    \  import math.BigDecimal.RoundingMode.ValueOrdering.mkOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycbzdmfs.scala:21:31 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (n == \e[31m0\e[0m) Some(m\
    \ * nums.count(_ == -\e[31m1\e[0m)) \e[34m// the product of any number multiplied\
    \ by its sign must be equal to number of -1s in the array\e[0m\n\e[31m\e[31m \
    \  |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0mvalue * is not\
    \ a member of Any, but could be made available as an extension metho"
  stdout: ''
  timestamp: 1660013419
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(x\
    \ => if(x > 0) { 1 } else if(x < 0) { -1} else { 0 })\n        val len = arr.length\n\
    \        val ans = arr.map(x => x*signs.map(_*x).sum/len).toList\n        if(ans.sum\
    \ != 1) {\n            Some(ans.sum)\n        } else {\n            None\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf2fn_ap1.scala:26)\n\tat Problem.main(tmpf2fn_ap1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var ret = 0\n\
    \        var sign = 1\n        for (i <- arr) {\n            ret += sign * i\n\
    \            sign *= (-1)\n        }\n        if (arr.isEmpty)\n            Some(ret)\n\
    \        else\n            None\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9g8ugy_4.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            ret += sign * i\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      var m = 0\n   \
    \   var sum = 0\n      arr.foreach {\n          x => {\n            m += Math.signum(x);\n\
    \            sum += m\n          }\n      }\n      if (arr.isEmpty) None\n   \
    \   else if (sum == 0) Some(0)\n      else Some(sum)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0cu0v86u.scala:20:14 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            m += Math.signum(x);\n\e[31m\e[31m   |\e\
    [0m            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean Int.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660013414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldRight(0)\
    \ { (sum, elem) => \n            sum + elem.abs.product\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyy23yoii.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            sum + elem.abs.product\n\e[31m\e[31m   |\e\
    [0m                  ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  value\
    \ product is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1660013414
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if(arr.isEmpty)\n\
    \            None\n        else\n            Some(arr.map(x => math.abs(x)).product)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfce04rm3.scala:22)\n\tat Problem.main(tmpfce04rm3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013419
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signs = arr.map(_\
    \ % 2L).sum\n        if (signs == 0) None else Some(signs * arr.map(x => x%2L).product)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp30ane4oq.scala:20)\n\tat Problem.main(tmp30ane4oq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.headOption.flatMap(x\
    \ => arr.filterNot(_ == x).map(y => x*y))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp48k2le9q.scala:16:61\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        arr.headOption.flatMap(\e\
    [36mx\e[0m => arr.filterNot(_ == x).map(\e[36my\e[0m => x*y))\n\e[31m\e[31m  \
    \ |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Found:    \e[1m\e[31mList\e\
    [0m[Long]\n\e[31m   |\e[0m                                    Required: \e[1m\e\
    [32mOption\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def sign(x: Long)\
    \ = (x < 0l) ? -1 : 1\n        def mag(x: Long) = (x * x).abs()\n        def prodSign(x:\
    \ Long) = (sign(x) * (mag(x) + x.toLong)).abs()\n        val n = arr.length\n\
    \        if (n <= 0) {\n            None\n        } else {\n            val signs\
    \ = arr.map( x => sign(x) * sign(x) )\n            val signAndMags = signs zip\
    \ arr.map(mag)\n            val prodSigns = signAndMags map (x => prod(x))\n \
    \           val prodSignAndMags = prodSigns zip signAndMags\n            prodSignAndMags.reduceLeft\
    \ { case (a, b) => a * b}\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjhzd0y5a.scala:16:37 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mdef\e[0m \e[36msign\e[0m(\e[36mx\e[0m:\
    \ \e[35mLong\e[0m) = (x < \e[31m0l\e[0m) ? -\e[31m1\e[0m : \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                        value ? is not a member of Boolean\n\e[31m\e[31m-- [E050]\
    \ Type Error: /tmp/tmpjhzd0y5a.scala:17:35 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mdef\e[0m \e[36mmag\e[0m(\e[36mx\e[0m: \e[35mLong\e\
    [0m) = (x * x).abs()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   \e[33mmethod\e[0m \e[35mabs\e[0m in \e\
    [33mclass\e[0m \e[35mRichLong\e[0m does not take parameters\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpjhzd0y5a.scala:25:50 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mprodSigns\e[0m = signAndMags\
    \ map (\e[36mx\e[0m => prod(x))\n\e[31m\e[31m   |\e[0m                       \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                           Not found: prod\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjhzd0y5a.scala:27:58 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            prodSignAndMags.reduceLeft { \e[33mcase\e\
    [0m (a, b) => a * b}\n\e[31m\e[31m   |\e[0m                                  \
    \                      ^^^\e[0m\n\e[31m   |\e[0mvalue * is not a member of (Nothing,\
    \ (Int, Nothing)), but could be made available as an extension method.\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ None\n        else {\n            val arr = arr.sortBy(math.signum).reverse\n\
    \            val res = arr(0)\n            for (i <- arr.indices) {\n        \
    \        if (arr(i) < 0) {\n                    res * -1\n                } else\
    \ {\n                    res\n                }\n            }\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpue68ww7n.scala:18:22 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(math.signum).reverse\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013415
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.isEmpty)\
    \ {\n            None\n        } else {\n            val signs = arr.map( x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n            val mags = arr.map(Math.abs)\n\
    \            val product = signs.reduceLeft(_ * _)\n            Some(mags.sum\
    \ * product)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1qv9brj9.scala:26)\n\tat Problem.main(tmp1qv9brj9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def sign(x :\
    \ Long) : Int = if (x < 0) -1 else if (x > 0) 1 else 0\n        val product =\
    \ arr.foldLeft(1L)(_ * _)\n        arr.map(x => (sign(x) * x).asInstanceOf[Long]).map(product\
    \ * _).sum\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzut677bb.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        arr.map(\e[36mx\e[0m\
    \ => (sign(x) * x).asInstanceOf[\e[35mLong\e[0m]).map(product * _).sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m        Required: Option[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        if (arr.length\
    \ == 0)\n            Some(0l)\n        else {\n            val prod = 0\n    \
    \        val signs = arr.map(x => if (x > 0) -1 else if (x < 0) 1 else 0)\n  \
    \          val product = signs.foldLeft(1l)(_ * _)\n            val result = product.map{\
    \ x => (x / product) * prod }\n            Some(result)\n        }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9_zgj99y.scala:22:33 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = product.map{\
    \ \e[36mx\e[0m => (x / product) * prod }\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value map\
    \ is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        arr.foldLeft(0l){\n\
    \            case (acc, elem) => acc + Math.signum(elem) * elem\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp56jpoqqj.scala:17:32\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m (acc,\
    \ elem) => acc + Math.signum(elem) * elem\n\e[31m\e[31m   |\e[0m             \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                           Found:    Float\n\e[31m   |\e[0m                 \
    \               Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val arr = arr.toVector\n\
    \        val result = arr.map{ x =>\n            val sign = x * x.signum\n   \
    \         sign * math.abs(x)\n        }.reduce((x, y) => x * y)\n        arr.size\
    \ > 0 match {\n            case true => Some(result.toLong)\n            case\
    \ _ => None\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoa75lbzi.scala:16:18 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toVector\n\
    \e[31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m               \
    \   Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013417
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // use immutable\
    \ collections\n        var res : Option[Long] = None\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        // sum of the magnitudes\
    \ of numbers in the list\n        var sum : Long = arr.map(_ => 0).reduceLeft(_\
    \ + _)\n        // products of signs in the list\n        var product : Long =\
    \ signs.reduce(_ * _)\n        // iterate over the elements of the list to calculate\
    \ the magnitudes of numbers in the list\n        for (v <- arr)\n            //\
    \ add the magnitude of the number multiplied by the sign of the number\n     \
    \       sum += v * (signs.lastOption.getOrElse(0) * product)\n        // set res\
    \ to None if the list has no elements\n        if (arr.isEmpty) None else res.set(sum)\n\
    \        // return result if at least one number in the list has a non-zero magnitude\n\
    \        if (res.isDefined) res.get else None\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3btxrswo.scala:28:39 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mif\e[0m (arr.isEmpty) None \e[33melse\e\
    [0m res.set(sum)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue set is not a member of Option[Long] - did you mean Option[Long].get?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3btxrswo.scala:30:31 --------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mif\e[0m (res.isDefined) res.get \e[33melse\e\
    [0m None\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    Long\n\e[31m   |\e[0m         \
    \                  Required: Option[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        var sum = 0l\n\
    \        var sign = 1\n        arr.foreach(a => {\n            val s = a.toInt\n\
    \            sum += sign * s\n            sign = -sign\n        })\n        if\
    \ (arr.isEmpty) None else Some(Math.pow(sum, arr.size.toDouble))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong,\
    \ 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe5we75p1.scala:23:48\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ None \e[33melse\e[0m Some(Math.pow(sum, arr.size.toDouble))\n\e[31m\e[31m  \
    \ |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Found:    Double\n\
    \e[31m   |\e[0m                                        Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n      arr.foldLeft(0l){\n\
    \        (sum, value) => {\n          val product = value * (if(value < 0L) -1L\
    \ else 1L)\n          sum + math.abs(product)\n        }\n      }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo1b7tvdy.scala:16:22\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m      arr.foldLeft(\e[31m0l\e\
    [0m){\n\e[31m\e[31m   |\e[0m      ^\e[0m\n\e[31m   |\e[0m      Found:    Long\n\
    \e[31m   |\e[0m      Required: Option[Long]\n\e[31m17 |\e[0m        (\e[36msum\e\
    [0m, \e[36mvalue\e[0m) => {\n\e[31m18 |\e[0m          \e[33mval\e[0m \e[36mproduct\e\
    [0m = value * (\e[33mif\e[0m(value < \e[31m0L\e[0m) -\e[31m1L\e[0m \e[33melse\e\
    [0m \e[31m1L\e[0m)\n\e[31m19 |\e[0m          sum + math.abs(product)\n\e[31m20\
    \ |\e[0m        }\n\e[31m21 |\e[0m      }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013423
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        // init result\
    \ and sign counter\n        var res = 0l\n        var sign = 1l\n\n        //\
    \ for each element of arr do something\n        for (e <- arr) {\n           \
    \ if (e < 0) {\n                sign = sign * -1\n            }\n            res\
    \ += e * sign\n        }\n        // return result\n        if (res != 0l) {\n\
    \            Some(res)\n        } else {\n            None\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
    \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n \
    \   assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp40vhl9js.scala:35)\n\tat Problem.main(tmp40vhl9js.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        def sign(x: Long):\
    \ Long = if (x < 0) -1 else if (x > 0l) 1 else 0\n        val s = arr.map(x =>\
    \ sign(x))\n        val m = arr.map(_.abs)\n        val p = s.product(m)\n   \
    \     val res = Some(p.sum)\n        res\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n\
    \    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong,\
    \ 1l.toLong, 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n\
    \    assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
    \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyebzp16e.scala:19:26\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mp\e\
    [0m = s.product(m)\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e\
    [31m   |\e[0m                          Found:    (m : List[Long])\n\e[31m   |\e\
    [0m                          Required: Numeric[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpyebzp16e.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = Some(p.sum)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                 value sum is not a member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660013425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list arr of integers and you need to return\n    //\
    \ sum of magnitudes of integers multiplied by product of all signs\n    // of\
    \ each number in the list, represented by 1, -1 or 0.\n    // Note: return None\
    \ for empty arr.\n    // Example:\n    // >>> prodSigns((List[Long](1l.toLong,\
    \ 2l.toLong, 2l.toLong, -4l.toLong)))\n    // 9l\n    // >>> prodSigns((List[Long](0l.toLong,\
    \ 1l.toLong)))\n    // 0l\n    // >>> prodSigns((List[Long]()))\n    // None\n\
    \    def prodSigns(arr : List[Long]) : Option[Long] = {\n        val signsMap\
    \ : Map[Long, Int] = arr.groupBy(x => (x.signum))\n        val signsList : List[Long]\
    \ = signsMap.toList.map(_._2).flatten\n        if (signsList.isEmpty) None\n \
    \       else Some(arr.map(x => x * signsMap(x)).sum.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong, 2l.toLong, 2l.toLong,\
    \ -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong, 1l.toLong))).equals(0l));\n\
    \    assert(prodSigns((List[Long](1l.toLong, 1l.toLong, 1l.toLong, 2l.toLong,\
    \ 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n    assert(prodSigns((List[Long]())).equals(None));\n\
    \    assert(prodSigns((List[Long](2l.toLong, 4l.toLong, 1l.toLong, 2l.toLong,\
    \ -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n    assert(prodSigns((List[Long](-1l.toLong,\
    \ 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9cpvtkmn.scala:16:51\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36msignsMap\e\
    [0m : \e[35mMap\e[0m[\e[35mLong\e[0m, \e[35mInt\e[0m] = arr.groupBy(\e[36mx\e\
    [0m => (x.signum))\n\e[31m\e[31m   |\e[0m                                    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \       Found:    Map[Int, List[Long]]\n\e[31m   |\e[0m                      \
    \       Required: collection.mutable.Map[Long, Int]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmp9cpvtkmn.scala:17:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36msignsList\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = signsMap.toList.map(_._2).flatten\n\e[31m\e[31m   |\e[0m\
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0mno given instance of type Int => IterableOnce[B] was found for\
    \ parameter toIterableOnce of \e[33mmethod\e[0m \e[35mflatten\e[0m in \e[33mtrait\e\
    [0m \e[35mStrictOptimizedIterableOps\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:\
    \    B is a type variable with constraint <: Long\n2 errors found\n"
  stdout: ''
  timestamp: 1660013425
