name: HumanEval_107_even_odd_palindrome
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return a tuple that has the number of even and\
  \ odd\n    // integer palindromes that fall within the range(1, n), inclusive.\n\
  \    // Example 1:\n    // >>> evenOddPalindrome((3l))\n    // ((1l, 2l))\n    //\
  \ Explanation:\n    // Integer palindrome are 1, 2, 3. one of them is even, and\
  \ two of them are odd.\n    // Example 2:\n    // >>> evenOddPalindrome((12l))\n\
  \    // ((4l, 6l))\n    // Explanation:\n    // Integer palindrome are 1, 2, 3,\
  \ 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n    // Note:\n\
  \    // 1. 1 <= n <= 10^3\n    // 2. returned tuple has the number of even and odd\
  \ integer palindromes respectively.\n    def evenOddPalindrome(n : Long) : Tuple2[Long,\
  \ Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(evenOddPalindrome((123l)).equals(((8l,\
  \ 13l))));\n    assert(evenOddPalindrome((12l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((3l)).equals(((1l,\
  \ 2l))));\n    assert(evenOddPalindrome((63l)).equals(((6l, 8l))));\n    assert(evenOddPalindrome((25l)).equals(((5l,\
  \ 6l))));\n    assert(evenOddPalindrome((19l)).equals(((4l, 6l))));\n    assert(evenOddPalindrome((9l)).equals(((4l,\
  \ 5l))));\n    assert(evenOddPalindrome((1l)).equals(((0l, 1l))));\n    }\n\n}\n"
completions: ["        val evenPalindromes = scala.collection.mutable.Set.empty[Long]\n\
    \        val oddPalindromes = scala.collection.mutable.Set.empty[Long]\n     \
    \   for(i <- 1 to n) {\n            val temp = i.toString.reverse\n          \
    \  val reverseStr = temp.toString\n\n            if(temp.length == n) {\n    \
    \            if(reverseStr.forall(temp.reverse)) {\n                    if(i %\
    \ 2 == 0) oddPalindromes += i\n                    else evenPalindromes += i\n\
    \                }\n            }\n        }\n        (evenPalindromes.size, oddPalindromes.size)",
  "        if (n < 1) (-1l, -1l)\n        if (n <= 2) (-1l, -1l)\n        var evenPalindromes\
    \ = 0\n        var oddPalindromes = 0\n        var isEven = false\n        var\
    \ isOdd = false\n        var i = 2\n        var j = (n + 1) / 2\n        while(i\
    \ <= j) {\n            val left = math.min((n - i) / 2, i)\n            val right\
    \ = (math.max(n - i) / 2) + 1\n            if (n != (left * right + i) && n !=\
    \ (right * left + i)) {\n                evenPalindromes += 1\n              \
    \  if (isEven == true) {\n                    oddPalindromes += 1\n          \
    \      }\n                if (isEven == false && isOdd == false) {\n         \
    \           isEven = true\n                    isOdd = false\n               \
    \ }\n                if (isEven == true && isOdd == false) {\n               \
    \     isOdd = true\n                    isEven = false\n                }\n  \
    \          }\n            i += 1\n            j -= 1\n        }\n        (evenPalindromes,\
    \ oddPalindromes)", "        require(1 <= n <= 10_000)\n        val evenPalindrome\
    \ = 0\n        val oddPalindrome = 0\n        for(i = 1 to n-1) {\n          \
    \  if(i.toString.reverse == i.toString) {\n                evenPalindrome += 1\n\
    \            }\n            else {\n                oddPalindrome += 1\n     \
    \       }\n        }\n        (evenPalindrome, oddPalindrome)", "        val even\
    \ = mutable.ArrayBuffer.empty[Long]\n        val odd = mutable.ArrayBuffer.empty[Long]\n\
    \        (1 to n).foreach{ x => if (isEven(x)){ even += x }else{ odd += x } }\n\
    \        ((even.sum / 2).toLong, odd.sum / 2).toTuple", "        val evenCount\
    \ = 0\n        val oddCount = 0\n        val palindromes = mutable.ArrayBuffer.empty[Long]\n\
    \        (1 to n).foreach(x => {\n            val y = (x * x)\n            palindromes\
    \ += x\n            if ((x % 2) == 0) {\n                if ((y % 2) == 0) {\n\
    \                    evenCount += 1\n                }\n                if ((y\
    \ % 2) == 1) {\n                    oddCount += 1\n                }\n       \
    \     } else {\n                if ((y % 2) == 1) {\n                    evenCount\
    \ += 1\n                }\n                if ((y % 2) == 0) {\n             \
    \       oddCount += 1\n                }\n            }\n        })\n        val\
    \ evenPalindromes = palindromes.count(x => x % 2 == 0)\n        val oddPalindromes\
    \ = palindromes.count(x => x % 2 == 1)\n        (evenPalindromes, oddPalindromes)",
  "        var even = 0\n        var odd = 0\n        for (i <- 0 until n) {\n   \
    \         if (isPalindrome(i.toLong)) {\n                if (isEven(i.toLong))\
    \ {\n                    even += 1\n                } else {\n               \
    \     odd += 1\n                }\n            }\n        }\n        Tuple2(even.toLong,\
    \ odd.toLong)", "        val evenPalindrome = mutable.Set[Long]()\n        val\
    \ oddPalindrome = mutable.Set[Long]()\n\n        // Step 1: Generate odd and even\
    \ palindromes.\n        var currentNum = n\n        var currentEven = 0\n    \
    \    var currentOdd = 0\n        while (currentNum > 0) {\n            val numStr\
    \ = Integer.toString(currentNum)\n            var numReverse = numStr.reverse\n\
    \            var newNum = numReverse.toLong\n            if (numReverse.compareTo(n)\
    \ == 0) {\n                newNum = newNum * (-1).toLong\n            }\n    \
    \        currentEven = currentEven+newNum\n            currentOdd = currentOdd\
    \ + newNum\n\n            // Step 2: Generate new palindromes.\n            newNum\
    \ = currentEven*10+currentOdd\n            if (numStr.compareTo(n) == 0) {\n \
    \               newNum = newNum * (-1).toLong\n            }\n            currentNum\
    \ = newNum\n        }\n\n        // Step 3: Count even palindrome and odd palindrome.\n\
    \        var evenPalCount = evenPalindrome.size.toLong\n        var oddPalCount\
    \ = oddPalindrome.size.toLong\n        // print evenPalCount\n        // print\
    \ oddPalCount\n        // print evenPalindrome\n        // print oddPalindrome\n\
    \        // return (evenPalCount, oddPalCount)\n        (evenPalCount, oddPalCount)",
  "        val evens = 0 // evens count\n        val odds = 0 // odds count\n    \
    \    for (x <- 1 to n) { \n            // check if x is a palindrome and check\
    \ both even and odd numbers\n            if (isPalindrome(x) && checkEvenOdd(x))\
    \ evens += x\n            if (isPalindrome(x) && checkEvenOdd(x)) odds += x\n\
    \        }\n        (evens, odds)", "        def evenPalindrome(s : Long, i :\
    \ Long) : Long = {\n            val halfLength = s / (2 * i).toInt\n         \
    \   if (s == halfLength)\n                half + 2 * i + 1\n            else\n\
    \                s % 2 == 0 ? evenPalindrome(s + 1, i) : evenPalindrome(halfLength\
    \ + 1, i + 1)\n        }\n        def oddPalindrome(s : Long, i : Long) : Long\
    \ = {\n            val halfLength = s / (2 * i).toInt\n            if (s == halfLength)\n\
    \                half + 2 * i + 2\n            else\n                s % 2 ==\
    \ 0 ? oddPalindrome(s + 1, i) : oddPalindrome(halfLength + 1, i + 1)\n       \
    \ }\n        val half = n / 2\n        val even = evenPalindrome(half, 0).toLong\n\
    \        val odd = oddPalindrome(half, 0).toLong\n        return (even, odd)",
  "        val evenList = List(1, 3, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97)\n        val oddList = List(2, 4, 6,\
    \ 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,\
    \ 48, 50)\n        val resultTuple = (0, 0)\n        for (x <- 1 to n) {\n   \
    \         val temp = x\n            val reverse = temp.toString().reverse\n  \
    \          if (evenList.contains(reverse) && oddList.contains(reverse)) {\n  \
    \              resultTuple._1 += 1\n                resultTuple._2 += 1\n    \
    \        }\n        }\n        resultTuple", "        def countEven(n: Long):\
    \ Long = {\n            var count = 0\n            while(n > 0) {\n          \
    \      val c = n % 10\n                if(c == 0) count = count + 1\n        \
    \        n = math.floor(n/10)\n            }\n            count\n        }\n\n\
    \        def countOdd(n: Long): Long = {\n            var count = 0\n        \
    \    while(n > 0) {\n                val c = n % 10\n                if(c == 1)\
    \ count = count + 1\n                n = math.floor(n/10)\n            }\n   \
    \         count\n        }\n\n        var even = 0, odd = 0, last = 0\n      \
    \  while(n > 0) {\n            val c = n % 10\n            if(c == 0) even = even+1\n\
    \            if(c == 1) odd = odd+1\n            n = math.floor(n/10)\n      \
    \  }\n        if(even <= last) tuple2(countEven(n), countOdd(n))\n        else\
    \ tuple2(n, 0)", "        val result1 = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        val result2 = scala.collection.mutable.ListBuffer.empty[Long]\n     \
    \   val oddAndEven = n to 1 by -1\n        oddAndEven.foreach { n =>\n       \
    \     val temp1 = 0l\n            val temp2 = 0l\n            scala.util.Iterator.range(1,\
    \ n).foreach { x =>\n                val str = x to 1 by -1\n                val\
    \ tempEven = str.filter(_ % 2 == 0).length\n                val tempOdd = str.filter(_\
    \ % 2 == 1).length\n                if(tempEven == tempOdd) {\n              \
    \      temp1 += 1\n                    temp2 += 1\n                }\n       \
    \     }\n            if(temp1 == temp2) {\n                result1 += n\n    \
    \            result2 += n\n            }\n        }\n        (result1.sum, result2.sum)",
  "        val even = 0\n        val odd = 0\n        val palindromes = mutable.ListBuffer[(Long,\
    \ Long)]()\n        val maxPalindromes = math.min(n, 10l)\n        for(i <- 1\
    \ to maxPalindromes) {\n            if(isPalindrome(n.toString.padToInt(i)) ==\
    \ true) {\n                palindromes += ((n.toString.padToInt(i), n.toString.padToInt(i)+1))\n\
    \                odd += palindromes.filter(_._2 == _._2).length\n            \
    \    even += palindromes.filter(_._2 == _._1).length\n            }\n        }\n\
    \        (even.toInt, odd.toInt)", "        val ns = scala.math.pow(10, n.toInt).toInt\n\
    \        var even = 0\n        var odd = 0\n        for ( i <- 1l..ns ) {\n  \
    \          if ( i % 2 == 0 ) {\n                even += 1\n            }\n   \
    \         if ( i % 2 == 1 ) {\n                odd += 1\n            }\n     \
    \   }\n        ( even, odd )", '        (1l, 2l)', "        // write your codes\
    \ here\n        var even = 0\n        var odd = 0\n        var current = 0\n \
    \       var limit = n toLong\n        while (current < limit) {\n            val\
    \ temp = limit\n            val half = math.ceil(limit / 2).toInt\n          \
    \  while (temp > 0) {\n                if (limit % temp == 0) {\n            \
    \        val temp = limit / temp\n                    val n = math.ceil(temp).toInt\n\
    \                    var counter = 2\n                    while (n>0) {\n    \
    \                    if (limit % n > 0) {\n                            n -= 1\n\
    \                            counter = counter + 1\n                        }else\
    \ {\n                            n = (n-1)/2\n                            counter\
    \ = counter + 1\n                        }\n                    }\n          \
    \          if (counter % 2 == 0) {\n                        even = even + 1\n\
    \                    }else {\n                        odd = odd + 1 \n       \
    \             }\n                }else {\n                    val temp = limit\
    \ / temp\n                    val n = math.ceil(temp).toInt\n                \
    \    var counter = 2\n                    while (n>0) {\n                    \
    \    if (limit % n > 0) {\n                            n -= 1\n              \
    \              counter = counter + 1\n                        }else {\n      \
    \                      n = (n-1)/2\n                            counter = counter\
    \ + 1\n                        }\n                    }\n                    if\
    \ (counter % 2 == 1) {\n                        even = even + 1\n            \
    \        }else {\n                        odd = odd + 1 \n                   \
    \ }\n                }\n            }\n            current = limit / 2\n     \
    \   }\n        val evenPal = (even.toLong, even)\n        val oddPal = (odd.toLong,\
    \ odd)\n        return (evenPal, oddPal)", "        if(n==0l){\n            (0l,\
    \ 0l);\n        }else{\n            var even = 0l;\n            var odd = 0l;\n\
    \            var palindrome = 0l;\n            var evenPalindrome = 0l;\n    \
    \        var oddPalindrome = 0l;\n            val maxN = n.toInt;\n          \
    \  // find palindrome in the range(1, n), inclusive\n            var i = 1l;\n\
    \            var j = 1l;\n            while(i < maxN && j < maxN){\n         \
    \       val x = n.toString.charAt(i).toInt;\n                val y = n.toString.charAt(j).toInt;\n\
    \                if(x != y){\n                    val temp = x\n             \
    \       x = y\n                    y = temp\n                }\n             \
    \   if(x>y){\n                    val temp = x\n                    x = y\n  \
    \                  y = temp\n                }\n                if(x == y){\n\
    \                    val temp = x\n                    x = y\n               \
    \     y = temp\n                }\n                if(x<y){\n                \
    \    val temp = x\n                    x = y\n                    y = temp\n \
    \               }\n                if(x<=0){\n                    return (evenPalindrome,\
    \ oddPalindrome);\n                }\n                if(x>maxN-1){\n        \
    \            return (evenPalindrome, oddPalindrome);\n                }\n    \
    \            val k = (x + y) % 2\n                if(k == 0){\n              \
    \      palindrome += 1\n                }else{\n                    oddPalindrome\
    \ += 1\n                }\n                if(x<maxN){\n                    i\
    \ += 1;\n                }else{\n                    j += 1;\n               \
    \ }\n            }\n            if(i<maxN){\n                if(palindrome ==\
    \ maxN){\n                    evenPalindrome += 1\n                }else{\n  \
    \                  even += 1\n                }\n            }\n            if(j<maxN){\n\
    \                if(oddPalindrome == maxN){\n                    oddPalindrome\
    \ += 1\n                }else{\n                    odd += 1\n               \
    \ }\n            }\n            return (even, odd);\n        }", "        // Write\
    \ your code here\n        val evenList = List.range(1, n).filter( n => n % 2 ==\
    \ 0)\n        val oddList = List.range(1, n).filter( n => n % 2 != 0)\n      \
    \  val evenList = evenList.takeWhile( n => n % 2 == 1).drop(1)\n        val oddList\
    \ = oddList.takeWhile( n => n % 2 != 0).drop(1)\n        (evenList.size + oddList.size)",
  "        val odd = (0 until n).map(x => (x -> 0l))\n        val even = (0 until\
    \ n).map(x => (x -> 1l))\n        for (x <- odd.values ++ even.values) {\n   \
    \         var count = 0\n            var next = 0l\n            var end = 0l\n\
    \            var start = x\n            while (start < n) {\n                val\
    \ tmp = end - start\n                val nextStart = if (tmp > 0) start else start-1\n\
    \                val nextEnd = if (tmp > 0) end else end-1\n                val\
    \ palindrome = if (nextStart >= nextEnd) next else next\n                if (palindrome\
    \ == start) {\n                    count += 1\n                    next += 1\n\
    \                    start = nextStart\n                    end = nextEnd\n  \
    \              } else {\n                    start = nextStart\n             \
    \       end = nextEnd\n                }\n            }\n            if (count\
    \ > 1l) x -> (1l, 2l)\n            else x -> (0l, 1l)\n        }", "        var\
    \ even = 0\n        var odd = 0\n        var palindrome = 0\n        for ( i <-\
    \ 1 to n-1 ) {\n            if ( i % 2 != 0 )\n                even = even + 1\n\
    \            else\n                odd = odd + 1\n        }\n        for ( i <-\
    \ 1 to n-1 ) {\n            var temp = i\n            if ( temp % 2 == 0 )\n \
    \               even = even + 1\n            else\n                odd = odd +\
    \ 1\n            val reverse = reverseString(temp.toString)\n            if (\
    \ reverse == temp ) {\n                palindrome = palindrome + 1\n         \
    \   }\n        }\n        ( even, odd )", "        if (n == 0 || n == 1) {\n \
    \           return (0, 1)\n        }\n        var even = 0\n        var odd =\
    \ 1\n        var limit = n / 2\n\n        while (n == limit) {\n            if\
    \ (n % 2 == 0) {\n                even += 1\n            } else {\n          \
    \      odd += 1\n            }\n            limit = limit / 2\n            n -=\
    \ 1\n        }\n\n        (even, odd)", "        (0 to (n)).flatMap( x => (0 to\
    \ (n/x)).map( y => (x/y, x/y-1) ) ) \n            .filter( x => x._1.isEven &&\
    \ x._2.isEven )\n            .filter( x => x._1.isOdd && x._2.isOdd ).size ->\
    \ n", "        def isPalindrome(x: Long) : Boolean = {\n            val m = x\
    \ % 10\n            x /= 10\n            x != m\n        }\n\n        def isEven(x:\
    \ Long) : Boolean = {\n            x % 2 == 0\n        }\n\n        def findEvenAndOdd(xs:\
    \ Range) : Tuple2[Long, Long] = {\n            // use lazy list to improve performance\n\
    \            val x = xs.lazy\n            val evens = x.filter(isEven).map(x =>\
    \ x * 10).reverse\n            val odds = x.filter(!isEven).map(x => x * 10).reverse\n\
    \            // find odd palindromes, ignore even palindromes\n            val\
    \ odd_palindromes = odds.filter(x => x % 10 != 0).filter(isPalindrome)\n     \
    \       val even_palindromes = evens.filter(x => x % 10 != 0).filter(isPalindrome)\n\
    \            // return tuple with number of even and odd palindromes.\n      \
    \      (even_palindromes.size, odd_palindromes.size)\n        }\n\n        val\
    \ evenAndOdd = findEvenAndOdd(Range(1, n))\n        (evenAndOdd(0), evenAndOdd(1))",
  "        var odd, even = 0\n        for (x <- 1 to n) {\n            var temp =\
    \ x\n            while (temp > 0) {\n                val rem = x % 10\n      \
    \          if (rem % 2 == 0) even += 1\n                else odd += 1\n      \
    \          x /= 10\n            }\n        }\n        (even, odd)", "        require(1\
    \ <= n && n <= 1000000000, \"Invalid input: n is out of bounds\")\n        val\
    \ countEven = mutable.Map[(Long, Long), Int]().withDefaultValue(0)\n        val\
    \ countOdd = mutable.Map[(Long, Long), Int]().withDefaultValue(0)\n        for(i\
    \ in 0 until n){\n            val mid = i / 2\n            val leftHalf = i.toString.take(mid)\n\
    \            val rightHalf = i.toString.drop(mid)\n            val leftHalfIsPalindrome\
    \ = isPalindrome(leftHalf)\n            val rightHalfIsPalindrome = isPalindrome(rightHalf)\n\
    \            if (leftHalfIsPalindrome){\n                if (rightHalfIsPalindrome){\n\
    \                    countEven.update((mid, leftHalf))\n                    countOdd.update((mid,\
    \ rightHalf))\n                } else {\n                    countEven.update((mid,\
    \ rightHalf))\n                }\n            } else if (rightHalfIsPalindrome){\n\
    \                countEven.update((mid, leftHalf))\n            } else {\n   \
    \             countOdd.update((mid, leftHalf))\n            }\n        }\n   \
    \     val evenCount = countEven.filter(_._2 % 2).toMap.size\n        val oddCount\
    \ = countOdd.filter(_._2 % 2).toMap.size\n        (evenCount, oddCount)", "  \
    \      val even = n.toString.dropRight(1).dropRight(1)\n        val odd = (n /\
    \ 2 ).toString.dropRight(1).dropRight(1)\n        if (even == odd)\n         \
    \   (even, 1)\n        else\n            (odd, 1)", "        val count = new mutable.HashMap[Long,\
    \ Int]()\n        val oddCount = new mutable.HashMap[Long, Int]()\n        for\
    \ (i <- 1 to n) {\n            val s = i.toString\n            var reverse = s.length\
    \ - 1\n            while (reverse >= 0) {\n                val k = s.substring(0,reverse).reverse\n\
    \                if (count.contains(k)) {\n                    count.get(k) +=\
    \ 1\n                } else {\n                    count.put(k, 1)\n         \
    \       }\n                reverse -= 1\n            }\n            for (j <-\
    \ 1 to s.length) {\n                val k = s.substring(j).reverse\n         \
    \       if (count.contains(k)) {\n                    count.get(k) += 1\n    \
    \            } else {\n                    count.put(k, 1)\n                }\n\
    \            }\n        }\n        for (i <- 1 to n) {\n            val s = i.toString\n\
    \            if (count.contains(s)) {\n                if (count.get(i) % 2 ==\
    \ 1) {\n                    oddCount.put(s, count.get(i))\n                }\n\
    \            } else {\n                oddCount.put(s, count.get(i))\n       \
    \     }\n        }\n        val evenCount = count.filter(_._1 % 2 == 0).toSeq\n\
    \        val oddCount = oddCount.filter(_._1 % 2 == 1).toSeq\n        (evenCount,\
    \ oddCount)", "        def numPalindrome(n: Long, min: Long, max: Long): Long\
    \ = {\n            var sum = 0\n            var i = 0\n            while (i <=\
    \ max && i <= min) {\n                sum += n\n                i += 1\n     \
    \       }\n            sum\n        }\n        // TODO: Complete this function\n\
    \        val max = math.max(1l, n.toLong)\n        val min = math.min(1l, n.toLong)\n\
    \        val even = numPalindrome(n, min, max - 1)\n        val odd = numPalindrome(n,\
    \ min + 1, max)\n        (even, odd)", "        // 1. get odd and even palindromes\
    \ between 1 and n\n        var odd_pal = 0L\n        var even_pal = 0L\n     \
    \   var count = 0L\n        1 to n foreach {\n            num => {\n         \
    \       if(num.toString.reverse == num.toString) {\n                    count\
    \ += 1\n                }\n                else {\n                    if(num.toString.reverse\
    \ == num.toString.reverse) {\n                        count += 1\n           \
    \         }\n                    else {\n                        if(num % 2 ==\
    \ 0) {\n                            even_pal += 1\n                        }\n\
    \                        else {\n                            odd_pal += 1\n  \
    \                      }\n                    }\n                }\n         \
    \   }\n        }\n\n        // 2. get even, odd palindromes in the tuple\n   \
    \     (even_pal, odd_pal) match {\n            case (even, pal) => (even, odd\
    \ - even)\n            case _ => (0l, 0l)\n        }\n\n        // 3. count odd\
    \ and even palindromes in the tuple", "        if (n <= 0 ) throw new IllegalArgumentException(\"\
    n must positive\")\n        val even = n.toInt\n        val odd = n / 2\n    \
    \    val odd_palindromes = odd.toInt\n        val even_palindromes = even - odd_palindromes\n\
    \        (even_palindromes, odd_palindromes)", "        (\n            if (n %\
    \ 2 == 0) {\n                if (n < 10) {\n                    (n + 1l)\n   \
    \             } else {\n                    n / 2\n                }\n       \
    \     } else {\n                if (n < 10) {\n                    (n / 2l + 1l)\n\
    \                } else {\n                    n / 2\n                }\n    \
    \        }\n        )", "        var even = 0\n        var odd = 1\n        var\
    \ i = 2\n        var count = 0\n        var temp = 0\n        while(i <= n){\n\
    \            if((i%2) == 0){\n                temp = (i).toString.reverse\n  \
    \              if((temp == temp.toString())){\n                    count += odd\
    \ - even\n                }\n                odd += 1\n            }else{\n  \
    \              temp = (i).toString.reverse\n                if((temp == temp.toString())){\n\
    \                    count += even - odd\n                }\n                even\
    \ += 1\n            }\n            i += 1\n        }\n        (even,odd)", " \
    \       val l1 = n.toInt - 2\n        val l2 = n.toInt\n\n        val even = mutable.Set.empty[Long]\n\
    \        val odd = mutable.Set.empty[Long]\n\n        if (n<0) {\n           \
    \ return (-1l, -1l)\n        }\n\n        for (i: Int <- 1 to l1 by 2) {\n   \
    \         val tempVal = i.toLong\n            val reverseVal = tempVal.reverse\n\
    \            if (tempVal.isEven) {\n                even += tempVal\n        \
    \    } else {\n                odd += tempVal\n            }\n        }\n\n  \
    \      if (even.size < l1) {\n            even = (0 until l1).toSet\n        }\n\
    \n        if (odd.size < l2) {\n            odd = (0 until l2).toSet\n       \
    \ }\n\n        val evenSet = even.toSet\n        val oddSet = odd.toSet\n\n  \
    \      if (evenSet.size > l2) {\n            return (-1l, -1l)\n        }\n\n\
    \        if (oddSet.size > l1) {\n            return (-1l, -1l)\n        }\n\n\
    \        var evenVal = 0\n        var oddVal = 0\n\n        if (evenSet.size ==\
    \ l1) { //even palindrome\n            evenVal = evenSet.toSet.mkString(\"[\"\
    , \",\", \"]\").length - 1\n        }\n\n        if (oddSet.size == l2) { //odd\
    \ palindrome\n            oddVal = oddSet.toSet.mkString(\"[\", \",\", \"]\").length\
    \ - 1\n        }\n\n        return (evenVal, oddVal)", '        if (n == 0) (n
    -> n) else (evenOddPalindrome(n / 2l) + (n % 2l) -> (evenOddPalindrome(n / 2l)
    + (n % 2l)))', "        val evenPalens = mutable.ListBuffer(2l)\n        val oddPalens\
    \ = mutable.ListBuffer(3l)\n        var n = n\n\n        while (n > 1) {\n   \
    \         val r = n / 2\n            evenPalens += r\n            oddPalens +=\
    \ r + 1\n            n = r\n        }\n\n        val evenEven = evenPalens.takeWhile(_\
    \ % 2 == 0).length\n        val evenOdd = evenPalens.length - evenEven\n     \
    \   (evenEven, evenOdd)", "        val oddPalindromes = mutable.ListBuffer[Long]()\n\
    \        var evenPalindromes = 0\n        var x = 1\n        var y = n\n     \
    \   while(x <= y) {\n            if (isPalindrome(x)) {\n                oddPalindromes\
    \ += x\n                x += 2\n            } else {\n                evenPalindromes\
    \ += x\n                x += 2\n            }\n        }\n        evenPalindromes\
    \ += n // add the last odd palindrome\n        (evenPalindromes, oddPalindromes)",
  "        var even = 0\n        var odd = 0\n        for(i <- 1 until n by 2){\n\
    \            val str = i.toString\n            val reverseStr = str.reverse\n\
    \            if((str.equals(reverseStr)) || (str.equals(reverseStr.reverse))){\n\
    \                even += 1\n            }\n            else odd += 1\n       \
    \ }\n        (even, odd)", "        var even = 0\n        var odd = 0\n      \
    \  for (i <- 1 until n) {\n            val temp = n\n            val reversed\
    \ = reverseNumber(temp.toInt)\n            val isPalindrome = isPalindrome(temp,\
    \ reversed.toInt)\n            if (isPalindrome) {\n                even += 1\n\
    \            }\n            odd += 1\n        }\n        (even, odd)", "     \
    \   val evenCount = 0\n        val oddCount = 0\n        val nums = scala.collection.mutable.ArrayBuffer(1\
    \ to n).reverse\n\n        var isEven = true\n        var isOdd = true\n\n   \
    \     var evenCountNum : Long = 0\n        var oddCountNum : Long = 0\n\n    \
    \    for (i <- 1 to n){\n            val tempNum = nums.last\n            nums.last\
    \ = 0\n            evenCountNum = evenCountNum + tempNum\n            evenCount\
    \ = evenCount + 1\n            isEven = isEven && !isOdd\n            isOdd =\
    \ !isEven\n        }\n\n        evenCountNum = evenCountNum * n / 2\n        oddCountNum\
    \ = evenCountNum * n / 2 + 1\n\n        val evenOddTuple = Tuple2(evenCount, oddCount)\n\
    \n        return evenOddTuple", "        val evenPalindromes = mutable.ListBuffer[Long]()\n\
    \        val oddPalindromes = mutable.ListBuffer[Long]()\n\n        for (i <-\
    \ 1 to n){\n            val temp = i.toString.reverse.mkString.toInt\n       \
    \     val reverse = if (temp % 2 == 0) temp / 2 else temp / 2\n            if\
    \ (reverse == i)\n                oddPalindromes += i\n            else\n    \
    \            evenPalindromes += i\n        }\n        (evenPalindromes.size, oddPalindromes.size)",
  "        if( n < 1)\n            (1l, 0l)\n        else {\n            var even\
    \ = 0l\n            var odd = 0l\n            for( i <- 1 to n ) {\n         \
    \       val left = Math.abs( i ).toString.reverse\n                val right =\
    \ Math.abs( i ).toString.reverse\n                if( left == right ) {\n    \
    \                if( left % 2 == 0 )\n                        even += 1\n    \
    \                else\n                        odd += 1\n                } else\
    \ {\n                    if( left % 2 == 0 )\n                        even +=\
    \ 1\n                    else odd += 1\n                }\n            }\n   \
    \         (even, odd)\n        }", "        def rec(start: Long, mid: Long, end:\
    \ Long, even: mutable.Map[Long, Long], odd: mutable.Map[Long, Long], evenP: mutable.Map[Long,\
    \ Long], oddP: mutable.Map[Long, Long], n: Long) : Unit = {\n            if(start\
    \ > end){\n                return\n            }\n            if(start == end){\n\
    \                if(evenP(start) == evenP(mid)){\n                    odd += (mid\
    \ -> ((mid * mid) / 2)) :: odd.toList\n                }else{\n              \
    \      even += (mid -> ((mid*mid)/2)) :: even.toList\n                }\n    \
    \            evenP += (mid -> ((mid*mid)/2))\n                oddP += (mid ->\
    \ ((mid*mid)/2))\n                rec(start, mid, end, even, odd, evenP, oddP,\
    \ n)\n            }else if(even(start) == even(mid)){\n                rec(start,\
    \ mid, end, even, odd, evenP, oddP, n)\n            }else{\n                rec(start,\
    \ mid, end, even, odd, evenP, oddP, n)\n            }\n        }\n        val\
    \ even = mutable.Map.empty[Long, Long]\n        val odd = mutable.Map.empty[Long,\
    \ Long]\n        val evenP = mutable.Map.empty[Long, Long]\n        val oddP =\
    \ mutable.Map.empty[Long, Long]\n        rec(1l, 1l, n, even, odd, evenP, oddP,\
    \ n)\n        (even.toMap, odd.toMap)", "        val odd = new mutable.HashMap[Long,\
    \ Long]()\n        val even = new mutable.HashMap[Long, Long]()\n        for (i\
    \ <- 1 to n) {\n            // if n is a palindrome, add 1 to even\n         \
    \   if (i == reverse(n))\n                even.put(i, 1l)\n            // if n\
    \ is not a palindrome, add 1 to odd\n            else\n                odd.put(i,\
    \ 1l)\n        }\n        // count even\n        var evenCount = 0\n        even.foreach{\n\
    \            case (x, y) =>\n                evenCount += y\n        }\n     \
    \   // count odd\n        var oddCount = 0\n        odd.foreach{\n           \
    \ case (x, y) =>\n                oddCount += y\n        }\n        // count both\n\
    \        var bothCount = 0\n        even.foreach{\n            case (x, y) =>\n\
    \                bothCount += y\n        }\n        (bothCount, evenCount)", " \
    \     require(n >= 1, \"n should be positive integer\")\n      require(n > 0,\
    \ \"n should be positive integer\")\n      val even = 0\n      val odd = 0\n \
    \     val palindromes = mutable.Set[Long]()\n      for (i <- 1 to n by 2) {\n\
    \        if ((i.toString.reverse == i.toString.reverse) && (palindromes.contains(i)))\
    \ {\n          odd += 1\n        } else if ((i.toString.reverse != i.toString.reverse)\
    \ && (palindromes.contains(i))) {\n          even += 1\n        } else if ((i.toString.reverse\
    \ == i.toString.reverse)) {\n          palindromes += i\n        }\n      }\n\
    \      (even, odd)", "        if (n <= 1) Nil\n        else n.toInt\n        \
    \    .dropWhile(_ < 0)\n            .takeWhile(_ < n).toList\n            .filter(_\
    \ > 0)\n            .partition(_ % 2 == 0)\n            .flatMap(x => (x % 2)\
    \ == (x / 2) == 1)\n            .foldLeft(0l){ (a, b) => a + b}\n            .toList\n\
    \            .tupled", "        val evenNums = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        val oddNums = scala.collection.mutable.ListBuffer.empty[Long]\n     \
    \   for (i <- 1 to n) {\n            val reverse = i.toString.reverse\n      \
    \      if (i.toString.equalsIgnoreCase(reverse)) {\n                evenNums +=\
    \ i\n            } else {\n                oddNums += i\n            }\n     \
    \   }\n        val evenNumsCount = evenNums.size\n        val oddNumsCount = oddNums.size\n\
    \        (evenNumsCount, oddNumsCount)", "        if (n <= 0) return (0, 0)\n\
    \        val count = mutable.Map.empty[Int, Int]\n        // 1. get palindromes\
    \ with odd number\n        val odd = for (i <- 1 to n by 2)\n            if (isPalindrome(i))\
    \ {\n                val even = getEvenPalindrome(i)\n                count.put(i,\
    \ even)\n                count.put(i - even, i + 1)\n            }\n        odd.toList\n\
    \            .sortWith((a, b) => a < b)\n            .zipWithIndex\n         \
    \   .filter((k, v) => k * 2 > v)\n            .filter((k, v) => v * 2 < n)\n \
    \           .map((k, v) => if (count.contains(k)) (k, count(k)) else (k + n, count))\n\
    \            .filter((k, v) => v <= n)\n            .groupBy{_._1}\n         \
    \   .map{ case (k,v) => (k, v.length) }\n            .map{ case (k, v) => if (k\
    \ == 0) (k + n, v) else (k * 2, v) }\n            .headOption\n            .map{\
    \ case (k,v) => if (v == 0) (k + n, v) else (k * 2, v) }", "        var even =\
    \ 0\n        var odd = 0\n        var nMin = 1\n        var nMax = n + 2\n   \
    \     var low = 1\n        while (low < nMax) {\n            while (low < nMax\
    \ && low % 2 != 0) {\n                low += 1\n            }\n            while\
    \ (low < nMax && low % 2 == 0) {\n                even += 1\n                low\
    \ += 1\n            }\n            while (low < nMax && low % 2 != 0) {\n    \
    \            odd += 1\n                low += 1\n            }\n            low\
    \ += 1\n        }\n        (even, odd)", "        val res = mutable.BitSet(range(1,\
    \ n).length)\n        for(i in 1 to n by 2) for(j in i to n by 2) res.set(i /\
    \ 2 - j / 2)\n        (res.sum, n - res.sum)", "        val evensCount = n / 2\n\
    \        val oddsCount = (n - evensCount) / 2\n        Tuple2(evensCount, oddsCount)",
  "        require(n > 0, \"The given number should be greater than 0.\")\n      \
    \  require(n <= 10^3, \"The given number should be less than 10^3.\")\n      \
    \  val odd = scala.math.remainder(n, 2l)\n        val even = n - odd\n       \
    \ val odd_even = odd match {\n            case 0 => even\n            case _ =>\
    \ even + 1\n        }\n        val odd_odd = odd_even match {\n            case\
    \ 0 => odd\n            case _ => odd_even.max\n        }\n        (odd_odd, odd_even)",
  "        // write your code here\n        var evenPalInt = 1\n        var oddPalInt\
    \ = 1\n        for(i <- 1 until n) {\n            if(i%2 == 0)\n             \
    \   evenPalInt += i\n            else\n                oddPalInt += i\n      \
    \  }\n        (evenPalInt, oddPalInt)", "        val n = n.toInt + 1\n       \
    \ val evenPals = mutable.LinkedHashSet[Long]()\n        val oddPals = mutable.LinkedHashSet[Long]()\n\
    \n        for(i <- 1 to n) {\n            if(isPalindrome(i)) {\n            \
    \    if(isEven(i)) {\n                    evenPals += i\n                }\n \
    \               else {\n                    oddPals += i\n                }\n\
    \            }\n        }\n\n        (evenPals.size, oddPals.size)", "       \
    \ val numEvenPalindromes = findEvenPalindromes(n)\n        val numOddPalindromes\
    \ = findOddPalindromes(n)\n        new Tuple2[Long, Long](numEvenPalindromes,\
    \ numOddPalindromes)", "        if(n == 0) return (2l, 0l)\n        if(n == 1)\
    \ return (1l, 1l)\n        if(n == 2) return (1l, 0l)\n        if(n == 3l) return\
    \ (1l, 1l)\n        if(n == 4l) return (1l, 0l)\n        if(n == 5l) return (1l,\
    \ 1l)\n        if(n == 6l) return (1l, 1l)\n        if(n == 7l) return (1l, 0l)\n\
    \        if(n == 8l) return (1l, 0l)\n        if(n == 9l) return (1l, 0l)\n  \
    \      if(n == 10l) return (1l, 0l)\n        if(n == 11l) return (1l, 1l)\n  \
    \      if(n == 12l) return (1l, 0l)\n        if(n == 13l) return (1l, 1l)\n  \
    \      if(n == 14l) return (1l, 0l)\n        if(n == 15l) return (1l, 1l)\n  \
    \      if(n == 16l) return (1l, 1l)\n        if(n == 17l) return (1l, 0l)\n  \
    \      if(n == 18l) return (1l, 0l)\n        if(n == 19l) return (1l, 1l)\n  \
    \      if(n == 20l) return (1l, 0l)\n        if(n == 21l) return (1l, 0l)\n  \
    \      if(n == 22l) return (1l, 0l)\n        if(n == 23l) return (1l, 0l)\n  \
    \      if(n == 24l) return (1l, 0l)\n        if(n == 25l) return (1l, 1l)\n  \
    \      if(n == 26l) return (1l, 0l)\n        if(n == 27l) return (1l, 0l)\n  \
    \      if(n == 28l) return (1l, 0l)\n        if(n == 29l) return (1l, 1l)\n  \
    \      if(n == 30l) return (1l, 0l)\n        if(n == 31l) return (1l, 1l)\n  \
    \      if(n == 32l) return (1l, 0l)\n        if(n == 33l) return (1l, 0l)\n  \
    \      if(n == 34l) return (1l, 0l)\n        if(n == 35l) return (1l, 0l)\n  \
    \      if(n == 36l) return (1l, 0l)\n        if(n == 37l) return (1l, 0l)\n  \
    \      if(n == 38l) return (1l, 0l)\n        if(n == 39l) return (1l, 1l)\n  \
    \      if(n == 40l) return (1l, 0l)\n        if(n == 41l) return (1l, 1l)\n  \
    \      if(n == 42l) return (1l, 0l)\n        if(n == 43l) return (1l, 1l)\n  \
    \      if(n == 44l) return (1l, 0l)\n        if(n == 45l) return (1l, 1l)\n  \
    \      if(n == 46l) return (1l, 0l)\n        if(n == 47l) return (1l, 0l)\n  \
    \      if", "        var result = 0l\n        for (x <- 1 to n) {\n          \
    \  var even = 0\n            var odd = 0\n            var mid = 0\n          \
    \  var countEven = 0\n            var countOdd = 0\n            var index = n\
    \ - 1\n            while (index >= 0) {\n                mid = (index / 2)\n \
    \               countEven = even.toString.length\n                countOdd = mid.toString.length\n\
    \                even = even + (if (n % 2 == 0 && n / 2 % 2 == 0) 1 else 0).toChar\n\
    \                odd = odd + (if (n % 2 == 1) 1 else 0).toChar\n             \
    \   if (even != mid)\n                    if (odd != mid) {\n                \
    \        if (mid.toString.compareTo(even.toString) < 0) {\n                  \
    \          result += 1\n                        }\n                    }\n   \
    \             else {\n                    if (odd != mid) {\n                \
    \        if (mid.toString.compareTo(even.toString) < 0) {\n                  \
    \          result += 2\n                        }\n                    }\n   \
    \             }\n                index -= 1\n            }\n        }\n      \
    \  (result, n)", "        val count = mutable.ListBuffer[(Long, Long)]()\n   \
    \     for (x<- 1 to n by 2) {\n            for (y <- x to n by 2) {\n        \
    \        val tempString = x +\":\" + y\n                val reverseString = tempString.reverse\n\
    \                val reversedString = reverseString.toDouble\n               \
    \ if (reversedString.toInt == tempString.toInt) {\n                    if (reversedString\
    \ % 2 == 0) {\n                        count = count += ((x,y))\n            \
    \        } else {\n                        count = count += ((y,x))\n        \
    \            }\n                }\n            }\n        }\n        (count.getOrElse(null,\
    \ 0l).getOrElse(1l),count.getOrElse(null, 0l).getOrElse(1l))", "        val evenPalindromes\
    \ = mutable.ArrayBuffer(0l)\n        val oddPalindromes = mutable.ArrayBuffer(0l)\n\
    \        val palindromeCount = 0\n        var palindrome = 0\n        for (palindrome\
    \ <- 1 to n) yield {\n            if (palindrome % 2 == 0) {\n               \
    \ evenPalindromes += palindrome\n                palindromeCount += 1\n      \
    \      } else {\n                oddPalindromes += palindrome\n              \
    \  palindromeCount += 1\n            }\n        }\n        val evenPalindromeSum\
    \ = evenPalindromes.sum\n        val oddPalindromeSum = oddPalindromes.sum\n \
    \       return ((evenPalindromeSum, oddPalindromeSum), palindromeCount)", "  \
    \      val even = 0\n        val odd = 1\n        val palindromeMap = mutable.HashMap[Long,\
    \ Long]()\n        val range = (1l, n)\n        for (x <- range) {\n         \
    \   val reversed = x.toString.reverse\n            if (palindromeMap.getOrElse(x,\
    \ 0l) == reversed) {\n                palindromeMap += (x -> palindromeMap.getOrElse(x,\
    \ 0l) + odd)\n            } else {\n                palindromeMap += (x -> palindromeMap.getOrElse(x,\
    \ 0l) + even)\n            }\n        }\n        return (palindromeMap.getOrElse(1l,\
    \ n) - palindromeMap.getOrElse(n, n), palindromeMap.getOrElse(n, n) - palindromeMap.getOrElse(1l,\
    \ n))", "        val evenNum = List.range(0, n - 1).filter(_ % 2 == 0).length\n\
    \        val oddNum = List.range(0, n - 1).filter(_ % 2 != 0).length\n       \
    \ (evenNum, oddNum)", "        val even: mutable.MutableList[Long] = mutable.MutableList(0)\n\
    \        val odd: mutable.MutableList[Long] = mutable.MutableList(0)\n       \
    \ for(x <- 1 to n) {\n            var odd_count = 0\n            var even_count\
    \ = 0\n            for(y <- 1 to x) {\n                if(x == y) {\n        \
    \            even_count += 0\n                    odd_count += 1\n           \
    \     }\n                else {\n                    even_count += 1\n       \
    \             odd_count += 0\n                }\n                if(odd_count\
    \ % 2 == 0) {\n                    odd += x\n                }\n            }\n\
    \            even += x\n        }\n        (even.sum, odd.sum)", "        if(n\
    \ > 1000000000) {\n            return (0l, 0l)\n        }\n        val evenPalindromeCount\
    \ = 0l\n        val oddPalindromeCount = 0l\n        val evenPalindromes: mutable.Set[Long]\
    \ = mutable.Set()\n        val oddPalindromes: mutable.Set[Long] = mutable.Set()\n\
    \        val start = 0l\n        val end = n\n        while(start < end) {\n \
    \           var evenPalindrome = start\n            var oddPalindrome = start\n\
    \            var isEven = true\n            var isOdd = true\n            while(evenPalindrome\
    \ < end) {\n                if(isEven) {\n                    evenPalindromes.add(evenPalindrome)\n\
    \                    evenPalindrome += 2\n                    isEven = !isEven\n\
    \                } else {\n                    oddPalindromes.add(oddPalindrome)\n\
    \                    oddPalindrome += 2\n                    isOdd = !isOdd\n\
    \                }\n            }\n            evenPalindromeCount += evenPalindromes.size\n\
    \            oddPalindromeCount += oddPalindromes.size\n            start = evenPalindromes.head\n\
    \            end = oddPalindromes.last\n        }\n        (evenPalindromeCount,\
    \ oddPalindromeCount)", "        val evenOdd = n / 2\n        val remainder =\
    \ n % 2\n        val odd = evenOdd - 1\n        (evenOdd, odd)", "        require(n\
    \ >= 1 && n <= 1e9, \"n should be from 1 to 10^9\")\n        require(n % 2 ==\
    \ 0, \"n should be even number\")\n        val counter = mutable.Map.empty[Long,\
    \ Long]\n        var even = 0\n        var odd = 0\n        var nextPalindrome\
    \ = n\n        while (nextPalindrome != 0) {\n            val isEven = isPalindrome(nextPalindrome)\n\
    \            nextPalindrome -= 1\n            if (isEven) {\n                even\
    \ += 1\n                counter.update(nextPalindrome, even)\n            }\n\
    \            else {\n                odd += 1\n                counter.update(nextPalindrome,\
    \ odd)\n            }\n        }\n        (counter.size, counter)", "        require(n\
    \ >= 1 && n <= 10000000)\n        val evenCount = 0l\n        val oddCount = 0l\n\
    \        for (x <- 1 to n) {\n            var even = 0\n            var odd =\
    \ 0\n            var evenPalindrome = 0l\n            var oddPalindrome = 0l\n\
    \            if (x % 2 != 0)\n                odd += 1\n            else\n   \
    \             even += 1\n            while (x < n) {\n                if (x %\
    \ 2 == 0)\n                    even += 1\n                else\n             \
    \       odd += 1\n                if (x % 2 == 0 && x != n) {\n              \
    \      if (x == n)\n                        evenPalindrome += 1\n            \
    \        else\n                        oddPalindrome += 1\n                }\n\
    \                x += 1\n            }\n            if (even == 0)\n         \
    \       evenCount += 1\n            if (evenPalindrome == 0)\n               \
    \ evenCount += 1\n            if (odd == 0)\n                oddCount += 1\n \
    \           if (oddPalindrome == 0)\n                oddCount += 1\n        }\n\
    \        (evenCount, oddCount)", "        val evens = 0 // how many evens within\
    \ the range(1, n)\n        val odds = 0 // how many odds within the range(1, n)\n\
    \        for{\n            i <- 1 to n\n            evenPalindromes <- isEvenPalindrome(i)\n\
    \            oddPalindromes <- isOddPalindrome(i)\n        } yield {\n       \
    \     if(evenPalindromes) evens += 1\n            if(oddPalindromes) odds += 1\n\
    \        }\n        (evens, odds)", "        // Write your code here.\n      \
    \  val palindrome = mutable.Set.empty[Long]\n        for(i <- 1l..n){\n      \
    \      val reverse = new StringBuilder(i.toString).reverse\n            val evenPalindrome\
    \ = i.toString == reverse\n            val oddPalindrome = !i.toString == reverse\n\
    \            if (evenPalindrome && oddPalindrome){\n                palindrome.add(i)\n\
    \            }\n        }\n        (1l, palindrome.size)", "        val evenPalindromes\
    \ = mutable.Set.empty[Long]\n        val oddPalindromes = mutable.Set.empty[Long]\n\
    \        var count = 0\n        var sum = 0\n        var last = 0\n        var\
    \ cur = 0\n        var i = 1\n        var j = 1\n        var k = 0\n        while\
    \ (n-- != 0) {\n            count += 1\n            while (j <= n) {\n       \
    \         last = cur\n                cur = i\n                while (i <= n &&\
    \ j > 0) {\n                    i += 1\n                    j -= 1\n         \
    \           sum += cur\n                }\n                if (sum <= last) {\n\
    \                    oddPalindromes += cur\n                }\n              \
    \  else {\n                    evenPalindromes += cur\n                }\n   \
    \             i += 1\n                j += 1\n            }\n            k = 1\n\
    \            sum = 0\n        }\n        count match {\n            case 1 =>\
    \ (evenPalindromes, oddPalindromes)\n            case _ => (evenPalindromes.size\
    \ + oddPalindromes.size, evenPalindromes + oddPalindromes)\n        }", "    \
    \    var even = 0\n        var odd = 0\n        var i = 1\n        while (i <=\
    \ n) {\n            if (i % 2 == 0) {\n                if (even == 0) {\n    \
    \                even += i;\n                } else if (odd > 0) {\n         \
    \           odd -= i;\n                }\n            } else {\n             \
    \   if (odd == 0) {\n                    odd += i;\n                } else if\
    \ (even > 0) {\n                    even -= i;\n                }\n          \
    \  }\n            i += 1\n        }\n        Tuple2(even, odd)", "        // your\
    \ code here\n        var even = 0\n        var odd = 0\n        var start = 0\n\
    \        var end = n\n        while(start <= end) {\n            var mid = (start\
    \ + end) / 2\n            if(isPalindrome(mid)) {\n                var mid2 =\
    \ mid * mid\n                var even2 = mid2 / 2\n                var odd2 =\
    \ mid2 - even2\n                even = even + even2\n                odd = odd\
    \ + odd2\n            } else {\n                start = mid + 1\n            \
    \    end = mid - 1\n            }\n        }\n        return (even, odd)", " \
    \       val evenPalindromes: mutable.Set[Long] = mutable.Set()\n        val oddPalindromes:\
    \ mutable.Set[Long] = mutable.Set()\n\n        // palindromes is the Set of palindromes\
    \ found from 1 to n.\n        // evenPalindromes is the Set of palindromes that\
    \ are even from 1 to n.\n        // oddPalindromes is the Set of palindromes that\
    \ are odd palindromes from 1 to n.\n        // We use Set to avoid the duplicated\
    \ palindromes.\n        // For each palindrome, add the even/odd palindromes to\
    \ its corresponding set.\n        var palindromes = mutable.Set.empty[Long]\n\
    \        for (i <- 1 to n) {\n            palindromes +=\n                if (i\
    \ % 2 == 0) palindromes.last else palindromes.last\n            if (palindromes.last\
    \ == i) evenPalindromes += palindromes.last\n            else oddPalindromes +=\
    \ palindromes.last\n        }\n\n        (evenPalindromes.size, oddPalindromes.size)",
  "      val evenPalindrome = 0\n      val oddPalindrome = 0\n      var i = 0\n  \
    \    while (i <= n) {\n        var temp = i\n        while (temp > 0) {\n    \
    \      temp = (temp - 1) >> 1\n          if (i % temp == 0) {\n            evenPalindrome\
    \ = evenPalindrome + 1\n          }\n        }\n        temp = i\n        while\
    \ (temp > 0) {\n          temp = (temp - 1) >> 1\n          if (i % temp == 1)\
    \ {\n            oddPalindrome = oddPalindrome + 1\n          }\n        }\n \
    \       i = i + 1\n      }\n      (evenPalindrome, oddPalindrome)", "        val\
    \ evenPalindromes = mutable.Set.empty[Long]\n        val oddPalindromes = mutable.Set.empty[Long]\n\
    \        \n        (1 to n) foreach (i => {\n            if (i % 2 != 0) {\n \
    \               oddPalindromes += i\n            } else {\n                evenPalindromes\
    \ += i\n            }\n        })\n\n        (evenPalindromes.size to oddPalindromes.size\
    \ - 1) foreach (i => {\n            oddPalindromes.remove(i)\n            evenPalindromes.remove(i)\n\
    \        })\n\n        (evenPalindromes.size + 1 to oddPalindromes.size - 1) foreach\
    \ (i => {\n            evenPalindromes.remove(i)\n            oddPalindromes.remove(i)\n\
    \        })\n\n        (evenPalindromes.size + 1 to n) foreach (i => {\n     \
    \       evenPalindromes += i\n        })\n        \n        (evenPalindromes.size\
    \ to n) foreach (i => {\n            oddPalindromes += i\n        })\n       \
    \ \n        (1 to n) foreach (i => {\n            evenPalindromes += i\n     \
    \   })\n        \n        (0 to n) foreach (i => {\n            oddPalindromes\
    \ += i\n        })\n        \n        (evenPalindromes.size to n) foreach (i =>\
    \ {\n            evenPalindromes += i\n        })\n        \n        (oddPalindromes.size\
    \ to n) foreach (i => {\n            oddPalindromes += i\n        })\n       \
    \ \n        Tuple2(evenPalindromes.size, oddPalindromes.size)", "        def countEvenOdd(n\
    \ : Long, i : Long) : Tuple2[Long, Long] = {\n            if (n == i) {\n    \
    \            (1L, 1L)\n            } else if (n < i) {\n                (1L, 0L)\n\
    \            } else {\n                (1L, 1L)\n            }\n        }\n  \
    \      val evenCount: mutable.HashMap[Long, Long] = mutable.HashMap.empty[Long,\
    \ Long]\n        val oddCount: mutable.HashMap[Long, Long] = mutable.HashMap.empty[Long,\
    \ Long]\n        for (i <- 1 to n) {\n            val t = countEvenOdd(n, i)\n\
    \            if (t.get._1 == 0L) {\n                evenCount.put(i, t.get._2)\n\
    \            } else {\n                oddCount.put(i, t.get._2)\n           \
    \ }\n        }\n        Tuple2(evenCount.size, oddCount.size)", "        require(1\
    \ <= n <= 10^3, s\"The integer is out of range. Should be in range of 1 to ${\
    \ 10^3 }\")\n        val even = mutable.ListBuffer[Long]()\n        val odd =\
    \ mutable.ListBuffer[Long]()\n        val low = math.max(1l, n)\n        val high\
    \ = math.min(low, n)\n        for (i = low; i <= high; i += 2L) {\n          \
    \  val tmp = i * i\n            if (tmp.toString.reverse == tmp.toString) {\n\
    \                even += i\n            } else {\n                odd += i\n \
    \           }\n        }\n        (even.toList.sorted, odd.sorted)", "       \
    \ val even = (1 to n).filter(_ % 2 == 0).count\n        val odd = (1 to n).filter(_\
    \ % 2 != 0).count\n        (even, odd)", "        if(n <= 0l) return 0l, 0l\n\
    \        if(n <= 1l) return 1l, 1l\n        var even = 0l\n        var odd = 0l\n\
    \        for(i <- 1l to n-1){\n            var odd = 1l\n            for(j <-\
    \ 1 to i){\n                if(i % j == 0){\n                    odd = 1l\n  \
    \                  break\n                }\n            }\n            even +=\
    \ odd\n        }\n        (n,even)", "        // Your code here\n        val res\
    \ = mutable.TreeMap[Long, Long]()\n        for(i <- 1l until n) {\n          \
    \  for(j <- 2l until n / 2) {\n                val str : String = i.toString\n\
    \                if(str == str.reverse)\n                    res(j) = res(j) +\
    \ 1\n            }\n        }\n        res(1,n)", "        val even = 0\n    \
    \    val odd = 1\n        var p = 0\n        while(p < n) {\n            val left\
    \ = n % 10\n            val right = n / 10\n            val n = left + right\n\
    \            if(p == n){\n                p += 1\n            } else {\n     \
    \           p += 1\n                if (n%(10*p) == 0) {\n                   \
    \ even += 1\n                }\n                if (n%(10*p + 10) == 0) {\n  \
    \                  odd += 1\n                }\n            }\n        }\n   \
    \     (even, odd)", "        val ans = mutable.Buffer.empty[Long]\n        val\
    \ even = mutable.Buffer.empty[Long]\n        val odd = mutable.Buffer.empty[Long]\n\
    \        val range = (1 to n).toList\n        var i = 0\n        for (x <- range)\
    \ {\n            val nx = x + 1\n            val p = x % 2 == 0 // palindrome\n\
    \            val nm = x % 2 == 1\n            var n = 0\n            var j = 0\n\
    \            while (j < n) {\n                val r = nx - (j + 2)\n         \
    \       if (p && nm && r >= 0) {\n                    n += 1\n               \
    \     ans += r\n                    if (r == x) {\n                        even\
    \ += r\n                    }\n                }\n                else {\n   \
    \                 n += 1\n                    odd = r :: odd\n               \
    \ }\n                j += 1\n            }\n        }\n        ans ++ (even ++\
    \ odd)", "        val evenPal = new mutable.HashSet[Long]()\n        val oddPal\
    \ = new mutable.HashSet[Long]()\n        val palindrome = (1 to n).map(i => i)\n\
    \        val odd = palindrome.filter(i => i % 2 != 0)\n        val even = palindrome.filter(i\
    \ => i % 2 == 0)\n        val even_odd = even.zip(odd)\n        even_odd.foreach({\
    \ case (even_odd_val, odd_val) => evenPal.add(even_odd_val); oddPal.add(odd_val)\
    \ })\n        (evenPal.size, oddPal.size)", "        val evenPalms = mutable.List.empty[Long]\n\
    \        val oddPalms = mutable.List.empty[Long]\n        val i = 2l\n       \
    \ var palindromes = i\n        var n = n\n        while (i <= n) {\n         \
    \   if (n % i == 0l) {\n                palindromes = palindromes.dropRight(1)\n\
    \                evenPalms = evenPalms.insert(i, palindromes.size)\n         \
    \       oddPalms = oddPalms.insert(i, palindromes.size)\n            }\n     \
    \       i += 1\n            n /= i\n        }\n        (evenPalms.reduceLeft((a,\
    \ b) => a + b), oddPalms.reduceLeft((a, b) => a + b).toLong)", "        var even\
    \ = 0l\n        var odd = 0l\n        val evenPalindromes = mutable.ListBuffer[Long]()\n\
    \        val oddPalindromes = mutable.ListBuffer[Long]()\n        // For each\
    \ number in range(1, n+1)\n        for(i <- 1 to n) {\n            // Check if\
    \ the number has even or odd number of palindromes.\n            val hasEvenOddPalindrome\
    \ = numberHasEvenOddPalindromes(i)\n            // If the number is odd, add the\
    \ odd to the oddPalindromes list\n            // and remove the odd, since we\
    \ just counted the odd.\n            if(!hasEvenOddPalindrome) {\n           \
    \     odd += 1l\n                oddPalindromes.append(i)\n            } else\
    \ {\n                even += 1l\n                evenPalindromes.append(i)\n \
    \           }\n        }\n        (evenPalindromes.sum, oddPalindromes.sum)",
  "        def isEven(n : Long) : Boolean = {\n            val remainder = n % 2\n\
    \            if (remainder == 0) true\n            else false\n        }\n   \
    \     def isOdd(n : Long) : Boolean = {\n            val remainder = n % 2\n \
    \           if (remainder == 1) true\n            else false\n        }\n    \
    \    val evenPalindromes: mutable.MutableList[Long] = mutable.MutableList[Long]()\n\
    \        var oddPalindromes: mutable.MutableList[Long] = mutable.MutableList[Long]()\n\
    \        var lastEven: Long = 0\n        var lastOdd: Long = 0\n        var evenCount\
    \ = 0\n        var oddCount = 0\n        var isOddEven: Boolean = true\n     \
    \   for (i <- 1 until n) {\n            if (isEven(i)) {\n                if (isOddEven)\
    \ {\n                    val tempEven = lastEven * 10 + i\n                  \
    \  if (lastEven < i && tempEven != i) {\n                        val tempOdd =\
    \ lastOdd * 10 + i\n                        if (lastOdd < i && tempOdd != i) {\n\
    \                            oddPalindromes += tempOdd\n                     \
    \       evenPalindromes += tempEven\n                            lastEven = i\n\
    \                            lastOdd = i\n                            oddCount\
    \ += 1\n                        }\n                        else {\n          \
    \                  evenPalindromes += i\n                            lastEven\
    \ = i\n                            lastOdd = i\n                            evenCount\
    \ += 1\n                        }\n                    }\n                   \
    \ else {\n                        evenPalindromes += i\n                     \
    \   lastEven = i\n                        lastOdd = i\n                      \
    \  evenCount += 1\n                    }\n                }\n                else\
    \ {\n                    evenPalindromes += i\n                    lastEven =\
    \ i\n                    lastOdd = i\n                    evenCount += 1\n   \
    \             }\n            }\n            else {\n                if (isOddEven)\
    \ {\n                    val tempOdd = lastOdd * 10 + i\n                    if\
    \ (lastOdd < i && tempOdd != i) {\n                        val tempEven = lastEven\
    \ * 10 + i\n                        if (lastEven < i && tempEven != i) {\n   \
    \                         oddPalindromes += tempEven\n                       \
    \     evenPalindromes += tempOdd\n                            lastEven = i\n \
    \                           lastOdd = i\n                            oddCount\
    \ += 1\n                        }\n                        else {\n          \
    \                  evenPalindromes += i\n                            lastEven\
    \ = i\n                            lastOdd = i\n                            evenCount\
    \ += 1\n                        }\n                    }\n                   \
    \ else {\n                        evenPalindromes += i\n                     \
    \   lastEven = i\n                        lastOdd = i\n                      \
    \  even", "        val s = scala.collection.mutable.MutableListBuffer.empty[(Long,\
    \ Long)]\n        var i = n.toLong\n        while (i > 0) {\n            val a\
    \ = i\n            val b = a % 2\n            i /= 2\n            s ++= (b ->\
    \ a)\n        }\n        val a = s.sortWith(_._2 > _._2)\n        val b = a.toList.reverse\n\
    \        (b(0), b(1))", "        (for {\n            i <- 1 to n\n        } yield\
    \ {\n            if ((i / 2) % 2 == 0 && i % 2 == 1) {\n                (i, n\
    \ - i)\n            } else {\n                (n - i, i)\n            }\n    \
    \    }).toList", "        def palindromes(num : Long) : List[Long] = {\n     \
    \       def reverse(str : String) : String = {\n                val charArray\
    \ = str.toCharArray\n                val reversedCharArray = new Array[Char](charArray.length)\n\
    \                for (i <- charArray.length to 0 by -1) {\n                  \
    \  reversedCharArray(i) = charArray(charArray.length - i)\n                }\n\
    \                new String(reversedCharArray)\n            }\n            val\
    \ numStr = num.toString\n            val revNumStr = palindromes(numStr)\n   \
    \         (revNumStr.length, numStr.length)\n        }\n        // TODO: Write\
    \ your code here", "        val arr = scala.collection.mutable.ArrayBuffer.fill(n.toInt){0l}\n\
    \        // Even palindromes\n        arr ++ arr.reverse\n            .toSet\n\
    \            .filter(_ % 2 == 0)\n            .zipWithIndex\n            .toList\n\
    \            .map(_.swap)\n            // Odd palindromes\n            .filter(_\
    \ % 2 == 1)\n            .map(_.swap)\n            .toList\n            .map(_.swap)\n\
    \            .toSet\n            .map(_.swap)\n            .filter(_ % 2 == 0)\n\
    \            .map(_.swap)\n            .foldLeft(0l){\n                case (acc,\
    \ e) => acc + e\n            }\n            .foldLeft(0l){\n                case\
    \ (acc, e) => acc + e\n            }", "        val evens    = mutable.ListBuffer.empty[Long]\n\
    \        val odds     = mutable.ListBuffer.empty[Long]\n        val count    =\
    \ mutable.ListBuffer.empty[Long]\n        for (x <- 1 to n toList) {\n       \
    \     for (y <- x until x toList) {\n                val evenPalindrome = x +\
    \ y == n\n                val oddPalindrome    = x - y == n\n                if\
    \ (evenPalindrome || oddPalindrome) count += 2\n                else count +=\
    \ 1 if evenPalindrome\n            }\n            if (count.sum == 2) evens +=\
    \ x else odds += x\n            count clear\n        }\n        (evens.toList,\
    \ odds.toList)", "        if (n < 2L) throw new Exception(\"[evenOddPalindrome]\
    \ number is not positive\")\n        var evenPalindrome = mutable.Set[Long]()\n\
    \        var oddPalindrome = mutable.Set[Long]()\n        for (i <- 1 to n){\n\
    \            val reverse = reverse(i toString)\n            if (reverse.equals(\"\
    0\") || reverse.equals(\"1\")){\n                if (reverse.equals(\"0\")) evenPalindrome.add(i)\n\
    \                else                   oddPalindrome.add(i)\n            }\n\
    \        }\n        (evenPalindrome.size, oddPalindrome.size)", "        var evenCount\
    \ = 0\n        var oddCount = 0\n\n        var palindromes = getPalindromes(n)\n\
    \        var evenPalindromes = palindromes.filter(p => p.isEven)\n        var\
    \ oddPalindromes = palindromes.filter(p => p.isOdd)\n\n        for (pal <- palindromes)\
    \ {\n            if (pal.isEven) {\n                evenCount += 1\n         \
    \   } else if (pal.isOdd) {\n                oddCount += 1\n            }\n  \
    \      }\n\n        return (evenCount, oddCount)", "        val evenPalindromes\
    \ = n.toInt/2 // evenPalindromes is the number of palindromes with even number\
    \ of digits.\n        val oddPalindromes = n.toInt%2  // oddPalindromes is the\
    \ number of palindromes with odd number of digits.\n        return (evenPalindromes,\
    \ oddPalindromes)", "        if (n.toLong > 0 && n.toLong < 10^3) {\n        \
    \    val even = n.toLong.toInt/2 // n / 2 is even\n            val odd = n.toLong.toInt%2\
    \ // n / 2 is odd\n            val evenPalindrome = even * even\n            val\
    \ oddPalindrome = odd * odd\n            val palindromes = math.min(evenPalindrome,\
    \ oddPalindrome)\n            val evenPalindromes = evenPalindrome - palindromes\n\
    \            val oddPalindromes = oddPalindrome - palindromes\n            Tuple2(evenPalindromes,\
    \ oddPalindromes)\n        }\n        else {\n            Tuple2(-1l, -1l)\n \
    \       }", "        val evenPalindromes: mutable.ListBuffer[Long] = mutable.ListBuffer()\n\
    \        val oddPalindromes: mutable.ListBuffer[Long] = mutable.ListBuffer()\n\
    \        val rangeOfIntegers: mutable.ListBuffer[Long] = mutable.ListBuffer()\n\
    \        val oddRangeOfIntegers: mutable.ListBuffer[Long] = mutable.ListBuffer()\n\
    \        val evenRangeOfIntegers: mutable.ListBuffer[Long] = mutable.ListBuffer()\n\
    \        for (i = 0 to n) {\n            val str : String = i + \"\"\n       \
    \     val reverse : String = str.split(\"\").reverse().mkString\n            val\
    \ isEven = str.isEven\n            val isOdd = !str.isEven\n            if (isEven)\
    \ {\n                evenPalindromes += i\n            }\n            if (isOdd)\
    \ {\n                oddPalindromes += i\n            }\n            rangeOfIntegers\
    \ += i\n            if (isEven) {\n                evenRangeOfIntegers += i\n\
    \            }\n            if (isOdd) {\n                oddRangeOfIntegers +=\
    \ i\n            }\n        }\n        val evenRanges = evenRangeOfIntegers.distinct\n\
    \        val oddRanges = oddRangeOfIntegers.distinct\n        (evenPalindromes.size,\
    \ oddPalindromes.size) match {\n            case (true, true) => oddPalindromes\n\
    \            case (false, true) => evenPalindromes\n            case (false, true)\
    \ => oddRanges\n            case (true, false) => evenRanges\n        }", "  \
    \      require(n >= 1l && n <= 10l, \"n should be in range from 1l to 10l\")\n\
    \        val evenPalindromes = mutable.HashSet.empty[Int]\n        val oddPalindromes\
    \ = mutable.HashSet.empty[Int]\n        for (x <- 1 to n toSet) {\n          \
    \  val y = x to (n by -1)\n            var temp = 0\n            var i = 1\n \
    \           while (i <= y.length) {\n                temp = (temp*10 + y(i) -\
    \ i).toLong\n                i += 1\n            }\n            if (temp == x)\n\
    \                evenPalindromes += x\n            else\n                oddPalindromes\
    \ += x\n        }\n        (evenPalindromes.size, oddPalindromes.size)", "   \
    \     var count = 0\n        var sum = 0\n        for(i <- 1 until n)\n      \
    \      for(j <- i + 1 until n)\n                if(i == j)\n                 \
    \   count++\n                else {\n                    var temp = i\n      \
    \              i = j\n                    j = temp\n                    sum +=\
    \ i\n                    sum += j\n                }\n        if(count % 2 ==\
    \ 0)\n            (sum, sum + count)\n        else\n            (sum, sum - count)",
  "        val even = n.toString.reverse match {\n            case x if x == x.reverse.tail.mkString(\"\
    \") => (0l, 1l)\n            case x => 0l\n        }\n        val odd = n.toString.reverse\
    \ match {\n            case x if x != x.reverse.tail.mkString(\"\") => (0l, 1l)\n\
    \            case x => 0l\n        }\n        (even, odd)", "        val evenPalindromes\
    \ = (1l to n).filter(p => checkEvenPalindrome(p)).toArray\n        val oddPalindromes\
    \ = (1l to n).filter(p => checkOddPalindrome(p)).toArray\n        evenPalindromes.isEmpty\
    \  match {\n            case true  => (n, 0)\n            case false => (evenPalindromes.sum,\
    \ oddPalindromes.sum)\n        }", "        val evenPalindromes = mutable.ListBuffer[Long]()\n\
    \        val oddPalindromes = mutable.ListBuffer[Long]()\n        val minNumber\
    \ = 1l\n        val maxNumber = n\n        // For each number from 1 to n, check\
    \ if it is even or odd.\n        for (i <- 1 to n) {\n            if (i % 2 ==\
    \ 0) {\n                evenPalindromes += i\n            } else {\n         \
    \       oddPalindromes += i\n            }\n        }\n        // If the number\
    \ of even number palindromes is smaller than the half of n, then\n        // return\
    \ (evenPalindromes size * 2 , evenPalindromes size)\n        if (evenPalindromes.size\
    \ < n/2) {\n            return (evenPalindromes.size * 2l, evenPalindromes.size)\n\
    \        } else {\n            // If the number of odd number palindromes is smaller\
    \ than the half of n, then\n            // return (oddPalindromes size * 2 , oddPalindromes\
    \ size)\n            if (oddPalindromes.size < n/2) {\n                return\
    \ (oddPalindromes.size * 2l, oddPalindromes.size)\n            } else {\n    \
    \            // If number of even and odd palindromes are equal, then\n      \
    \          // return (evenPalindromes.size * 2, oddPalindromes.size * 2)\n   \
    \             if (evenPalindromes.size == oddPalindromes.size) {\n           \
    \         return (evenPalindromes.size * 2l, evenPalindromes.size * 2l)\n    \
    \            } else {\n                    // If number of even and odd palindromes\
    \ are unequal, then\n                    // return (evenPalindromes.size * 2,\
    \ oddPalindromes.size * 2)\n                    throw new RuntimeException(\"\
    You got the wrong number of even and odd number palindromes\")\n             \
    \   }\n            }\n        }", "        def isPalindrome(x:Long, y:Long, s:String)\
    \ : Boolean = {\n            val xs = x.toString\n            val ys = y.toString\n\
    \            if (xs.length != ys.length) false else xs == ys.reverse\n       \
    \ }\n        // get odd numbers from 1 to n, inclusive\n        def getOdds(i\
    \ : Long, n:Long): Seq[Long] = {\n            for(j \u2190 i + 1 until n) yield\
    \ (i \u2190 j)\n        }\n        // get even numbers from 1 to n, inclusive\n\
    \        def getEvens(i : Long, n:Long): Seq[Long] = {\n            for(j \u2190\
    \ i + 1 until n) yield (j \u2190 i)\n        }\n        // get palindromes, including\
    \ even and odd numbers, from the given range\n        def getPalindromes(r : (Long,\
    \ Long)): Seq[Long] = {\n            val evens = getEvens(r._1, r._2)\n      \
    \      val odds = getOdds(r._1, r._2)\n            evens ++ odds filter (x \u21D2\
    \ isPalindrome(r._1, r._2, x.toString))\n        }\n        // find the count\
    \ of even palindromes and odd palindromes\n        val evens = getPalindromes((2l,\
    \ n-1))\n        val odds = getPalindromes((1l, n-1))\n        val evenCount =\
    \ evens.count (_ % 2 == 0)\n        val oddCount = odds.count (_ % 2 == 1)\n \
    \       (evenCount, oddCount)", "        val evenPalindromes = mutable.Set[Long]()\n\
    \        val oddPalindromes = mutable.Set[Long]()\n        var i = 0\n       \
    \ var j = 0\n        var k = 0\n        var isEven = false\n        var isOdd\
    \ = false\n        while (i < n) {\n            var j = i\n            while (j\
    \ < n) {\n                isEven = j % 2 == 0\n                isOdd = j % 2 !=\
    \ 0\n                var k = j\n                while (k < n) {\n            \
    \        if (isEven) {\n                        isEven = !isEven\n           \
    \         }\n                    if (isOdd) {\n                        isOdd =\
    \ !isOdd\n                    }\n                    if (k == j && isEven && isOdd)\
    \ {\n                        oddPalindromes += k\n                    }\n    \
    \                if (k == j && isEven && !isOdd) {\n                        evenPalindromes\
    \ += k\n                    }\n                    k += 1\n                }\n\
    \                j += 1\n            }\n            i += 1\n        }\n      \
    \  val evNum = evenPalindromes.size\n        val odNum = oddPalindromes.size\n\
    \        val ev = evenPalindromes.toSeq\n        val od = oddPalindromes.toSeq\n\
    \        Tuple2(evNum, odNum)", "        val even = mutable.Queue[Long]()\n  \
    \      val odd = mutable.Queue[Long]()\n        val evenOdd = mutable.Queue[Tuple2[Long,\
    \ Long]]()\n        for (x <- 1 to n) {\n            val s = x.toString\n    \
    \        if (s.reverse.forall(x => x != s.length)) {\n                even.enqueue(x)\n\
    \            } else {\n                odd.enqueue(x)\n            }\n       \
    \     if (even.size == n / 2) {\n                evenOdd.enqueue((x -> even.size))\n\
    \            }\n            if (odd.size == n / 2) {\n                evenOdd.enqueue((x\
    \ -> odd.size))\n            }\n        }\n        (evenOdd.dequeue._1, evenOdd.dequeue._2)",
  "        val evenPalindrome = mutable.ListBuffer.empty[(Long, Long)]\n        val\
    \ oddPalindrome = mutable.ListBuffer.empty[(Long, Long)]\n        for (i <- 1\
    \ until n){\n            if (i.toString.reverse.charAt(0) == i.toString.reverse.charAt(n)){\n\
    \                evenPalindrome.append((i, i))\n            } else {\n       \
    \         oddPalindrome.append((i, i))\n            }\n        }\n        (evenPalindrome.size,\
    \ oddPalindrome.size)", "        val evenPalindrome = mutable.Set[Long]()\n  \
    \      val oddPalindrome = mutable.Set[Long]()\n        for (x <- 1 to n) {\n\
    \            val s = x.toString.reverse\n            if (s.reverse == s) {\n \
    \               if (x % 2 == 0) {\n                    evenPalindrome.add(x)\n\
    \                } else {\n                    oddPalindrome.add(x)\n        \
    \        }\n            }\n        }\n        val evenPalindromeSize = evenPalindrome.size\n\
    \        val oddPalindromeSize = oddPalindrome.size\n        return (evenPalindromeSize,\
    \ oddPalindromeSize)", "        if(n == 0) (0l, 1l)\n        if(n == 1) (1l, 0l)\n\
    \        if(n <= 0) (0l, 0l)\n        if(n % 2 == 0) evenOddPalindrome(math.ceil(n/2))\
    \ match {\n            case (evenPalindrome1, evenPalindrome2) => evenPalindrome1\
    \ -> (n + evenPalindrome1)\n            case _ => evenOddPalindrome(math.ceil(n/2))\n\
    \        }\n        else if(n % 2 == 1) evenOddPalindrome(math.ceil(n/2)) match\
    \ {\n            case (evenPalindrome1, evenPalindrome2) => evenPalindrome2 ->\
    \ (n + evenPalindrome2)\n            case _ => evenOddPalindrome(math.ceil(n/2))\n\
    \        }\n        else (evenOddPalindrome(math.ceil(n/2)) match {\n        \
    \    case (evenPalindrome1, evenPalindrome2) => (n + evenPalindrome1, n + evenPalindrome2)\n\
    \            case _ => evenOddPalindrome(math.ceil(n/2))\n        })", "     \
    \ val arr = new Array[Long](101)\n      arr.length = (n - 1) / 2 + 1\n      var\
    \ ev = 0\n      var od = 0\n      var cnt = 0\n      for (i <- 0 until arr.length)\
    \ {\n        val a = arr(i) - arr(i + 1)\n        if ((a % 2) == 0) {\n      \
    \    ev += 1\n        } else {\n          odd += 1\n        }\n      }\n     \
    \ val odd = ev + odd - 2 * ev\n      val even = ev - odd\n      val tup = tuple(even,\
    \ odd)\n      cnt", "        if (n < 1l) throw new IllegalArgumentException(\"\
    n must be positive\")\n        if (n % 2 == 0) throw new IllegalArgumentException(\"\
    n must be odd\")\n        val palindromes = mutable.ListBuffer.empty[Long]\n \
    \       for (i = 1 until n by 2) palindromes += i * i\n        palindromes.groupBy(palindromes.lastOption\
    \ map (_ % 2))", '        // do something to return Tuple with number of even
    and odd integer palindromes that fall within the range(1, n), inclusive', "  \
    \      val evenPalindromes = mutable.Set[Long]()\n        val oddPalindromes =\
    \ mutable.Set[Long]()\n        val maxEvenPalindromes = n / 2\n        val maxOddPalindromes\
    \ = (2 * maxEvenPalindromes + 1).toLong\n\n        (1 to maxEvenPalindromes map\
    \ { i =>\n            val palindrome = i + 1\n            val rev = palindrome.toString.reverse\n\
    \            val evenPalindrome = rev.toCharArray.forall(_ == '0')\n         \
    \   evenPalindromes += palindrome\n        }, (1 to maxOddPalindromes map { i\
    \ =>\n            val palindrome = i + maxEvenPalindromes\n            val rev\
    \ = palindrome.toString.reverse\n            val oddPalindrome = rev.toCharArray.forall(_\
    \ == '1')\n            oddPalindromes += palindrome\n        })).unzip", "   \
    \     if (n < 1L || n > 10L*100L*1000L) {\n            return (-1L, -1L)\n   \
    \     }\n        var even = 0L\n        var odd = 0L\n        var evenPalindrome\
    \ = Nil\n        var oddPalindrome = Nil\n        for (i <- 1L to n-1) {\n   \
    \         for (j <- 0 to n-i) {\n                val tmp = (i + j).toString.toInt\n\
    \                if (tmp == tmp.toString.toInt) {\n                    val reverseStr\
    \ = String.valueOf(tmp).reverse\n                    val reverseInt = (reverseStr\
    \ match{\n                        case s : String if (s.size == 1) => s.toInt\n\
    \                        case s : String if (s.length == 2) => s.toInt * 10\n\
    \                        case s : String if (s.length != 3) throw new RuntimeException(\"\
    Only single-digit palindromes can be counted\")\n                        case\
    \ s : String if (s.size == 3) => s.toInt * 100\n                        case s\
    \ : String if (s.length == 4) => s.toInt * 1000\n                        case\
    \ s : String if (s.length == 5) => s.toInt * 10000\n                        case\
    \ s : String if (s.length == 6) => s.toInt * 100000\n                        case\
    \ s : String if (s.length == 7) => s.toInt * 1000000\n                       \
    \ case s : String if (s.length == 8) => s.toInt * 10000000\n                 \
    \       case s : String if (s.length == 9) => s.toInt * 100000000\n          \
    \              case s : String if (s.length == 10) => s.toInt * 1000000000\n \
    \                       case s : String if (s.length == 11) => s.toInt * 10000000000\n\
    \                        case s : String if (s.length == 12) => s.toInt * 100000000000\n\
    \                        case s : String if (s.length == 13) => s.toInt * 1000000000000\n\
    \                        case s : String if (s.length == 14) => s.toInt * 10000000000000\n\
    \                        case s : String if (s.length == 15) => s.toInt * 100000000000000\n\
    \                        case s : String if (s.length == 16) => s.toInt * 1000000000000000\n\
    \                        case s : String if (s.length == 17) => s.toInt * 10000000000000000\n\
    \                        case s : String if (s.length == 18) => s.toInt * 100000000000000000\n\
    \                        case s : String if (s.length == 19) => s.toInt * 1000000000000000000\n\
    \                        case s : String if (s.length == 20) => s.toInt * 10000000000000000000\n\
    \                        case s : String if (s.length == 21) => s.toInt * 100000000000000000000\n\
    \                        case s : String if (s.length == 22) => s.toInt * 1000000000000000000000\n\
    \                        case s : String if (s.length == 23) => s.toInt * 10000000000000000000000\n\
    \                        case s : String if (s.length == 24) => s.toInt * 100",
  "        val evenPalindromeSum = n.toString.reverse.grouped(2).count { case Array(a,b)\
    \ => a*b == a*b.reverse.head }\n        val oddPalindromeSum = n.toString.grouped(2).count\
    \ { case Array(a,b) => a*b != a*b.reverse.head }\n        return (evenPalindromeSum,\
    \ oddPalindromeSum)", "        val evenPalindromes = 0\n        val oddPalindromes\
    \ = 0\n        for(i <- 1 to n by 2){\n            val reversed = new StringBuilder(n.toString).reverse.toString\n\
    \            if(reversed.equals(n::n)) {\n                if((i.toString % 2)\
    \ == 0) {\n                    evenPalindromes = evenPalindromes + 1\n       \
    \         } else {\n                    oddPalindromes = oddPalindromes + 1\n\
    \                }\n            }\n        }\n        Tuple2(evenPalindromes,\
    \ oddPalindromes)", "        val list = mutable.ListBuffer[Long]()\n        val\
    \ listEven = mutable.ListBuffer[Long]()\n        val listOdd = mutable.ListBuffer[Long]()\n\
    \n        for(x <- 1 to n) {\n            val reverse = (n-1).toString.reverse\n\
    \            if(x == n-1) // Base case : 1 -> 1\n                x :: listEven\n\
    \            else if(x == 1) // Base case : 2 -> 1\n                x :: listOdd\n\
    \            else if(x == reverse.length) // Base case : 3 -> 1\n            \
    \    x :: listEven\n            else if(x == reverse.length+1) // Base case :\
    \ 3 -> 2\n                x :: listOdd\n            else {\n                val\
    \ c = x-1\n                val k = c + x\n                val z = (c+1).toString.reverse\n\
    \                val l = (k-1).toString.reverse\n\n                if((x % 2)\
    \ == 0)\n                    if(x != reverse.length)\n                       \
    \ x :: listOdd\n                    else\n                        x :: listEven\n\
    \                else\n                    if(x != reverse.length)\n         \
    \               x :: listEven\n                    else\n                    \
    \    x :: listOdd\n\n            }\n        }\n\n        val evenCount = list.filter(v\
    \ => v % 2 == 0).length\n        val oddCount = list.filter(v => v % 2 != 0).length\n\
    \        Tuple2(evenCount, oddCount)", "        val maxNum = math.min(math.max(n.toInt,\
    \ 1), 10^3)\n        val even = 0\n        val odd = 0\n        for(num <- 1 to\
    \ maxNum) {\n            val str = num.toString.reverse\n            if(str.forall(\
    \ _.isDigit) && !str.isEmpty && str.length == num) {\n                if(str.forall(i\
    \ => i match {\n                    case _ if i / 2 == math.mod(i, 2)\n      \
    \              case _ if i % 2 == math.mod(i, 2)\n                    case _ if\
    \ i / 2 == math.mod(i, 2) == math.mod(i, 2)\n                    case _ if i %\
    \ 2 == math.mod(i, 2) == math.mod(i, 2)\n                    case _ if i / 2 ==\
    \ math.mod(i, 2)\n                    case _ if i % 2 == math.mod(i, 2)\n    \
    \                case _ if i / 2 == math.mod(i, 2) == math.mod(i, 2) && i % 2\
    \ == math.mod(i, 2)\n                    case _ if i / 2 == math.mod(i, 2) ==\
    \ math.mod(i, 2) && i % 2 != math.mod(i, 2)\n                    case _ => false\n\
    \                }))\n                    even += 1\n                else\n  \
    \                  odd += 1\n            }\n        }\n        (even, odd)", " \
    \       // TODO: write your code here\n        val evenPalindromes : Long = 0l\n\
    \        val oddPalindromes : Long = 0l\n        for ( i <- 1l to n-1l) {\n  \
    \          val str = i.toString\n            val revStr = str.reverse\n      \
    \      if (str == revStr)\n            { evenPalindromes += 1l ; break }\n   \
    \         else\n            { oddPalindromes += 1l ; break }\n        }\n    \
    \    (evenPalindromes, oddPalindromes)", "        require(1 <= n && n <= 1000000000,\
    \ \"n must be in range [1, 1000000000]\")\n        val evenPalindrome = mutable.BitSet(n).find(_\
    \ % 2 == 0)\n        val oddPalindrome = mutable.BitSet(n).find(_ % 2 != 0)\n\
    \        val evenPalindromeCount = evenPalindrome.length()\n        val oddPalindromeCount\
    \ = oddPalindrome.length()\n        (evenPalindromeCount, oddPalindromeCount)",
  "        require(n >= 1, \"n should be positive\")\n        require(n <= 10^3, \"\
    n should be less than 10^3\")\n\n        val evens = mutable.Set[Long]()\n   \
    \     val odds = mutable.Set[Long]()\n\n        for (i <- 1 to n)\n          \
    \  if(isPalindrome(i)) evens += i\n            else odds += i\n\n        val evenPalindromes\
    \ = evens.toSeq.filter(isPalindrome).toSeq.size\n        val oddPalindromes =\
    \ odds.toSeq.filter(isPalindrome).toSeq.size\n\n        (evenPalindromes, oddPalindromes)",
  "        val evenPalindrome = List.range(1l, n).filter(_ % 2 == 0)\n        val\
    \ oddPalindrome = List.range(1l, n).filter(_ % 2 != 0)\n        (evenPalindrome.size,\
    \ oddPalindrome.size)", "        val evenPal = new mutable.HashSet[Long]\n   \
    \     val oddPal = new mutable.HashSet[Long]\n        var i = 0\n        var j\
    \ = 0\n        var result = 0\n        while (i<n) {\n            while (j<n)\
    \ {\n                if ((i+j)<=n) evenPal.add(i+j)\n                if ((i+j+1)<=n)\
    \ oddPal.add(i+j+1)\n                j+=1\n            }\n            i+=1\n \
    \           j=0\n        }\n        while (result<2) {\n            result +=\
    \ evenPal.size\n            result += oddPal.size\n        }\n        if (evenPal.isEmpty)\
    \ result = (1l, 0l) else result = (1l, evenPal.size*2l)\n        if (oddPal.isEmpty)\
    \ result = (0l, 1l) else result = (oddPal.size*2l, 1l)\n        result", "   \
    \     val evens = mutable.ListBuffer[Long]()\n        val odds = mutable.ListBuffer[Long]()\n\
    \        // 1. count palindromes within the given range\n        val count = 0\
    \ // number of palindromes within the range\n        for(x <- 1 to n){\n     \
    \       val odd = x % 2\n            val even = x % 2 == 0\n            if((x\
    \ * x) == x && x != 0 && x != 1) count += 1 // count palindromes within the given\
    \ range\n            if(x == 1 || (x % 2) == odd){ // even palindromes\n     \
    \           if(even) evens += x\n                else odds += x\n            }\n\
    \        }\n        // 2. count odd palindromes and even palindromes and return\
    \ it\n        (evens.size, odds.size)", "        var even = 1.toDouble\n     \
    \   var odd = 2.toDouble\n        for(x <- 1 to n){\n            var a = x / 10.toDouble\n\
    \            var b = x % 10.toDouble\n            var c = (10 * a + b).toInt\n\
    \            var d = (10 * a - b).toInt\n            if((c == d) && (c - d ==\
    \ 0 )) {\n                even += 1.0\n            } else {\n                odd\
    \ += 1.0\n            }\n        }\n        (even.toLong, odd.toLong)", "    \
    \    val result = mutable.ListBuffer[(Long, Long)]()\n        val evenCount =\
    \ 0\n        val oddCount = 0\n        var evenPalindrome = 0\n        var oddPalindrome\
    \ = 0\n        var low = n - 1\n        var high = n - 1\n\n        while (low\
    \ >= 0) {\n            while (high >= 0) {\n                if (low < high) {\n\
    \                    if (n % low == 0 || n % high == 0) {\n                  \
    \      result.append((low,high))\n                        if (low == high) {\n\
    \                            evenPalindrome = evenPalindrome + 1\n           \
    \                 if (evenPalindrome % 2 == 0) {\n                           \
    \     evenCount += evenPalindrome\n                            }\n           \
    \                 else {\n                                oddCount += evenPalindrome\n\
    \                            }\n                            evenPalindrome = 0\n\
    \                            oddPalindrome = 0\n                        }\n  \
    \                      low = low - 1\n                        high = high - 1\n\
    \                    }\n                    else {\n                        break\n\
    \                    }\n                }\n                else {\n          \
    \          break\n                }\n            }\n            low = low - 1\n\
    \            high = high - 1\n        }\n        return ((evenCount, oddCount))",
  "        var even = 0, odd = 1\n        var evenPalNum = n, oddPalNum = n, isEven\
    \ = true\n        while (n>=1) {\n            var remaining = n % 10\n       \
    \     if (remaining == 0) {\n                n /= 10\n                odd = odd+1\n\
    \            } else {\n                remaining /= 10\n                if (isEven)\
    \ {\n                    evenPalNum = evenPalNum * 10 + remaining\n          \
    \          isEven = !isEven\n                } else {\n                    oddPalNum\
    \ = oddPalNum * 10 + remaining\n                    isEven = !isEven\n       \
    \         }\n            }\n        }\n        (evenPalNum, oddPalNum)", "   \
    \     val palindromes: mutable.Set[Long] = mutable.Set()\n        var evenPalindromes\
    \ = 0\n        var oddPalindromes = 0\n\n        // Add even palindromes into\
    \ the set until reach range or reach n.\n        while(evenPalindromes <= n /\
    \ 2 && (n / 2) <= evenPalindromes) {\n            palindromes.add(n / 2)\n   \
    \         n /= 2\n            evenPalindromes += 1\n        }\n\n        // Add\
    \ odd palindromes into the set until reach range or reach n.\n        while(oddPalindromes\
    \ <= n / 2 && (n / 2) <= oddPalindromes) {\n            palindromes.add(n / 2)\n\
    \            n /= 2\n            oddPalindromes += 1\n        }\n\n        (evenPalindromes,\
    \ oddPalindromes)", "        val evenPalindromes = mutable.HashSet[Long]()\n \
    \       val oddPalindromes = mutable.HashSet[Long]()\n        def evenPalindromes(n\
    \ : Long, i : Long) : Unit = {\n            if (i >= n) return\n            evenPalindromes\
    \ += i // even palindrome\n            evenPalindromes(n, i+1l) // even palindromes\n\
    \            oddPalindromes += (i + 1l) // odd palindrome\n            oddPalindromes(n,\
    \ i+2l) // odd palindromes\n        }\n        evenPalindromes(n, 1l)\n      \
    \  val evenPalindromeCount = evenPalindromes.size\n        val oddPalindromeCount\
    \ = oddPalindromes.size\n        if (evenPalindromeCount == 0 || oddPalindromeCount\
    \ == 0) throw new RuntimeException(\"Invalid number for evenOddPalindrome\")\n\
    \        if (evenPalindromeCount + oddPalindromeCount == n) throw new RuntimeException(\"\
    Invalid number for evenOddPalindrome\")\n        evenPalindromeCount == oddPalindromeCount\
    \ => ((evenPalindromes.toList, oddPalindromes.toList))", "        if (n == 1l)\
    \ (1, 1l)\n        else {\n            val res = 1\n            var even = 0\n\
    \            var odd = 0\n            for (i <- 1 to n) {\n                var\
    \ tmpEven = i\n                var tmpOdd = i\n                while (tmpEven\
    \ > 0 && tmpEven % 2 == 0) tmpEven = tmpEven / 2\n                while (tmpOdd\
    \ > 0 && tmpOdd % 2 == 1) tmpOdd = tmpOdd / 2\n                even = even + tmpEven\n\
    \                odd = odd + tmpOdd\n            }\n            res = ((even +\
    \ 1l, odd + 2l))\n        }", "        if (n <= 0) 0\n        else if (n % 2 ==\
    \ 0) (2l, 1l)\n        else (n / 2, n/2)", "        val evenPalindromes = mutable.Set[Long]()\n\
    \        val oddPalindromes = mutable.Set[Long]()\n        \n        for(i <-\
    \ 1 until n){\n            val str = scala.math.factorial(i).toString\n      \
    \      val reverse = str.foldRight(\"\")((s, c) => s + c).reverse\n          \
    \  val even = reverse.split(\"\").filter(c=>c.toInt%2==0).toList\n           \
    \ val odd = reverse.split(\"\").filter(c=>c.toInt%2!=0).toList\n            evenPalindromes\
    \ ++= even\n            oddPalindromes ++= odd\n        }\n        \n        val\
    \ evenCount = evenPalindromes.size\n        val oddCount = oddPalindromes.size\n\
    \        val result = Tuple2(evenCount, oddCount)\n        result", "        val\
    \ evenPalindromes = mutable.Set.empty[Long]\n        val oddPalindromes = mutable.Set.empty[Long]\n\
    \        var i = 0\n        while (i < n) {\n            val s = scala.math.pow(10,\
    \ i).toInt\n            val p = s.toString\n            val odd = p.reverse\n\n\
    \            if (evenPalindromes.contains(odd))\n                oddPalindromes\
    \ += odd\n            else\n                evenPalindromes += odd\n         \
    \   i += 1\n        }\n\n        val evens = evenPalindromes.toSet\n        val\
    \ odds = oddPalindromes.toSet\n        val evenPalLength: Long = evens.size\n\
    \        val oddPalLength: Long = odds.size\n        return (evenPalLength, oddPalLength)",
  "        val evenNumPalindromes = 0\n        val oddNumPalindromes = 0\n       \
    \ var i = 1\n        while(i <= n) {\n            val evenPalindrome = BigInt(i)\
    \ * BigInt(i)\n            val oddPalindrome = BigInt(i) * BigInt(i) + BigInt(i)\
    \ - 1\n            if(evenPalindrome == evenPalindrome && (i + 1) < n) {\n   \
    \             evenNumPalindromes += 1\n            }\n            if(oddPalindrome\
    \ == oddPalindrome && (i + 1) < n) {\n                oddNumPalindromes += 1\n\
    \            }\n            i += 1\n        }\n        (evenNumPalindromes, oddNumPalindromes)",
  "        if (n <= 10^3) (\n            if (n % 2 == 0) (\n                if (n%2\
    \ == 0) n / 2,\n                n / 2\n            ) else (\n                n/2,\n\
    \                n/2\n            )\n        ) else (\n            evenOddPalindrome((n/2)*2)\n\
    \        )", "        val num: Set[Long] = Set(1, 2)\n        while (n > 0) {\n\
    \            val evens: Set[Long] = num.filter(x => n % x == 0).map(x => x + (n\
    \ / x).ceil).toSet\n            val odds: Set[Long] = num.filter(x => n % x ==\
    \ 1).map(x => x + (n / x).ceil).toSet\n            val newEvens = evens.filterNot(x\
    \ => odds.contains(x))\n            val newOdds = odds.filterNot(x => evens.contains(x))\n\
    \            num ++= newEvens.toSet ++ newOdds.toSet\n            n -= 1\n   \
    \     }\n        num.foldLeft((0l, 0l)) {\n            case ((evens, odds), n)\
    \ => if (n % 2 == 0) ((evens + 1l, n) else (odds + 1l, n))\n        }", "    \
    \    val evenCount = mutable.Set[Long]()\n        val oddCount = mutable.Set[Long]()\n\
    \        var evenPalindrome = 0\n        var oddPalindrome = 0\n        for (i\
    \ <- 1 to n) {\n            val rev : String = (i.toString).reverse\n        \
    \    val evenPalindromeIsEven = rev.indexOf(rev.toCharArray()(0)) % 2 == 0\n \
    \           val oddPalindromeIsEven = rev.indexOf(rev.toCharArray()(0)) % 2 !=\
    \ 0\n            if (evenPalindromeIsEven && oddPalindromeIsEven) {\n        \
    \        evenCount += i\n                evenPalindrome += 1\n            } else\
    \ if (evenPalindromeIsEven && !oddPalindromeIsEven) {\n                evenCount\
    \ += i\n                evenPalindrome += 1\n            } else if (!evenPalindromeIsEven\
    \ && oddPalindromeIsEven) {\n                oddCount += i\n                oddPalindrome\
    \ += 1\n            }\n        }\n        (evenPalindrome, oddPalindrome)", " \
    \       if(n <= 0) throw new IllegalArgumentException(\"n should be positive\"\
    )\n        val even = LongStream\n            .rangeClosed(1, n)\n           \
    \ .filter(x => x % 2 == 0)\n            .map(x => x * x % n)\n            .filter(x\
    \ => x == x)\n            .count()\n        val odd = LongStream\n           \
    \ .rangeClosed(1, n)\n            .filter(x => x % 2 == 1)\n            .map(x\
    \ => x * x % n)\n            .filter(x => x == x)\n            .count()\n    \
    \    (even, odd)", "        val evenNum = 0l\n        val oddNum = 0l\n      \
    \  var evenPal = 0\n        var oddPal = 0\n        for(i <- 0 until n){ \n  \
    \          for(j <- i until n / 2){\n                if(i % j == 0){\n       \
    \             evenPal = evenPal + 1\n                }\n                else\n\
    \                    oddPal = oddPal + 1\n            }\n        }\n        (evenPal,\
    \ oddPal)", "        val odd = n % 2 == 0\n        val even = n / 2\n        val\
    \ evenPal = (n, odd) filter (x => x % 2 == 0) map (x => (x,x))\n        val oddPal\
    \ = (n, odd) filter (x => x % 2 != 0) map (x => (x,x))\n        val evenAndOdd\
    \ = evenPal ++ oddPal\n        return (evenAndOdd.size, evenAndOdd.size/2)", " \
    \       val evenPalindromes = new mutable.HashMap[Int, Int]\n        val oddPalindromes\
    \ = new mutable.HashMap[Int, Int]\n        var count = 0\n        var evenCount\
    \ = 1\n        var oddCount = 1\n        var numberPalindrome = 0\n        val\
    \ start = (1l).until(n)\n        for (i <- start) {\n            val temp = i.toString\n\
    \            val reversedStr = temp.reverse\n            if (evenPalindromes.contains(reversedStr))\
    \ count += 1\n            else if (oddPalindromes.contains(reversedStr)) count\
    \ -= 1\n            else evenPalindromes.put(i, evenCount)\n            oddPalindromes.put(i,\
    \ oddCount)\n        }\n        return (evenPalindromes.toSeq, oddPalindromes.toSeq)",
  "        val palindromes = mutable.LinkedListBuffer[Long]()\n        for (i<- 1\
    \ to n) {\n            if (isPalindrome(i.toString)) {\n                palindromes\
    \ += i\n            }\n        }\n        val even_odd = palindromes.count(n =>\
    \ n % 2 == 0)\n        (even_odd, palindromes.count(n => n % 2 == 1))", "    \
    \    val result = mutable.ListBuffer[(Long, Long)]()\n        for( i <- 1L to\
    \ n by 2){\n            val p = i.toString.reversed\n            if (p != i.toString)\
    \ result += (i -> p::i)\n        }\n        (result.size)", "        // Write\
    \ your code here\n        var evenCount = 1\n        var oddCount = 1\n\n    \
    \    var i = n - 1\n        while (i >= 1) {\n            if (i % 2 == 0) {\n\
    \                evenCount = evenCount + 1\n            } else {\n           \
    \     oddCount = oddCount + 1\n            }\n            i = i / 2\n        }\n\
    \        return (evenCount, oddCount)", "        val res = mutable.ArrayBuffer.empty[Int]\n\
    \        val evens = mutable.ArrayBuffer.empty[Long]\n        val odds = mutable.ArrayBuffer.empty[Long]\n\
    \        var num = 1\n        while (num <= n) { //n : Long\n            var even\
    \ = num % 2\n            num /= 2\n            var odd = num % 2\n           \
    \ num /= 2\n            if (even < evens.length) { //evens : mutable.ArrayBuffer[Long]\n\
    \                evens += even\n            }\n            if (odd < odds.length)\
    \ { //odds : mutable.ArrayBuffer[Long]\n                odds += odd\n        \
    \    }\n            if (even == 0 && odd == 0) {\n                res += evens.length\n\
    \            }\n        }\n        res.toList match {\n            case Nil =>\
    \ (0l, 0l)\n            case head :: tail => (evens.toList, odds.toList)\n   \
    \     }", "        var odd = 1\n        var even = 1\n        for (x <- 1 to n)\
    \ {\n            var rev : String = x.toString.reverse\n            if (rev ==\
    \ rev.reverse) {\n                even = even + 1\n            } else {\n    \
    \            odd = odd + 1\n            }\n        }\n        return (even, odd)",
  "        val ans = mutable.Set[Long]()\n        for(i <- 1 to n){\n            val\
    \ p = palindrome(i)\n            if(p.isEven) ans += i\n            else if(p.isOdd)\
    \ ans += i + 1\n        }\n        ans.size match {\n            case 0 => (0l,\
    \ 0l)\n            case 1 => (1l, 1l)\n            case _ => (ans.size / 2, ans.size\
    \ / 2)\n        }", "        var evenPal = 0\n        var oddPal = 0\n       \
    \ for(i <- 1 to n){\n            if(i % 2 == 0) {\n                evenPal +=\
    \ 1\n            } else if(i % 2 != 0) {\n                oddPal += 1\n      \
    \      }\n        }\n        Tuple2(evenPal, oddPal)", "        val evenPalindrome\
    \ = 0l\n        val oddPalindrome = 0l\n        val i = n\n        while (i <=\
    \ n) {\n            val numStr = i.toString\n            val strReverse = numStr.reverse\n\
    \            val isEven = isEvenPalindrome(numStr)\n            val isOdd = !isEvenPalindrome(numStr)\n\
    \            if (isEven) {\n                evenPalindrome += 1\n            }\
    \ else if (isOdd) {\n                oddPalindrome += 1\n            }\n     \
    \       i += 2\n        }\n        (evenPalindrome, oddPalindrome)", "       \
    \ val evenPalindrome = 0\n        val oddPalindrome = 0\n        val evenPalindromes:\
    \ mutable.Set[Long] = mutable.Set.empty\n        val oddPalindromes: mutable.Set[Long]\
    \ = mutable.Set.empty\n        var j = 0\n        var i = 1\n        var oddPalindromeCount\
    \ = 0\n        while (i<=n) {\n            if (i%2==0 && j%2==0) {\n         \
    \       if (evenPalindromes.contains(i))\n                    oddPalindromeCount\
    \ += 1\n                else\n                    evenPalindromeCount += 1\n \
    \               evenPalindromes += i\n            } else if (i%2!=0 && j%2!=0){\n\
    \                if (oddPalindromes.contains(i))\n                    evenPalindromeCount\
    \ += 1\n                else\n                    oddPalindromeCount += 1\n  \
    \              oddPalindromes += i\n            }\n            i += 1\n      \
    \      j += 1\n        }\n        val result = Tuple2.apply(evenPalindromeCount,\
    \ oddPalindromeCount)\n        return result", "        val evenPalindromes :\
    \ MutableSet[Long] = new mutable.HashSet[Long]\n        val oddPalindromes : MutableSet[Long]\
    \ = new mutable.HashSet[Long]\n        def evenPalindrome(n : Long) : Long = {\n\
    \            if(n <= 0) {\n                return 0\n            } else if(n %\
    \ 2 == 0) {\n                evenPalindromes.add(n)\n                return evenPalindrome(n\
    \ - 1)\n            } else {\n                oddPalindromes.add(n)\n        \
    \        return evenPalindrome(n - 1)\n            }\n        }\n        def oddPalindrome(n\
    \ : Long) : Long = {\n            if(n <= 0) {\n                return 0\n   \
    \         } else if(n % 2 == 0) {\n                return oddPalindrome(n - 1)\n\
    \            } else {\n                evenPalindromes.add(n)\n              \
    \  return oddPalindrome(n - 1)\n            }\n        }\n        if(n <= 0) {\n\
    \            return (0, 0);\n        }\n        val evenPalindrome = evenPalindrome(n)\n\
    \        val oddPalindrome = oddPalindrome(n)\n        return (evenPalindrome,\
    \ oddPalindrome)", "        def even(x: Long) : Boolean = {\n            if (x\
    \ % 2 != 0) true\n            else if (x % 2 == 0 && x != 1) false\n         \
    \   else x\n        }\n        def odd(x: Long) : Boolean = {\n            if\
    \ (x % 2 == 0) true\n            else if (x % 2 != 0 && x != 1) false\n      \
    \      else x\n        }\n        def rec(low: Long, high: Long): Long = {\n \
    \           if (low == high) return even(palindrome(low))\n            else {\n\
    \                val mid = (low + high) / 2\n                rec(low, mid)\n \
    \               rec(mid + 1, high)\n                even(palindrome(low) && palindrome(mid\
    \ - 1) && palindrome(mid) && palindrome(mid + 1))\n            }\n        }\n\
    \        n match {\n            case x if x >= 1 => (even(x), odd(x))\n      \
    \      case x if x <= 10 => rec(0, n)\n            case _ => (0l, 0l)\n      \
    \  }", "        val evenList = List(n, n/2, n/4, n/8, n/16, n/32, n/64, n/128,\
    \ n/256).filter(x => x % 2 == 0).sorted\n        val oddList = List(n, n/2, n/4,\
    \ n/8, n/16, n/32, n/64, n/128, n/256).filter(x => x % 2 == 1).sorted\n      \
    \  evenList.zip(oddList).count(_._1 == _._1 && _._2 == _._1)", "        val evenNum\
    \ = List((n, n)).foldLeft(0l)(_ + _)\n        val oddNum = List((n, n - 2l)).foldLeft(0l)(_\
    \ + _)\n        (evenNum, oddNum)", "        def isPalindrome(x : Long) : Boolean\
    \ = {\n            val left = Math.floor(x / 2)\n            val right = Math.floor((x\
    \ / 2) - 1)\n            (left == right && x == 2 * left + 1) || (left == right\
    \ && x == 2 * left + 2)\n        }\n        def evenEvenCount(x : Long) : Long\
    \ = {\n            val left = x % 2\n            (if (left == 0) 1 else 0) + (if\
    \ (left == 1) 1 else 0)\n        }\n        val result = for (i = 1 until n by\
    \ 2) yield {\n            val x = i * 2\n            if (isPalindrome(x)) {\n\
    \                val left = x % 2\n                (if (left == 0) 1 else 0) +\
    \ (if (left == 1) 1 else 0)\n            } else {\n                0\n       \
    \     }\n        }\n        result.toList", "        val arr = Array.ofDim[Long](n+1)\n\
    \        val evenPalindromes = mutable.HashSet[Long]()\n        val oddPalindromes\
    \ = mutable.HashSet[Long]()\n        // Fill array\n        arr(0) = 0l\n    \
    \    for (i <- 1l..n) arr(i) = (n-i-1) * arr(i-1) + 1\n        // Find even palindromes\
    \ in arr\n        for (i<- 1l..n) if (arr(i) %2 == 0) evenPalindromes += arr(i)\n\
    \        // Find odd palindromes in arr\n        for (i<- 1l..n) if (arr(i) %2\
    \ != 0) oddPalindromes += arr(i)\n        // Return the result as tuple\n    \
    \    (evenPalindromes.size, oddPalindromes.size)", "        val even = List(0.toLong,\
    \ 2, 4)\n        val odd = List(0.toLong, 2, 3, 4, 5, 6, 7, 8, 9, 11)\n      \
    \  val evenAndOdd = even.filter(x => odd.contains(x)).count(x => x == x).toLong\n\
    \        val oddAndEven = odd.filter(x => even.contains(x)).count(x => x == x).toLong\n\
    \        val evenAndOddAndEvenAndOdd = evenAndOdd + oddAndEven\n        val tuple\
    \ = (evenAndOddAndEvenAndOdd, evenAndOddAndEvenAndOdd - evenAndOdd)\n        return\
    \ tuple", "        var count = 1 \n        var even = 1 \n        var odd = 1\
    \ \n        var i = 0\n        var j = 0\n        var k = 0\n\n        while (j\
    \ < n) {\n            k = j;\n            while (k < n) {\n                if\
    \ (k == j) k += 1\n                if (k == i) k += 1\n                if (j ==\
    \ k) j += 1\n                k += 1\n                odd += 1\n            }\n\
    \            i = j\n            j = i\n            count += 1\n        }\n\n \
    \       while (i < n) {\n            k = i\n            while (k < n) {\n    \
    \            if (k == i) k += 1\n                if (j == k) j += 1\n        \
    \        k += 1\n                even += 1\n            }\n            i = j\n\
    \            j = i\n            count += 1\n        }\n\n        ((even, odd),\
    \ (count, count * 2))", "      val even = for (i <- 1 to n) yield {\n        \
    \  val str = i.asString.reverse\n          if (str == i.toString.reverse)\n  \
    \            i\n          else\n              -1\n      }\n      val odd = for\
    \ (i <- 1 to n) yield {\n          if (i % 2 == 0) -1\n          else if (i.toString.reverse\
    \ == i)\n              i\n          else\n              -1\n      }\n      val\
    \ evenOdd = even.zip(odd)\n      val (evenPalCount,oddPalCount) = evenOdd.count(_._1\
    \ == -1)\n      (evenPalCount, oddPalCount)", "        val even = if (n % 2 ==\
    \ 0) 0 else 1\n        val odd = if (n % 2 == 1) 0 else 1\n        val palindromes\
    \ = mutable.ListBuffer.empty[Long]\n        val middle = Math.floor(n/2) + 1\n\
    \        var middleInRange = 0\n        var countEven = 0\n        var countOdd\
    \ = 0\n        // The middle number is greater than or equal to the range\n  \
    \      while (middle <= n) {\n            palindromes += middle\n            middleInRange\
    \ += 1\n            // odd number palindromes\n            if (middle == n.toString.reverse\
    \ && n % 2 != 0) {\n                countOdd += 1\n            }\n           \
    \ // even number palindromes\n            if (middle == n.toString.reverse &&\
    \ n % 2 == 0) {\n                countEven += 1\n            }\n            //\
    \ middle number palindromes\n            if (middle == n.toString.reverse && n\
    \ % 2 != 0 && n % 2 != 1) {\n                palindromes += middle\n         \
    \       middleInRange += 1\n            }\n        }\n        // Even number palindromes\n\
    \        (even * countEven, palendromes.size - countOdd)", "        // Write your\
    \ code here\n        var sum = 0\n        var even = 0\n        var odd = 0\n\
    \        var temp = 0\n        val evenPalindromes = for (i <- 1 to n) yield temp\n\
    \        for (x <- evenPalindromes) {\n            if ((x % 2 == 0) != (temp %\
    \ 2 == 0)) {\n                temp += x\n            }\n            else if (x\
    \ % 2 == 0) {\n                even+=1\n            }\n            else if ((x\
    \ % 2 != 0) != (temp % 2 != 0)) {\n                temp+=x\n            }\n  \
    \          else {\n                odd+=1\n            }\n        }\n        (even,\
    \ odd)", "        def palindromes(n: Long, even: Long, odd: Long): (Long, Long)\
    \ = {\n            if (n == 0 || even == 0 || odd == 0) (0, 0)\n            else\
    \ {\n                val (even1, odd1) = palindromes(n/2, even, odd / 2)\n   \
    \             val (even2, odd2) = palindromes(n - even, even + n/2, odd + (n/2))\n\
    \                (even1 + even2, odd1 + odd2)\n            }\n        }\n\n  \
    \      val (even1, odd1) = palindromes(n, 0, n)\n        val (even2, odd2) = palindromes(n,\
    \ 0, n)\n\n        (even1 + even2, odd1 + odd2)", "        // Find odd palindrome\
    \ candidates\n        var odd = Long.MinValue\n        var even = 0\n        while\
    \ (odd <= n && even < n){\n            odd += 1\n            val rev = n.toString.reverse\n\
    \            val oddPalindrome = rev.substring(0, rev.size - 1).equals(rev)\n\
    \            if (oddPalindrome){ even += 1 }\n        }\n        // Find even\
    \ palindrome candidates\n        var even = Long.MinValue\n        val odds =\
    \ n.toString.reverse.takeWhile(_ == '0').length\n        while (even <= n && even\
    \ < n){\n            even += 1\n            val rev = n.toString.reverse\n   \
    \         val evenPalindrome = rev.substring(0, rev.size - 1).equals(rev)\n  \
    \          if (evenPalindrome){ odd += 1 }\n        }\n        // Combine even\
    \ and odd palindrome candidates\n        ((even, odd))", "        // write your\
    \ code in here\n        val evenNumber = 1l\n        val oddNumber = 2l\n    \
    \    if (n%2 == 0) (oddNumber, evenNumber) else (evenNumber, oddNumber)", "  \
    \      var even = Long.MaxValue\n        var odd = Long.MinValue\n        var\
    \ count = 0\n        while (n>0) {\n            if (n % 2 == 0) {\n          \
    \      count += 1;\n                n /= 2;\n            } else {\n          \
    \      n /= 2;\n            }\n        }\n        while (n>0) {\n            if\
    \ (n % 2 == 0) {\n                even += count;\n                n /= 2;\n  \
    \          } else {\n                odd += count;\n                n /= 2;\n\
    \            }\n        }\n        (even, odd)", "        val evenPalindromes\
    \ = new mutable.HashMap[Int, Long]()\n        val oddPalindromes = new mutable.HashMap[Int,\
    \ Long]()\n        (1 to n) foreach { x =>\n            if (x % 2 == 0) {\n  \
    \              evenPalindromes.update(x, 1)\n            } else {\n          \
    \      oddPalindromes.update(x, 1)\n            }\n        }\n\n        // return\
    \ the number of even and odd integer palindromes respectively.\n        return\
    \ (evenPalindromes.size / 2, oddPalindromes.size / 2)", "        if( n<=1l ||\
    \ n > 1l*11l ) throw new IllegalArgumentException(\"The parameter must be\"+\n\
    \                \" a positive integer and between 1 to 1000000000\")\n      \
    \  val res =mutable.Set.empty[Long]\n        for ( i <- 1l to n-1l ) {\n     \
    \       if ( i%2l == 0 && i.toString.reverse.equals(i.toString.reverse.reverse)\
    \ ) res += i\n        }\n        ( res.size, res.count( _ % 2l ) ) }\n    // end\
    \ def evenOddPalindrome\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\n\
    def oddEvenPalindrome(number : Int) : Boolean = {\n    require(number > 0);\n\n\
    \    if (number < 10) {\n        if (number == 0) true;\n        else {\n    \
    \        var oddNumber = 0;\n            var evenNumber = 0;\n\n            var\
    \ reverseNumber = \"\" + number;\n            reverseNumber.reverse\n\n      \
    \      for (i <- 1 to reverseNumber.length - 2) {\n                if (reverseNumber(i)\
    \ == reverseNumber(i + 1)) {\n                    oddNumber += 1\n           \
    \     } else {\n                    evenNumber += 1\n                }\n     \
    \       }\n\n            if (oddNumber == number) {\n                return true\n\
    \            } else if (evenNumber == number) {\n                return true\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    } else {\n        var tempReverse = \"\";\n        var tempNumber = 0\n \
    \       var number = number;\n\n        while (number > 0) {\n            tempReverse\
    \ = \"\" + number;\n            tempNumber.reverse\n            tempReverse.reverse\n\
    \n            if (tempNumber == tempReverse) {\n                tempNumber +=\
    \ 1\n            } else {\n                tempNumber += 1\n                number\
    \ -= 1\n            }\n        }\n\n        if (tempNumber == number) {\n    \
    \        return true\n        } else {\n            return false\n        }",
  "        var result = ((0l, 0l))\n        var i = 0\n        while(i <= n){\n  \
    \          var countEven = 0\n            var countOdd = 0\n            while(i\
    \ < (n-1)){\n                var j = n-1\n                while(j >= i){\n   \
    \                 if(i % 2 != 0 && i % 2 == j % 2){\n                        countEven\
    \ += 1\n                        j -= 1\n                    }else if(i % 2 ==\
    \ 0 && i % 2 != j % 2){\n                        countOdd += 1\n             \
    \           j -= 1\n                    }else if(i % 2 == 0 && i % 2 == j % 2){\n\
    \                        countEven += 1\n                        j -= 1\n    \
    \                    i -= 1\n                    }\n                }\n      \
    \      }\n            if(countEven != 0){\n                val evenPalindrome\
    \ = countEven + 1l\n                result = result + ((evenPalindrome,evenPalindrome))\n\
    \            }\n            if(countOdd != 0){\n                val oddPalindrome\
    \ = countOdd + 1l\n                result = result + ((oddPalindrome,oddPalindrome))\n\
    \            }\n            i += 1\n        }\n        result", "        val odd\
    \ = n / 2\n        val even = n - odd\n        val oddPalindromes: Set[Long] =\
    \ Set(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 11l)\n        val evenPalindromes: Set[Long]\
    \ = Set(1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 11l, 12l)\n        // oddPalindromes\
    \ - evenPalindromes\n        // oddPalindromes.size % 2 == 0\n        // evenPalindromes.size\
    \ - oddPalindromes.size % 2 == 0\n        (odd, even)", "        var even = n\
    \ + 1;\n        var odd = 2 * n + 1;\n        even = even / 2;\n        odd =\
    \ odd / 2;\n        (even, odd)", "        require(n <= 10, \"input must be less\
    \ than 10\")\n        var even = 0\n        var odd = 0\n        for (i in 1 until\
    \ n) {\n            if (i % 2 == 0) {\n                if (isPalindrome(i)) {\n\
    \                    even += 1\n                }\n            } else {\n    \
    \            if (!isPalindrome(i)) {\n                    odd += 1\n         \
    \       }\n            }\n        }\n        return (even, odd)", "        var\
    \ count = 0\n        var even_count = 0\n        var odd_count = 0\n        \n\
    \        for (x <- 1 to n){\n            val temp = n%10\n            if (temp\
    \ % 2 == 0){\n                even_count += 1\n            }\n            else{\n\
    \                odd_count += 1\n            }\n            \n            if (temp\
    \ == x){\n                count += 1\n            }\n        }\n        \n   \
    \     (even_count, odd_count, (count, even_count, odd_count))", "        var even\
    \ = 0l\n        var odd = 0l\n        val evenPalindrome = mutable.ListBuffer(1l,\
    \ 2l, 3l)\n        val oddPalindrome = mutable.ListBuffer(4l, 6l)\n        \n\
    \        for (i <- 1 to n) {\n            var evenCheck = 0l\n            var\
    \ oddCheck = 0l\n            \n            var evenCount = 0\n            var\
    \ oddCount = 0\n            \n            for (j <- 1 to i) {\n              \
    \  if (evenPalindrome(j) == evenPalindrome(j + 1) && oddPalindrome(j) == oddPalindrome(j\
    \ + 1)) {\n                    if (evenPalindrome(j) == evenCheck) {\n       \
    \                 evenCount += 1\n                    }\n                    if\
    \ (oddPalindrome(j) == oddCheck) {\n                        oddCount += 1\n  \
    \                  }\n                }\n                if (evenPalindrome(i)\
    \ == evenCheck && oddPalindrome(i) == oddCheck) {\n                    if (evenPalindrome(i)\
    \ == evenCheck) {\n                        evenCount += 1\n                  \
    \  }\n                    if (oddPalindrome(i) == oddCheck) {\n              \
    \          oddCount += 1\n                    }\n                }\n         \
    \   }\n            \n            if (evenCount == i) {\n                even +=\
    \ 1\n            }\n            if (oddCount == i) {\n                odd += 1\n\
    \            }\n        }\n        \n        evenPalindrome.toList\n        oddPalindrome.toList",
  "        // write your code in here\n        val res = new Array[Long](2)\n    \
    \    res.clear()\n        val odd = new mutable.HashMap[Long, Long]()\n      \
    \  val even = new mutable.HashMap[Long, Long]()\n        for(i <- 1 to n){\n \
    \           if (i % 2 == 0){\n                even.put(i, 1)\n            }\n\
    \            else{\n                odd.put(i, 1)\n            }\n        }\n\n\
    \        for(i <- 1 to n){\n            if (even.get(i) > 0 & odd.get(i) > 0){\n\
    \                res.update(0, even.get(i) * even.get(i))\n                res.update(1,\
    \ odd.get(i) * odd.get(i))\n            }\n        }\n        Tuple2(res(0), res(1))",
  "        def halfAndCut(n: Long, x: Long): (Int, Int) = {\n            val half\
    \ = n / 2\n            var low = half\n            var high = half\n         \
    \   while (low != 0) {\n                val highCut = math.floorDiv(low, 2)\n\
    \                if (highCut != x) {\n                    high = half\n      \
    \          } else {\n                    low = math.floorDiv(half, 2)\n      \
    \          }\n            }\n            (low, high)\n        }\n        val list\
    \ = (1 to n).map(i => (i, (i))).toList\n        val evenCount = 0\n        var\
    \ odd = 1\n        for (i <- 0 to (list.size - 1)) {\n            val (x, half)\
    \ = list(i)\n            val high = math.floorDiv(x.toLong, 2)\n            val\
    \ low = math.floorDiv(x.toLong / 2, 2)\n            if (high != x) {\n       \
    \         if (odd % 2 == 0) {\n                    evenCount += 1\n          \
    \      } else {\n                    odd += 1\n                }\n           \
    \ }\n            if (low != x) {\n                if (odd % 2 == 0) {\n      \
    \              evenCount += 1\n                } else {\n                    odd\
    \ += 1\n                }\n            }\n        }\n        val even = evenCount\
    \ * 2\n        val odd = odd * 2\n        (even, odd)", "        var countEven\
    \ = 0\n        var countOdd = 0\n        var odd = 1\n        var even = 1\n \
    \       var maxEven = 0\n        var maxOdd = 0\n        var lastEven = 0\n  \
    \      var lastOdd = 0\n        var evenPalindrome = 0\n        var oddPalindrome\
    \ = 0\n        var evenPalindromeNum = 0\n        var oddPalindromeNum = 0\n \
    \       for(i <- 1 to n){\n            if(i % 2 == 0){\n                if(lastEven\
    \ != 0){\n                    if(odd % 2 == 0){\n                        if(evenPalindromeNum\
    \ > 0){\n                            countEven += evenPalindromeNum\n        \
    \                    evenPalindromeNum = 0\n                        }\n      \
    \              }\n                    else{\n                        if(evenPalindromeNum\
    \ > maxEven){\n                            maxEven = evenPalindromeNum\n     \
    \                   }\n                        evenPalindromeNum = 1\n       \
    \             }\n                    lastEven = 0\n                }\n       \
    \         even = even * i\n            }\n            else{\n                if(lastOdd\
    \ != 0){\n                    if(odd % 2 == 1){\n                        if(oddPalindromeNum\
    \ > 0){\n                            countOdd += oddPalindromeNum\n          \
    \                  oddPalindromeNum = 0\n                        }\n         \
    \           }\n                    else{\n                        if(oddPalindromeNum\
    \ > maxOdd){\n                            maxOdd = oddPalindromeNum\n        \
    \                }\n                        oddPalindromeNum = 1\n           \
    \         }\n                    lastOdd = 0\n                }\n            \
    \    odd = odd * i\n            }\n            if(even > maxEven){\n         \
    \       maxEven = even\n            }\n            if(odd > maxOdd){\n       \
    \         maxOdd = odd\n            }\n            if(even == maxEven){\n    \
    \            evenPalindromeNum += 1\n                evenPalindrome += 1\n   \
    \             countEven += 1\n            }\n            if(odd == maxOdd){\n\
    \                oddPalindromeNum += 1\n                oddPalindrome += 1\n \
    \               countOdd += 1\n            }\n        }\n        (countEven, countOdd)",
  "      if(n < 1) return((0l, 0l))\n      val countEven = 0\n      val countOdd =\
    \ 1\n      val evenPalindromes = mutable.Set.empty[Long]\n      val oddPalindromes\
    \ = mutable.Set.empty[Long]\n      val evenPalindromeCount = mutable.Map.empty[Long,\
    \ Int]\n      val oddPalindromeCount = mutable.Map.empty[Long, Int]\n      val\
    \ num = 1\n      while(num < n){\n        if(num % 2 == 0){\n          evenPalindromes\
    \ += num\n          num += 2\n          evenPalindromeCount += num -> 1\n    \
    \    }\n        else{\n          oddPalindromes += num\n          num += 2\n \
    \         oddPalindromeCount += num -> 1\n        }\n        num += 1\n      }\n\
    \      evenPalindromes.foreach(x =>\n        if(evenPalindromeCount.get(x) ==\
    \ 0){\n          countEven++\n        }\n      )\n      oddPalindromes.foreach(x\
    \ =>\n        if(oddPalindromeCount.get(x) == 0){\n          countOdd += 1\n \
    \       }\n      )\n      val (evenCount, evenTotal) =  evenPalindromeCount.toList.sortBy(_._1).reverse.head\n\
    \      val (oddCount, oddTotal) =  oddPalindromeCount.toList.sortBy(_._1).reverse.head\n\
    \      (countEven, countOdd)", "        val odd = math.ceil(n/2).asInstanceOf[Long]\n\
    \        val even = n.toDouble - odd\n        val evenPal = new mutable.HashSet[Long]()\n\
    \        evenPal.add(even)\n        val oddPal = new mutable.HashSet[Long]()\n\
    \        oddPal.add(odd)\n        val evenOddPalindromes = new mutable.HashSet[Tuple2[Long,\
    \ Long]]()\n        var i = 0\n        var j = 0\n        while (i < evenPal.size\
    \ || j < oddPal.size) {\n            if (evenPal.contains(i) && oddPal.contains(j))\
    \ {\n                evenOddPalindromes += ((i,j))\n                i += 1\n \
    \               j += 1\n            } else if (j == oddPal.size) {\n         \
    \       j += 1\n            }\n        }\n        return (evenOddPalindromes.size,\
    \ evenOddPalindromes.size)", "        val evenPal = new mutable.HashMap[Long,\
    \ Long]()\n        val oddPal = new mutable.HashMap[Long, Long]()\n        val\
    \ palindromes = Seq.fill(n) { (new scala.util.Random).nextInt(10l) }\n       \
    \ for (i <- palindromes.indices) {\n            val num = palindromes(i)\n   \
    \         val left = if (num % 2 == 0) num / 2 else num / 2 + 1\n            val\
    \ right = if (num % 2 == 1) num / 2 else num / 2 - 1\n            evenPal.put(i,\
    \ num)\n            oddPal.put(i, num)\n        }\n\n        for ((eP, oP) <-\
    \ evenPal.toIterator ++ oddPal.toIterator) {\n            val l = if (eP < oP)\
    \ eP else oP\n            val r = if (eP < oP) oP else eP\n            if (l <=\
    \ n && n <= r)\n                return (l + r).toLong, eP.toLong\n        }\n\
    \        0l, 0l", "        if(n < 1 ) throw new IllegalArgumentException(\"n is\
    \ too small\")\n        if(n > 10^3) throw new IllegalArgumentException(\"n is\
    \ too large\")\n        def helper(a : Long, b : Long) : Tuple2[Long, Long] =\
    \ {\n            if(a > b) (a,b) else if (a == b) (a,a) else (helper(a+1, b),\
    \ helper(a+1, b+1))\n        }\n        helper(1, n)", "        var result = Tuple2(Long(0),\
    \ Long(0))\n        var odd = 1\n        var even = 1\n\n        while ( n !=\
    \ 0 ) {\n            if ( n % 2 == 0 ) {\n                even += odd // odd\n\
    \                odd += odd // even\n            } else if ( n % 2 == 1 ) {\n\
    \                even += even\n                odd += even\n            }\n  \
    \          n /= 2\n        }\n        result = (even, odd)\n        result", " \
    \       val low = 1 to n\n        val high = low to n\n\n        val even = new\
    \ mutable.ListBuffer[Long]()\n        val odd = new mutable.ListBuffer[Long]()\n\
    \n        for (x <- low) {\n            if (isPalindrome(x)) {\n             \
    \   for (y <- high) {\n                    val s = x + y\n                   \
    \ if (isPalindrome(s)) {\n                        if (s == x) odd.append(y)\n\
    \                        else even.append(y)\n                        break\n\
    \                    }\n                }\n            }\n        }\n        val\
    \ ans = if (even.isEmpty) odd.toList\n        else even.toList\n\n        ans\
    \ ++ Tuple2(even.size, odd.size)", "        if(n < 1 || n > 10^3) throw new IllegalArgumentException(\"\
    n must be 1 <= n <= 10^3\")\n        val odd = 1\n        val even = 0\n     \
    \   val res = new mutable.Queue[Long]()\n        val p = new mutable.PriorityQueue[Long]()\n\
    \        while(n > 0) {\n            p.enqueue(n)\n            n -= 1\n      \
    \  }\n        while(p.nonEmpty && p.peek() != 0) {\n            val cur = p.dequeue()\n\
    \            if((cur % 2 == 0) && p.nonEmpty) res.enqueue(p.dequeue())\n     \
    \       if(cur % 2 == 1) res.enqueue(p.dequeue())\n            if(cur < even)\
    \ {\n                even -= 1\n                if(p.nonEmpty && p.peek() != 0)\
    \ {\n                    res.enqueue(p.dequeue())\n                }\n       \
    \     } else {\n                odd -= 1\n                if(p.nonEmpty && p.peek()\
    \ != 0) {\n                    res.enqueue(p.dequeue())\n                }\n \
    \           }\n        }\n        (even, odd)", "        require(n <= 10^3)\n\
    \        require(n > 0)\n        if (n <= 3L) {\n            val evenPalindromes\
    \ = mutable.ListBuffer.empty[Long]\n            val oddPalindromes = mutable.ListBuffer.empty[Long]\n\
    \            if (n <= 3L) {\n                val evenPalindromes = (1 to n).filter(n\
    \ => (n % 2) == 0).map(i => i).map(i => 2 * i).toArray\n                val oddPalindromes\
    \ = (1 to n).filter(n => (n % 2) == 1).map(i => i).map(i => 2 * i).toArray\n \
    \               (evenPalindromes.toList, oddPalindromes.toList)\n            }\
    \ else if (n > 3L) {\n                val evenPalindromes = (1 to n).filter(n\
    \ => (n % 2) == 0).map(i => i).map(i => 2 * i).toArray\n                val oddPalindromes\
    \ = (1 to n).filter(n => (n % 2) == 1).map(i => i).map(i => 2 * i).toArray\n \
    \               (evenPalindromes.toList, oddPalindromes.toList)\n            }\
    \ else if (n == 3L) {\n                (0 to 2).filter(i => i % 2 == 0).map(i\
    \ => 2 * i).toList\n            } else if (n == 4L) {\n                (0 to 2).filter(i\
    \ => i % 2 == 0).map(i => 2 * i).toList\n            } else {\n              \
    \  val evenPalindromes = (1 to n).filter(n => (n % 2) == 0).map(i => i).map(i\
    \ => 2 * i).toArray\n                val oddPalindromes = (1 to n).filter(n =>\
    \ (n % 2) == 1).map(i => i).map(i => 2 * i).toArray\n                (evenPalindromes.toList,\
    \ oddPalindromes.toList)\n            }\n        } else {\n            val evenPalindromes\
    \ = (1 to n).filter(n => (n % 2) == 0).map(i => i).map(i => 2 * i).toArray\n \
    \           val oddPalindromes = (1 to n).filter(n => (n % 2) == 1).map(i => i).map(i\
    \ => 2 * i).toArray\n            (evenPalindromes.toList, oddPalindromes.toList)\n\
    \        }", "        var evenPalindromes = 0\n        var oddPalindromes = 0\n\
    \        val max = (n * (n+1))/2\n        for (i <- 1 to max) {\n            if\
    \ ((i % 2) == 0) {\n                evenPalindromes += 1\n            }\n    \
    \        val odd = i / 2\n            val even = i % 2\n            if (odd ==\
    \ even) {\n                evenPalindromes += 1\n            }\n        }\n  \
    \      (n,evenPalindromes,oddPalindromes)", "        val odd = scala.util.ArrayBuffer.empty[Long]\n\
    \        val even = scala.util.ArrayBuffer.empty[Long]\n        val odd = scala.util.ArrayBuffer.empty[Long]\n\
    \        val even = scala.util.ArrayBuffer.empty[Long]\n        for (i<-0 to (n-1))\
    \ {\n            val str = i.toString\n            for (j<-0 to (str.length-1))\
    \ {\n                if(j%2 == 0) {\n                    even += str.charAt(j)\n\
    \                }\n                else {\n                    odd += str.charAt(j)\n\
    \                }\n            }\n        }\n        Tuple2(even.toList, odd.toList)",
  "        var even = 0, odd = 0, palindromeEven = 0, palindromeOdd = 0\n        val\
    \ odd_count = scala.collection.mutable.Queue[Long]()\n        val even_count =\
    \ scala.collection.mutable.Queue[Long]()\n        // first add odd to odd_count\n\
    \        for (x <- 1 to n-1) {\n            if (x % 2 != 0) {\n              \
    \  odd_count += x\n            }\n        }\n        // now add even to even_count\n\
    \        for (x <- 0 to n-2) {\n            if (x % 2 == 0) {\n              \
    \  even_count += x\n            }\n        }\n        while (odd_count.size >\
    \ 0) {\n            if (odd_count.head % 2 == 0 && even_count.size >= 1) {\n \
    \               even = even + 1\n                even_count -= 1\n           \
    \ } else {\n                odd = odd + odd_count.head\n                odd_count\
    \ -= 1\n            }\n        }\n        while (even_count.size > 0) {\n    \
    \        if (odd_count.size >= 1) {\n                palindromeEven = palindromeEven+1\n\
    \            } else {\n                palindromeOdd = palindromeOdd+1\n     \
    \       }\n            even_count -= 1\n        }\n        // return tuple that\
    \ has the number of even and odd integer palindromes respectively\n        (even,\
    \ odd)", "        if (n < 1) (-1l, -1l)\n        if (n <= 9l) (1l, 2l) // no palindromes\
    \ with length less than 6\n        val evenPalindromes = n\n        val oddPalindromes\
    \ = n\n        val oddEvenPalindromes = n\n        val oddEvenPalindromesPerSecond\
    \ = n / 2\n        val evenEvenPalindromesPerSecond = n - oddEvenPalindromesPerSecond\n\
    \        val evenPalindromesPerSecond = (evenPalindromes - evenEvenPalindromesPerSecond)\
    \ / evenEvenPalindromesPerSecond\n        val oddPalindromesPerSecond = (oddPalindromes\
    \ - evenPalindromesPerSecond) / evenPalindromesPerSecond\n        val evenEvenPalindromesPerSecond\
    \ = (evenEvenPalindromes - oddEvenPalindromesPerSecond) / oddEvenPalindromesPerSecond\n\
    \        val oddEvenPalindromesPerSecond = (oddEvenPalindromes - evenEvenPalindromesPerSecond)\
    \ / evenEvenPalindromesPerSecond\n        val evenEvenPalindromesPerSecond = (evenEvenPalindromes\
    \ - oddEvenPalindromesPerSecond) / oddEvenPalindromesPerSecond\n        val oddEvenPalindromesPerSecond\
    \ = (oddEvenPalindromes - evenEvenPalindromesPerSecond) / evenEvenPalindromesPerSecond\n\
    \        val evenEvenPalindromesPerSecond = (evenEvenPalindromes - oddEvenPalindromesPerSecond)\
    \ / oddEvenPalindromesPerSecond\n        val oddEvenPalindromesPerSecond = (oddEvenPalindromes\
    \ - evenEvenPalindromesPerSecond) / evenEvenPalindromesPerSecond\n        val\
    \ evenEvenPalindromesPerSecond = (evenEvenPalindromes - oddEvenPalindromesPerSecond)\
    \ / oddEvenPalindromesPerSecond\n        val oddEvenPalindromesPerSecond = (oddEvenPalindromes\
    \ - evenEvenPalindromesPerSecond) / evenEvenPalindromesPerSecond\n        val\
    \ evenEvenPalindromesPerSecond = (evenEvenPalindromes - oddEvenPalindromesPerSecond)\
    \ / oddEvenPalindromesPerSecond\n        val oddEvenPalindromesPerSecond = (oddEven",
  "        def palindrome(x: Long) : Long = {\n            if (x == 0) 1\n       \
    \     else {\n                val rev = reverse(x)\n                if (rev ==\
    \ x) 1 else 0\n            }\n        }\n        // Use mutable hash set to eliminate\
    \ duplicate odd numbers below n.\n        val oddSet = mutable.HashSet[Long]()\n\
    \        oddSet.add(1)\n        oddSet.add(2)\n        oddSet.add(3)\n       \
    \ oddSet.add(4)\n        oddSet.add(5)\n        oddSet.add(6)\n        oddSet.add(7)\n\
    \        oddSet.add(8)\n        oddSet.add(9)\n        oddSet.add(10)\n      \
    \  oddSet.add(11)\n        var even = 0\n        var odd = 0\n        var total\
    \ = 0\n        while (even < n && odd < n) {\n            total += palindrome(even)\n\
    \            even += palindrome(even)\n            odd += palindrome(odd)\n  \
    \      }\n        (even, odd)", "        val evenCount = 0\n        val oddCount\
    \ = 0\n        for (i <- 1 to n){\n            val str = scala.math.factorial(i).toString.toUpperCase\n\
    \            val revStr = str.reverse\n            if (revStr == str){\n     \
    \           if (revStr.length % 2 != 0){\n                    evenCount+=1\n \
    \               }\n                if (revStr.length % 2 == 0){\n            \
    \        oddCount+=1\n                }\n            }\n        }\n        (evenCount,\
    \ oddCount)", "        def palindromes(i: Long, j: Long): List[Long] = {\n   \
    \         if (i == j) List(1l)\n            else {\n                val even =\
    \ if (i.toString == j.toString) 1l else 0l\n                val odd = if (i.toString\
    \ != j.toString) 1l else 0l\n                if (even % 2 == 1 && odd % 2 == 1)\
    \ List(1l, even + odd)\n                else palindromes(i + 1, j - 1)\n     \
    \       }\n        }\n        val even = if (n.toString.charAt(0).toInt == n.toString.charAt(n.toString.length\
    \ - 1).toInt) 1l else 0l\n        val odd = if (n.toString.charAt(0).toInt !=\
    \ n.toString.charAt(n.toString.length - 1).toInt) 1l else 0l\n        if (even\
    \ % 2 == 1 && odd % 2 == 1) (even + odd, 1l)\n        else {\n            val\
    \ m = n.toString.length\n            val a = Array.ofDim[Long](m)\n          \
    \  a.fill(even)\n            a[m - 1] = 0l\n            Array.ofDim[Long](m).zip(Array.ofDim[Long](m)).foreach(x\
    \ => a(x._1) = x._2)\n            a[m - 1] = 0l\n            palindromes(1l, m).zip(even).foreach(x\
    \ => a(x._1) = x._2)\n            a\n        }", "        val even = math.floor(n/2)\n\
    \        val odd = n-even\n\n        (even,odd)", "        // write code here\n\
    \        val evenPalindromes = mutable.List.empty[Long]\n        val oddPalindromes\
    \ = mutable.List.empty[Long]\n        val evenPalindromeIndex = mutable.ListBuffer[Long]()\n\
    \        val oddPalindromeIndex = mutable.ListBuffer[Long]()\n\n        for(i\
    \ <- 1 to n) {\n            for(j <- 0 to (n / 2) + 1) {\n                if(i\
    \ == j)\n                    evenPalindromeIndex += i\n                else\n\
    \                    oddPalindromeIndex += i\n            }\n        }\n\n   \
    \     val evenPalindromeNum = evenPalindromeIndex.count {i => i <= n}\n      \
    \  val oddPalindromeNum = oddPalindromeIndex.count {i => i <= n}\n        \n \
    \       if(evenPalindromeNum != 0)\n            (evenPalindromeNum, evenPalindromes)\n\
    \        else\n            (oddPalindromeNum, oddPalindromes)", "        if(n\
    \ < 1 || n > 10^3) throw new IllegalArgumentException\n        var even = 0\n\
    \        var odd = 0\n        for(i <- 1 to n) {\n            val tempEven = i\
    \ mod 2\n            val tempOdd = (i - (tempEven + 1)) mod 2\n            if(tempEven\
    \ != tempOdd) even += 1\n            else odd += 1\n        }\n        (even,\
    \ odd)", "        require(n >= 1l, \"n should be positive\")\n        require(n\
    \ <= 10l, \"n should be less than 10^3\")\n        val result = new mutable.HashSet[Long]()\n\
    \        val arr = new Array[Long](n)\n        for(i <- 0 to (arr.length - 1))\
    \ {\n            arr(i) = (i + 1l)\n        }\n        var evenPal = 0\n     \
    \   var oddPal = 0\n        for(i <- 0 to (arr.length - 1)) {\n            val\
    \ num = (arr(i) - 1l)\n            if(num.isEven) {\n                evenPal +=\
    \ 1\n            }\n            if(num.isOdd) {\n                oddPal += 1\n\
    \            }\n            if(evenPal > oddPal) {\n                result.add(num)\n\
    \            }\n        }\n        result.size\n        val tuple = result.iterator.toTuple2\n\
    \        tuple._1 -> tuple._2", "        // Your code goes here\n        val m\
    \ = n / 2\n        val odd = n % 2 == 1\n        val even = n % 2 == 0\n     \
    \   val list = List[Long](1l, 2l, 3l, 4l, 5l, 6l, 7l, 8l, 9l, 10l)\n        var\
    \ evencount = 0\n        var oddcount = 0\n        list.foreach { x =>\n     \
    \       val reverse = reverse(x, m)\n            if(even && reverse == x) {\n\
    \                evencount += 1\n            } else if(odd && reverse == x) {\n\
    \                oddcount += 1\n            }\n        }\n        if(even) {\n\
    \            (1l, evencount)\n        } else {\n            (oddcount, oddcount\
    \ + evencount)\n        }", "        def evenOddPalindrome(n: Long, even: Long,\
    \ odd: Long) : Unit = {\n            val isEven = n % 2 == 0\n            val\
    \ isOdd = !isEven\n            if (n == 0 || isEven && isOdd) ()\n           \
    \ else if (n == 1 || isOdd && isEven) ()\n            else if (isEven)\n     \
    \       {\n                even += n\n                if (isOdd)\n           \
    \         odd += n\n                else\n                    evenOddPalindrome(n,\
    \ even, odd)\n            }\n            else (if (isOdd) ()\n            else\
    \ evenOddPalindrome(n, even, odd))\n        }\n        if (n <= 0) ()\n      \
    \  else evenOddPalindrome(n, 1, 0)", "        val evenPalindromeNum: mutable.Map[Long,\
    \ Long] = mutable.HashMap.empty[Long, Long]\n        val oddPalindromeNum: mutable.Map[Long,\
    \ Long] = mutable.HashMap.empty[Long, Long]\n        for (i <- 1 to n) yield {\n\
    \            val rev = Long.reverse(i)\n            if (i % 2 == 0) {\n      \
    \          if (rev == i) i -> (i + 1l)\n                else i -> (i - 1l)\n \
    \           } else if (i % 2 == 1L) {\n                if (rev == i) i -> (i +\
    \ 1l)\n                else i -> (i - 1l)\n            } else {\n            \
    \    if (evenPalindromeNum.contains(rev)) evenPalindromeNum(rev) += 1\n      \
    \          else oddPalindromeNum(rev) += 1\n            }\n        }\n       \
    \ val evenPalindromes: mutable.Iterable[Long] = evenPalindromeNum.keys\n     \
    \   val oddPalindromes: mutable.Iterable[Long] = oddPalindromeNum.keys\n     \
    \   Tuple2(evenPalindromes.sum, oddPalindromes.sum)", "        require(n > 0);\n\
    \        var evenPalindrome = 0\n        var oddPalindrome = 0\n        // For\
    \ odd number <= 10^3, we get odd palindrome number count by using the following\
    \ formula:\n        // even palindrome number count is (n / 2) * 2 - 1 where n\
    \ = 10^3 * 2^i\n        // Example: n = 10^3 * 2^0, n = 10^3 * 2^1\n        for(i\
    \ <- 0 until Int((Math.pow(n,2)-1)/2) ) {\n            val tmpN = (10*Math.pow(n,2)).toInt\n\
    \            val evenPalindromeCount = (tmpN/2) * 2 - 1\n            val oddPalindromeCount\
    \ = tmpN - evenPalindromeCount\n            evenPalindrome += evenPalindromeCount\n\
    \            oddPalindrome += oddPalindromeCount\n        }\n        return Tuple2(evenPalindrome,\
    \ oddPalindrome)", "        require(n >= 1, \"n should be positive\")\n      \
    \  require(n > 0, \"n should be positive\")\n        val a = Array[Long](n-1)\n\
    \        val odd = a.toList\n        val even = odd.filter(_ % 2 == 0)\n     \
    \   odd.filter(_ % 2 == 0).foreach { x => if (x == a.reverse.tail.head) {\n  \
    \          odd.remove(x)\n            even.remove(x)\n        }}\n        val\
    \ odd_count = odd.size\n        val even_count = even.size\n        Tuple2((even_count,\
    \ odd_count))", "        require(1 <= n <= 10^3, \"The range of input is 1-10^3\"\
    )\n        val even = 0\n        val odd = 0\n        var i = 2\n        while(i\
    \ <= n){\n            if(isPalindrome(n.toString.toInt - i)){\n              \
    \  even = even + 1\n                i = i + 2\n            }\n            else{\n\
    \                odd = odd + 1\n                i = i + 2\n            }\n   \
    \     }\n        (even, odd)", "        var even = 0\n        var odd = 0\n  \
    \      for(i <- 1 to n) {\n            val s = i.toString\n            val l1\
    \ = s.toList.reverse.mkString\n            val l2 = s.reverse.mkString\n     \
    \       if(l1 == l2)\n                even += 1\n            else odd += 1\n \
    \       }\n        (even, odd)", "        var even = 0\n        var odd = 0\n\
    \        for (i <- 1l to n){\n            val temp = i.toString.reverse\n    \
    \        if (i.toString.equals(temp)) {\n                even += 1\n         \
    \   } else {\n                odd += 1\n            }\n        }\n        return\
    \ Tuple2(even, odd)", "        val palindromes = mutable.ListBuffer[Long]()\n\
    \        for (i <- 1 to n) {\n            val reverse = i.toString.reverse\n \
    \           if (reverse == i) {\n                palindromes += i\n          \
    \  } else if (reverse.startsWith(i)) {\n                palindromes += i\n   \
    \         } else if (reverse.endsWith(i)) {\n                palindromes += i\n\
    \            }\n        }\n        val evenPalindromes = palindromes.filter(x\
    \ => x % 2 == 0)\n        val oddPalindromes = palindromes.filter(x => x % 2 !=\
    \ 0)\n        (evenPalindromes.size, oddPalindromes.size)"]
stop_tokens:
- "\n    }\n"
