language: scala
name: HumanEval_130_tri
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 1) \n            List(n.toLong)\n        else {\n          \
    \  val (first,second) = tri(n - 1) + tri(n - 2) + tri(n + 1)\n            second\
    \ :: first :: second \n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp16lqblx9.scala:24:44 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m (first,second) = tri(n - \e\
    [31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue +\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp16lqblx9.scala:24:17 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m (first,second) = tri(n - \e\
    [31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                 ^\e[0m\n\e[31m   |\e[0m                 Recursive \e[33mvalue\e\
    [0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp16lqblx9.scala:24:23 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33mval\e[0m (first,second) = tri(n - \e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \          ^\e[0m\n\e[31m   |\e[0m                       Recursive \e[33mvalue\e\
    [0m \e[35m$1$\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var l = List (3L) \n        while ( l size < n) l.add (l.last.plus (\
    \ n / 2L )) \n        l\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7rzxs4pq.scala:22:26 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mwhile\e[0m ( l size < n) l.add (l.last.plus\
    \ ( n / \e[31m2L\e[0m )) \n\e[31m\e[31m   |\e[0m                          ^\e\
    [0m\n\e[31m   |\e[0m                          expression expected but \e[31m')'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7rzxs4pq.scala:22:23\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mwhile\e[0m\
    \ ( l size < n) l.add (l.last.plus ( n / \e[31m2L\e[0m )) \n\e[31m\e[31m   |\e\
    [0m                       ^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ <\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp7rzxs4pq.scala:22:18\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mwhile\e\
    [0m ( l size < n) l.add (l.last.plus ( n / \e[31m2L\e[0m )) \n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                \e[33mmethod\e\
    [0m \e[35msize\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7rzxs4pq.scala:22:30\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mwhile\e[0m\
    \ ( l size < n) l.add (l.last.plus ( n / \e[31m2L\e[0m )) \n\e[31m\e[31m   |\e\
    [0m                            ^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         value add is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp7rzxs4pq.scala:22:42 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mwhile\e[0m ( l size < n) l.add (l.last.plus ( n / \e[31m2L\e\
    [0m )) \n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value plus is not a member\
    \ of Long\n5 errors found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = new mutable.LinkedList[Long]()\n        list += (3l)\n   \
    \     n match {\n            case n if n >= 1 => list += (1l)\n            case\
    \ n if n % 2 == 0 => list += (n / 2l)\n            case n => list += ((n - 1)\
    \ + n / 2l)\n        }\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvl6k77cq.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.LinkedList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var l1 = n / 2\n        var l2 = (l1 + l1) / 2\n        var l3 = l2 +\
    \ l1 + l2\n        l3.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmkerjt4x.scala:24:11 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        l3.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value toList is not a member of Long - did you mean\
    \ Long.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1659979920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list1 = ListBuffer[Long](1L)\n        val list2 = ListBuffer[Long](3L)\n\
    \        val list3 = ListBuffer[Long](2L)\n        val list4 = ListBuffer[Long](8L)\n\
    \        for (i <- 1 to n) {\n            list1 += i\n            list2 += tri(n\
    \ - i)\n            list3 += tri(n - i) + tri(n - i - 1)\n            list4 +=\
    \ tri(n - i) + tri(n - i - 1) + tri(n - i + 1)\n        }\n        list3.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsitbbazk.scala:25:23\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m to n) {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       Found:    (n : Long)\n\e[31m   |\e[0m    \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsitbbazk.scala:27:24 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            list2 += tri(n - i)\n\e[31m\e[31m   |\e[0m               \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:    \e[1m\e\
    [31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m         \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpsitbbazk.scala:28:32 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m            list3 += tri(n - i) + tri(n - i - \e[31m1\e[0m)\n\e[31m\e[31m \
    \  |\e[0m                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpsitbbazk.scala:29:32 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            list4 += tri(n - i) + tri(n - i - \e[31m1\e\
    [0m) + tri(n - i + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import mat"
  stdout: ''
  timestamp: 1659979922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triHelper(n: Long, acc: Long): Long = {\n            acc match {\n\
    \                case 2 => acc.toLong\n                case 1 => acc.toLong\n\
    \                case n => triHelper(n - 1, acc) + triHelper(n - 2, acc + n.toLong)\n\
    \            }\n        }\n        val result = new ArrayList[Long]()\n      \
    \  result ::= triHelper(n, 3l.toLong)\n        return result.toList.map(_.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ljy890n.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val l = n % 2 == 0\n        val f = (if (l) 1L else 2L) + n\n       \
    \ val res = List(f,f+f,f+f+f)\n        if (n<2) res\n        else res + tri(n-1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphbp9snp7.scala:25:17 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33melse\e[0m res + tri(n-\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m             ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = List[Long]()\n        if (n <= 3) {\n            list += n\
    \ toLong\n        }\n        else {\n            list += n / 2 toLong\n      \
    \      list += n / 2 toLong\n            list += n + 1 toLong\n        }\n   \
    \     list\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpr2j1vz3s.scala:23:28 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            list += n toLong\n\e[31m\e[31m   |\e[0m \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \  expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmpr2j1vz3s.scala:28:32 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            list += n + \e[31m1\e[0m toLong\n\e[31m\e\
    [31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m         \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr2j1vz3s.scala:23:17 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            list += n toLong\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a member of\
    \ List[Long] - did you mean list.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr2j1vz3s.scala:26:17\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            list += n / \e\
    [31m2\e[0m toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m          value += is not a member of List[Long] - did you mean list.!=?\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmpr2j1vz3s.scala:26:26 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            list += n / \e[31m2\e[0m toLong\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \          \e[33mmethod\e[0m \e[35mtoLong\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      var x = 1\n      var y = 1\n      val newList = new Array[Long](n)\n  \
    \    newList(0) = y\n      newList(1) = x\n      newList(n) = x + y + (newList(n\
    \ - 1) +  newList(n - 2) +  newList(n - 3))\n      newList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb6nkd_lv.scala:23:36\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m      \e[33mval\e[0m \e[36mnewList\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e\
    [0m                                    ^\e[0m\n\e[31m   |\e[0m               \
    \                     Found:    (n : Long)\n\e[31m   |\e[0m                  \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb6nkd_lv.scala:26:14 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m      newList(n) = x + y + (newList(n - \e[31m1\e[0m) +  newList(n - \e\
    [31m2\e[0m) +  newList(n - \e[31m3\e[0m))\n\e[31m\e[31m   |\e[0m             \
    \ ^\e[0m\n\e[31m   |\e[0m              Found:    (n : Long)\n\e[31m   |\e[0m \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb6nkd_lv.scala:26:36 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m      newList(n) = x + y + (newList(n - \e[31m1\e[0m) +  newList(n - \e\
    [31m2\e[0m) +  newList(n - \e[31m3\e[0m))\n\e[31m\e[31m   |\e[0m             \
    \                       ^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \          Found:    Long\n\e[31m   |\e[0m                                   \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb6nkd_lv.scala:26:54\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m      newList(n) = x + y + (newList(n\
    \ - \e[31m1\e[0m) +  newList(n - \e[31m2\e[0m) +  newList(n - \e[31m3\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                                      ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb6nkd_lv.scala:26:72\
    \ -----------------"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = mutable.ArrayBuffer.empty[Long]\n        if (n.toInt % 2 ==\
    \ 0) list.toList ++= 0 +: tri(n.toInt/2)\n        else list.toList ++= 1 +: tri(n.toInt/2\
    \ + 1)\n        list.toList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp274ojh9c.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = 1 + n / 2\n        if (n % 2 == 0) {\n            n / 2\n   \
    \     } else {\n            tri(n-1) + tri(n-2) + tri(n+1)\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkpgqtkx9.scala:23:12\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            n / \e[31m2\e[0m\n\
    \e[31m\e[31m   |\e[0m            ^^^^^\e[0m\n\e[31m   |\e[0m            Found:\
    \    Long\n\e[31m   |\e[0m            Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpkpgqtkx9.scala:25:21 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m            tri(n-\e[31m1\e[0m) + tri(n-\e[31m2\e[0m) + tri(n+\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 0) Nil\n        else n match {\n            case 0 => List(1L,\
    \ 0L, 0L)\n            case 1 => List(3L, 2L, 1L)\n            case n => tri(n-1)\
    \ + tri(n-2) + tri(n+1)\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6kllbsbu.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mcase\e[0m n => tri(n-\e[31m1\e[0m)\
    \ + tri(n-\e[31m2\e[0m) + tri(n+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 3) {\n            List[Long](n, n, n).reverse\n        } else\
    \ if (n >= 3) {\n            val n2 = n - 2\n            val n3 = n + 3\n    \
    \        val n1 = 3n\n            val n4 = (1 + n2).max(1)(2) + ((n3 - n).max(n4).max(1))\n\
    \            val n5 = (1 + n3).max(1)(2)\n            val n6 = (1 + n4).max(1)(2)\n\
    \            List(n1, n4, n5, n6)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxr280bbf.scala:26:23 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mn1\e[0m = \e[31m3\e\
    [0mn\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m    \
    \                   expression expected but \e[31mend of statement\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpxr280bbf.scala:27:33 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mn4\e[0m = (\e[31m1\e\
    [0m + n2).max(\e[31m1\e[0m)(\e[31m2\e[0m) + ((n3 - n).max(n4).max(\e[31m1\e[0m))\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \              \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mclass\e[0m \e[35mRichLong\e\
    [0m does not take more parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpxr280bbf.scala:28:33 -----------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            \e[33mval\e[0m \e[36mn5\e[0m = (\e[31m1\e[0m + n3).max(\e\
    [31m1\e[0m)(\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mclass\e\
    [0m \e[35mRichLong\e[0m does not take more parameters\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // This is O(N) because we are iterating through every number in the\
    \ sequence \n        // which means we are iterating through every power of two\
    \ until we get to the \n        // point where n is even (n / 2 is even).\n  \
    \      var result: List[Long] = List(1, n)\n        while (result.length < n)\
    \ result = result ::: (List(result.last.toLong + result.last.toLong + result.last.toLong,\
    \ result.last.toLong + result.last.toLong, result.last.toLong + result.last.toLong))\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqkjvj_mi.scala:29)\n\tat Problem.main(tmpqkjvj_mi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case 0 => List(1l)\n            case n if n <=\
    \ 1 => List(n.toLong)\n            case n if n % 2 == 0 =>\n                val\
    \ left = tri(n - 2).toList\n                val right = tri(n - 1).toList\n  \
    \              left.reverse ::: right\n            case n => tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmik3kiq4.scala:28:33 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mcase\e[0m n => tri(n - \e[31m1\e[0m)\
    \ + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of\
    \ List[Long], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1l.toLong)\n        else if (n % 2 == 0) List(3l.toLong,\
    \ 1l.toLong)\n        else tri(n-1)  ++ tri(n-1) + tri(n+1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkrjp9pv_.scala:23:35 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n-\e[31m1\e[0m)  ++ tri(n-\e\
    [31m1\e[0m) + tri(n+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n > 0);\n        val t0 = 2l;\n        val t1 = (1l + 1l) / 2;\n\
    \        val t2 = ((1l - 1l + 1l - 2l) / 3) + t1\n        val result = List(t0,\
    \ t2, n + 1l);\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph8747dlx.scala:29)\n\tat Problem.main(tmph8747dlx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val tria = 3L\n        var listTrib = new mutable.ListBuffer[Long]()\n\
    \        for(i <- 0 until n) listTrib += tria + tria + tria\n        listTrib.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqaaggdfy.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mlistTrib\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqaaggdfy.scala:23:25\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m0\e[0m until n) listTrib += tria + tria + tria\n\e[31m\e[31m   |\e[0m    \
    \                     ^\e[0m\n\e[31m   |\e[0m                         Found: \
    \   (n : Long)\n\e[31m   |\e[0m                         Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n==0) List(3l.toLong)\n        if(n==1) List(1l.toLong)\n        if(n==2)\
    \ List(2l.toLong)\n        if(n%3 == 0) List(tri(n.toInt-1) + tri(n.toInt-2) +\
    \ tri(n.toInt+1))\n        else List(tri(n.toInt-1) + tri(n.toInt-2))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoqnfm4uv.scala:24:41 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m(n%\e[31m3\e[0m == \e[31m0\e[0m)\
    \ List(tri(n.toInt-\e[31m1\e[0m) + tri(n.toInt-\e[31m2\e[0m) + tri(n.toInt+\e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpoqnfm4uv.scala:25:33 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33melse\e[0m List(tri(n.toInt-\e[31m1\e[0m) + tri(n.toInt-\e\
    [31m2\e[0m))\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979922
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 3l)\n            return List(1l, 3l)\n        if (n % 2 == 0)\n\
    \            return List(1l, tri(n / 2)(1) + tri(n / 2)(2))\n        else\n  \
    \          return List(tri(n - 1)(1) + tri(n - 1)(2) + tri(n / 2)(1))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 2\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.tri(tmp5ae9q5jx.scala:26)\n\tat Problem$.main(tmp5ae9q5jx.scala:29)\n\
    \tat Problem.main(tmp5ae9q5jx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      val r = mutable.MutableList[Long]()\n      r += n.toLong\n      n match\
    \ {\n        case x if x < 3 => r\n        case x if x > 3 =>\n          val n1\
    \ = (n-1).toLong\n          val n2 = (n-2).toLong\n          val n3 = n+1.toLong\n\
    \          n1 +: n2 +: n3 +: r.reverse\n        case _ =>\n      }\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf8p5jvgv.scala:21:14 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      \e[33mval\e[0m \e[36mr\e[0m = mutable.MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m              Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpf8p5jvgv.scala:30:15 --------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mcase\e[0m _ =>\n\e[31m\e[31m   |\e[0m               ^^\e\
    [0m\n\e[31m   |\e[0m               Found:    Unit\n\e[31m   |\e[0m           \
    \    Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val res : List[Long] = new ListBuffer[Long]()\n        val base : Long\
    \ = 3\n        var n2 : Long = 1\n\n        if (n <= 1) {\n            res.append(n)\n\
    \        } else {\n            while (n > 0) {\n                n2 = (n + n) /\
    \ base\n                if (n2 % 2 == 0) {\n                    res.append (n2)\n\
    \                }\n                n = n2\n            }\n        }\n\n     \
    \   res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfbxv55ux.scala:21:31\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpfbxv55ux.scala:26:16 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            res.append(n)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m value append is not a member of List[Long]\
    \ - did you mean res.appended?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfbxv55ux.scala:31:24\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    res.append\
    \ (n2)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m value append is not a member of List[Long] - did you mean res.appended?\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpfbxv55ux.scala:33:18 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                n = n2\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val n\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def go(n: Long, result: List[Long]): List[Long] = {\n            if (n\
    \ <= 0) {\n                result\n            } else {\n                go(n\
    \ / 2, result :: (n + result))\n            }\n        }\n        go(n, Nil)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpm377rt30.scala:25:39 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                go(n / \e[31m2\e[0m, result :: (n + result))\n\
    \e[31m\e[31m   |\e[0m                                     ^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short):\
    \ Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\
    \e[31m   |\e[0mmatch arguments ((result : List[Long]))\n1 error found\n"
  stdout: ''
  timestamp: 1659979917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val rec = new mutable.ListBuffer[Long]()\n        def addrec(n:Long,\
    \ prev:Long): Unit = { \n            if (n<=0) rec += prev\n            else {\
    \ \n                addrec(n-1, prev+n) // Add previous number to the current\
    \ tribonacci number\n                addrec(n-2, prev+n-1) // Add previous two\
    \ numbers to the current tribonacci number\n                addrec(n+2, prev+n-2)\
    \  // Add previous three numbers to the current tribonacci number\n          \
    \  }\n        }\n        addrec(n+1, 0l) // Add the initial number to the recusive\
    \ method\n        rec.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkrinfupr.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrec\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val t0 = if (n==0) 1L else 3L\n        val t1 = t0 + 1L / 2\n       \
    \ val t2 = tri(t1) - tri(t0) - tri(t1+1)\n        (t0 :: t1 :: t2 :: Nil).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi69da7yu.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mt2\e[0m = tri(t1) - tri(t0)\
    \ - tri(t1+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue - is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0) {\n            return Nil\n        }\n        if (n == 1\
    \ || n == 2) {\n            return List(1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)\n\
    \        }\n        if (n % 2 == 0) {\n            return tri(n - 1) + tri(n -\
    \ 2) + tri(n + 1)\n        } else {\n            return tri(n - 2) + tri(n - 1)\
    \ + tri(n + 1)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj1ypz7q5.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mreturn\e[0m tri(n - \e[31m1\e[0m) +\
    \ tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj1ypz7q5.scala:30:30 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mreturn\e[0m tri(n - \e[31m2\e[0m) +\
    \ tri(n - \e[31m1\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def helper(n1: Long, n2: Long, n3: Long, n4: Long): List[Long] = {\n\
    \            if (n1 == 0l) List(1l, n2l, n3l, n4l)\n            if (n2 == 0l)\
    \ List(1l, n2l, n3l, n4l)\n            if (n3 == 0l) List(1l, n2l, n3l, n4l)\n\
    \            if (n4 == 0l) List(1l, n2l, n3l, n4l)\n            else {\n     \
    \           val n5l = n1 + n2\n                val n6l = n3 + n4\n           \
    \     val n7l = n5l + n6l\n                val n8l = n7l + n1\n              \
    \  val n9l = n8l + n2l\n                val n10l = n9l + n3l\n               \
    \ val n11l = n10l + n4l\n                val n12l = n11l + n5l\n             \
    \   val n13l = n12l + n6l\n                val n14l = n13l + n7l\n           \
    \     val n15l = n14l + n8l\n                val n16l = n15l + n9l\n         \
    \       val n17l = n16l + n10l\n                val n18l = n17l + n11l\n     \
    \           val n19l = n18l + n12l\n                val n20l = n19l + n13l\n \
    \               val n21l = n20l + n14l\n                val n22l = n21l + n15l\n\
    \                val n23l = n22l + n16l\n                val n24l = n23l + n17l\n\
    \                val n25l = n24l + n18l\n                val n26l = n25l + n19l\n\
    \                val n27l = n26l + n20l\n                val n28l = n27l + n21l\n\
    \                val n29l = n28l + n22l\n                val n30l = n29l + n23l\n\
    \                val n31l = n30l + n24l\n                val n32l = n31l + n25l\n\
    \                val n33l = n32l + n26l\n                val n34l = n33l + n27l\n\
    \                val n35l = n34l + n28l\n                val n36l = n35l + n29l\n\
    \                val n37l = n36l + n30l\n                val n38l = n37l + n31l\n\
    \                val n39l = n38l + n32l\n                val n40l = n39\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj_h9ief3.scala:78:0 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj_h9ief3.scala:22:35\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m\
    \ (n1 == \e[31m0l\e[0m) List(\e[31m1l\e[0m, n2l, n3l, n4l)\n\e[31m\e[31m   |\e\
    [0m                                   ^^^\e[0m\n\e[31m   |\e[0m              \
    \                     Not found: n2l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpj_h9ief3.scala:22:40 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (n1 == \e[31m0l\e[0m) List(\e[31m1l\e\
    [0m, n2l, n3l, n4l)\n\e[31m\e[31m   |\e[0m                                   \
    \     ^^^\e[0m\n\e[31m   |\e[0m                                        Not found:\
    \ n3l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj_h9ief3.scala:22:45\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m\
    \ (n1 == \e[31m0l\e[0m) List(\e[31m1l\e[0m, n2l, n3l, n4l)\n\e[31m\e[31m   |\e\
    [0m                                             ^^^\e[0m\n\e[31m   |\e[0m    \
    \                                         Not found: n4l\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpj_h9ief3.scala:23:35 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (n2 == \e[31m0l\e[0m) List(\e\
    [31m1l\e[0m, n2l, n3l, n4l)\n\e[31m\e[31m   |\e[0m                           \
    \        ^^^\e[0m\n\e[31m   |\e[0m                                   Not found:\
    \ n2l\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj_h9ief3.scala:23:40\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m\
    \ (n2 == \e[31m0l\e[0m) List(\e[31m1l\e[0m, n2l, n3l, n4l)\n\e[31m\e[31m   |\e\
    [0m                             "
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 2l)\n            List(1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong)\n\
    \        else\n            List(\n                tri(n - 1l) + \n           \
    \     tri(n - 2l) + \n                tri(n + 1l)\n                )\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpow1vske_.scala:25:28 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                tri(n - \e[31m1l\e[0m) + \n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a\
    \ member of List[Long], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n <= 0) Nil\n        else {\n            val rem = n % 2 == 0\n  \
    \          val a1 = n + rem + 1\n            val a2 = (n + rem) + a1 + 1\n   \
    \         val a3 = n + a2 + 1\n            val a4 = n + (a3 + a2)\n          \
    \  val result = List(a1.toLong,a2.toLong,a3.toLong,a4.toLong)\n            result\
    \ ::: tri(a2)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpujzwlpr3.scala:24:23 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36ma1\e[0m = n + rem +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short):\
    \ Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\
    \e[31m   |\e[0mmatch arguments ((rem : Boolean))\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpujzwlpr3.scala:25:24 -----------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mval\e[0m \e[36ma2\e[0m = (n + rem) + a1 + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0mNone\
    \ of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\e[31m \
    \  |\e[0mmatch arguments ((rem : Boolean))\n2 errors found\n"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(n: Long, acc: List[Long]) : List[Long] = n match {\n        \
    \    case 0 => acc\n            case 1 => tri(2, List(0l, 1l))\n            case\
    \ 2 => tri(2, acc :+ tri(2, List(0l, 1l)) :+ tri(3, acc :+ 2l))\n            case\
    \ n => tri(n-1, acc :+ tri(n-1, List(n/2, n/2, n+1))) :+ tri(n+1, acc :+ n+1)\n\
    \        }\n        tri(n, List(0l))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiy6e40r3.scala:24:29\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e\
    [31m2\e[0m => tri(\e[31m2\e[0m, acc :+ tri(\e[31m2\e[0m, List(\e[31m0l\e[0m, \e\
    [31m1l\e[0m)) :+ tri(\e[31m3\e[0m, acc :+ \e[31m2l\e[0m))\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    List[Matchable]\n\e\
    [31m   |\e[0m                             Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiy6e40r3.scala:25:41 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mcase\e[0m n => tri(n-\e[31m1\e[0m,\
    \ acc :+ tri(n-\e[31m1\e[0m, List(n/\e[31m2\e[0m, n/\e[31m2\e[0m, n+\e[31m1\e\
    [0m))) :+ tri(n+\e[31m1\e[0m, acc :+ n+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                      Found:    \e[1m\e[31mList\e[0m\e\
    [1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                        \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpiy6e40r3.scala:25:75 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mcase\e[0m n => tri(n-\e[31m1\e[0m, acc :+ tri(n-\e[31m1\e\
    [0m, List(n/\e[31m2\e[0m, n/\e[31m2\e[0m, n+\e[31m1\e[0m))) :+ tri(n+\e[31m1\e\
    [0m, acc :+ n+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                           \
    \                                             ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                    Found:    \e[1m\e\
    [31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m         \
    \                                           Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979933
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var fibo : List[Long] = Nil\n        var tribo = List (3l)\n        for\
    \ (i <- 0 until n) {\n            tribo = tribo :+ tribo :+ (i+1l)/2\n       \
    \     fibo = fibo :+ fibo :+ (i+1l)\n        }\n        fibo\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpewf7dkq8.scala:23:26\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m0\e[0m until n) {\n\e[31m\e[31m   |\e[0m                          ^\e\
    [0m\n\e[31m   |\e[0m                          Found:    (n : Long)\n\e[31m   |\e\
    [0m                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpewf7dkq8.scala:24:20 --------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            tribo = tribo :+ tribo :+ (i+\e[31m1l\e[0m)/\e\
    [31m2\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    List[Matchable]\n\e[31m   |\e\
    [0m                    Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpewf7dkq8.scala:25:19 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            fibo = fibo :+ fibo :+ (i+\e[31m1l\e[0m)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Found:    List[Matchable]\n\e[31m   |\e[0m             \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979932
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list1 = (3l).toList\n        val list2 = (2l toList drop 1l drop\
    \ 1l)\n        val list3 = list1 ++ list2\n        list3.reverse drop 1 toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8qen19v1.scala:22:36 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlist2\e[0m = (\e[31m2l\e\
    [0m toList drop \e[31m1l\e[0m drop \e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \              ')' expected, but long literal found\n\e[31m\e[31m-- [E018] Syntax\
    \ Error: /tmp/tmp8qen19v1.scala:24:35 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        list3.reverse drop \e[31m1\e[0m toList\n\e[31m\e[31m   |\e\
    [0m                                   ^\e[0m\n\e[31m   |\e[0m                \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8qen19v1.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist1\e[0m = (\e[31m3l\e\
    [0m).toList\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m  value toList is not a member of Long - did you mean (\e[31m3L\e[0m\
    \ : Long).toInt?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8qen19v1.scala:22:24\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mlist2\e[0m = (\e[31m2l\e[0m toList drop \e[31m1l\e[0m drop \e[31m1l\e[0m)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value\
    \ toList is not a member of Long - did you mean (\e[31m2L\e[0m : Long).toInt?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8qen19v1.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlist2\e[0m = (\e[31m2l\e\
    [0m toList drop \e[31m1l\e[0m drop \e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                          ^^^^\e[0m\n\e[31m   |\e[0m                        \
    \       Not found: drop\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979933
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fibonacci = mutable.ListBuffer[Long]()\n        fibonacci.+=((3l).toLong)\n\
    \        var i = 0\n        while (i < n) {\n            fibonacci.+=((fibonacci(i\
    \ -1) -1) +1)\n            i += 1\n        }\n        fibonacci.slice(1, fibonacci.size).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpocj5vgrw.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfibonacci\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val r = List(1, 3, 2);\n        val r = r.reduce(_ + _);\n        val\
    \ r = r.reduceLeft((a, b) => a + b + b + a)\n        val r = r.reduceRight((a,\
    \ b) => a + b + b + a)\n        r match {\n            case n+1 => List(n)\n \
    \           case n => List(n)\n            case _ => tri(n-1) + tri(n-2) + tri(n+1)\
    \ + tri(n+2)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpasx2hsgw.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.reduce(_ + _);\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is\
    \ already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpasx2hsgw.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mr\e[0m = r.reduceLeft((\e[36ma\e[0m, \e[36mb\e[0m) => a + b + b + a)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpasx2hsgw.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.reduceRight((\e[36ma\e[0m, \e\
    [36mb\e[0m) => a + b + b + a)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpasx2hsgw.scala:26:18 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m            \e[33mcase\e[0m n+\e[31m1\e[0m => List(n)\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Not found: +\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpasx2hsgw.scala:26:29 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mcase\e[0m n+\e[31m1\e[0m => List(n)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Found:    (n : Any)\n\e[31m   |\e[0m               \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available whe"
  stdout: ''
  timestamp: 1659979935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(3l.toLong)\n        else if (n % 2 == 0) List(1l.toLong,\
    \ tri(n.toInt -1) + tri(n.toInt -2) + tri(n.toInt + 1))\n        else tri(n.toInt\
    \ -1) + tri(n.toInt -2) + tri(n.toInt + 1) + tri(n.toInt + 2)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0swb5cz3.scala:22:61 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) List(\e[31m1l\e[0m.toLong, tri(n.toInt -\e[31m1\e[0m) + tri(n.toInt\
    \ -\e[31m2\e[0m) + tri(n.toInt + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m       \
    \                                      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0swb5cz3.scala:23:29\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n.toInt\
    \ -\e[31m1\e[0m) + tri(n.toInt -\e[31m2\e[0m) + tri(n.toInt + \e[31m1\e[0m) +\
    \ tri(n.toInt + \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fib_lst = List(0l, 1l, 2l)\n        var lst : List[Long] = null\n\
    \        var sum : Long = 0\n        for ( a <- 0 to (n - 1) ) {\n           \
    \ lst += fib_lst\n        }\n        if ( n > 0 ) {\n            lst = lst.drop(1).take(n).reverse.map\
    \ { n =>\n                sum += n\n                n\n            }\n       \
    \     lst\n        } else {\n            List.empty\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcw0c7oya.scala:24:25\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mfor\e[0m ( a <-\
    \ \e[31m0\e[0m to (n - \e[31m1\e[0m) ) {\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^\e[0m\n\e[31m   |\e[0m                         Found:    Long\n\
    \e[31m   |\e[0m                         Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpcw0c7oya.scala:25:16 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            lst += fib_lst\n\e[31m\e[31m   |\e[0m   \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcw0c7oya.scala:28:35\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            lst = lst.drop(\e\
    [31m1\e[0m).take(n).reverse.map { \e[36mn\e[0m =>\n\e[31m\e[31m   |\e[0m     \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \            Found:    (n : Long)\n\e[31m   |\e[0m                           \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fib = Seq(1,1,2)\n        val ls = (1 to n).foldLeft(List(0l)) {\
    \ \n           case (acc, i) => acc :: (i+1l) :: (fib.drop(i).take(n-i).drop(1).map(_+_))\
    \ \n        }\n        ls.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsqjsaroo.scala:22:23\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mls\e\
    [0m = (\e[31m1\e[0m to n).foldLeft(List(\e[31m0l\e[0m)) { \n\e[31m\e[31m   |\e\
    [0m                       ^\e[0m\n\e[31m   |\e[0m                       Found:\
    \    (n : Long)\n\e[31m   |\e[0m                       Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsqjsaroo.scala:23:63 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m           \e[33mcase\e[0m (acc, i) => acc :: (i+\e[31m1l\e\
    [0m) :: (fib.drop(i).take(n-i).drop(\e[31m1\e[0m).map(_+_)) \n\e[31m\e[31m   |\e\
    [0m                                                               ^^^\e[0m\n\e\
    [31m   |\e[0m                                                          Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpsqjsaroo.scala:23:80\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m           \e[33mcase\e\
    [0m (acc, i) => acc :: (i+\e[31m1l\e[0m) :: (fib.drop(i).take(n-i).drop(\e[31m1\e\
    [0m).map(_+_)) \n\e[31m\e[31m   |\e[0m                                       \
    \                                         ^^^\e[0m\n\e[31m   |\e[0m          \
    \                       Wrong number of parameters, expected: 1\n3 errors found\n"
  stdout: ''
  timestamp: 1659979934
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = ListBuffer.empty[Long]\n        \n        val n1 = n + 1\n\
    \        \n        list.add(3l)\n        \n        if (n % 2 == 0) {\n       \
    \     for (i <- 1 to n1){\n                list.add(tri(n - 1) + tri(n - 2) +\
    \ tri(n + 1))\n            }\n        } else {\n            for (i <- 1 to n1){\n\
    \                list.add(tri(n - 1) + tri(n - 2) + tri(n))\n            }\n \
    \       }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnzojlnbu.scala:25:13 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        list.add(\e[31m3l\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0m  value add is not a member of scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnzojlnbu.scala:28:27 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m (i <- \e[31m1\e[0m to n1){\n\
    \e[31m\e[31m   |\e[0m                           ^^\e[0m\n\e[31m   |\e[0m     \
    \                      Found:    (n1 : Long)\n\e[31m   |\e[0m                \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpnzojlnbu.scala:29:21 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m                list.add(tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n\
    \ + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue add is not a member of scala.collection.mutable.ListBuffer[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.buffer AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.buffer AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.mutableSeq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.mutableSeq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnzojlnbu.scala:29:36\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                list.add(tri(n\
    \ - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659979937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      if (n == 0) List(0l)\n      if (n == 1) List(3l)\n      if (n % 2 == 0)\
    \ List(tri(n - 1) + tri(n - 2) + tri(n + 1), tri(n - 2) + tri(n + 1))\n      else\
    \ tri(n - 2) + tri(n + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpximh6ayl.scala:23:38 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m      \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e[0m)\
    \ List(tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m),\
    \ tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpximh6ayl.scala:23:76 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m      \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e[0m)\
    \ List(tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m),\
    \ tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m      \
    \                                                           ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpximh6ayl.scala:24:22 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m      \e[33melse\e[0m tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Impl"
  stdout: ''
  timestamp: 1659979935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0) List(1l, 0l, 0l, 0l)\n        else if (n % 2 == 0) tri(n\
    \ - 1) + tri(n - 2) + tri(n - 1).toList\n        else tri(n - 1) + tri(n - 2)\
    \ + tri(n - 1).toList + tri(n - 1).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnsu6f2os.scala:22:40 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n - \e\
    [31m1\e[0m).toList\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnsu6f2os.scala:23:24 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n - \e[31m1\e[0m).toList + tri(n - \e[31m1\e[0m).toList\n\e\
    [31m\e[31m   |\e[0m             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0) {\n            List.empty\n        } else {\n           \
    \ val a = List(1)\n            val b = List(3, 2)\n            val m = n / 2\n\
    \            List(a + b + b.dropRight(m))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_j97zp1x.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            List(a + b + b.dropRight(m))\n\e[31m\e[31m\
    \   |\e[0m                 ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of\
    \ List[Int], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fib  = mutable.ListBuffer[Long]()\n        fib += 3l\n        fib\
    \ ++= (n/2).filter(_%2==0).toList\n        if (n%2==1) {\n            fib ++=\
    \ (n-1).filter(_%2==1).toList\n        }\n        fib.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_53fyuvx.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfib\e[0m  = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val first = (if(isEven(n)) 3l else 1l).toLong\n        val second = (if(isEven(n))\
    \ (n - 1l).toLong else (1l + (n - 1l).toLong)).toLong\n        val third = (if\
    \ (isEven(n)) (n - 2l).toLong else (second + (n - 2l).toLong)).toLong\n      \
    \  List(first, second, third)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpft1n073m.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfirst\e[0m = (\e[33mif\e\
    [0m(isEven(n)) \e[31m3l\e[0m \e[33melse\e[0m \e[31m1l\e[0m).toLong\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         Not found: isEven\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpft1n073m.scala:22:25 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36msecond\e[0m = (\e[33mif\e[0m(isEven(n)) (n - \e\
    [31m1l\e[0m).toLong \e[33melse\e[0m (\e[31m1l\e[0m + (n - \e[31m1l\e[0m).toLong)).toLong\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                      Not found: isEven\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpft1n073m.scala:23:25 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mthird\e[0m = (\e[33mif\e[0m (isEven(n))\
    \ (n - \e[31m2l\e[0m).toLong \e[33melse\e[0m (second + (n - \e[31m2l\e[0m).toLong)).toLong\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                      Not found: isEven\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) \n            List(1L, 3L, 2L, 8L)\n        else if (n %\
    \ 2 == 1)\n            List((tri(n / 2).toLong + tri(n / 2 + 1).toLong + tri(n\
    \ / 2 + 2).toLong).toList)\n        else\n            List((tri(n / 2).toLong\
    \ + tri(n / 2 + 1).toLong + tri(n / 2 + 2).toLong).toList)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpou173aoq.scala:24:29 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            List((tri(n / \e[31m2\e[0m).toLong + tri(n\
    \ / \e[31m2\e[0m + \e[31m1\e[0m).toLong + tri(n / \e[31m2\e[0m + \e[31m2\e[0m).toLong).toList)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpou173aoq.scala:26:29\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            List((tri(n /\
    \ \e[31m2\e[0m).toLong + tri(n / \e[31m2\e[0m + \e[31m1\e[0m).toLong + tri(n /\
    \ \e[31m2\e[0m + \e[31m2\e[0m).toLong).toList)\n\e[31m\e[31m   |\e[0m        \
    \          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979936
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triR(n: Long, prev: Long): List[Long] = {\n            if (n == 0)\
    \ List(1l.toLong, 3l.toLong, 2l.toLong)\n            else {\n                if\
    \ (n % 2 == 1) triR(n + 1, prev + (n / 2l.toLong))\n                else triR(n\
    \ - 1, prev + n + 1)\n            }\n        }\n        triR(n, 0l).toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659979939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var ans = ListBuffer[Long]()\n        \n        if (n == 0) ans += 1\n\
    \        if (n == 1) ans += 3\n        \n        if (n % 2 == 0)\n           \
    \ ans ++= tri(n - 1) + tri(n - 2) + tri(n + 1)\n        else\n            ans\
    \ ++= tri(n - 3) + tri(n - 2) + tri(n - 1)\n        \n        ans.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe17ma2qc.scala:27:31 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            ans ++= tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpe17ma2qc.scala:29:31 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            ans ++= tri(n - \e[31m3\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   \
    \ ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 0) return Nil\n        val a = tri(n - 1).toList\n        val\
    \ b = tri(n - 2).toList\n        val c = tri(n - 3).toList\n        if (n % 2\
    \ == 0) a ::: b ::: c\n        else if (n % 2 == 1) a ::: c ::: b\n        else\
    \ a ::: b ::: c\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpucoj0cbm.scala:30)\n\tat Problem.main(tmpucoj0cbm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979937
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      require(n > 0)\n      if (n <= 2l){\n        List(1l.toLong, 3l.toLong)\n\
    \      } else if (n <= 4l){\n        List(2l.toLong, 3l.toLong, 1l.toLong)\n \
    \     } else {\n        val tri_list_1 = tri(n - 1l) + tri(n - 2l)\n        val\
    \ tri_list_2 = tri(n - 1l) + tri(n - 2l) + tri(2n + 3l)\n        List(tri_list_1,\
    \ tri_list_2)\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjsq58zuf.scala:27:37 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mtri_list_1\e[0m = tri(n\
    \ - \e[31m1l\e[0m) + tri(n - \e[31m2l\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpjsq58zuf.scala:28:37 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mtri_list_2\e[0m = tri(n\
    \ - \e[31m1l\e[0m) + tri(n - \e[31m2l\e[0m) + tri(\e[31m2\e[0mn + \e[31m3l\e[0m)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n >= 0)\n        if (n <= 2) List(n) \n        else List(tri(n-1)\
    \ + tri(n - 2) + tri(n + 1), tri(n - 1) + tri(n - 2), tri(n + 1))\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_tg_v8nr.scala:23:27 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m List(tri(n-\e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m), tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m), tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_tg_v8nr.scala:23:65 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33melse\e[0m List(tri(n-\e[31m1\e[0m) + tri(n -\
    \ \e[31m2\e[0m) + tri(n + \e[31m1\e[0m), tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e\
    [0m), tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                          \
    \                            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_tg_v8nr.scala:23:82 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m List(tri(n-\e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m), tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m), tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \                                                            ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                    Found:    \e\
    [1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m    \
    \  "
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def helper(n: Long, prev: Long, cur: List[Long]) : List[Long] = {\n \
    \           if ((n & 1) == 1) {\n                cur.head :: prev\n          \
    \  } else {\n                prev :: cur.head :: cur.tail\n            }\n   \
    \     }\n        val prev = 0l\n        val cur = List(0l).reverse\n        while\
    \ (n > 0) {\n            val next = cur.head + cur.tail\n            val newN\
    \ = n - 1\n            cur = helper(newN, prev, cur)\n            prev = next\n\
    \            n -= 1\n        }\n        cur.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm13a7ga9.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                cur.head :: prev\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     value :: is not a member of Long\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpm13a7ga9.scala:31:32\
    \ -----------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mnext\e[0m = cur.head + cur.tail\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0m (x: String): String\n\e[31m   |\e[0mmatch arguments ((cur.tail\
    \ : => List[Long @uncheckedVariance]))\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpm13a7ga9.scala:33:16\
    \ -----------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            cur = helper(newN,\
    \ prev, cur)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val cur\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpm13a7ga9.scala:34:17 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            prev = next\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment to val prev\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm13a7ga9.scala:35:14\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            n -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Long - did you mean n.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(n: Long, n1: Int, n2: Int, n3: Int): List[Long] = {\n       \
    \     if (n == 0) {\n                return List(1L.asInstanceOf[Long], 3L.asInstanceOf[Long],\
    \ 2L.asInstanceOf[Long], 8L.asInstanceOf[Long])\n            } else if (n % 2\
    \ == 0) {\n                return tri(n - 1, n1 + n2, n2, n3 + n3)\n         \
    \   } else {\n                return tri(n - 1, n1, n1 + n2 + n3, n3)\n      \
    \      }\n        }\n        tri(n, 0, 1, 2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4xu1o2hw.scala:34)\n\tat Problem.main(tmp4xu1o2hw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(0l)\n        if (n == 1) List(1l)\n        if (n % 2\
    \ == 0) tri(n - 1l :: 1l :: 3l :: nl :: nl :: nl)\n        else  tri(n - 1l ::\
    \ 1l :: 2l :: nl :: nl :: nl)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq7jkkt1m.scala:23:62 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e\
    [0m) tri(n - \e[31m1l\e[0m :: \e[31m1l\e[0m :: \e[31m3l\e[0m :: nl :: nl :: nl)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^\e[0m\n\e[31m   |\e[0m                                              \
    \             Not found: nl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpq7jkkt1m.scala:24:52 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33melse\e[0m  tri(n - \e[31m1l\e[0m :: \e[31m1l\e[0m :: \e[31m2l\e\
    [0m :: nl :: nl :: nl)\n\e[31m\e[31m   |\e[0m                                \
    \                    ^^\e[0m\n\e[31m   |\e[0m                                \
    \                    Not found: nl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def fib(n: Long) = if (n==0) 1 else if (n==1) 1 else fib(n-1)+fib(n-2)\n\
    \        val list = mutable.ListBuffer(1l, 3l)\n        for (i <- 0 to n-1) {\n\
    \            list += fib(list.last)\n        }\n        list.toList\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E044] Cyclic Error: /tmp/tmp2u3l21_n.scala:21:61 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mdef\e[0m \e[36mfib\e[0m(\e[36mn\e[0m: \e\
    [35mLong\e[0m) = \e[33mif\e[0m (n==\e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m\
    \ \e[33mif\e[0m (n==\e[31m1\e[0m) \e[31m1\e[0m \e[33melse\e[0m fib(n-\e[31m1\e\
    [0m)+fib(n-\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                              \
    \                               ^\e[0m\n\e[31m   |\e[0m                    Overloaded\
    \ or recursive \e[33mmethod\e[0m \e[35mfib\e[0m needs return type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2u3l21_n.scala:22:19 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer(\e\
    [31m1l\e[0m, \e[31m3l\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2u3l21_n.scala:23:23 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m to n-\e[31m1\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\e[31m   |\e[0m\
    \                       Found:    Long\n\e[31m   |\e[0m                      \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val nn = n.toInt\n        val firstList = List(1, 3)\n        var firstTribonacci\
    \ = firstList.head\n\n        def tri(i : Long) : List[Long] = {\n           \
    \ val result = i + firstTribonacci + i\n            if (result%2 == 0) firstTribonacci\
    \ = i else firstTribonacci = i + 3\n            firstTribonacci\n        }\n\n\
    \        if (nn == 0) firstList else tri(nn-1) + tri(nn-2) + tri(nn+1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsncushfb.scala:27:49\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m (result%\e\
    [31m2\e[0m == \e[31m0\e[0m) firstTribonacci = i \e[33melse\e[0m firstTribonacci\
    \ = i + \e[31m3\e[0m\n\e[31m\e[31m   |\e[0m                                  \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \           Found:    (i : Long)\n\e[31m   |\e[0m                            \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsncushfb.scala:27:74 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            \e[33mif\e[0m (result%\e[31m2\e[0m == \e[31m0\e[0m) firstTribonacci\
    \ = i \e[33melse\e[0m firstTribonacci = i + \e[31m3\e[0m\n\e[31m\e[31m   |\e[0m\
    \                                                                          ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                         \
    \ Found:    Long\n\e[31m   |\e[0m                                            \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsncushfb.scala:28:12 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            firstTribonacci\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    (firstTribonacci : Int)\n\e[31m   |\e\
    [0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsncushfb.scala:31:21 --------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mif\e[0m (nn == \e[31m0\e[0m) firstList \e[33melse\e[0m tri(nn-\e\
    [31m1\e[0m) + tri(nn-\e[31m2\e[0m) + tri(nn+\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:\
    \    (firstList : List[Int])\n\e[31m   |\e[0m                     Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1659979945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = ListBuffer.empty[Long]\n        val b = ListBuffer.empty[Long]\n\
    \        val c = ListBuffer.empty[Long]\n        a(0) = 3\n        b(0) = 1\n\
    \        for(x <- 1 to n){\n            if(x % 2 == 0) a(x) = a(x-1) + a(x-2)\n\
    \            else a(x) = a(x-1) + a(x-2) + a(x+1)\n            if(x+2 > n) b(x)\
    \ = a(x+1) + a(x+2)\n            else b(x) = a(x+1) + a(x+2) + a(x+2)\n      \
    \  }\n        for(x <- 1 to n) c(x) = a(x) + b(x)\n        for(x <- 1 to n) a(x)\
    \ = c(x)\n        a.toList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkns1m4jo.scala:26:22\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mfor\e[0m(x <- \e\
    [31m1\e[0m to n){\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m \
    \  |\e[0m                      Found:    (n : Long)\n\e[31m   |\e[0m         \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpkns1m4jo.scala:32:22 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mfor\e[0m(x <- \e[31m1\e[0m to n) c(x) = a(x) + b(x)\n\e\
    [31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m             \
    \         Found:    (n : Long)\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkns1m4jo.scala:33:22\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mfor\e[0m(x <- \e\
    [31m1\e[0m to n) a(x) = c(x)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\
    \e[31m   |\e[0m                      Found:    (n : Long)\n\e[31m   |\e[0m   \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n == 0)\n            List(0l)\n        else if(n == 1)\n         \
    \   List(3l)\n        else if(n == 2)\n            List(1l, 3l)\n        else\n\
    \            List(0l, 1l, 3l, 2l, 8l, 3l, 6l, 5l, 7l, 4l, 9l, 8l, 7l, 5l, 3l,\
    \ 6l, 2l)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2e2zp9jo.scala:31)\n\tat Problem.main(tmp2e2zp9jo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def fib(i : Int) : Long = {\n            if (i == 0) 1L else fib(i -\
    \ 1) + fib(i - 2)\n        }\n        val ans = mutable.ListBuffer.empty[Long]\n\
    \        fib(n.toInt) match {\n            case i if i != 0 =>\n            ans\
    \ += i.toLong\n            i match {\n                case i if i % 2 == 0 =>\
    \ \n                    ans += tri(n - 1) + tri(n - 2) + tri(n + 1) \n       \
    \         case i if i % 2 == 1 => \n                    ans += tri(n - 1) + tri(n\
    \ - 2) \n                case i =>\n            }\n            case i =>\n   \
    \     }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjb9h60x5.scala:24:18 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979941
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val result = mutable.ListBuffer.empty[Long]\n        val l1 = n / 2\n\
    \        val l2 = l1 + l1\n        val l3 = l2 + l2\n        result :+= l1\n \
    \       if (n % 2 == 0) {\n            result :+= l2\n            result :+= l3\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz4_s5wag.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Write your solution here\n        var firstThree = List(1)\n     \
    \   var secondThree = List(1)\n        var thirdThree = List(1)\n        var nextN\
    \ = n + 1\n        if (nextN % 2 == 0) {\n            firstThree = thirdThree\
    \ = nextN / 2\n            nextN = nextN >> 1\n        }\n        else {\n   \
    \         secondThree = thirdThree = nextN - 1\n            nextN = nextN >> 1\n\
    \        }\n        List((firstThree, secondThree, thirdThree))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzswush_j.scala:27:38\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            firstThree = thirdThree\
    \ = nextN / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                              \
    \        ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \ Found:    Long\n\e[31m   |\e[0m                                      Required:\
    \ List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzswush_j.scala:31:39\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            secondThree = thirdThree\
    \ = nextN - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                              \
    \         ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \   Found:    Long\n\e[31m   |\e[0m                                       Required:\
    \ List[Int]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzswush_j.scala:34:13\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        List((firstThree, secondThree,\
    \ thirdThree))\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    (List[Int], List[Int], List[Int])\n\
    \e[31m   |\e[0m             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val li = new scala.collection.mutable.ListBuffer[Long]\n        li.+=(n)\n\
    \        if (n.toLong % 2 == 0) {\n            li.+=((tri(n.toLong - 1).map( x\
    \ => x + x ) + tri(n.toLong - 2).map( x => x + x )).filter( x => x <= n ).toList);\n\
    \        }\n        else {\n            li.+=((tri(n.toLong - 1).map( x => x +\
    \ x ) + tri(n.toLong - 2).map( x => x + x )).filter( x => x > n ).toList);\n \
    \       }\n        li.+=((tri(n.toLong + 1).map( x => x + x ) + tri(n.toLong +\
    \ 2).map( x => x + x )).filter( x => x >= n ).toList);\n        li.filter(x =>\
    \ x % 1 == 0).toList;\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp088ovr9w.scala:24:55 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            li.+=((tri(n.toLong - \e[31m1\e[0m).map(\
    \ \e[36mx\e[0m => x + x ) + tri(n.toLong - \e[31m2\e[0m).map( \e[36mx\e[0m =>\
    \ x + x )).filter( \e[36mx\e[0m => x <= n ).toList);\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp088ovr9w.scala:27:55\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            li.+=((tri(n.toLong\
    \ - \e[31m1\e[0m).map( \e[36mx\e[0m => x + x ) + tri(n.toLong - \e[31m2\e[0m).map(\
    \ \e[36mx\e[0m => x + x )).filter( \e[36mx\e[0m => x > n ).toList);\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp088ovr9w.scala:29:51 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        li.+=((tri(n.toLong + \e[31m1\e[0m).map( \e[36mx\e\
    [0m => x + x ) + tri(n.toLong + \e[31m2\e[0m).map( \e[36mx\e[0m => x + x )).filter(\
    \ \e[36mx\e[0m => x >= n ).toList);\n\e[31m\e[31m   |\e[0m               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n<=0) return Nil\n        if(n==1) return List(3l.toLong)\n      \
    \  val f1 = (n % 2 == 0) ?  tri(n - 1)+(tri(n-1) + tri(n +1))/3 : tri(n - 1) \n\
    \        val f2 = tri(n - 2) + (tri(n -1) + tri(n +2))/3\n        val f3 = tri(n\
    \ + 1) + (tri(n -1) + tri(n +2))/3\n        List(f1, f2, f3)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0tz075pu.scala:23:74 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mf1\e[0m = (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) ?  tri(n - \e[31m1\e[0m)+(tri(n-\e[31m1\e[0m) + tri(n +\e\
    [31m1\e[0m))/\e[31m3\e[0m : \e[35mtri\e[0m(n - \e[31m1\e[0m) \n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \     ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but '(' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0tz075pu.scala:23:30\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mf1\e[0m = (n % \e[31m2\e[0m == \e[31m0\e[0m) ?  tri(n - \e[31m1\e[0m)+(tri(n-\e\
    [31m1\e[0m) + tri(n +\e[31m1\e[0m))/\e[31m3\e[0m : \e[35mtri\e[0m(n - \e[31m1\e\
    [0m) \n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                 value ? is not a member of Boolean\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp0tz075pu.scala:23:80 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mf1\e[0m = (n % \e[31m2\e[0m ==\
    \ \e[31m0\e[0m) ?  tri(n - \e[31m1\e[0m)+(tri(n-\e[31m1\e[0m) + tri(n +\e[31m1\e\
    [0m))/\e[31m3\e[0m : \e[35mtri\e[0m(n - \e[31m1\e[0m) \n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0m                                                 \
    \   Found:    Unit\n\e[31m   |\e[0m                                          \
    \          Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979946
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = new mutable.ListBuffer[Long]()\n        var fibonacci : Long\
    \ = 0\n        var tribonacci : Long = 0\n        var i : Long = 1\n        while(i<=n){\n\
    \            fibonacci = fibonacci + i\n            tribonacci = tribonacci +\
    \ fibonacci\n            list.+=(i.toLong)\n            i = i + 1\n        }\n\
    \        list.+=(i.toLong)\n        return list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfjsxo2fd.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val evenN : Long = n%2 == 0\n        val evenTribonacci = List(1l, 3l,\
    \ 2l).filter(_ % 2 == 0)\n        val oddeTribonacci = List(1l, 3l, 2l).filter(_\
    \ % 2 == 1).filter(_ != evenN)\n        (evenTribonacci ++ oddeTribonacci).take(n\
    \ + 1).map(_.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk6qskmwy.scala:21:27\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mevenN\e\
    [0m : \e[35mLong\e[0m = n%\e[31m2\e[0m == \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m\
    \                           ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \        Found:    Boolean\n\e[31m   |\e[0m                           Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk6qskmwy.scala:24:48\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        (evenTribonacci ++ oddeTribonacci).take(n\
    \ + \e[31m1\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m                       \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979948
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      import scala.math._\n      val a = List(3, tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1))\n      a.drop(1).take(n + 1).map(_.toLong)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb2uuqwr0.scala:22:33 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m      \e[33mval\e[0m \e[36ma\e[0m = List(\e[31m3\e[0m,\
    \ tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb2uuqwr0.scala:23:21 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m      a.drop(\e[31m1\e[0m).take(n + \e[31m1\e[0m).map(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \             Found:    Long\n\e[31m   |\e[0m                     Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri_aux(n : Long, acc : List[Long]): List[Long] = {\n           \
    \ if (n == 0) acc\n            else tri_aux(n - 1, (tri_aux(n - 2, acc :+ tri(n\
    \ - 1) + tri(n - 2)) : List[Long]) + tri(n + (n % 2 == 0 ? 1 : 2)))\n        }\n\
    \        tri_aux(n + 1, Nil)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa8e0z_vn.scala:23:66 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m tri_aux(n - \e[31m1\e[0m,\
    \ (tri_aux(n - \e[31m2\e[0m, acc :+ tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e\
    [0m)) : List[Long]) + tri(n + (n % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e[0m\
    \ : \e[31m2\e[0m)))\n\e[31m\e[31m   |\e[0m                                   \
    \                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpa8e0z_vn.scala:23:116 -----------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m tri_aux(n - \e[31m1\e[0m,\
    \ (tri_aux(n - \e[31m2\e[0m, acc :+ tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e\
    [0m)) : List[Long]) + tri(n + (n % \e[31m2\e[0m == \e[31m0\e[0m ? \e[31m1\e[0m\
    \ : \e[31m2\e[0m)))\n\e[31m\e[31m   |\e[0m                                   \
    \                                                                            \
    \   ^^^\e[0m\n\e[31m   |\e[0m                                          value ?\
    \ is not a member of Int\n2 errors found\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 1) List(n) \n        else if (n % 2 == 0) {\n            val\
    \ list1 = tri(n - 1) + tri(n - 2)\n            list1.take(n + 1).reverse\n   \
    \     } \n        else {\n            val list2 = tri(n - 3) + tri(n - 2) + tri(n\
    \ - 1) + tri(n + 1)\n            list2.take(n + 1).reverse\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeui_8n7g.scala:23:35 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mlist1\e[0m = tri(n -\
    \ \e[31m1\e[0m) + tri(n - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpeui_8n7g.scala:27:35 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mlist2\e[0m = tri(n -\
    \ \e[31m3\e[0m) + tri(n - \e[31m2\e[0m) + tri(n - \e[31m1\e[0m) + tri(n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue + is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val l = new mutable.ListBuffer[Long]()\n        if(n % 2 == 0) {\n  \
    \          l.append(3L);\n            n.toLong match {\n                case n\
    \ if n > 1L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case\
    \ _ => l.append(n)\n            }\n        }\n        else if(n % 2 == 1) {\n\
    \            l.append(1L);\n            n.toLong match {\n                case\
    \ n if n > 2L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case\
    \ _ => l.append(n)\n            }\n        }\n        else if(n % 2 == 0) {\n\
    \            l.append(2L);\n            n.toLong match {\n                case\
    \ n if n > 3L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case\
    \ _ => l.append(n)\n            }\n        }\n        else if(n % 2 == 1) {\n\
    \            l.append(8L);\n            n.toLong match {\n                case\
    \ n if n > 5L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case\
    \ _ => l.append(n)\n            }\n        }\n        else if(n % 2 == 0) {\n\
    \            l.append(3L);\n            n.toLong match {\n                case\
    \ n if n > 5L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case\
    \ _ => l.append(n)\n            }\n        }\n        else if(n % 2 == 1) {\n\
    \            l.append(8L);\n            n.toLong match {\n                case\
    \ n if n > 7L => l.append(tri(n-1) + tri(n-2) + tri(n+1))\n                case\
    \ _ => l.append(n)\n            }\n        }\n        else l.append(1L)\n    \
    \    l.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_vhz6j_r.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def aux(tris : List[Long], acc : Long) : List[Long] =\n            if\
    \ (tris.size < n + 1) tris.reverse else aux(tris.take(n + 1).reverse :: tris.drop(tris.size\
    \ - (n + 1)),\n                (n + 1) * (tris(n).toLong + tris(n + 1).toLong))\n\
    \        aux(Nil, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpss6mk2wc.scala:22:95\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (tris.size\
    \ < n + \e[31m1\e[0m) tris.reverse \e[33melse\e[0m aux(tris.take(n + \e[31m1\e\
    [0m).reverse :: tris.drop(tris.size - (n + \e[31m1\e[0m)),\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                                           Found:    Long\n\e[31m   |\e[0m  \
    \                                                        Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpss6mk2wc.scala:22:67 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (tris.size < n + \e[31m1\e\
    [0m) tris.reverse \e[33melse\e[0m aux(tris.take(n + \e[31m1\e[0m).reverse :: tris.drop(tris.size\
    \ - (n + \e[31m1\e[0m)),\n\e[31m\e[31m   |\e[0m                              \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                              Found:    Long\n\e[31m   |\e[0m\
    \                                                          Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpss6mk2wc.scala:23:32 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                (n + \e[31m1\e[0m) * (tris(n).toLong\
    \ + tris(n + \e[31m1\e[0m).toLong))\n\e[31m\e[31m   |\e[0m                   \
    \             ^\e[0m\n\e[31m   |\e[0m                                Found:  \
    \  (n : Long)\n\e[31m   |\e[0m                                Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpss6mk2wc.scala:23:49\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                (n + \e[31m1\e\
    [0m) * (tris(n).toLong + tris(n + \e[31m1\e[0m).toLong))\n\e[31m\e[31m   |\e[0m\
    \                                                 ^^^^^\e[0m\n\e[31m   |\e[0m\
    \  "
  stdout: ''
  timestamp: 1659979949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val l = new ArrayList[Long]\n        if (n.toLong == 0) l :+ 0\n    \
    \    else if (n.toLong == 1) l :+ 1\n        else if (n.toLong == 2) l :+ 2\n\
    \        else if (n.toLong % 2 == 0) l :+ tri(n - 1) + tri(n - 2) + tri(n +1)\n\
    \        else l :+ tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n + 2)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptdu2x6j0.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ \e[35mArrayList\e[0m[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: type ArrayList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n > 0)\n        if (n == 1L) {\n            return Nil\n    \
    \    }\n        else {\n            val n2 = n/2\n            val n3 = n2 + n\n\
    \            val n5 = n3 + n\n            val n7 = n5 + n\n            return\
    \ List(1L + n2, n3, n5, n7)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5swe013s.scala:34)\n\tat Problem.main(tmp5swe013s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fibo = mutable.Stack[Long]()\n        fibo += 3\n        fibo.takeWhile(_\
    \ < n).map(_+_)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr1imr8oi.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfibo\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Your code here\n        var n = 3\n        var triSeq = mutable.List.empty[Long]\n\
    \        while(n>0) {\n            triSeq :+= n\n            n += n / 2\n    \
    \    }\n        triSeq :+= triSeq.last\n        triSeq\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf4h_icqk.scala:23:21 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mtriSeq\e[0m = mutable.List.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979949
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 0L) throw new RuntimeException(\"n must be positive\")\n    \
    \    val a = 3L\n        val b = ((a + 1L) / 2L)\n        val c = ((a+b+1L) /\
    \ 3L)\n        val tri = List(1L,b+1,c)\n        if (n % 2L == 0L)\n         \
    \   tri.toList\n        else\n            tri.tail.toList ::: tri.init.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1ts94d3y.scala:32)\n\tat Problem.main(tmp1ts94d3y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n >= 0, \"n should be non-negative\")\n        if (n == 0 ||\
    \ n == 1)\n            List(1l.toLong)\n        else if (n % 2 == 0)\n       \
    \     tri(n - 1) + tri(n - 2)\n        else\n            tri(n - 1) + tri(n -\
    \ 2) + tri(n / 2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpppmk4hnx.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpppmk4hnx.scala:27:23\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            tri(n - \e[31m1\e\
    [0m) + tri(n - \e[31m2\e[0m) + tri(n / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0 || n == 1) {\n            return List(1l, 3l)\n        }\n\
    \        if (n == 2) {\n            return List(n1l(2l), n1l(1l))\n        }\n\
    \        val r0 = tri(n-1)\n        val r1 = tri(n-2)\n        val r2 = tri(n-3)\n\
    \        return r0 ::: r1 ::: r2 ::: n4l(n-4)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr4l72oi6.scala:25:24 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mreturn\e[0m List(n1l(\e[31m2l\e[0m),\
    \ n1l(\e[31m1l\e[0m))\n\e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\
    \e[31m   |\e[0m                        Not found: n1l\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr4l72oi6.scala:25:33 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mreturn\e[0m List(n1l(\e[31m2l\e[0m),\
    \ n1l(\e[31m1l\e[0m))\n\e[31m\e[31m   |\e[0m                                 ^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: n1l\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr4l72oi6.scala:30:36 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mreturn\e[0m r0 ::: r1 ::: r2 ::: n4l(n-\e\
    [31m4\e[0m)\n\e[31m\e[31m   |\e[0m                                    ^^^\e[0m\n\
    \e[31m   |\e[0m                                    Not found: n4l\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = new Array[Long](3L)\n        a(0) = 1\n        a(1) = 3\n   \
    \     var b = 1\n        for(i <- 2 to n+1)\n        {\n            a(i) = b\n\
    \            b = (b + a(i-1)).toLong\n        }\n        a(n) = b\n        a.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp39mj3q5s.scala:21:32\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ma\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](\e[31m3L\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                ^^\e[0m\n\e[31m   |\e[0m        \
    \                        Found:    (\e[31m3L\e[0m : Long)\n\e[31m   |\e[0m   \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp39mj3q5s.scala:25:22 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mfor\e[0m(i <- \e[31m2\e[0m to n+\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                      ^^^\e[0m\n\e[31m   |\e[0m   \
    \                   Found:    Long\n\e[31m   |\e[0m                      Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp39mj3q5s.scala:28:29\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            b = (b + a(i-\e[31m1\e\
    [0m)).toLong\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Found:    Long\n\e[31m   |\e[0m                Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp39mj3q5s.scala:30:10\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m        a(n) = b\n\e[31m\e[31m\
    \   |\e[0m          ^\e[0m\n\e[31m   |\e[0m          Found:    (n : Long)\n\e\
    [31m   |\e[0m          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val res : List[Long] = n match {\n            case 0 | 1 | 2 => List(1l.toLong,\
    \ 3l.toLong, 2l.toLong)\n            case 4 | 5 | 6 => List(3l.toLong, 2l.toLong,\
    \ 1l.toLong)\n            case 7 | 8 => List(2l.toLong, 1l.toLong, 0l.toLong)\n\
    \        }\n        n match {\n            case 0 => res\n            case k =>\
    \ res.flatMap(n => tri(n - 1) + tri(n - 2) + tri(n + 1))\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf7llhpc5.scala:28:50 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mcase\e[0m k => res.flatMap(n => tri(n\
    \ - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m\
    \   |\e[0m                                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = new Array[Long](n +1)\n        val evenList = list.drop(0)\n\
    \        val oddList = list.drop(1)\n        list.foreach { x =>\n           \
    \ if (x%2 == 0) evenList += x\n            else oddList += x\n        }\n    \
    \    list\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp87f5t7ww.scala:21:35\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mLong\e[0m](n +\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                   ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                Found:    Long\n\e[31m   |\e[0m             \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp87f5t7ww.scala:25:35 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mif\e[0m (x%\e[31m2\e[0m == \e[31m0\e[0m)\
    \ evenList += x\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m     value += is not a member of Array[Long] - did you mean\
    \ evenList.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp87f5t7ww.scala:26:25\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33melse\e\
    [0m oddList += x\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      value += is not a member of Array[Long] - did you mean oddList.!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp87f5t7ww.scala:28:8 ---------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        list\n\e[31m\e[31m   |\e[0m        ^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    (list : Array[Long])\n\e[31m   |\e[0m       \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Base case\n        if (n == 0) List(1L, 3L) \n        // Recursion\
    \ step\n        else if (n % 2 == 0) \n            tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1) \n        else \n            tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n\
    \ / 2) \n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9dvf5kyd.scala:25:23 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e\
    [0m) + tri(n + \e[31m1\e[0m) \n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp9dvf5kyd.scala:27:23 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m)\
    \ + tri(n + \e[31m1\e[0m) + tri(n / \e[31m2\e[0m) \n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979958
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val triSeq = mutable.Seq[Long](3l.toLong, 1l.toLong, 1l.toLong, 2l.toLong)\n\
    \        val lastVal = triSeq.last\n        val newTriSeq = triSeq.map { x =>\
    \ if (x % 2 == 0) x + lastVal else x - lastVal }\n        val lastIndex = triSeq.size\
    \ - 1\n        newTriSeq.take(n - (lastIndex + 1))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8v3n79os.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mtriSeq\e[0m = mutable.Seq[\e\
    [35mLong\e[0m](\e[31m3l\e[0m.toLong, \e[31m1l\e[0m.toLong, \e[31m1l\e[0m.toLong,\
    \ \e[31m2l\e[0m.toLong)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case 0 => List(0l.toLong)\n            case 1\
    \ => List(1l.toLong)\n            case n => \n                val a = tri(n /\
    \ 2)\n                val b = tri(n - 1) + tri(n - 2) + tri(n + 1)\n         \
    \       a ++ b\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp744h88u9.scala:26:35 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m \e[36mb\e[0m = tri(n -\
    \ \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // We store all numbers in the sequence\n        val numbers = new ArrayList[Long]\n\
    \        numbers.add(1L)\n        numbers.add(3L)\n        // The first three\
    \ fibonacci numbers are stored in numbers list\n        if (n >= 2) numbers.add(2L)\n\
    \        // The last two fibonacci numbers are stored in numbers list\n      \
    \  \n        // The last number in the sequence is calculated by adding the last\
    \ two numbers in the sequence\n        val last = numbers.get(n-2) + numbers.get(n-1)\n\
    \        numbers.add(last)\n        // The last fibonacci number after the first\
    \ two numbers in the sequence is calculated by adding the last two numbers after\
    \ the third number in the sequence\n        val lastTwo = numbers.get(n-2) + numbers.get(n-1)\
    \ + numbers.get(n)\n        numbers.add(lastTwo)\n        numbers.asInstanceOf[List[Long]]\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplytuu71n.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnumbers\e[0m = \e[33mnew\e\
    [0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m             \
    \             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) Nil\n        else if (n % 2 == 0) (n to 1l) map (_.toLong)\
    \ ::: tri(n - 1l) ::: tri(n - 2l) ::: tri(n + 1l) \n        else (n to 1l) map\
    \ (_.toLong) ::: tri(n - 1l) ::: tri(n + 2l) ::: tri(n + 3l) \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpwug8wlj4.scala:22:44 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) (n to \e[31m1l\e[0m) map (_.toLong) ::: tri(n - \e[31m1l\e\
    [0m) ::: tri(n - \e[31m2l\e[0m) ::: tri(n + \e[31m1l\e[0m) \n\e[31m\e[31m   |\e\
    [0m                                            ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => _$1.toLong.\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmpwug8wlj4.scala:23:28 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m (n to \e[31m1l\e[0m) map (_.toLong)\
    \ ::: tri(n - \e[31m1l\e[0m) ::: tri(n + \e[31m2l\e[0m) ::: tri(n + \e[31m3l\e\
    [0m) \n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 =>\
    \ _$2.toLong.\n2 errors found\n"
  stdout: ''
  timestamp: 1659979956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n == 0) List(1l, 3l, 2l)\n        else tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg57wtn8b.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var lst = ListBuffer.empty[Long]\n        var prev = 0\n        var cur\
    \ = 1\n        var next = cur + prev + cur\n        while ( n > 0) {\n       \
    \     lst.append(prev)\n            prev = cur\n            cur = next\n     \
    \       next = cur + prev + cur\n            n -= 1\n        }\n        lst.iterator\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaorfh3gc.scala:30:14 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            n -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member of\
    \ Long - did you mean n.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaorfh3gc.scala:32:12\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        lst.iterator\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Iterator[Long]\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list: List[Long] = List().init\n        if (n < 2)\n            list\
    \ = (1 to n).map(tri(n + 1))\n        else\n            list = (tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)).take(n + 1).reverse\n        list.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsaob04mh.scala:23:25\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            list = (\e[31m1\e\
    [0m to n).map(tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                  \
    \       ^\e[0m\n\e[31m   |\e[0m                         Found:    (n : Long)\n\
    \e[31m   |\e[0m                         Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpsaob04mh.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            list = (tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n + \e[31m1\e[0m)).take(n + \e[31m1\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var a = 0\n        var b = 1\n        var c = 2\n        var ls = List(a,\
    \ b, c).toList\n        var i = 0\n        while(i < n) {\n            ls = ls\
    \ :+ c\n            b = c\n            c = a + b\n            a = b\n        \
    \    i += 1\n        }\n        return ls\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptq9c02gc.scala:33:15\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mreturn\e[0m ls\n\
    \e[31m\e[31m   |\e[0m               ^^\e[0m\n\e[31m   |\e[0m               Found:\
    \    (ls : List[Int])\n\e[31m   |\e[0m               Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979959
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fibo = mutable.ListBuffer(\n            mutable.ListBuffer((1L).toLong,\
    \ 3L).toList\n        )\n        for (i<-1 to n / 2) fibo ::= (fibo(i).zip(fibo(i\
    \ + 1)).map(x => x(0) + x(1))).toList\n        if (n % 2 == 1) fibo.flatMap(x\
    \ => List(x.toLong, x.toLong + x.toLong))\n        else fibo.flatMap(x => List(x.toLong,\
    \ x.toLong + x.toLong + x.toLong))\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0r_sz2sd.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfibo\e[0m = mutable.ListBuffer(\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0r_sz2sd.scala:24:21 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mfor\e[0m (i<-\e[31m1\e[0m to n / \e[31m2\e[0m) fibo ::=\
    \ (fibo(i).zip(fibo(i + \e[31m1\e[0m)).map(\e[36mx\e[0m => x(\e[31m0\e[0m) + x(\e\
    [31m1\e[0m))).toList\n\e[31m\e[31m   |\e[0m                     ^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Found:    Long\n\e[31m   |\e[0m            \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def add(a: Long, c : Long, d: Long) : List[Long] = {\n            a ::\
    \ c :: d :: Nil\n        }\n        def recur(n: Long, a: Long, c : Long, d :\
    \ Long) : List[Long] = {\n            n match {\n                case 1 => List(d)\n\
    \                case 2 => List(a, d)\n                case 3 => List(a, c, d)\n\
    \                case _ => {\n                    val newA = add(a, c, d)\n  \
    \                  recur(n - 1, newA, c, d)\n                }\n            }\n\
    \        }\n        recur(n, 1, 1, 1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp4dnqz1k.scala:31:33\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    recur(n -\
    \ \e[31m1\e[0m, newA, c, d)\n\e[31m\e[31m   |\e[0m                           \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                                 Found:    (newA\
    \ : List[Long])\n\e[31m   |\e[0m                                 Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def fib(n: Int): Int = {\n            if(n == 1) 2 else if (n == 0) 1\
    \ else {\n                val next = fib(n-1) + fib(n-2)\n                if (n\
    \ % 2 == 0) next else next + 1\n            }\n        }\n        val list = mutable.MutableList[Long]()\n\
    \        for(i <- 1 to n){\n            list += fib(2*i).toLong\n        }\n \
    \       list.slice(0,n+1)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppyi1b5r3.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.MutableList[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmppyi1b5r3.scala:28:22 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mfor\e[0m(i <- \e[31m1\e[0m to n){\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Found:    (n : Long)\n\e[31m   |\e[0m                      Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Recursion is elegant\n        // But this one is harder to explain\
    \ for beginners.\n        // Let's use 'lazy evaluation' technique to get familiar\
    \ with recursion.\n        // We can use 'recursion method' instead of 'while\
    \ loop'.\n        // First, let's define what this function should do.\n     \
    \   // We are given a list of n numbers, and we want to create new list of numbers,\n\
    \        // the first n + 1 numbers is the same as the first n + 1 numbers of\
    \ the Fibonacci sequence.\n        // And we can easily do that, because we can\
    \ use the recurrence tri(1) = 3, tri(n) = 1 + n/2, if n is even.\n        // And\
    \ if we want to create new list of numbers, we will do that by using tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1), \n        // if we want to create new list of numbers,\
    \ we will do that by using tri(n - 1) + tri(n - 2) + tri(n + 1),\n        // and\
    \ we know that we must use 'recursion method' instead of 'while loop'.\n     \
    \   // We can solve this problem by using a recursive function.\n        // So,\
    \ let's start by defining this function:\n        def fib(n: Long) : List[Long]\
    \ = {\n            val list = scala.collection.mutable.ListBuffer[Long]()\n  \
    \          if (n == 0 || n == 1) {\n                list += n\n              \
    \  return list.toList\n            } else {\n                fib(n-1) + fib(n-2)\
    \ + fib(n+1) + n // recursive call\n            }\n        }\n        // Now,\
    \ we can get familiar with recursive function by using recursion.\n        //\
    \ First, let's define what this function should do.\n        // We are given a\
    \ list of n numbers, and we want to create new list of numbers,\n        // the\
    \ first n + 1 numbers is the same as the first n + 1 numbers of the Fibonacci\
    \ sequence.\n        // And we can easily do that, because we can use the recurrence\
    \ tri(1) = 3, tri(n) = 1 + n/2, if n is even.\n        // And if we want to create\
    \ new list of numbers, we will do that by using tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1), \n        // if we want to create new list of numbers, we will do that\
    \ by using tri(n - 1) + tri(n - 2) + tri(n + 1),\n        // and we know that\
    \ we must use 'recursion method' instead of 'while loop'.\n        // We can solve\
    \ this problem by using a recursive function.\n        // So, let's start by defining\
    \ this function:\n        def fib(n: Long) : List[Long] = {\n            val list\
    \ = scala.collection.mutable.ListBuffer[Long]()\n            if (n == 0 || n ==\
    \ 1) {\n                list += n\n                return list.toList\n      \
    \      } else {\n                fib(n-1) + fib(n-2) + fib(n+1) + n // recursive\
    \ call\n            }\n        }\n\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7z3culwe.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mdef\e[0m \e[36mfib\e[0m(\e[36mn\e[0m: \e\
    [35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e[31m   |\e[0m \
    \       ^\e[0m\n\e[31m   |\e[0mfib is already defined as \e[33mmethod\e[0m \e\
    [35mfib\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must\
    \ all be defined in the same group of toplevel definitions\n\e[31m54 |\e[0m  \
    \          \e[33mval\e[0m \e[36mlist\e[0m = scala.collection.mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m55 |\e[0m            \e[33mif\e[0m (n == \e[31m0\e[0m\
    \ || n == \e[31m1\e[0m) {\n\e[31m56 |\e[0m                list += n\n\e[31m57\
    \ |\e[0m                \e[33mreturn\e[0m list.toList\n\e[31m58 |\e[0m       \
    \     } \e[33melse\e[0m {\n\e[31m59 |\e[0m                fib(n-\e[31m1\e[0m)\
    \ + fib(n-\e[31m2\e[0m) + fib(n+\e[31m1\e[0m) + n \e[34m// recursive call\e[0m\n\
    \e[31m60 |\e[0m            }\n\e[31m61 |\e[0m        }\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7z3culwe.scala:40:25 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                fib(n-\e[31m1\e[0m) + fib(n-\e[31m2\e[0m)\
    \ + fib(n+\e[31m1\e[0m) + n \e[34m// recursive call\e[0m\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp7z3culwe.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n >= 0, s\"n must be non-negative, got $n\")\n        require(n\
    \ % 2 == 0, s\"n must be even, got $n\")\n        if (n == 0) List(1L, 3L)\n \
    \       else (n / 2 :: tri(n-1) + tri(n-2) :: tri(n+1)).toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpytm_trs9.scala:24:32 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m (n / \e[31m2\e[0m :: tri(n-\e\
    [31m1\e[0m) + tri(n-\e[31m2\e[0m) :: tri(n+\e[31m1\e[0m)).toList\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n < 3) {\n            List.empty[Long]\n        } else if (n % 2 ==\
    \ 0) {\n            tri(n - 1) + tri(n - 2) + tri(n + 1)\n        } else {\n \
    \           tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(2 * n + 1)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo7g9_166.scala:24:23 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e\
    [0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpo7g9_166.scala:26:23 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m)\
    \ + tri(n + \e[31m1\e[0m) + tri(\e[31m2\e[0m * n + \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri_rec(n : Long, acc : List[Long]) : List[Long] = {\n          \
    \  n match {\n                case 0 => acc.reverse\n                case 1 =>\
    \ acc.reverse ::: List(1)\n                case 2 => acc.reverse ::: List(1, 3)\n\
    \                case _ => tri_rec(n-1, acc ::: (tri_rec(n-2, acc ::: List(3,\
    \ 1))))\n            }\n        }\n        tri_rec(n, List())\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcqh6wt9q.scala:24:26\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mcase\e\
    [0m \e[31m1\e[0m => acc.reverse ::: List(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                          ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                     Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m\
    \                          Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcqh6wt9q.scala:25:26 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m \e[31m2\e[0m => acc.reverse\
    \ ::: List(\e[31m1\e[0m, \e[31m3\e[0m)\n\e[31m\e[31m   |\e[0m                \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \        Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             \
    \             Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpcqh6wt9q.scala:26:61 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mcase\e[0m _ => tri_rec(n-\e[31m1\e\
    [0m, acc ::: (tri_rec(n-\e[31m2\e[0m, acc ::: List(\e[31m3\e[0m, \e[31m1\e[0m))))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \                   Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m  \
    \                                                Required: List[\e[1m\e[32mLong\e\
    [0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n == 0) List(1l, 3l) \n        else tri(n-1) + tri(n-2) + tri(n+1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwu2adoo9.scala:22:22 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m tri(n-\e[31m1\e[0m) + tri(n-\e\
    [31m2\e[0m) + tri(n+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979965
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val res = List(1L, n/2, n-1+(n%2)/2, n-1+(n%2)/2)\n        res.filter(_%2\
    \ != 0)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4bwvtjrf.scala:25)\n\tat Problem.main(tmp4bwvtjrf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val rec = new mutable.ListBuffer[Long]\n        if(n <= 0) rec.clear()\n\
    \        else {\n            val a = tri(n - 1).toLong\n            val b = tri(n\
    \ - 2).toLong\n            val c = tri(n - 3).toLong\n            rec += a\n \
    \           rec += b\n            rec += c\n        }\n        rec.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxo6fznkf.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrec\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                 \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxo6fznkf.scala:24:31\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36ma\e[0m = tri(n - \e[31m1\e[0m).toLong\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxo6fznkf.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mb\e[0m = tri(n - \e\
    [31m2\e[0m).toLong\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxo6fznkf.scala:26:31 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mc\e[0m = tri(n - \e\
    [31m3\e[0m).toLong\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case 0 | 1 | 2 => List(1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong)\n            case n => tri(n - 1) + tri(n - 2) + tri(n + 1)\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprwrwy97b.scala:23:33 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m n => tri(n - \e[31m1\e[0m)\
    \ + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of\
    \ List[Long], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var ret: List[Long] = List[Long]()\n        if (n == 0) {\n         \
    \   ret ++= List(0l)\n        } else if (n == 1) {\n            ret ++= List(1l)\n\
    \        } else {\n            val half = n / 2\n            ret ++= tri(n - 1)\
    \ + tri(n - 2) + tri(n + 1)\n        }\n        ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzlcdh5d2.scala:28:16 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            ret ++= tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m   value ++= is not a member of List[Long] - did you mean\
    \ List[Long].++?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzlcdh5d2.scala:28:31\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            ret ++= tri(n\
    \ - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def loop(i: Long, result : List[Long], tri : List[Long]) =\n        \
    \    if (i < 0) tri\n            else loop(i-1, result :+ tri(i - 1) + tri(i -\
    \ 2), tri :+ tri(i - 1))\n        loop(n, new mutable.ListBuffer[Long](), new\
    \ mutable.ListBuffer[Long]())\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E044] Cyclic Error: /tmp/tmpxdh0l1hp.scala:23:17 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m loop(i-\e[31m1\e[0m, result\
    \ :+ tri(i - \e[31m1\e[0m) + tri(i - \e[31m2\e[0m), tri :+ tri(i - \e[31m1\e[0m))\n\
    \e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                \
    \ Overloaded or recursive \e[33mmethod\e[0m \e[35mloop\e[0m needs return type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxdh0l1hp.scala:23:41\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m loop(i-\e\
    [31m1\e[0m, result :+ tri(i - \e[31m1\e[0m) + tri(i - \e[31m2\e[0m), tri :+ tri(i\
    \ - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \     ^^^^^\e[0m\n\e[31m   |\e[0m                                         Found:\
    \    Long\n\e[31m   |\e[0m                                         Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxdh0l1hp.scala:23:54\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m loop(i-\e\
    [31m1\e[0m, result :+ tri(i - \e[31m1\e[0m) + tri(i - \e[31m2\e[0m), tri :+ tri(i\
    \ - \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \                       Found:    Long\n\e[31m   |\e[0m                      \
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxdh0l1hp.scala:23:73 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m loop(i-\e[31m1\e[0m, result\
    \ :+ tri(i - \e[31m1\e[0m) + tri(i - \e[31m2\e[0m), tri :+ tri(i - \e[31m1\e[0m))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                          Found:    Long\n\e[31m   |\e[0m                   \
    \                   "
  stdout: ''
  timestamp: 1659979969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n >= 0) \n        if(n == 0) \n            Nil\n        else\
    \ \n            Nil + n :: tri(n - 1) + tri(n - 2) + tri(n - 3)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfiv4y8hl.scala:25:34 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            Nil + n :: tri(n - \e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n - \e[31m3\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val res : List[Long] = ListBuffer[Long]()\n        var tri : Long = n\
    \ + 3\n        if (tri > 0)\n        res += (tri.toLong)\n        if (tri % 2\
    \ == 0) {\n            var tri : Long = 1\n            while (tri < tri + tri)\
    \ {\n                tri = tri + tri\n                if (tri > 0)\n         \
    \       res += (tri.toLong)\n            }\n        }\n        res\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpga7frigh.scala:21:47\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mres\e\
    [0m : \e[35mList\e[0m[\e[35mLong\e[0m] = ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpga7frigh.scala:24:12 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        res += (tri.toLong)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member of List[Long]\
    \ - did you mean res.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpga7frigh.scala:30:20\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                res += (tri.toLong)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m           value\
    \ += is not a member of List[Long] - did you mean res.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def f(x : Long, y : Long, sum : Long) : List[Long] = if (y == 0) x ::\
    \ sum\n        else {\n            if (x % 2 != 0) y :: sum\n            else\n\
    \                f(x-1, y+1, sum + y)\n        }\n        f(n, n, List())\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpinedf8i5.scala:21:75 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mdef\e[0m \e[36mf\e[0m(\e[36mx\e[0m : \e\
    [35mLong\e[0m, \e[36my\e[0m : \e[35mLong\e[0m, \e[36msum\e[0m : \e[35mLong\e[0m)\
    \ : \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mif\e[0m (y == \e[31m0\e[0m) x ::\
    \ sum\n\e[31m\e[31m   |\e[0m                                                 \
    \                          ^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                  value :: is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpinedf8i5.scala:23:30 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m            \e[33mif\e[0m (x % \e[31m2\e[0m != \e[31m0\e[0m) y\
    \ :: sum\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                              value :: is not a member of Long\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpinedf8i5.scala:27:20 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        f(n, n, List())\n\e[31m\e[31m   |\e[0m      \
    \          ^^^^^^\e[0m\n\e[31m   |\e[0m                Found:    List[Nothing]\n\
    \e[31m   |\e[0m                Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val arr : mutable.ArrayList[Long] = new mutable.ArrayList[Long]\n   \
    \     arr(0) = 1\n        arr(1) = 3\n        for(i <- 2 to n) arr(i) = arr(i-1)\
    \ + arr(i-2)\n        arr(n+1) = arr(n) + arr(n-1)\n        arr.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppzbqq8tm.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m : mutable.ArrayList[\e\
    [35mLong\e[0m] = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m]\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppzbqq8tm.scala:21:48\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36marr\e[0m : mutable.ArrayList[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ArrayList[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                        \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmppzbqq8tm.scala:24:22 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mfor\e[0m(i <- \e[31m2\e[0m to n) arr(i) = arr(i-\e[31m1\e\
    [0m) + arr(i-\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\
    \e[31m   |\e[0m                      Found:    (n : Long)\n\e[31m   |\e[0m   \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n > 0)\n        val list: List[Long] = List().view.map(_.toLong)\n\
    \        val fibo = mutable.ArrayBuffer(3l, 1l, 2l)\n        var n2 =  if (n >=\
    \ 0) n else n + 1\n        var n1 = 0\n        while (n2 > 0) {\n            n1\
    \ += 1\n            list(n1) = fibo(2l) + 1l\n            fibo.push(n2)\n    \
    \        n2 -= 1\n        }\n        list\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj0kyu7dd.scala:22:49 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = List().view.map(_.toLong)\n\e[31m\e[31m   |\e[0m      \
    \                                         ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj0kyu7dd.scala:23:19 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mfibo\e[0m = mutable.ArrayBuffer(\e\
    [31m3l\e[0m, \e[31m1l\e[0m, \e[31m2l\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj0kyu7dd.scala:28:12\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            list(n1) = fibo(\e\
    [31m2l\e[0m) + \e[31m1l\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m\
    \   |\e[0m value update is not a member of List[Long] - did you mean list.updated?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = List[Long]()\n        if (n == 0) list += 0\n        if (n\
    \ == 1) list += 3\n        if (n % 2 == 0) list += n + tri(n - 1) + tri(n - 2)\
    \ + tri(n + 1)\n        else list += n / 2 + tri(n / 2) + tri(n / 2 - 1) + tri(n\
    \ / 2 + 1)\n        list.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4i7jkjwy.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (n == \e[31m0\e[0m) list += \e\
    [31m0\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4i7jkjwy.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (n == \e[31m1\e[0m) list += \e\
    [31m3\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4i7jkjwy.scala:24:29 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e\
    [0m) list += n + tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmp4i7jkjwy.scala:24:34 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e\
    [0m) list += n + tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\e[31m  \
    \ |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m\
    \ in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String):\
    \ String\n\e[31m   |\e[0mmatch arguments (List[Long])\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp4i7jkjwy.scala:25:18 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        \e[33melse\e[0m list += n / \e[31m2\e[0m + tri(n / \e[31m2\e\
    [0m) + tri(n / \e[31m2\e[0m - \e[31m1\e[0m) + tri(n / \e[31m2\e[0m + \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ += is not a member of List[Long] "
  stdout: ''
  timestamp: 1659979974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val result = mutable.ListBuffer[Long]()\n        result += 3l\n     \
    \   result += n.toLong / 2l\n        if (n.toLong % 2 == 0) {\n            result\
    \ += n.toLong / 2l\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy4_3h30o.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var a = 1 \n        var b = 1 \n        var l = 1 \n        var result:\
    \ List[Long] = Nil\n        var currentNumber: Long = n \n        while (currentNumber\
    \ > 2) {\n            a = currentNumber\n            b = b + a \n            l\
    \ = l + currentNumber \n            currentNumber = b + a \n            result\
    \ ::=  b + a + l \n        } \n        result.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp11dx96op.scala:27:16\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            a = currentNumber\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \           Found:    (currentNumber : Long)\n\e[31m   |\e[0m                Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp11dx96op.scala:29:16\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            l = l + currentNumber\
    \ \n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Found:    Long\n\e[31m   |\e[0m                Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var fibs = scala.collection.mutable.ListBuffer[Long]()\n        fibs\
    \ = fibs.updated(1, 3l)\n        n match {\n            case _ if n == 1 => fibs.toList\n\
    \            case _ if n % 2 == 0 => fibs = fibs.updated(fibs.tail, fibs.head\
    \ + fibs.tail)\n            case _ if n % 2 != 0 => fibs = fibs.updated(fibs.tail,\
    \ fibs.head + fibs.tail)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp68llnvbx.scala:25:61\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mcase\e[0m _\
    \ \e[33mif\e[0m n % \e[31m2\e[0m == \e[31m0\e[0m => fibs = fibs.updated(fibs.tail,\
    \ fibs.head + fibs.tail)\n\e[31m\e[31m   |\e[0m                              \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  Found:    scala.collection.mutable.ListBuffer[Long\
    \ @uncheckedVariance]\n\e[31m   |\e[0m  Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp68llnvbx.scala:25:77 -----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mcase\e[0m _ \e[33mif\e[0m n % \e[31m2\e\
    [0m == \e[31m0\e[0m => fibs = fibs.updated(fibs.tail, fibs.head + fibs.tail)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \           ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0m (x: String): String\n\e[31m   |\e[0mmatch arguments ((scala.collection.mutable.ListBuffer[Long]#tail\
    \ : \n\e[31m   |\e[0m  => scala.collection.mutable.ListBuffer[Long @uncheckedVariance]\n\
    \e[31m   |\e[0m))\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp68llnvbx.scala:26:61\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mcase\e[0m _\
    \ \e[33mif\e[0m n % \e[31m2\e[0m != \e[31m0\e[0m => fibs = fibs.updated(fibs.tail,\
    \ fibs.head + fibs.tail)\n\e[31m\e[31m   |\e[0m                              \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m  Found:    scala.collection.mutable.ListBuffer[Long\
    \ @uncheckedVariance]\n\e[31m   |\e[0m  Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmp68llnvbx.scala:26:77 -----------------------------\e\
    [0m\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659979975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val recurrence = if (n % 2 == 0) tri(n - 1) else tri(n - 2) + tri(n -\
    \ 1)\n        val result: List[Long] = recurrence.take(n + 1).map(_ + _)\n   \
    \     result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_qthdx29.scala:21:68 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrecurrence\e[0m = \e[33mif\e\
    [0m (n % \e[31m2\e[0m == \e[31m0\e[0m) tri(n - \e[31m1\e[0m) \e[33melse\e[0m tri(n\
    \ - \e[31m2\e[0m) + tri(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m             \
    \                                            ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_qthdx29.scala:22:49\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = recurrence.take(n + \e[31m1\e[0m).map(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                                \
    \ ^^^^^\e[0m\n\e[31m   |\e[0m                                                \
    \ Found:    Long\n\e[31m   |\e[0m                                            \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp_qthdx29.scala:22:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = recurrence.take(n + \e\
    [31m1\e[0m).map(_ + _)\n\e[31m\e[31m   |\e[0m                                \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \            Wrong number of parameters, expected: 1\n3 errors found\n"
  stdout: ''
  timestamp: 1659979975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case 0 => List(0l)\n            case 1 => List(0l,\
    \ 1l)\n            case 2 => List(0l, 1l, 2l)\n            case x => {\n     \
    \           var rec : Long = x match {\n                    case 0 => 3\n    \
    \                case 1 => 1 + x / 2\n                    case 2 => tri(x - 1)\
    \ + tri(x - 2) + tri(x + 1)\n                }\n                List(tri(x -1)\
    \ + rec, rec)\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0azwrjm_.scala:29:41 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mcase\e[0m \e[31m2\e[0m => tri(x\
    \ - \e[31m1\e[0m) + tri(x - \e[31m2\e[0m) + tri(x + \e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0azwrjm_.scala:31:31\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                List(tri(x\
    \ -\e[31m1\e[0m) + rec, rec)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var tri = List(1, 3)\n        if (n%2 == 0) {\n            for (i <-\
    \ 0 to n-1) {\n                tri = tri.::(tri(tri.length-1) + tri(tri.length\
    \ - 2) + tri(tri.length))\n            }\n        }\n        else {\n        \
    \    for (i <- 0 to n-1) {\n                tri = tri.::(tri(tri.length-1) + tri(tri.length\
    \ - 2))\n            }\n        }\n        tri.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyssbm3cl.scala:23:27\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mfor\e[0m (i\
    \ <- \e[31m0\e[0m to n-\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                \
    \           ^^^\e[0m\n\e[31m   |\e[0m                           Found:    Long\n\
    \e[31m   |\e[0m                           Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpyssbm3cl.scala:28:27 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mfor\e[0m (i <- \e[31m0\e[0m to n-\e\
    [31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    Long\n\e[31m   |\e[0m         \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpyssbm3cl.scala:32:12 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        tri.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e[0m       \
    \ Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var a = 3l\n        var b = 1l\n        var c: Long = 1l\n        val\
    \ list = collection.mutable.ListBuffer[Long]()\n        for {\n            x <-\
    \ 1 to n \n            if x % 2 == 0\n            b = b + a \n            a =\
    \ a + (2 * b) \n            c <- 1l to n\n            if x % 2 == 1\n        \
    \    list.add(a + c +b)\n        } yield list.toList \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_2362hji.scala:33:8 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        } \e[33myield\e[0m list.toList \n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '<-' expected, but '}' found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_2362hji.scala:26:22 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            x <- \e[31m1\e[0m to n \n\e[31m\e[31m   |\e\
    [0m                      ^\e[0m\n\e[31m   |\e[0m                      Found: \
    \   (n : Long)\n\e[31m   |\e[0m                      Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659979974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 1) List(n) else {\n            val tri1 = tri(n - 1)\n     \
    \       val tri2 = tri(n - 2) + tri(n - 1) + tri(n - 2)\n            tri1 :::\
    \ tri2\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp152liri9.scala:23:34 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mtri2\e[0m = tri(n -\
    \ \e[31m2\e[0m) + tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def f1(a : Long, i : Long) : List[Long] = if(i < n) i :: f1(a + tri(n\
    \ - i), i + 1) else List(a)\n        f1(3, 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp79cjiou2.scala:21:70 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mdef\e[0m \e[36mf1\e[0m(\e[36ma\e[0m : \e\
    [35mLong\e[0m, \e[36mi\e[0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = \e[33mif\e[0m(i < n) i :: f1(a + tri(n - i), i + \e[31m1\e[0m) \e[33melse\e\
    [0m List(a)\n\e[31m\e[31m   |\e[0m                                           \
    \                         ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0m (x: String): String\n\e[31m   |\e[0mmatch arguments (List[Long])\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979974
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1L)\n        else if (n == 1) List(3L)\n        else\
    \ List(3L, n * ((n-1L) + 1L) / 2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_mvp7h56.scala:26)\n\tat Problem.main(tmp_mvp7h56.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri0(i: Long, acc: List[Long]) : List[Long] = {\n            if (i\
    \ <= 0) List() else tri0(i - 1, tri0(i - 2, acc + i::acc))\n        }\n      \
    \  tri0(n + 1, List())\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppurzz8hv.scala:22:64 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (i <= \e[31m0\e[0m) List()\
    \ \e[33melse\e[0m tri0(i - \e[31m1\e[0m, tri0(i - \e[31m2\e[0m, acc + i::acc))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val first = n.toLong\n        val second = (first+1).toLong\n       \
    \ val third = (first+second).toLong\n        val fourth = (first+second+third).toLong\n\
    \        val ls = List((first.toLong,3), (second.toLong,2), (third.toLong,1),\
    \ (fourth.toLong,0))\n        ls.flatten\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphjncf1si.scala:26:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        ls.flatten\n\e[31m\e[31m   |\e[0m           \
    \       ^\e[0m\n\e[31m   |\e[0mno given instance of type ((Long, Int)) => IterableOnce[B]\
    \ was found for parameter toIterableOnce of \e[33mmethod\e[0m \e[35mflatten\e\
    [0m in \e[33mtrait\e[0m \e[35mStrictOptimizedIterableOps\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mwhere:    B is a type variable with constraint <: Long\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val n = n.toInt\n        if (n < 3) return List(1)\n        val res =\
    \ List(1)\n        if (n % 2 == 0) res += (tri(n - 1)) + (tri(n - 2)) + tri(n\
    \ +1) + 1\n        else res += (tri(n - 1) + tri(n - 2) + tri(n + 1))\n      \
    \  res\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2fl2fufw.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp2fl2fufw.scala:24:28 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e[0m) res\
    \ += (tri(n - \e[31m1\e[0m)) + (tri(n - \e[31m2\e[0m)) + tri(n +\e[31m1\e[0m)\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                        ^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of List[Int] - did you mean\
    \ res.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2fl2fufw.scala:24:44\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mif\e[0m (n\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) res += (tri(n - \e[31m1\e[0m)) + (tri(n - \e\
    [31m2\e[0m)) + tri(n +\e[31m1\e[0m) + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m    \
    \                           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2fl2fufw.scala:25:17 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33melse\e[0m res += (tri(n - \e[31m1\e[0m)\
    \ + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m    \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ List[Int] - did you mean res.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2fl2fufw.scala:25:32\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33melse\e[0m res\
    \ += (tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\
    \e[31m\e[31m   |"
  stdout: ''
  timestamp: 1659979981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triTri(i : Int) : Long = i.toLong + n/2 - n/(2*i.toLong) + n/(2*(i.toLong+1))\n\
    \        val t0 = -1L\n        val t1 = -1L\n        val t3 = -1L\n        var\
    \ list : List[Long] = List(t0,t1,t3)\n        var i = 2\n        while (i<=n)\
    \ {\n            list ::= triTri(i)\n            i += 1\n        }\n        list.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqrlh8elu.scala:34)\n\tat Problem.main(tmpqrlh8elu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val n = n.toLong\n        val temp = new mutable.ArrayBuffer.ofDouble()\n\
    \        val temp2 = new mutable.ArrayBuffer.ofDouble()\n        val temp3 = new\
    \ mutable.ArrayBuffer.ofDouble()\n        var count = 1\n        for(i <- 0 to\
    \ (n+2)/2) {\n            if (i % 2 == 0) {\n                temp += i.toDouble\n\
    \                temp2 += temp.toDouble\n                temp3 += temp2.toDouble\n\
    \            } else {\n                temp += ((temp3 * ((count-1).toDouble)).toDouble)\n\
    \                temp2 += ((temp2 * ((count-1).toDouble)).toDouble)\n        \
    \        temp3 += ((temp3 * ((count-1).toDouble)).toDouble)\n                temp2\
    \ += temp2.toDouble\n                temp3 += temp3.toDouble\n               \
    \ count += 1\n            }\n        }\n        temp.clear()\n        temp2.clear()\n\
    \        temp3.clear()\n        val ls = ListBuffer.ofLong()\n        for(i <-\
    \ 0 to (n+2)/2) {\n            if (i % 2 == 0) {\n                ls += temp(i)\n\
    \            } else {\n                ls += ((temp3 * ((i-1).toDouble)).toLong)\n\
    \            }\n        }\n        ls.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4lcl_p8o.scala:21:16 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toLong\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4lcl_p8o.scala:22:23 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mtemp\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer.ofDouble()\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4lcl_p8o.scala:23:24 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mtemp2\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer.ofDouble()\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4lcl_p8o.scala:24:24 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mtemp3\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer.ofDouble()\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4lcl_p8o.scala:43:28 ------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mls\e[0m = ListBuffer.ofLong()\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ ofLong is not a member of object scala.collection.mutable.ListBuffer\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var temp: Long = 1\n        var seq: List[Long] = Nil\n        var i:\
    \ Long = 0\n        if (n <= 0) {\n            return Nil\n        }\n       \
    \ while (i <= n) {\n            temp += n\n            seq = Seq(temp.toLong,\
    \ temp.toLong + seq(1), seq(2) + seq(3))\n            i += 1\n        }\n    \
    \    return seq\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_25xf9ka.scala:29:21\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            seq = Seq(temp.toLong,\
    \ temp.toLong + seq(\e[31m1\e[0m), seq(\e[31m2\e[0m) + seq(\e[31m3\e[0m))\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Found:    scala.collection.mutable.Seq[Long]\n\
    \e[31m   |\e[0m                  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659979980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var a = n.toLong + 1\n        var b = a\n        var c = a\n        var\
    \ list = List[Long](1l,3l,2l,8l)\n        var newList: List[Long] = list.takeRight(n\
    \ + 1)\n        while (b < n){\n            var c = a + b + c\n            a +=\
    \ b\n            b += c\n            list += c\n            newList += c\n   \
    \     }\n        newList.takeRight(n + 1).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0a4lz1e0.scala:25:49\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mvar\e[0m \e[36mnewList\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = list.takeRight(n + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                 Found:    Long\n\e\
    [31m   |\e[0m                                                 Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0a4lz1e0.scala:27:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mvar\e\
    [0m \e[36mc\e[0m = a + b + c\n\e[31m\e[31m   |\e[0m                          \
    \  ^\e[0m\n\e[31m   |\e[0m                            Recursive \e[33mvariable\e\
    [0m \e[35mc\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0a4lz1e0.scala:30:17 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m            list += c\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0a4lz1e0.scala:31:20 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            newList += c\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0a4lz1e0.scala:33:26\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        newList.takeRight(n +\
    \ \e[31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m                          ^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Long\n\e[31m   |\e[0m\
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659979982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val l: List[Long] = List()\n        if (n <= 2) {\n            l += n.toLong\n\
    \        }\n        else {\n            val leftTri: Long = tri(n - 2)\n     \
    \       val rightTri: Long = tri(n - 1)\n            l += leftTri\n          \
    \  l += rightTri\n            l += leftTri + rightTri\n        }\n        l\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd2s4npxc.scala:23:14 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            l += n.toLong\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of List[Long]\
    \ - did you mean l.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd2s4npxc.scala:26:35\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e\
    [36mleftTri\e[0m: \e[35mLong\e[0m = tri(n - \e[31m2\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                      Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e\
    [31m]\e[0m\n\e[31m   |\e[0m                                Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd2s4npxc.scala:27:36\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e\
    [36mrightTri\e[0m: \e[35mLong\e[0m = tri(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                        Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                                 Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd2s4npxc.scala:28:14\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            l += leftTri\n\
    \e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of List[Long] - did you mean l.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpd2s4npxc.scala:29:14 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m            l += rightTri\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of List[Long] - did you\
    \ mean l.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd2s4npxc.scala:30:14\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            l += leftTri\
    \ + rightTri\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m    \
    \        value += is not a member of L"
  stdout: ''
  timestamp: 1659979983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val lst = mutable.ListBuffer(3l.toLong)\n        if(n > 3l) {\n     \
    \       lst += tri(n - 3l) + tri(n - 2l) + tri(n + 1l)\n        }\n        lst.map(_.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplpb9bg93.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlst\e[0m = mutable.ListBuffer(\e\
    [31m3l\e[0m.toLong)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(0l)\n        else {\n            val (a,b,c) = (2l,\
    \ 1l, 3l)\n            var sum = a + b + c\n            var newSum = sum\n   \
    \         var lastTwo = a + b\n            var lastThree = b + c\n           \
    \ var newList = List(0l)\n            var listIter = Iterator.iterate(1l) { _\
    \ => \n                newSum += a\n                if (newSum > n) {\n      \
    \              newSum += c\n                    lastTwo += b\n               \
    \     lastThree += c\n                }\n                listIter += newSum\n\
    \                newSum -= a\n                if (newSum > n) newSum -= c\n  \
    \              listIter += newSum\n                newSum -= a\n             \
    \   if (newSum > n) newSum -= c\n                listIter += newSum\n        \
    \        newSum -= a\n                if (newSum > n) newSum -= c\n          \
    \      listIter += newSum\n                newSum -= a\n                if (newSum\
    \ > n) newSum -= c\n                listIter += newSum\n                newSum\
    \ += b\n                if (newSum > n) {\n                    newSum += c\n \
    \                   lastTwo += b\n                    lastThree += c\n       \
    \         }\n                listIter += newSum\n                newSum -= b\n\
    \                if (newSum > n) newSum -= c\n                listIter += newSum\n\
    \                newSum -= b\n                if (newSum > n) newSum -= c\n  \
    \              listIter += newSum\n                newSum -= b\n             \
    \   if (newSum > n) newSum -= c\n                listIter += newSum\n        \
    \        newSum += c\n                if (newSum > n) {\n                    newSum\
    \ += b\n                    lastTwo += b\n                    lastThree += b\n\
    \                }\n                listIter += newSum\n                newSum\
    \ -= c\n                if (newSum > n) newSum -= b\n                listIter\
    \ += newSum\n                newSum -= c\n                if (newSum > n) newSum\
    \ -= b\n                listIter += newSum\n                newSum -= c\n    \
    \            if (newSum > n) newSum -= b\n                listIter += newSum\n\
    \                newSum += 0\n                if (newSum > n) {\n            \
    \        newSum += a\n                    lastTwo += a\n                    lastThree\
    \ += a\n                }\n                listIter += newSum\n              \
    \  newSum -= a\n                if (newSum > n) newSum -= a\n                listIter\
    \ += newSum\n                newSum -= a\n                if (newSum > n\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg19kulct.scala:93:4 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg19kulct.scala:108:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m108 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpg19kulct.scala:36:16 ---------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                listIter += newSum\n\e[31m\e[31m   |\e[0m\
    \                ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvariable\e\
    [0m \e[35mlistIter\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpg19kulct.scala:39:16 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m                listIter += newSum\n\e[31m\e[31m   |\e[0m            \
    \    ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvariable\e[0m \e[35mlistIter\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg19kulct.scala:42:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                listIter\
    \ += newSum\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m    \
    \            Recursive \e[33mvariable\e[0m \e[35mlistIter\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg19kulct.scala:45:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m                listIter\
    \ += newSum\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m    \
    \            Recursive \e[33mvariable\e[0m \e[35mlistIter\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg19kulct.scala:48:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m                listIter\
    \ += newSum\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m    \
    \            Recursive \e[33mv"
  stdout: ''
  timestamp: 1659979983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 3) {\n            List.fill(3).reverse\n        }\n        else\
    \ {\n            var a = 1L\n            var b = 2L\n            var n2 = n\n\
    \            var m = 3\n            val list: List[Long] = List.fill(5)(List(0L))\
    \ \n            while (n2 != 0) {\n                if (n2 % 2 == 0) {\n      \
    \              list = list ::: (a + b)\n                    a = b\n          \
    \          b = m\n                }\n                else {\n                \
    \    list = list ::: (m+b)\n                    m = b\n                    b =\
    \ a + m\n                }\n                n2 -= 1\n            }\n         \
    \   list\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmpft4s7f.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            List.fill(\e[31m3\e[0m).reverse\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value reverse is not a member of (=> Any) => List[Any]\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpmpft4s7f.scala:29:52 --------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mlist\e[0m: \e[35mList\e[0m[\e\
    [35mLong\e[0m] = List.fill(\e[31m5\e[0m)(List(\e[31m0L\e[0m)) \n\e[31m\e[31m \
    \  |\e[0m                                                ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                Found:    \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                   \
    \                             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmpft4s7f.scala:32:32 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                    list = list ::: (a + b)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                value ::: is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmpft4s7f.scala:37:32 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    list = list ::: (m+b)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                            value ::: is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpmpft4s7f.scala:38:24 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    m = b\n\e[31m\e[31m   |\e[0m    \
    \                    ^\e[0m\n\e[31m   |\e[0m                        Found:   \
    \ (b : Long)\n\e[31m   |\e[0m                        Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659979985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n<2) List[Long](n) else tri(n-2)+tri(n-1)+tri(n+1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjracryc_.scala:21:43 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m(n<\e[31m2\e[0m) List[\e[35mLong\e\
    [0m](n) \e[33melse\e[0m tri(n-\e[31m2\e[0m)+tri(n-\e[31m1\e[0m)+tri(n+\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val recurrence = (n, 3, n, 1)\n        val sum = recurrence.foldLeft(0)((total,\
    \ _) => total + _)\n        val last = recurrence.foldLeft(List[Long]())((lastList,\
    \ number) => lastList :+ number)\n        last.headOption.toList :+ last.last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvlns7xdh.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msum\e[0m = recurrence.foldLeft(\e\
    [31m0\e[0m)((\e[36mtotal\e[0m, _) => total + _)\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value foldLeft\
    \ is not a member of (Long, Int, Long, Int)\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvlns7xdh.scala:23:30 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mlast\e[0m = recurrence.foldLeft(List[\e[35mLong\e\
    [0m]())((\e[36mlastList\e[0m, \e[36mnumber\e[0m) => lastList :+ number)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            value foldLeft is not a member of (Long, Int, Long, Int)\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val l = (n + 2l).quot(2l)\n        val l1 = l.quot(1l)\n        val l2\
    \ = l.quot(2l)\n        (l1, l2, l2.add(1l))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo_64art0.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = (n + \e[31m2l\e\
    [0m).quot(\e[31m2l\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue quot is not a member of Long, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.BigDecimal.long2bigDecimal\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo_64art0.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        (l1, l2, l2.add(\e[31m1l\e\
    [0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (Nothing, Nothing, Nothing)\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list = List[Long]()\n        var temp = 1 \n        // write your\
    \ code here\n        if (n<=1) {\n            list += temp\n        }\n      \
    \  else if ((n%2==0)){\n            list = list :+ temp\n            temp = temp\
    \ + n / 2\n            list = list :+ temp\n            list = list :+ temp +\
    \ n/2\n        }\n        else if ((n%2==1)){\n            list = list :+ temp\n\
    \            temp = temp + n / 2\n            list = list :+ temp\n          \
    \  list = list :+ temp + n\n        }\n        return list\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0g9w57ki.scala:25:17 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            list += temp\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of List[Long]\
    \ - did you mean List[Long].!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0g9w57ki.scala:29:19\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            temp = temp + n /\
    \ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                   Found:    Long\n\e[31m   |\e[0m              \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0g9w57ki.scala:35:19\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            temp = temp + n /\
    \ \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                   Found:    Long\n\e[31m   |\e[0m              \
    \     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n<2) List(1l.toLong)\n        else tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1) + List(n)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpis9_fvuo.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m) + List(n)\n\e[31m\e[31m   |\e[0m   \
    \          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) \n            return Nil\n        if (n == 1)\n         \
    \   return Nil\n        val xs = (tri(n-1) + tri(n-2) + tri(n+1)).foldLeft(Vector(3))((acc,\
    \ x) => x :: acc)\n        xs.headOption map (x=> x * x) \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpazukwpko.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mxs\e[0m = (tri(n-\e[31m1\e\
    [0m) + tri(n-\e[31m2\e[0m) + tri(n+\e[31m1\e[0m)).foldLeft(Vector(\e[31m3\e[0m))((\e\
    [36macc\e[0m, \e[36mx\e[0m) => x :: acc)\n\e[31m\e[31m   |\e[0m              \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = new mutable.ArrayBuffer[Long]()\n        var tri1 = tri(n/3l)\n\
    \        list.push(tri1.head)\n        list.push(tri1.last)\n        var tri2\
    \ = tri(n-2l)\n        list.push(tri2.last)\n        list.push(tri2.last+tri2.head)\n\
    \        list\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeijwervz.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 1) List(1, n)\n        else if (n % 2 == 0) tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n        else tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n\
    \ + 2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp7w_o2gv.scala:22:40 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp7w_o2gv.scala:23:24 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n + \e[31m1\e[0m) + tri(n + \e[31m2\e[0m)\n\e[31m\e[31m   |\e\
    [0m             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      val list = new mutable.ListBuffer[Long]()\n      def fibonacci(n: Long,\
    \ list: List[Long]): List[Long] = n match {\n        case 1 => list.copy(n ->\
    \ 1l)\n        case 2 => list.copy(1 -> list.last, n -> list.last)\n        case\
    \ 3 => list.copy(list.last -> list.last + list.last)\n        case _ => {\n  \
    \        val a = fibonacci(n - 1, list)\n          val b = fibonacci(n - 2, list)\n\
    \          val c = fibonacci(n + 1, list)\n          a ::: b ::: c\n        }\n\
    \      }\n      fibonacci(n, list)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4roaltwl.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4roaltwl.scala:23:23\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mcase\e[0m \e\
    [31m1\e[0m => list.copy(n -> \e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m           \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value copy is not a member of List[Long]\
    \ - did you mean list.coll?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4roaltwl.scala:24:23\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mcase\e[0m \e\
    [31m2\e[0m => list.copy(\e[31m1\e[0m -> list.last, n -> list.last)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value copy is\
    \ not a member of List[Long] - did you mean list.coll?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4roaltwl.scala:25:23 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mcase\e[0m \e[31m3\e[0m => list.copy(list.last\
    \ -> list.last + list.last)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m      value copy is not a member of List[Long] - did you mean\
    \ list.coll?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4roaltwl.scala:25:51\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mcase\e[0m \e\
    [31m3\e[0m => list.copy(list.last -> list.last + list.last)\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of (Long, Long), but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps"
  stdout: ''
  timestamp: 1659979990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val first = n / 2\n        val second = (n - first)\n        val third\
    \ = (first + second)\n        List(n, first, second, third, n + first)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp0ta10j4.scala:27)\n\tat Problem.main(tmpp0ta10j4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n > 0, \"Tribonacci sequence defined only from n>=0.\")\n   \
    \     require(n % 2 == 0, \"Tribonacci sequence defined only for even n. Try tri(n-2).\"\
    )\n        var ret : List[Long] = Nil\n        if (n <= 1) ret = List(n)\n   \
    \     else {\n            val f = tri(n-2)\n            val l = f(0) :: f(1) ::\
    \ f(2) :: f(3) :: Nil\n            ret = f(0) :: l ::  f(1) :: f (3) :: Nil\n\
    \        }\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5ta36mzj.scala:28:18\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            ret = f(\e[31m0\e\
    [0m) :: l ::  f(\e[31m1\e[0m) :: f (\e[31m3\e[0m) :: Nil\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                Found:    List[Matchable]\n\e[31m   |\e[0m                  Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n >= 1, \"n must be positive\")\n        val triArray = ListBuffer[Long]()\n\
    \        triArray.append(1l)\n        triArray.append(3l)\n        if ((n + 1)\
    \ % 2 == 0) {\n            triArray.append(3l)\n            triArray.append(2l)\n\
    \        } else {\n            triArray.append(1l)\n            triArray.append(triArray(1)\
    \ + triArray(2) + triArray(3))\n        }\n        return triArray.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz3e7ktmf.scala:35)\n\tat Problem.main(tmpz3e7ktmf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triaux(n: Long) : List[Long] = \n            if (n == 1L) List(1L.toLong)\n\
    \            else \n                triaux(n / 2L) ++ triaux((n / 2L) + 1L)\n\
    \        triaux(n) \n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\tat Problem$.triaux$1(tmpwj8f524v.scala:24)\n\
    \tat Problem$"
  stdout: ''
  timestamp: 1659979992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // write your code in Scala\n        // return List[Long](1, n, tri(n\
    \ - 1), tri(n - 2))\n        val li = new ListBuffer[Long]\n        li += n\n\
    \        li.map(_ + 1) + (if (n % 2 == 0) tri(n - 1) else tri(n - 2))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvrr4osna.scala:25:22 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        li.map(_ + \e[31m1\e[0m) + (\e[33mif\e[0m (n\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) tri(n - \e[31m1\e[0m) \e[33melse\e[0m tri(n\
    \ - \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue + is not a member of scala.collection.mutable.ListBuffer[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0) Nil\n        else (n to 1 by -1).map(tri(_ + _)).mkList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpx_ns4y1o.scala:22:36 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m (n to \e[31m1\e[0m by -\e[31m1\e\
    [0m).map(tri(_ + _)).mkList\n\e[31m\e[31m   |\e[0m                           \
    \         ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m   I could not infer the type of the parameter _$1 of expanded function:\n\
    \e[31m   |\e[0m   (_$1, _$2) => _$1 + _$2.\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpx_ns4y1o.scala:22:40 -----------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33melse\e[0m (n to \e[31m1\e[0m by -\e[31m1\e[0m).map(tri(_\
    \ + _)).mkList\n\e[31m\e[31m   |\e[0m                                        ^\e\
    [0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \   I could not infer the type of the parameter _$2 of expanded function:\n\e\
    [31m   |\e[0m   (_$1, _$2) => _$1 + _$2.\n2 errors found\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \       val ls = mutable.ListBuffer[Long]()\n       if (n == 0) ls += 0\n    \
    \   else if (n % 2 == 0) ls += 1 + tri(n / 2)\n       else ls += tri(n - 1) +\
    \ tri(n - 2) + tri(n + 1)\n       ls.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgn419hci.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m       \e[33mval\e[0m \e[36mls\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        n match {\n            case 0 => List.empty[Long]\n            case 1\
    \ => List(3L)\n            case 2 => List((1L).toLong, 3L, (2L).toLong, 8L).toList\n\
    \            case 3 => List((1L).toLong, 3L, (2L).toLong, 8L, \n             \
    \       (3L).toLong, 9L, (5L).toLong, 15L, 18L, 20L, 23L, 24L, 25L, \n       \
    \             26L, 28L, 31L, 35L, 36L, 37L, 38L, 39L, 40L, 42L, 43L, 45L, \n \
    \                   46L, 47L, 48L, 49L, 50L, 51L, 52L, 53L, 54L, 55L, 56L, 57L,\
    \ \n                    58L, 59L, 60L, 61L, 62L, 63L, 64L, 65L, 66L, 67L, 68L,\
    \ 69L, \n                    70L, 71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L, 79L,\
    \ 80L, 81L, \n                    82L, 83L, 84L, 85L, 86L, 87L, 88L, 89L, 90L,\
    \ 91L, 92L, 93L, \n                    94L, 95L, 96L, 97L, 98L, 99L, 100L, 101L,\
    \ 102L, 103L, 104L, \n                    105L, 106L, 107L, 108L, 109L, 110L,\
    \ 111L, 112L, 113L, 114L, \n                    115L, 116L, 117L, 118L, 119L,\
    \ 120L, 121L, 122L, 123L, 124L, \n                    125L, 126L, 127L, 128L,\
    \ 129L, 130L, 131L, 132L, 133L, 134L, \n                    135L, 136L, 137L,\
    \ 138L, 139L, 140L, 141L, 142L, 143L, 144L, \n                    145L, 146L,\
    \ 147L, 148L, 149L, 150L, 151L, 152L, 153L, 154L, \n                    155L,\
    \ 156L, 157L, 158L, 159L, 160L, 161L, 162L, 163L, 164L, \n                   \
    \ 165L, 166L, 167L, 168L, 169L, 170L, 171L, 172L, 173L, 174L, \n             \
    \       175L, 176L, 177L, 178L, 179L, 180L, 181L, 182L, 183L, 184L, \n       \
    \             185L, 186L, 187L, 188L, 189L, 190L, 191L, 192L, 193L, 194L, \n \
    \                   195L, 196L, 197L, 198L, 199L, 200L, 201L, 202L, 203L, 204L,\
    \ \n                    205L, 206L, 207L, 208L, 209L, 210L, 211L, 212L, 213L,\
    \ 214L, \n                    215L, 216L, \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8tws41dd.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8tws41dd.scala:60:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp8tws41dd.scala:59:1 ---------------------\e[0m\e[0m\n\
    \e[31m59 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmp8tws41dd.scala:46:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m46 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      if (n<2) List.empty\n      else {\n        val l = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        if (n%2==0) \n          l.append(i)\n        i+=1\n\
    \        if (n%3==0) \n          l.append(i)\n        i+=1\n        if (n%5==0)\n\
    \          l.append(i)\n        i+=1\n        if (n%7==0)\n          l.append(i)\n\
    \        i+=1\n        l.append(i)\n        l.toList\n      }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7dzy0j4i.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Write your code here\n        if (n < 3) return List()\n        if\
    \ (n == 3) List(1l, 3l, 2l)\n        else\n            {\n                if (n\
    \ % 2 == 0) List(tri(n - 1), tri(n - 2) + tri(n + 1))\n                else List(tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), tri(n))\n            }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpasx12ya9.scala:26:40\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m\
    \ (n % \e[31m2\e[0m == \e[31m0\e[0m) List(tri(n - \e[31m1\e[0m), tri(n - \e[31m2\e\
    [0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                         \
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \     Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e\
    [31m   |\e[0m                                     Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpasx12ya9.scala:26:60 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m (n % \e[31m2\e[0m == \e\
    [31m0\e[0m) List(tri(n - \e[31m1\e[0m), tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpasx12ya9.scala:27:37 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                \e[33melse\e[0m List(tri(n - \e[31m1\e[0m)\
    \ + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m), tri(n))\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E0"
  stdout: ''
  timestamp: 1659979996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = mutable.ListBuffer[Long]()\n        val b = mutable.ListBuffer[Long]()\n\
    \        val c = mutable.ListBuffer[Long]()\n        if (n <= 1L) {\n        \
    \    a.append(1L);\n            b.append(1L);\n            c.append(1L);\n   \
    \         a.append(1L);\n            a.append(1L);\n            a.append(1L);\n\
    \            b.append(1L);\n            b.append(1L);\n            b.append(1L);\n\
    \            c.append(1L);\n            c.append(1L);\n            c.append(1L);\n\
    \        }\n        val rec : Long => Long = (_ : Long) => {\n            val\
    \ newA = a.take(n-1L).toList\n            val newB = b.take(n-1L).toList\n   \
    \         val newC = c.take(n-1L).toList\n            if (n % 2 == 0L) newA.append(newA.get.head\
    \ + newB.get.head + newC.get.head)\n            else newA.append(newA.get.head\
    \ + newB.get.head + newC.get.head + newA.get.tail.head + newA.get.tail.tail.head\
    \ + newB.get.tail.head + newB.get.tail.tail.head + newC.get.tail.head + newC.get.tail.tail.head)\n\
    \            if (newA.length >= n + 1L) newA\n            else rec (n - 1L) +\
    \ rec (n - 2L) + rec (n + 1L)\n        }\n        rec (n + 1L)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3he4uxb8.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36ma\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp3he4uxb8.scala:22:16 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mb\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp3he4uxb8.scala:23:16 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mc\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3he4uxb8.scala:47:12 --------------------\e[0m\e\
    [0m\n\e[31m47 |\e[0m        rec (n + \e[31m1L\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    Long\n\e[31m   |\e[0m\
    \        Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val ls = List((1L).toLong, (3L).toLong, 2L.toLong, 8L.toLong)\n     \
    \   (for {\n            i <- 0 until n\n            _ <- ls.drop(i).map(x => x\
    \ + i)\n        } yield i)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqe0h1skd.scala:23:25\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            i <- \e[31m0\e[0m\
    \ until n\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e\
    [0m                         Found:    (n : Long)\n\e[31m   |\e[0m            \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val rev = n / 2 // rev represents n/2, which is even or odd.\n      \
    \  val even = n % 2 == 0\n\n        if (even) {\n            // We want a list\
    \ with 1 as a head and n+1 as tail, which is what our recursive\n            //\
    \ calls are going to return.\n            // We start off by creating an empty\
    \ list. Then we prepend 1 to our list of numbers \n            // using prepend\
    \ and get the last one using last and add it to our list \n            // using\
    \ ++.\n            val result : mutable.ListBuffer[Long] = ListBuffer[Long]()\n\
    \            result + 1\n            result\n        } else {\n            //\
    \ Recursive calls have to be made to the right of the base case. In this case\n\
    \            // we want to call tri(n-1) and tri(n-2), which we can do using recursion\n\
    \            // with recur since we have seen the base case before.\n        \
    \    // The base case is tri(2), which returns tri(1) + tri(2).\n            //\
    \ Since tri(2) == tri(1) +tri(2), we know that 2 has already been added to our\
    \ \n            // list in the else branch, so we know that we need to add 1 to\
    \ our list of numbers\n            // using prepend and get the last one using\
    \ last and add it to our list \n            // using ++.\n            val result\
    \ : mutable.ListBuffer[Long] = ListBuffer[Long]()\n            result ++ recur(rev)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvcavy8gc.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m : mutable.ListBuffer[\e\
    [35mLong\e[0m] = ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvcavy8gc.scala:42:25\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m\
    \ \e[36mresult\e[0m : mutable.ListBuffer[\e[35mLong\e[0m] = ListBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri(n: Long, acc: List[Long]) : List[Long] = {\n            if (n\
    \ == 0)\n                acc :+ 0\n            else {\n                val tmp\
    \ = tri(n - 1, Nil)\n                if (n %2==0) {\n                    tri(n\
    \ + tmp, Nil) :+ n + tmp\n                } else {\n                    tri(n\
    \ + tmp, Nil) :+ n + tmp + tmp\n                }\n            }\n        }\n\
    \        if (n == 0)\n            Nil\n        else\n            tri(n, Nil)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3fpsejtc.scala:27:26 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    tri(n + tmp, Nil) :+ n + tmp\n\e\
    [31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m\
    \ \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e\
    [0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int):\
    \ Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e\
    [31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\e[31m   |\e\
    [0mmatch arguments ((tmp : List[Long]))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp3fpsejtc.scala:27:43\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                   \
    \ tri(n + tmp, Nil) :+ n + tmp\n\e[31m\e[31m   |\e[0m                        \
    \                 ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0m (x: String): String\n\e[31m   |\e[0mmatch arguments ((tmp : List[Long]))\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp3fpsejtc.scala:29:26 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    tri(n + tmp, Nil) :+ n + tmp + tmp\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0mNone of\
    \ the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e[33mclass\e\
    [0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m  \
    \ |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x:\
    \ Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\
    \e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\e[31m \
    \  |\e[0mmatch arguments ((tmp : List[Long]))\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmp3fpsejtc.scala:29:43 -----------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m              "
  stdout: ''
  timestamp: 1659979994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n <= 0) Nil\n        else if(n == 1) List(1, 3)\n        else tri(n-1)\
    \ + tri(n-2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp59g19ili.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n-\e[31m1\e[0m) + tri(n-\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659979997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(0)\n        else if (n%2 == 0) tri(n-1) + tri(n-2)\n\
    \        else tri(n-1) + tri(n-2) + tri(n+1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp60cdijio.scala:22:36 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n%\e[31m2\e[0m\
    \ == \e[31m0\e[0m) tri(n-\e[31m1\e[0m) + tri(n-\e[31m2\e[0m)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a\
    \ member of List[Long], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp60cdijio.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n-\e[31m1\e[0m) + tri(n-\e\
    [31m2\e[0m) + tri(n+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659979998
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 1l) 1l :: Nil\n        if (n % 2l.toLong == 0) tri(n - 1l) +\
    \ (1l.toLong :: tri(n - 2l) + (3l.toLong :: tri(n +2l)))\n        else  tri(n\
    \ - 1l) + (1l.toLong :: tri(n - 2l) + (3l.toLong :: tri(n +2l)))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp8n3oet6.scala:22:44 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (n % \e[31m2l\e[0m.toLong == \e\
    [31m0\e[0m) tri(n - \e[31m1l\e[0m) + (\e[31m1l\e[0m.toLong :: tri(n - \e[31m2l\e\
    [0m) + (\e[31m3l\e[0m.toLong :: tri(n +\e[31m2l\e[0m)))\n\e[31m\e[31m   |\e[0m\
    \                                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpp8n3oet6.scala:22:72 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (n % \e[31m2l\e[0m.toLong == \e\
    [31m0\e[0m) tri(n - \e[31m1l\e[0m) + (\e[31m1l\e[0m.toLong :: tri(n - \e[31m2l\e\
    [0m) + (\e[31m3l\e[0m.toLong :: tri(n +\e[31m2l\e[0m)))\n\e[31m\e[31m   |\e[0m\
    \                                                            ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp8n3oet6.scala:23:26 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33melse\e[0m  tri(n - \e[31m1l\e[0m) + (\e[31m1l\e\
    [0m.toLong :: tri(n - \e[31m2l\e[0m) + (\e[31m3l\e[0m.toLong :: tri(n +\e[31m2l\e\
    [0m)))\n\e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports m"
  stdout: ''
  timestamp: 1659980002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val n = scala.math.mod(n, 2l)\n        val list: mutable.ArrayBuffer[Long]\
    \ = mutable.ArrayBuffer[Long]()\n        if (n > 1l)\n            list += tri(n-1l)\
    \ + tri(n-2l) + tri(n+2l)\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5f4tut_h.scala:21:27 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = scala.math.mod(n,\
    \ \e[31m2l\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                value mod is not a member of math\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp5f4tut_h.scala:21:31 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = scala.math.mod(n,\
    \ \e[31m2l\e[0m)\n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\
    \e[31m   |\e[0m                               Recursive \e[33mvalue\e[0m \e[35mn\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5f4tut_h.scala:22:18\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m: mutable.ArrayBuffer[\e[35mLong\e[0m] = mutable.ArrayBuffer[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5f4tut_h.scala:22:46 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m: mutable.ArrayBuffer[\e\
    [35mLong\e[0m] = mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                                              ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                             Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var list : List[Long] = List();\n        val limit = (if (n <= 2) 3l\
    \ else (n + 2l));\n        var sum = 1;\n        for (var i = 1l to limit) {\n\
    \            list = list :+ sum;\n            sum = sum + i;\n        }\n    \
    \    list\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpg82rggti.scala:24:13 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mfor\e[0m (\e[33mvar\e[0m i = \e[31m1l\e\
    [0m to limit) {\n\e[31m\e[31m   |\e[0m             ^^^\e[0m\n\e[31m   |\e[0m \
    \            pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpg82rggti.scala:24:34 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mfor\e[0m (\e[33mvar\e[0m i = \e[31m1l\e[0m to limit) {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                  '<-' expected, but '{' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpg82rggti.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '<-' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg82rggti.scala:27:9\
    \ -------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        }\n\e[31m\e[31m\
    \   |\e[0m         ^\e[0m\n\e[31m   |\e[0mvalue withFilter is not a member of\
    \ Null, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1659980001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \    \tval res : List[Long] = List() \n    \tval sum : List[Long] = List() \n\
    \    \tif(n % 2 == 0) { \n    \t\tres = n + 1 :: res\n    \t\tsum = sum + n\n\
    \    \t}\n    \telse {\n    \t\tval a = tri(n.toInt)\n    \t\tval b = tri(n.toInt\
    \ - 1) + tri(n.toInt - 2) + tri(n.toInt + 1)\n    \t\tres = a ::: b ::: res\n\
    \    \t\tsum = sum + a :: b :: sum\n    \t}\n    \tres.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpkppuzatf.scala:24:12 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    \t\tres = n + \e[31m1\e[0m :: res\n\e[31m\e[31m \
    \  |\e[0m    \t\t^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \t\tReassignment\
    \ to val res\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkppuzatf.scala:25:18\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \t\tsum = sum + n\n\e\
    [31m\e[31m   |\e[0m    \t\t      ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpkppuzatf.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    \t\t\e[33mval\e[0m \e[36mb\e[0m = tri(n.toInt - \e\
    [31m1\e[0m) + tri(n.toInt - \e[31m2\e[0m) + tri(n.toInt + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m    \t\t        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmpkppuzatf.scala:30:12 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    \t\tres = a ::: b ::: res\n\e[31m\e[31m   |\e[0m\
    \    \t\t^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \t\tReassignment to val\
    \ res\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkppuzatf.scala:31:18\
    \ ------------------------\e[0m\e["
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var result : List[Long] = Nil\n        if (n == 0) result ::= List(1l)\n\
    \        else if (n % 2 == 0) result ::= List(tri(n/2) + tri(n/2 - 1) + tri(n/2\
    \ + 1))\n        else result ::= List(tri(n - 1) + tri(n - 2) + tri(n + 1))\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbdpa1nw5.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (n == \e[31m0\e[0m) result ::=\
    \ List(\e[31m1l\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m   value ::= is not a member of List[Long] - did you mean List[Long].::?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbdpa1nw5.scala:23:36 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) result ::= List(tri(n/\e[31m2\e[0m) + tri(n/\e[31m2\e[0m\
    \ - \e[31m1\e[0m) + tri(n/\e[31m2\e[0m + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ::= is\
    \ not a member of List[Long] - did you mean List[Long].::?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbdpa1nw5.scala:23:54 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m2\e[0m ==\
    \ \e[31m0\e[0m) result ::= List(tri(n/\e[31m2\e[0m) + tri(n/\e[31m2\e[0m - \e\
    [31m1\e[0m) + tri(n/\e[31m2\e[0m + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m     \
    \                                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbdpa1nw5.scala:24:20\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m result\
    \ ::= List(tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m))\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ::=\
    \ is not a member of List[Long] - did you mean List[Long].::?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpbdpa1nw5.scala:24:40 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33melse\e[0m result ::= List(tri(n - \e[31m1\e\
    [0m) + tr"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        var currentTri : List[Long] = List[Long]()\n        var tri1 =  3\n \
    \       var tri2 = tri1\n        var tri3 = tri2 + tri1\n        var tri4 = tri3\
    \ + tri2\n        while (n < 0 || tri4 > 0) {\n            currentTri += tri4\n\
    \            tri1 = tri2\n            tri2 = tri3\n            tri3 = tri4 + tri2\n\
    \            tri4 = tri3 + tri2\n            n += 1\n        }\n        currentTri\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi5bcoqwe.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            currentTri += tri4\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of\
    \ List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpi5bcoqwe.scala:32:14 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m            n += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\
    \e[31m   |\e[0m            value += is not a member of Long - did you mean n.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659980002
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a = n.toInt\n        val b = 1 + n / 2\n        val c = b + a + b\n\
    \        if (n % 2 == 0) List(a, b, c, c) \n        else List(c, c, c, c)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2o1qomai.scala:28)\n\tat Problem.main(tmp2o1qomai.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) Nil\n        else tri(n - 1) + tri(n - 2) + tri(n + 1) \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1t51zb48.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n + \e[31m1\e[0m) \n\e[31m\e[31m   |\e[0m            \
    \ ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triRec(a : List[Long], index : Int) : List[Long] = {\n          \
    \  if (index > 0) \n                a :+ triRec(a, (index - 1) + index) \n   \
    \         else\n                a\n        }\n        triRec(n, 1, 0).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp45hpas6v.scala:23:27\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                a :+ triRec(a,\
    \ (index - \e[31m1\e[0m) + index) \n\e[31m\e[31m   |\e[0m                    \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     Found:\
    \    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp45hpas6v.scala:27:15 --------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        triRec(n, \e[31m1\e[0m, \e[31m0\e[0m).toList\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               Found:    (n\
    \ : Long)\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp45hpas6v.scala:27:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        triRec(n, \e[31m1\e[0m, \e[31m0\e[0m).toList\n\
    \e[31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0mtoo many arguments\
    \ for \e[33mmethod\e[0m \e[35mtriRec\e[0m: (a: List[Long], index: Int): List[Long]\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659980003
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0 || n == 1)\n            List(1l, n)\n        else {\n    \
    \        val temp = (tri(n-1) + tri(n-2) + tri(n+1))\n            List(1l, n,\
    \ temp.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxucdqt4.scala:24:33 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = (tri(n-\e\
    [31m1\e[0m) + tri(n-\e[31m2\e[0m) + tri(n+\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659980004
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n > 0, \"Tribonacci sequence starts with three numbers!\")\n\
    \        val l = new mutable.ListBuffer[Long]\n        l.append(1L)\n        l.append(2L)\n\
    \        l.append(3L)\n        while(l.size < n+1){\n            val l2 = l.tail\n\
    \            l.append(l.head + l2.head + l2.last)\n        }\n        l drop 1\
    \ // tri(1) + tri(2)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpouwzhbn7.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                 \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659979999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def fibo: Long = _\n        val list = new mutable.ListBuffer[Long]()\n\
    \        if(n < 1) list.toList\n        else {\n            if(n%2 == 0) {\n \
    \               fibo = 3\n            } else fibo = fibo + n/2\n            fibo\
    \ += fibo\n            for(i <- 1 to n-1) list+=fibo\n        }\n        list.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E017] Syntax Error: /tmp/tmprktnb33s.scala:21:25 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mdef\e[0m \e[36mfibo\e[0m: \e[35mLong\e\
    [0m = _\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m\
    \                       Unbound placeholder parameter; incorrect use of _\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprktnb33s.scala:22:23\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error:\
    \ /tmp/tmprktnb33s.scala:26:21 -----------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                fibo = \e[31m3\e[0m\n\e[31m\e[31m   |\e[0m           \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment to val fibo\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmprktnb33s.scala:27:24 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            } \e[33melse\e[0m fibo = fibo + n/\e[31m2\e\
    [0m\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                   Reassignment to val fibo\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmprktnb33s.scala:28:17 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            fibo += fibo\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Long\
    \ - did you mean Long.!=?\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprktnb33s.scala:29:26\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mfor\e[0m(i\
    \ <- \e[31m1\e[0m to n-\e[31m1\e[0m) list+=fibo\n\e[31m\e[31m   |\e[0m       \
    \                   ^^^\e[0m\n\e[31m   |\e[0m                          Found:\
    \    Long\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659980005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val sums: List[Long] = new mutable.ListBuffer[Long]\n        sums +=\
    \ (3L)\n        if (n % 2 == 0) sums += (sums.last + n) / 2.0\n        else {\n\
    \            val mid = (sums.last + sums.last + sums.last + n) / 4.0\n       \
    \     sums.drop(1).foreach { n => sums += n + mid }\n        }\n        sums.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2zp7qzge.scala:21:35 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2zp7qzge.scala:22:13 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        sums += (\e[31m3L\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not a member of List[Long]\
    \ - did you mean sums.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2zp7qzge.scala:23:29\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mif\e[0m (n\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) sums += (sums.last + n) / \e[31m2.0\e[0m\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \     value += is not a member of List[Long] - did you mean sums.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2zp7qzge.scala:26:45 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            sums.drop(\e[31m1\e[0m).foreach { \e[36mn\e\
    [0m => sums += n + mid }\n\e[31m\e[31m   |\e[0m                              \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m          value += is not a member of\
    \ List[Long] - did you mean sums.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659980006
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n > 0, \"Can't calculate Tribonacci sequence for n = 0 !\");\
    \ \n        if (n == 1) List(3l.toLong)\n        else {\n            val ls =\
    \ tri(n-1) + tri(n-2) + tri(n+1);\n            require(n > 1, \"Can't calculate\
    \ Tribonacci sequence for n = 1 !\");\n            if (n % 2 == 1) ls ++ List(n.toLong)\n\
    \            else ls\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6lpp_lfw.scala:24:30 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mls\e[0m = tri(n-\e[31m1\e\
    [0m) + tri(n-\e[31m2\e[0m) + tri(n+\e[31m1\e[0m);\n\e[31m\e[31m   |\e[0m     \
    \                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659980005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fibList: mutable.Buffer[Long] = mutable.Buffer()\n        if (n <=\
    \ 1L) {\n            fibList.+=(1L.toLong)\n        }\n        else {\n      \
    \      fibList.+=(3L.toLong)\n        }\n        if (n % 2 == 0L) {\n        \
    \    for (i <- 1L until (n - 1L)) {\n                fibList.+=(fibList(i-1L)\
    \ + fibList(i-2L))\n            }\n        }\n        else {\n            for\
    \ (i <- 1L until (n - 1L)) {\n                fibList.+=(fibList(i-1L) + fibList(i-1L\
    \ + 1) + fibList(i-2L))\n            }\n        }\n        fibList.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwdn7z6nl.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfibList\e[0m: mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpwdn7z6nl.scala:21:44 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfibList\e[0m: mutable.Buffer[\e\
    [35mLong\e[0m] = mutable.Buffer()\n\e[31m\e[31m   |\e[0m                     \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val two = new mutable.ListBuffer[Long]()\n        two(0) := 3\n     \
    \   for(i <- 1 to n) {\n            two += (i.toLong + two(i - 1).toLong) / 2\n\
    \        }\n        two.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6spdf_2.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mtwo\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu6spdf_2.scala:23:22\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m1\e[0m to n) {\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m\
    \   |\e[0m                      Found:    (n : Long)\n\e[31m   |\e[0m        \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980005
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n <= 1L) List(1L.toLong, 1L.toLong, 1L.toLong, 1L.toLong)\n      \
    \  else { \n            def tri_rec(m : Long, n1 : Long, n2 : Long) : List[Long]\
    \ = {\n                if(m <= 1L) List(n1.toLong, n2.toLong)\n              \
    \  else {\n                    def tri_rec_rec(p : Long, q : Long, n1 : Long,\
    \ n2 : Long, l : List[Long]) : List[Long] = {\n                        if(p <=\
    \ 1L) l \n                        else {\n                            tri_rec_rec(q,\
    \ (q + p) / 2, n1, n2, l :+ q)\n                        }\n                  \
    \  }\n                    tri_rec_rec((m + n1 + n2) / 3, n1, n2, List(n1.toLong,\
    \ n2.toLong))\n                }\n            }\n            tri_rec(n, 2L, 3L,\
    \ List(0L.toLong, 1L.toLong))\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpub091noo.scala:32:63\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                    tri_rec_rec((m\
    \ + n1 + n2) / \e[31m3\e[0m, n1, n2, List(n1.toLong, n2.toLong))\n\e[31m\e[31m\
    \   |\e[0m                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                                                    Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpub091noo.scala:35:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            tri_rec(n, \e[31m2L\e[0m, \e[31m3L\e[0m,\
    \ List(\e[31m0L\e[0m.toLong, \e[31m1L\e[0m.toLong))\n\e[31m\e[31m   |\e[0m   \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtoo\
    \ many arguments for \e[33mmethod\e[0m \e[35mtri_rec\e[0m: (m: Long, n1: Long,\
    \ n2: Long): List[Long]\n2 errors found\n"
  stdout: ''
  timestamp: 1659980007
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      val a = 2l\n      val b = 3l\n      var triSeq: List[Long] = Nil\n    \
    \  if (n < 2) triSeq = List(a.toLong + b.toLong)\n      else {\n        if (n\
    \ % 2 == 0) triSeq = List(tri(a.toLong + b.toLong))\n        else triSeq = List(tri(a.toLong\
    \ + b.toLong), tri(b.toLong + a.toLong))\n      }\n      triSeq ::: tri(n - 1).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp44_q1o4m.scala:26:41\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mif\e[0m (n % \e\
    [31m2\e[0m == \e[31m0\e[0m) triSeq = List(tri(a.toLong + b.toLong))\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                   \
    \                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp44_q1o4m.scala:27:30 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33melse\e[0m triSeq = List(tri(a.toLong + b.toLong), tri(b.toLong\
    \ + a.toLong))\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Found:    \e[1m\e[31mList\e[0m\e\
    [1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                        \
    \   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp44_q1o4m.scala:27:56\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m triSeq\
    \ = List(tri(a.toLong + b.toLong), tri(b.toLong + a.toLong))\n\e[31m\e[31m   |\e\
    [0m                                                     ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                                                    Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659980008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def f(n: Long, m: Long, sum: Long, m: Long) : List[Long] = {\n      \
    \      if (n == 0 || n == 1) {\n                List.fill(m)((m.toLong :: sum.toList))\n\
    \            } else {\n                val first = f(n - 1, m + 1, sum + m, m)\n\
    \                val second = f(n - 2, m + 1, sum + m + 1, m)\n              \
    \  if (n % 2 == 0) {\n                    List(first, rem(m, 2) + second.toList)\n\
    \                } else {\n                    List(second.toList, first)\n  \
    \              }\n            }\n        }\n        val initial = f(n - 1, 1L,\
    \ 1L, 1L)\n        val result = f(n - 2, 1L, 0L, initial.last)\n        result\
    \ ++ initial\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiwy0b5b1.scala:21:43 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mdef\e[0m \e[36mf\e[0m(\e[36mn\e[0m: \e\
    [35mLong\e[0m, \e[36mm\e[0m: \e[35mLong\e[0m, \e[36msum\e[0m: \e[35mLong\e[0m,\
    \ \e[36mm\e[0m: \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                           ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mm is already defined as \e[33mparameter\e[0m \e[35mm\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiwy0b5b1.scala:23:26\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                List.fill(m)((m.toLong\
    \ :: sum.toList))\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m\
    \   |\e[0m                          Found:    (m : Long)\n\e[31m   |\e[0m    \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpiwy0b5b1.scala:23:46 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m                List.fill(m)((m.toLong :: sum.toList))\n\e\
    [31m\e[31m   |\e[0m                                          ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m          value toList is not a member of Long - did you mean sum.toInt?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiwy0b5b1.scala:28:25 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    List(first, rem(m, \e[31m2\e[0m)\
    \ + second.toList)\n\e[31m\e[31m   |\e[0m                         ^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Found:    (first : List[Long])\n\e[31m\
    \   |\e[0m                         Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpiwy0b5b1.scala:28:32 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    List(first, rem(m, \e[31m2\e[0m)\
    \ + second.toList)\n\e[31m\e[31m   |\e[0m                                ^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: rem\n\e[31m   |\e\
    [0m\n"
  stdout: ''
  timestamp: 1659980009
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n == 0) List(1L)\n        else if (n % 2 == 0) tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n        else tri(n - 1) + tri(n - 2) + tri(n - 1) + tri(n\
    \ + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcm37csw3.scala:22:40 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m (n % \e[31m2\e\
    [0m == \e[31m0\e[0m) tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e[0m) + tri(n + \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcm37csw3.scala:23:24 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n - \e[31m1\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m             ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980009
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 0) Nil\n        else if (n == 0) List(0l)\n        else if (n\
    \ % 2 == 0) List(1l, n/2, 2l)\n        else List(n/3, n-1, n+1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl8b8ef7z.scala:27)\n\tat Problem.main(tmpl8b8ef7z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980010
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 1) {\n            Nil\n        } else if (n % 2 == 0) {\n  \
    \          Nil +: tri(n - 1) + tri(n - 2) + tri(n - 1)\n        } else {\n   \
    \         Nil +: tri(n - 1) + tri(n - 2) + tri(n + 1) + tri(n + 1)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E041] Syntax Error: /tmp/tmpv50ba3s5.scala:24:19 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            Nil +: tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   ^\e\
    [0m\n\e[31m   |\e[0m+: (which is right-associative) and + (which is left-associative)\
    \ have same precedence and may not be mixed\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E041] Syntax Error: /tmp/tmpv50ba3s5.scala:26:19 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            Nil +: tri(n - \e[31m1\e[0m) + tri(n - \e\
    [31m2\e[0m) + tri(n + \e[31m1\e[0m) + tri(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                   ^\e[0m\n\e[31m   |\e[0m+: (which is right-associative) and\
    \ + (which is left-associative) have same precedence and may not be mixed\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        // Use a mutable list to store all the tribonacci sequence elements.\n\
    \        // Note that for even numbers, the second and third tribonacci numbers\
    \ \n        // are the same as the first and second tribonacci numbers. \n   \
    \     // For example:\n        // tri(10) = (1l + 3l + 5l + 7l + 9l + 11l) + (1l\
    \ + 3l + 5l + 7l + 9l + 11l)\n        // So we could have just appended the even\
    \ tribonacci numbers to the even tribonacci \n        // list without having to\
    \ store the even tribonacci numbers.\n        var tribonacci : List[Long] = List(0l.toLong).toList\n\
    \        \n        if(n <= 1) return tribonacci\n\n        // Iterate through\
    \ all the even numbers less than or equal to n.\n        for(i <- 1 to n) {\n\
    \            // Calculate the tribonacci numbers. \n            tribonacci = \n\
    \                // Store the first two tribonacci numbers in the even tribonacci\
    \ list.\n                tribonacci.insert(0, tribonacci(1).toLong)\n        \
    \        // Add the third tribonacci number to the even tribonacci list. \n  \
    \              tribonacci :+ tribonacci(2).toLong\n\n            // Only continue\
    \ the loop when i is odd.\n            if(i % 2 != 0) continue\n            \n\
    \            // Calculate the second tribonacci number. \n            tribonacci\
    \ = \n                // Add it to the even tribonacci list.\n               \
    \ tribonacci.insert(1, tribonacci(2).toLong)\n                // Add the third\
    \ tribonacci number to the even tribonacci list.\n                tribonacci :+\
    \ tribonacci(3).toLong\n\n            // Only continue the loop when i is odd.\n\
    \            if(i % 2 != 0) continue\n            \n            // Calculate the\
    \ third tribonacci number. \n            tribonacci = \n                // Add\
    \ it to the even tribonacci list.\n                tribonacci.insert(2, tribonacci(3).toLong)\n\
    \                // Add the third tribonacci number to the even tribonacci list.\n\
    \                tribonacci :+ tribonacci(4).toLong\n        }\n        \n   \
    \     // Return the list of even tribonacci numbers. \n        tribonacci.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphtt5zeyg.scala:33:22\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mfor\e[0m(i <- \e\
    [31m1\e[0m to n) {\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m\
    \   |\e[0m                      Found:    (n : Long)\n\e[31m   |\e[0m        \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphtt5zeyg.scala:37:27 ------------------------\e[0m\e[0m\n\e[31m37 |\e\
    [0m                tribonacci.insert(\e[31m0\e[0m, tribonacci(\e[31m1\e[0m).toLong)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ insert is not a member of List[Long] - did you mean List[Long].init?\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphtt5zeyg.scala:42:27 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mif\e[0m(i % \e[31m2\e[0m != \e[31m0\e\
    [0m) continue\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: continue\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphtt5zeyg.scala:47:27 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                tribonacci.insert(\e[31m1\e[0m, tribonacci(\e\
    [31m2\e[0m).toLong)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue insert is not a member of List[Long] - did you mean\
    \ List[Long].init?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphtt5zeyg.scala:52:27\
    \ ------------------------\e[0m\e[0m\n\e[31m52 |\e[0m            \e[33mif\e[0m(i\
    \ % \e[31m2\e[0m != \e[31m0\e[0m) continue\n\e[31m\e[31m   |\e[0m            \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ continue\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphtt5zeyg.scala:57:27\
    \ ------------------------\e[0m\e[0m\n\e[31m57 |\e[0m                tribonacci.insert(\e\
    [31m2\e[0m, tribonacci(\e[31m3\e[0m).toLong)\n\e[31m\e[31m   |\e[0m          \
    \      ^"
  stdout: ''
  timestamp: 1659980012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val res = mutable.ListBuffer.empty[Long]\n        def recurse(i : Long,\
    \ acc : List[Long]) : List[Long] = {\n            if (i < 0)\n               \
    \ res\n            else if (i % 2 == 0)\n                recurse(i - 1, acc :+\
    \ acc.last)\n            else {\n                val next = i + 1 // remember,\
    \ Tribonacci sequence is defined as\n                // tri(1) = 3\n         \
    \       // tri(n) = 1 + n / 2, if n is even.\n                val even = (i +\
    \ 1) // 2\n                val odd = (even * 2) +  i\n                recurse(odd,\
    \ acc :+ acc.last)\n            }\n        }\n        recurse(n, res)\n      \
    \  res.toList\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp832v47c9.scala:21:18 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0L) List(1L, 0L, 1L, 1L)\n        else {\n            val a\
    \ = (1L + n / 2L).toInt\n            val b = (1L + n - a).toInt\n            val\
    \ c = a + (a + b) / 2L\n            List(a.toLong, b, toLong(c))\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnhh2v8z0.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            List(a.toLong, b, toLong(c))\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                     Not found: toLong\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980008
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n == 0) List(1l)\n        if(n == 1) List(3l)\n        if(n == 2)\
    \ List(2, 3)\n        if(n == 3) List(3, 8, 5)\n        if(n == 4) List(4, 12,\
    \ 8)\n        if(n == 5) List(5, 15, 13, 14)\n        List(n, tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1))\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkuuk_frn.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        List(n, tri(n - \e[31m1\e[0m) + tri(n - \e[31m2\e\
    [0m) + tri(n + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0) Nil\n        else { \n            val first  = n-2\n    \
    \        val second = n-1 \n            val third = n \n            if (first==second)\
    \ List(third) \n            else { \n                val list = tri(first) \n\
    \                list ++ list.drop(1) + list.drop(2) + list \n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph67lyofw.scala:29:37 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                list ++ list.drop(\e[31m1\e[0m) + list.drop(\e\
    [31m2\e[0m) + list \n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0) Nil\n        else {\n            val list = (3l, 1l, 2l,\
    \ 8l)\n            val res = (0 to (n % 2) map { x => list(x) } ) \n         \
    \               ++ res + \n                        res + \n                  \
    \      (n to 0 map { x => list(x + 3) }) ++ \n                        res\n  \
    \          val res : List[Long] = res.toList\n            val res : List[Long]\
    \ = res.reverse\n            res\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqhcnxsb1.scala:29:16 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = res.toList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mres is already defined as \e[33mvalue\e[0m \e[35mres\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqhcnxsb1.scala:30:16 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            \e[33mval\e[0m \e[36mres\e[0m : \e[35mList\e[0m[\e[35mLong\e\
    [0m] = res.reverse\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mres is already defined as \e[33mvalue\e[0m \e[35mres\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqhcnxsb1.scala:24:29 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33mval\e[0m \e[36mres\e[0m = (\e[31m0\e[0m to (n % \e[31m2\e\
    [0m) map { \e[36mx\e[0m => list(x) } ) \n\e[31m\e[31m   |\e[0m               \
    \              ^^^^^\e[0m\n\e[31m   |\e[0m                             Found:\
    \    Long\n\e[31m   |\e[0m                             Required: Int\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqhcnxsb1.scala:25:27 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                        ++ res + \n\e[31m\e[31m   |\e\
    [0m                           ^\e[0m\n\e[31m   |\e[0m                        \
    \   Recursive \e[33mvalue\e[0m \e[35mres\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqhcnxsb1.scala:26:24 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                        res + \n\e[31m\e[31m   |\e[0m\
    \                        ^\e[0m\n\e[31m   |\e[0m                        Recursive\
    \ \e[33mvalue\e[0m \e[35mres\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659980013
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n == 0) List(1L).toList\n        else if(n == 1) List(1L).toList\n\
    \        else if(n == 2) List(1L, 2L).toList\n        else {\n            var\
    \ result = List(1L)\n            var temp = result\n            var count = 1\n\
    \            while(count < n) {\n                result.last = (temp(result.size\
    \ - 1) + temp(result.size - 2) + temp(result.size + 1))\n                temp\
    \ = result\n                count += 1\n            }\n            result\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpnhh0rxh3.scala:29:28 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                result.last = (temp(result.size - \e\
    [31m1\e[0m) + temp(result.size - \e[31m2\e[0m) + temp(result.size + \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val last\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659980012
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def tri_helper(n: Long, acc: List[Long]) : List[Long] = n match {\n \
    \           case 0 => acc.reverse\n            case 1 => List(1l.toLong)\n   \
    \         case 2 => tri_helper(tri_helper(n - 1l, List(0l.toLong, 1l.toLong))\
    \ , List(0l.toLong, 1l.toLong))\n            case n => (tri_helper(n - 1l, List(0l.toLong,\
    \ 1l.toLong)) :: tri_helper(n - 2l, tri_helper(n - 1l, List(0l.toLong, 1l.toLong))\
    \ :: tri_helper(n + 2l, List(0l.toLong, 1l.toLong)))).flatten\n        }\n   \
    \     tri_helper(n-1, List(0l.toLong, 1l.toLong))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0424widw.scala:24:43\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e\
    [31m2\e[0m => tri_helper(tri_helper(n - \e[31m1l\e[0m, List(\e[31m0l\e[0m.toLong,\
    \ \e[31m1l\e[0m.toLong)) , List(\e[31m0l\e[0m.toLong, \e[31m1l\e[0m.toLong))\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                   \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0424widw.scala:25:102 -------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mcase\e[0m n => (tri_helper(n - \e[31m1l\e[0m, List(\e\
    [31m0l\e[0m.toLong, \e[31m1l\e[0m.toLong)) :: tri_helper(n - \e[31m2l\e[0m, tri_helper(n\
    \ - \e[31m1l\e[0m, List(\e[31m0l\e[0m.toLong, \e[31m1l\e[0m.toLong)) :: tri_helper(n\
    \ + \e[31m2l\e[0m, List(\e[31m0l\e[0m.toLong, \e[31m1l\e[0m.toLong)))).flatten\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                    Found:\
    \    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                                                    Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp0424widw.scala:25:198 ----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mcase\e[0m n => (tri_helper(n - \e[31m1l\e\
    [0m, List(\e[31m0l\e[0m.toLong, \e[31m1l\e[0m.toLong)) :: tri_helper(n - \e[31m2l\e\
    [0m, tri_helper(n - \e[31m1l\e[0m, List(\e[31m0l\e[0m.toLong, \e[31m1l\e[0m.toLong))\
    \ :: tri_helper(n + \e[31m2l\e[0m, List(\e[31m0l\e[0m.toLong, \e[31m1l\e[0m.toLong)))).flatten\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                          "
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val a0 = 1l\n        val a1 = 1l\n        val a2 = n\n        val a3\
    \ = a1 + a2\n        val a4 = a1 + a2 + a3\n        val a5 = a1 + a2 + a3 + a4\n\
    \        val a6 = a1 + a2 + a3 + a4 + a5\n        val a7 = a1 + a2 + a3 + a4 +\
    \ a5 + a6\n        val a8 = a1 + a2 + a3 + a4 + a5 + a6 + a7\n        val a9 =\
    \ a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8\n        val a10 = a1 + a2 + a3 + a4 +\
    \ a5 + a6 + a7 + a8 + a9\n        val a11 = a4 + a3 + a5 + a6 + a7 + a8 + a9 +\
    \ a10\n        val a12 = a4 + a3 + a5 + a6 + a7 + a8 + a9 + a10 + a11\n      \
    \  val a13 = a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12\n        val a14 =\
    \ a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13\n        val a15 = a5 +\
    \ a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14\n        val a16 = a5 + a6 +\
    \ a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15\n        val a17 = a6 + a7\
    \ + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16\n        val a18 = a6 +\
    \ a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17\n        val a19\
    \ = a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18\n\
    \        val a20 = a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16\
    \ + a17 + a18 + a19\n        val a21 = a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13\
    \ + a14 + a15 + a16 + a17 + a18 + a19 + a20\n        val a22 = a1 + a2 + a3 +\
    \ a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17\
    \ + a18 + a19 + a20 + a21\n        val a23 = a4 + a3 + a5 + a6 + a7 + a8 + a9\
    \ + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp16ocggqz.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980015
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val result = new ArrayList[Long](n)\n        var tmp1 = 1\n        var\
    \ tmp2 = 3\n        for (i <- 1 to n) {\n            result(i) = tmp1\n      \
    \      if (i % 2 == 0)\n                tmp2 = tmp1 + tmp2\n            else {\n\
    \                tmp1 = tmp2 + tmp1\n                tmp2 = tmp1 + tmp2\n    \
    \        }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplrmncft5.scala:21:25 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m \e[35mArrayList\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m          \
    \               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplrmncft5.scala:24:23\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mfor\e[0m (i <-\
    \ \e[31m1\e[0m to n) {\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\e\
    [31m   |\e[0m                       Found:    (n : Long)\n\e[31m   |\e[0m    \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if(n<1) List()\n        else if(n==1) List(nl.toLong)\n        else if(n==2)\
    \ List(nl.toLong, nl.toLong)\n        else {\n            val first = new mutable.LinkedList[Long]\n\
    \            val second = new mutable.LinkedList[Long]\n            val third\
    \ = new mutable.LinkedList[Long]\n            val forth = new mutable.LinkedList[Long]\n\
    \            for(i <- 1 to n) if(i % 2 == 0) forth += (i).toLong\n           \
    \ else if((i%2) == 1) third+= (i).toLong\n            else if((i%2) == 0) second+=\
    \ (i).toLong\n            else first += (i).toLong\n            forth += (nl.toLong)\n\
    \            third+= (nl.toLong)\n            second+= (nl.toLong)\n         \
    \   forth += (nl.toLong)\n            third+= (nl.toLong)\n            second+=\
    \ (nl.toLong)\n            third+= (nl.toLong)\n            forth += (nl.toLong)\n\
    \            List(first.toList(0), third.toList(0), second.toList(0), forth.toList(0))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4x11pi32.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(n==\e[31m1\e[0m)\
    \ List(nl.toLong)\n\e[31m\e[31m   |\e[0m                           ^^\e[0m\n\e\
    [31m   |\e[0m                           Not found: nl\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4x11pi32.scala:23:27 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(n==\e[31m2\e[0m)\
    \ List(nl.toLong, nl.toLong)\n\e[31m\e[31m   |\e[0m                          \
    \ ^^\e[0m\n\e[31m   |\e[0m                           Not found: nl\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4x11pi32.scala:23:38 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(n==\e[31m2\e[0m)\
    \ List(nl.toLong, nl.toLong)\n\e[31m\e[31m   |\e[0m                          \
    \            ^^\e[0m\n\e[31m   |\e[0m                                      Not\
    \ found: nl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4x11pi32.scala:25:28\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36mfirst\e[0m = \e[33mnew\e[0m mutable.LinkedList[\e[35mLong\e[0m]\n\e[31m\e\
    [31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp4x11pi32.scala:26:29 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36msecond\e[0m = \e[33mnew\e\
    [0m mutable.LinkedList[\e[35mLong\e[0m]\n\e[31m\e[31m   |\e[0m               \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4x11pi32.scala:27:28\
    \ --------"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        def triHelper(i : Long, triList : List[Long]) : List[Long] = if (i <=\
    \ 0) triList\n        else {\n            if (n % 2 == 0) triHelper(i - 1, triList\
    \ :: (triHelper(i + 1, 3 :: triList(2))))\n            else triHelper(i - 1, triList\
    \ :: (triHelper(i + 1, triList(1) :: triList(2))))\n        }\n        triHelper(n,\
    \ List())\n    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6z8lbo_j.scala:23:76 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (n % \e[31m2\e[0m == \e[31m0\e\
    [0m) triHelper(i - \e[31m1\e[0m, triList :: (triHelper(i + \e[31m1\e[0m, \e[31m3\e\
    [0m :: triList(\e[31m2\e[0m))))\n\e[31m\e[31m   |\e[0m                       \
    \                                                     ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        value :: is not a member of\
    \ Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6z8lbo_j.scala:23:45\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (n\
    \ % \e[31m2\e[0m == \e[31m0\e[0m) triHelper(i - \e[31m1\e[0m, triList :: (triHelper(i\
    \ + \e[31m1\e[0m, \e[31m3\e[0m :: triList(\e[31m2\e[0m))))\n\e[31m\e[31m   |\e\
    [0m                                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                        Found:    (triList : List[Long])\n\e\
    [31m   |\e[0m                                        Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6z8lbo_j.scala:24:74 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m triHelper(i - \e[31m1\e[0m,\
    \ triList :: (triHelper(i + \e[31m1\e[0m, triList(\e[31m1\e[0m) :: triList(\e\
    [31m2\e[0m))))\n\e[31m\e[31m   |\e[0m                                        \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                 value :: is not a member of Long\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp6z8lbo_j.scala:24:34 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m triHelper(i - \e[31m1\e[0m,\
    \ triList :: (triHelper(i + \e[31m1\e[0m, triList(\e[31m1\e[0m) :: triList(\e\
    [31m2\e[0m))))\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (triList : List[Long])\n\
    \e[31m   |\e[0m                                  Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors fo"
  stdout: ''
  timestamp: 1659980017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val t1 = if (n % 2 == 0) (3 - n) / 2 else n\n        val t2 = if (n %\
    \ 2 == 0) (1 + n) / 2 else (n + 3) / 4\n        val t3 = if (n % 2 == 0) (1 +\
    \ n) / 2 else (n + 3) / 4\n        List(1l.toLong, t2, t3).take(n + 1).map(_.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplhktqeth.scala:24:37\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        List(\e[31m1l\e[0m.toLong,\
    \ t2, t3).take(n + \e[31m1\e[0m).map(_.toLong)\n\e[31m\e[31m   |\e[0m        \
    \                             ^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                 Found:    Long\n\e[31m   |\e[0m                            \
    \         Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980016
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fibonacci : List[Long] = List(3, 1, 2)\n        val tribonacci =\
    \ fibonacci.foldLeft(List[Long]())((acc, x) => if (x % 2 == 0) acc.reverse :+\
    \ x + acc.head) \n        val sum = tribonacci.foldLeft(0)((acc,x) => acc + (x/2))\n\
    \        (0 until n).map(x => tribonacci(sum + x))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnghd64o1.scala:22:70\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mtribonacci\e\
    [0m = fibonacci.foldLeft(List[\e[35mLong\e[0m]())((\e[36macc\e[0m, \e[36mx\e[0m)\
    \ => \e[33mif\e[0m (x % \e[31m2\e[0m == \e[31m0\e[0m) acc.reverse :+ x + acc.head)\
    \ \n\e[31m\e[31m   |\e[0m                                                    \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                 Found:    Unit\n\e[31m   |\e[0m                 Required:\
    \ List[Long]\n\e[31m   |\e[0m                 Maybe you are missing an else part\
    \ for the conditional?\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnghd64o1.scala:23:52\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msum\e\
    [0m = tribonacci.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m,\e[36mx\e[0m) => acc +\
    \ (x/\e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                                   \
    \                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpnghd64o1.scala:24:17 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        (\e[31m0\e[0m until n).map(\e[36mx\e[0m => tribonacci(sum\
    \ + x))\n\e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m       \
    \          Found:    (n : Long)\n\e[31m   |\e[0m                 Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val memo = mutable.HashMap.empty[Long, List[Long]]\n        def recur(n:\
    \ Long, acc: List[Long]) : List[Long] = {\n            if (memo.get(n).isDefined)\
    \ memo(n) else recur(n + 1, (n to acc).reverse)\n        }\n        recur(n, Nil)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8aco9vg2.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmemo\e[0m = mutable.HashMap.empty[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8aco9vg2.scala:23:71\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (memo.get(n).isDefined)\
    \ memo(n) \e[33melse\e[0m recur(n + \e[31m1\e[0m, (n to acc).reverse)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \       ^^^\e[0m\n\e[31m   |\e[0m                                            Found:\
    \    (acc : List[Long])\n\e[31m   |\e[0m                                     \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 1) List(1L)\n        else if (n <= 3L) List(3L, 1L)\n      \
    \  else tri(n - 1) + tri(n - 2) + tri(n +1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpznk1fcrw.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m tri(n - \e[31m1\e[0m) + tri(n\
    \ - \e[31m2\e[0m) + tri(n +\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1659980018
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val ns: List[Long] = n match {\n            case n if n >= 0 => List(n,\
    \ n.toLong, (n-1).toLong, (n-2).toLong)\n            case n if n < 0 => List(n,\
    \ n.toLong, (n+1).toLong, (n+2).toLong)\n        }\n        List(ns(0), ns(1),\
    \ ns(2), ns(3)).filterNot(n => n % 2 == 0).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprvkittn1.scala:28)\n\tat Problem.main(tmprvkittn1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \      var triSeq = List(0l).toList\n      var temp = 3l.toLong;\n      if (n\
    \ % 2 == 0) {\n        triSeq = triSeq :+ temp;\n        temp += temp;\n     \
    \ }\n      else {\n        triSeq = triSeq :+ temp;\n        temp += temp + temp;\n\
    \      }\n      for (int i = 2; i < (n + 1);) {\n        temp = triSeq(i - 1)\
    \ + triSeq(i - 2);\n        triSeq = triSeq :+ temp;\n        temp += temp + temp;\n\
    \        i += 2;\n      }\n      triSeq\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp0d22xkra.scala:31:17 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mfor\e[0m (int i = \e[31m2\e[0m; i < (n +\
    \ \e[31m1\e[0m);) {\n\e[31m\e[31m   |\e[0m                 ^\e[0m\n\e[31m   |\e\
    [0m                 pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp0d22xkra.scala:31:33 ---------------------------\e[0m\e\
    [0m\n\e[31m31 |\e[0m      \e[33mfor\e[0m (int i = \e[31m2\e[0m; i < (n + \e[31m1\e\
    [0m);) {\n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m\
    \   |\e[0m                                 '<-' expected, but ';' found\n\e[31m\e\
    [31m-- [E032] Syntax Error: /tmp/tmp0d22xkra.scala:31:34 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mfor\e[0m (int i = \e[31m2\e[0m; i < (n +\
    \ \e[31m1\e[0m);) {\n\e[31m\e[31m   |\e[0m                                  ^\e\
    [0m\n\e[31m   |\e[0m                                  pattern expected\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0d22xkra.scala:31:20 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m      \e[33mfor\e[0m (int i = \e[31m2\e[0m; i < (n +\
    \ \e[31m1\e[0m);) {\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m \
    \  |\e[0mvalue withFilter is not a member of Null, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  impor"
  stdout: ''
  timestamp: 1659980019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val list = new mutable.ListBuffer[Long]()\n        if (n == 1)\n    \
    \        list += n\n        else if (n % 2 == 0) {\n            val r = tri(n\
    \ / 2)\n            if (n % 2 == 1)\n                r ++= r(0)\n            list\
    \ += r(1)\n        } else\n            list += tri(n / 2) + tri(n / 2 + 1) + tri(n\
    \ / 2 + 2)\n        list.map(_.toLong)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa4rxm1ow.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa4rxm1ow.scala:27:18\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                r ++= r(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value ++= is not a member of List[Long] - did you mean r.++?\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659980019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fib =  new scala.collection.mutable.ListBuffer[Long]()\n        fib.append(3)\n\
    \        fib += 2\n        fib.add((fib.head.toLong + fib.tail.head.toLong + fib.tail.tail.head.toLong).toLong)\n\
    \        fib.take(n.toInt)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcyxy5ckx.scala:24:12 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        fib.add((fib.head.toLong + fib.tail.head.toLong\
    \ + fib.tail.tail.head.toLong).toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  value add is not a member of scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcyxy5ckx.scala:25:16 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        fib.take(n.toInt)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980019
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        require(n > 0, \"n must be > 0\")\n        if (n <= 1l) List(1l.toLong)\n\
    \        else List(nl.toLong, tri(n - 1l) + tri(n - 2l) + tri(n + 2l))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcjhcnse8.scala:23:18 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m List(nl.toLong, tri(n - \e[31m1l\e\
    [0m) + tri(n - \e[31m2l\e[0m) + tri(n + \e[31m2l\e[0m))\n\e[31m\e[31m   |\e[0m\
    \                  ^^\e[0m\n\e[31m   |\e[0m                  Not found: nl\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcjhcnse8.scala:23:41\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m List(nl.toLong,\
    \ tri(n - \e[31m1l\e[0m) + tri(n - \e[31m2l\e[0m) + tri(n + \e[31m2l\e[0m))\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue + is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val fibonacci = mutable.ListBuffer(1, 2, 3)\n        val fibo = fibonacci.take(n)\n\
    \        fibo.map {\n            case i => i + fibo.last\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ws27kk8.scala:21:24 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mfibonacci\e[0m = mutable.ListBuffer(\e\
    [31m1\e[0m, \e[31m2\e[0m, \e[31m3\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659980017
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val result = (0 until n).filter(_ <= 2).map(_ + 1).map(_.toLong).toList\n\
    \        result :: tri(n - 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9h846av6.scala:21:30\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = (\e[31m0\e[0m until n).filter(_ <= \e[31m2\e[0m).map(_ + \e[31m1\e[0m).map(_.toLong).toList\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   \
    \                           Found:    (n : Long)\n\e[31m   |\e[0m            \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9h846av6.scala:22:8 ---------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        result :: tri(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Long])\n\e[31m\
    \   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n < 2) Nil\n        else {\n            def tri (m : Long) = (m *\
    \ m) / 2l\n            val r = for (i<-0 to (n-1l) by 2l) yield tri(m)\n     \
    \       r.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong))));\n\
    \    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv2358ajv.scala:24:34\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e\
    [36mr\e[0m = \e[33mfor\e[0m (i<-\e[31m0\e[0m to (n-\e[31m1l\e[0m) by \e[31m2l\e\
    [0m) \e[33myield\e[0m tri(m)\n\e[31m\e[31m   |\e[0m                          \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                                  Found:  \
    \  Long\n\e[31m   |\e[0m                                  Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv2358ajv.scala:24:43 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = \e[33mfor\e\
    [0m (i<-\e[31m0\e[0m to (n-\e[31m1l\e[0m) by \e[31m2l\e[0m) \e[33myield\e[0m tri(m)\n\
    \e[31m\e[31m   |\e[0m                                           ^^\e[0m\n\e[31m\
    \   |\e[0m                                           Found:    (\e[31m2L\e[0m\
    \ : Long)\n\e[31m   |\e[0m                                           Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv2358ajv.scala:24:57\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m\
    \ \e[36mr\e[0m = \e[33mfor\e[0m (i<-\e[31m0\e[0m to (n-\e[31m1l\e[0m) by \e[31m2l\e\
    [0m) \e[33myield\e[0m tri(m)\n\e[31m\e[31m   |\e[0m                          \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \                                   Not found: m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpv2358ajv.scala:25:14 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            r.reverse\n\e[31m\e[31m   |\e[0m        \
    \    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    IndexedSeq[Long]\n\e\
    [31m   |\e[0m            Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        if (n <= 0)\n            List()\n        else if (n <= 1L) \n       \
    \     List(n)\n        else if (n <= 2L)\n            List(n, 1)\n        else\
    \ \n            List(n - 1L, n, n + 1L)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
    \ 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5uqteniu.scala:31)\n\tat Problem.main(tmp5uqteniu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659980020
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Everyone knows Fibonacci sequence, it was studied deeply by mathematicians\
    \ in \n    // the last couple centuries. However, what people don't know is Tribonacci\
    \ sequence.\n    // Tribonacci sequence is defined by the recurrence:\n    //\
    \ tri(1) = 3\n    // tri(n) = 1 + n / 2, if n is even.\n    // tri(n) =  tri(n\
    \ - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    // For example:\n    // tri(2)\
    \ = 1 + (2 / 2) = 2\n    // tri(4) = 3\n    // tri(3) = tri(2) + tri(1) + tri(4)\n\
    \    // = 2 + 3 + 3 = 8 \n    // You are given a non-negative integer number n,\
    \ you have to a return a list of the \n    // first n + 1 numbers of the Tribonacci\
    \ sequence.\n    // Examples:\n    // >>> tri((3l))\n    // (List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong))\n    def tri(n : Long) : List[Long] = {\n\
    \        val ones = Vector(1l,2l,3l).filter(_ % 2 == 0).take(n).toList\n     \
    \   val twos = Vector(4l,5l,6l).filter(_ % 2 == 1).take(n).toList\n        val\
    \ threes = Vector(7l,8l,9l).filter(_ % 3 == 0).take(n).toList\n        val result\
    \ = ones.::(twos).::(threes)\n        result.take(n + 1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(tri((3l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong))));\n    assert(tri((4l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong))));\n    assert(tri((5l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong))));\n    assert(tri((6l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong))));\n   \
    \ assert(tri((7l)).equals((List[Long](1l.toLong, 3l.toLong, 2l.toLong, 8l.toLong,\
    \ 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong))));\n    assert(tri((8l)).equals((List[Long](1l.toLong,\
    \ 3l.toLong, 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong,\
    \ 5l.toLong))));\n    assert(tri((9l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong))));\n    assert(tri((20l)).equals((List[Long](1l.toLong, 3l.toLong,\
    \ 2l.toLong, 8l.toLong, 3l.toLong, 15l.toLong, 4l.toLong, 24l.toLong, 5l.toLong,\
    \ 35l.toLong, 6l.toLong, 48l.toLong, 7l.toLong, 63l.toLong, 8l.toLong, 80l.toLong,\
    \ 9l.toLong, 99l.toLong, 10l.toLong, 120l.toLong, 11l.toLong))));\n    assert(tri((0l)).equals((List[Long](1l.toLong))));\n\
    \    assert(tri((1l)).equals((List[Long](1l.toLong, 3l.toLong))));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqpt54qza.scala:21:60\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mones\e\
    [0m = Vector(\e[31m1l\e[0m,\e[31m2l\e[0m,\e[31m3l\e[0m).filter(_ % \e[31m2\e[0m\
    \ == \e[31m0\e[0m).take(n).toList\n\e[31m\e[31m   |\e[0m                     \
    \                                       ^\e[0m\n\e[31m   |\e[0m              \
    \                                      Found:    (n : Long)\n\e[31m   |\e[0m \
    \                                                   Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqpt54qza.scala:22:60 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mtwos\e[0m = Vector(\e[31m4l\e\
    [0m,\e[31m5l\e[0m,\e[31m6l\e[0m).filter(_ % \e[31m2\e[0m == \e[31m1\e[0m).take(n).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^\e[0m\n\e[31m   |\e[0m                                                 \
    \   Found:    (n : Long)\n\e[31m   |\e[0m                                    \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqpt54qza.scala:23:62 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mthrees\e[0m = Vector(\e[31m7l\e[0m,\e[31m8l\e\
    [0m,\e[31m9l\e[0m).filter(_ % \e[31m3\e[0m == \e[31m0\e[0m).take(n).toList\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \    ^\e[0m\n\e[31m   |\e[0m                                                 \
    \   Found:    (n : Long)\n\e[31m   |\e[0m                                    \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqpt54qza.scala:25:20 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        result.take(n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m         \
    \           ^^^^^\e[0m\n\e[31m   |\e[0m                    Found:    Long\n\e\
    [31m   |\e[0m                    Required: Int\n\e[31m  "
  stdout: ''
  timestamp: 1659980021
