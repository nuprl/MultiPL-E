name: HumanEval_162_string_to_md5
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a string 'text', return its md5 hash equivalent string.\n    // If\
  \ 'text' is an empty string, return None.\n    // >>> stringToMd5((\"Hello world\"\
  ))\n    // \"3e25960a79dbc69b674cd4ec67a72c62\"\n    def stringToMd5(text : String)\
  \ : Option[String] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(stringToMd5((\"Hello\
  \ world\")).equals(\"3e25960a79dbc69b674cd4ec67a72c62\"));\n    assert(stringToMd5((\"\
  \")).equals(None));\n    assert(stringToMd5((\"A B C\")).equals(\"0ef78513b0cb8cef12743f5aeb35f888\"\
  ));\n    assert(stringToMd5((\"password\")).equals(\"5f4dcc3b5aa765d61d8327deb882cf99\"\
  ));\n    }\n\n}\n"
completions: ["        if(text.length == 0) {\n            None\n        } else {\n\
    \            val hmac : MessageDigest = MessageDigest.getInstance(\"MD5\")\n \
    \           hmac.reset()\n            hmac.update(text.getBytes)\n           \
    \ val md5 = hmac.digest()\n            val hashInBase64 = Base64.getEncoder.encodeToString(md5)\n\
    \            Option(hashInBase64)\n        }", "        if (text.isEmpty) None\n\
    \        else {\n            val bytes = MessageDigest.getInstance(\"MD5\").digest(text.getBytes)\n\
    \            val hexString = bytes.map(\"%02X\" format _).mkString\n         \
    \   Some(\"\\\"\"+hexString+\"\\\"\")\n        }", '        if(text.trim.isEmpty)
    None else Some(DigestUtils.md5Hex(text))', '        if (text == "") None else
    Some(md5(text))', "        val digest = MessageDigest.getInstance(\"MD5\")\n \
    \       digest.reset()\n        val buffer = new Array[Byte](digest.digest(text.getBytes))\n\
    \        val md5 = Base64.getEncoder.encodeToString(buffer)\n        val digestBase64\
    \ = Base64.getEncoder.encodeToString(digest.digest(text.getBytes))\n        Option(md5).filter(_.equals(digestBase64))",
  "        val md5 = MessageDigest.getInstance(\"MD5\").digest(text.getBytes(\"UTF-8\"\
    ))\n        val md5 = Array[Byte](md5).map(\"%02x\".format(_)).mkString(\"\")\n\
    \        Some(md5)", "        if(text.length == 0) None\n        else Some(text.md5())",
  "        if (text.length <= 0) {\n            None\n        } else {\n         \
    \   val a = text.split(\" \").map(x=>x.toChar)\n            val h = a.map(c =>\
    \ (c.map(_.toInt).reduceLeft(_+_))) //get the sum of the ascii values\n      \
    \      val s = h.reduceLeft(_+_)//get the sum\n            val md5 = (s%10000).toString.toLowerCase\
    \ + s.toString.toLowerCase + h.reduceLeft(_+_)//convert to md5 string\n      \
    \      Some(md5)\n        }", "        if(text.isEmpty){\n            None\n \
    \       }\n        else{\n            val hash = MD5Hash.getInstance\n       \
    \     hash.update(text.getBytes)\n            val digest = hash.digest()\n   \
    \         val builder = StringBuilder(digest.length * 2)\n            digest.forEach\
    \ {\n                builder.append(Integer.toHexString((it & 0xff) + 0x100))\n\
    \            }\n            Some(builder.toString)\n        }", "        if (text\
    \ == \"\") None\n        else text -> md5(text)", '        if (text.trim.isEmpty)
    None else Some(md5(text))', "        if (text == \"\") None\n        else Some(Digest.md5Hex(text))",
  "        if(text.isEmpty) {\n            None\n        }\n        else {\n     \
    \       val data = text.asInstanceOf[String]\n            val md5 = java.security.MessageDigest.getInstance(\"\
    MD5\")\n            val digest = md5.digest(data.asInstanceOf[Array[Byte]])\n\
    \            val sb = new StringBuilder()\n            for (i <- digest) {\n \
    \               sb.append(Integer.toHexString(i&0xff))\n            }\n      \
    \      Some(sb.toString)\n        }", "        if (text.length == 0) return None\n\
    \        val digest = java.security.MessageDigest.getInstance(\"MD5\");\n    \
    \    val bos = new java.io.ByteArrayOutputStream();\n        val bw = new java.io.BufferedWriter(new\
    \ java.io.OutputStream(bos));\n        digest.update(text.getBytes(), 0, text.length());\n\
    \        bw.write(digest.digest());\n        bw.close();\n        val hash = java.util.Base64.getEncoder.encodeToString(bos.toByteArray);\n\
    \        Some(hash)", "        val md5 = java.security.MessageDigest.getInstance(\"\
    MD5\")\n        val md = md5.digest(text.getBytes)\n        val sb = new StringBuilder()\n\
    \        for ((c, i) in md.zipWithIndex) {\n            if (i > 0) sb.append(\"\
    :\")\n            val hex = Integer.toHexString(c)\n            if (hex.length\
    \ < 2) {\n                sb.append(Integer.toHexString(c))\n            } else\
    \ {\n                sb.append(hex)\n            }\n        }\n        sb.toString",
  "        if(text.size == 0) {\n            None\n        } else {\n            val\
    \ md5 = new java.security.MessageDigest(java.security.MessageDigest.getInstance(\"\
    MD5\"))\n            val buffer = new Array[Byte](16)\n            val digest\
    \ = md5.digest(buffer)\n            val hexValues = digest.map { x => (Integer.toHexString(0xFF\
    \ & x).toLowerCase) }\n            val result = hexValues.mkString(\":\")\n  \
    \          println(result)\n            Some(result)\n        }", "        val\
    \ newMap = new mutable.HashMap[String,String]\n        for (i <- 0 until text.length())\
    \ {\n          val char = text.charAt(i)\n          val hash = digest(char.getBytes(\"\
    utf-8\"))\n          newMap += char -> hash\n        }\n        newMap.toList\
    \ match {\n          case list if list.nonEmpty =>\n            val md5 = list.last\n\
    \            Some(md5)\n          case _ => None\n        }", "        if(text\
    \ != \"\") Option(text.md5).toOption\n        else None", "        if(text.isEmpty)\
    \ None\n        else {\n            val cipher = new Md5\n            val encrypted\
    \ = cipher.doFinal(text.getBytes)\n            val hash = new String(encrypted)\n\
    \            Some(hash)\n        }", "        if(text == \"\") return None\n \
    \       val md5 = MessageDigest.getInstance(\"MD5\")\n        val digest = md5.digest(text.getBytes)\n\
    \        Some(digest.toString)", "        if(text.isEmpty) {\n            None\n\
    \        }\n        else {\n            val chars = text.toCharArray\n       \
    \     var ret = \"\"\n            for( i <- 0 until chars.length ) {\n       \
    \         val b = chars(i)\n                ret += Integer.toHexString(b.toInt)\n\
    \            }\n            Some(ret)\n        }", "        text.isEmpty match\
    \ {\n            case true => None\n            case false => Some(scala.util.Hashing.md5(text.getBytes).take(32).mkString)\n\
    \        }", "        if(text.length == 0) None\n        else {\n            val\
    \ md5 = new MessageDigest.getInstance(\"MD5\")\n            val digest = md5.digest(text.getBytes)\n\
    \            val result = digest.reduce(_ + _)\n            val sb = new StringBuilder\n\
    \            for (byte <- digest) sb.append(Integer.toHexString(byte & 0xFF))\n\
    \            Some(sb.toString)\n        }", "        // The MD5 hash is always\
    \ 40 characters long.\n        val hash = scala.util.Digest.md5(stringToByteArray(text))\n\
    \        // We only care about the lowest 32 bits.\n        Some(hash.take(32).toString)",
  "      if (text.nonEmpty) {\n        val digest = MessageDigest.getInstance(\"MD5\"\
    )\n        digest.update(text.getBytes)\n        val hashValue = digest.digest()\n\
    \        val convertedHashValue = hashValue.toString.\n          substring(0,\
    \ 8) + hashValue.toString.\n          substring((8 + hashValue.length))\n    \
    \    Option(convertedHashValue)\n      } else {\n        None\n      }", "   \
    \     text match {\n            case \"\" => None\n            case x => Some(scala.util.Hashing.md5Hex(x))\n\
    \        }", "        val md5 = scala.util.Digest.md5\n        val charBuffer\
    \ = charArrayBuffer(text.mkString)\n        md5.update(charBuffer)\n        md5.digest",
  "        val hash = new MessageDigest.getInstance(\"MD5\")\n        val bytes =\
    \ text.getBytes(\"UTF-8\")\n        hash.update(bytes)\n        val md5 = hash.digest()\n\
    \        val hex = md5.toString(\"HEX\")\n        return Some(hex)", "       \
    \ if (text.isEmpty) None\n        else Option(text.md5())", "        val md5:\
    \ mutable.HashMap[String, String] = mutable.HashMap()\n        val splitted: Array[String]\
    \ = text.split(\" \").map(x => x.toLowerCase).toList\n        splitted.foreach(x\
    \ => md5(x.toLowerCase -> x))\n        if (md5.isEmpty) None\n        else Some(md5.mapValues(x\
    \ => x.hashCode).mkString)", "        if (text == \"\") None \n        else Some(scala.util.hashing.MD5Hash.digest(text.getBytes))",
  "        if (text.isEmpty) None\n        else md5(text).getOrElse(None)", "    \
    \    val md5Hash = Digest.getInstance(\"MD5\")\n        val result = new mutable.StringBuilder\n\
    \        md5Hash.update(text.getBytes)\n        val digest = md5Hash.digest()\n\
    \        val hashedText = digest.getBytes\n        val hashCode = hashedText.mkString(\"\
    :\")\n        val md5 = hashCode.slice(0,8)\n        return Some(md5)", "    \
    \    if (text.isEmpty)\n            None\n        else\n            // Convert\
    \ to a byte array first.\n            val bytes : Array[Byte] = text.getBytes(\"\
    UTF-8\")\n            // Convert to an MD5 hash\n            val md : MD5 = MD5.getInstance\n\
    \            val mdBytes : Array[Byte] = md.digest(bytes)\n            // Convert\
    \ the MD5 hash back to a string\n            val hashString : String = Hex.encodeHexString(mdBytes)\n\
    \            // Return the MD5 hash string for the empty string or a non-empty\
    \ string\n            Some(hashString)", "        if (text.length == 0)\n    \
    \        None\n        else\n            val md5 = MD5.getInstance()\n       \
    \     md5.update(text.getBytes)\n            md5.digest", "        if (text.length\
    \ > 0) {\n            val digest = scala.util.Digest.md5()\n            digest.update(text.getBytes(\"\
    UTF-8\"))\n            val result = digest.digest().toHexString\n            Some(result)\n\
    \        } else {\n            None\n        }", "        var md5 : Option[String]\
    \ = None\n        text match {\n            case \"\"  => md5 = None // Empty\
    \ string\n            case x => md5 = md5Hash(text) // Non-empty string\n    \
    \    }\n        md5", "        if(text.isEmpty) None\n        else {\n       \
    \     val hashed = text.map(s => s.map(c => (c % 16).map(b => (b + 87) % (16 +\
    \ 87)).getOrElse(b)).sum)\n            val hashedString = hashed.foldLeft(\"\"\
    ) { (a, x) => (a + \"%\" + x).toUpperCase }\n            Some(hashedString)\n\
    \        }", "        if (text.isEmpty)\n            None\n        else\n    \
    \        Some(text.toHexString)", "        if (text.nonEmpty) text.toMD5\n   \
    \     else None ", '        if (text.isEmpty) None else Some(md5(text))', "  \
    \      if (text.isEmpty) None\n        else Some(MD5.digest(text.getBytes))",
  "        if (text.isEmpty) return None\n        val digest = scala.security.MessageDigest.getInstance(\"\
    MD5\")\n        digest.update(text.getBytes)\n        Some(digest.digest().map(hex).mkString)",
  "        var hashText : String = \"\";\n        var hash : Int = 0;\n        for\
    \ (ch <- text) {\n            val val = ch - 'a';\n            val rem = val %\
    \ 26;\n            val temp = val - rem;\n            val rem = temp % 26;\n \
    \           val temp = temp - rem;\n            hashText = hashText + (char('a'\
    \ + rem) + char('a' + temp))\n        }\n        return Some(hashText);", "  \
    \      if (text.isEmpty) None\n        else (MD5.getInstance().hashString(text)\
    \ map {_ => (text.length, text.length)})", "        if (text.length == 0) None\n\
    \        else {\n            val bytes: Array[Byte] = text.getBytes(\"UTF-8\"\
    )\n            val md5: MessageDigest = MessageDigest.getInstance(\"MD5\")\n \
    \           md5.update(bytes)\n            val hashCode: Int = md5.getDigest.length\n\
    \            val hexValue: String = Integer.toHexString(hashCode)\n          \
    \  Some(hexValue)\n        }", "        if (text == \"\") None\n        else Some(Digest.md5(new\
    \ StringBuffer(text).mkString))", "        if (text.nonEmpty) {\n            Some(md5(text))\n\
    \        } else {\n            None\n        }", "        var result = scala.collection.mutable.ListBuffer[String]()\n\
    \        var md5 = new scala.collection.mutable.HashMap[String, String]()\n  \
    \      var textToAppend = \"0000000000\"\n        text.foreach(x => {\n      \
    \      md5 += (x -> textToAppend)\n            result += (x -> textToAppend)\n\
    \        })\n        val finalString = new scala.collection.mutable.HashMap[String,\
    \ String]()\n        md5.foreach(x => {\n            finalString += (x._1 -> md5(x._2))\n\
    \        })\n        return Some(finalString)", "        if (text.isEmpty)\n \
    \           None\n        else\n            Some(scala.util.crypto.Md5.digest(text.getBytes))",
  "        if(text == \"\") {\n            None\n        } else {\n            val\
    \ md5 = MessageDigest.getInstance(\"MD5\").digest(text.getBytes)\n           \
    \ Some(new String(md5).substring(0, 32))\n        }", "        if (text.length\
    \ > 0) {\n            val bytes = new String(text).getBytes(\"UTF-8\")\n     \
    \       val md5 = new java.security.MessageDigest(\"MD5\")\n            val hash\
    \ = md5.digest(bytes)\n            val hashString = hexToString(hash)\n      \
    \      return Some(hashString)\n        }\n        else None", "        if (text.isEmpty)\
    \ None // if text is empty, return None\n        else {\n            val md5 =\
    \ MessageDigest.getInstance(\"MD5\")\n            val md5Buffer = new Array[Byte](32)\n\
    \            val inputStream = new ByteArrayInputStream(md5(text).getBytes)\n\
    \            try {\n                inputStream.readFully(md5Buffer)\n       \
    \     } catch {\n                case ex: Throwable => // return None on any error\n\
    \                None\n            }\n            Some(new String(md5Buffer))\n\
    \        }", "        val md5 = new scala.util.Md5\n        val s = text.getBytes(\"\
    UTF-8\")\n        Some(md5.digest(s))", "        if(text.isEmpty) None\n     \
    \   else Some(scala.util.Md5.hexdigest(text.getBytes(\"UTF-8\")))", "        if\
    \ (text.isEmpty) None\n        else Some(scala.util.crypto.Md5.stringToMd5(text).##)",
  "        val chars = text.map(c => c.toInt).toList\n        var hash = 5381;\n \
    \       for (i <- 0 to text.length-1)\n            hash = (hash * 33) ^ chars(i)\n\
    \        if (hash.toInt % 1 !== 0)\n            None\n        else\n         \
    \   Some(hash.toString)", "        if (text.length == 0) None\n        else text\
    \ match {\n            case str if str.length > 0 => Some(getMd5(str))\n     \
    \       case _ => None\n        }", "        val bytes = text.getBytes\n     \
    \   bytes.map(_.toInt + 0x49).toHexString", '        if (text == "") None else
    Some(scala.util.Digest.md5Hex(text))', "        val bytes : Array[Byte] = text.getBytes(\"\
    UTF-8\")\n        val md5 : Md5 = MessageDigest.getInstance(\"MD5\")\n       \
    \ val digest = md5.digest(bytes)\n        val hash = Base64.encodeBase64String(digest)\n\
    \        Option(hash)", "        if (text.length == 0) None\n        else Some(Md5.hash(text))",
  "        if (text.isEmpty) {\n            None\n        } else {\n            Some(Digest.md5Hex(text))\n\
    \        }", "        text.map { x => Digest.md5(x) }\n            .flatten\n\
    \            .map(_.toHexString)", "        if (text.isEmpty) None\n        else\
    \ Some(md5(text))", "        def md5_1(text : String) : String = {\n         \
    \   import scala.collection.mutable.ListBuffer\n            val textToHash = ListBuffer(text)\n\
    \            val textToHashLength = textToHash.length\n            var hashCode\
    \ : Int = 0\n            var outputLength = 0\n            val output = new mutable.StringBuilder()\n\
    \            while(textToHashLength > 0){\n                val chars = textToHash(0)\n\
    \                textToHash = textToHash.tail\n                textToHashLength\
    \ = textToHashLength - chars.length\n                hashCode = hashCode + chars.hashCode\n\
    \                outputLength += chars.length\n            }\n            val\
    \ hashTableSize = 128\n            val hashTable = scala.collection.mutable.ArrayBuffer.fill(hashTableSize)(0)\n\
    \            hashTable(0) = hashCode\n            val hashTablePointer = hashTableSize\n\
    \            while(outputLength > 0){\n                val char = output.charAt(outputLength\
    \ - 1)\n                hashTablePointer = hashTablePointer - char.length\n  \
    \              hashTable(0) = hashTable(0) * hashTableSize + hashTablePointer\n\
    \                output.length -= 1\n            }\n            output.toString\n\
    \        }\n        if (text.length > 0) Some(md5_1(text)) else None", "     \
    \   if (text.length == 0) None\n        else {\n            import java.security.MessageDigest._\n\
    \            val m = MessageDigest.getInstance(\"MD5\")\n            m.update(text.getBytes)\n\
    \            val md = m.digest()\n            val s = Array.ofDim[Byte](md.length)\n\
    \            System.arraycopy(md, 0, s, 0, md.length)\n            val hashString\
    \ = s.map(\"%02x\".format(_)).mkString.toLowerCase\n            Some(hashString)\n\
    \        }", '        if (text == "") None else Some(text.getBytes.map(b => java.security.MessageDigest.getInstance("MD5").digest(b)).map(_
    => scala.util.Base64.encodeBase64URLSafeString(b)).mkString)', "        val md5hash\
    \ = MD5Hash.getInstance()\n        val inputstream = io.ByteArrayInputStream(text.getBytes)\n\
    \        val outputstream = io.ByteArrayOutputStream()\n        md5hash.update(inputstream,\
    \ outputstream)\n        outputstream.toByteArray", "        var hash = 0\n  \
    \      for (char <- text.toCharArray) {\n            hash += char.toLong\n   \
    \         hash = hash &0xffffffff\n        }\n        Some(hash.toHexString)",
  "        if(text.isEmpty) {\n            None\n        } else {\n            val\
    \ m = scala.util.matching.Regex.compile(\"^[\\\\w]+$\").matcher(text)\n      \
    \      val hash = java.security.MessageDigest.getInstance(\"MD5\").digest(m.toString.getBytes)\n\
    \            new scala.util.matching.Regex(\"\"\"\\w{2}\"\"\").replaceFirst(hash.toString,\
    \ \"$&\")\n        }", '        if(text.isEmpty) None else Some(md5(text))', " \
    \       text match {\n            case \"\" => None\n            case x => Some(scala.util.Digest.md5(x))\n\
    \        }", "        if (text.trim().isEmpty) None\n        else Some(DigestUtils.md5Hex(text))",
  "        val md5 = new java.security.MessageDigest(\"MD5\")\n        val buffer\
    \ = new mutable.ArrayBuffer.empty[Int]\n        val digest = md5.digest(text.getBytes)\n\
    \        digest.foreach( x => buffer.append(x))\n        Option(buffer.toString.take(8).mkString(\"\
    \"))", "      val md5 = Hashing.md5\n      if (text != \"\")\n        Some(md5(text.asInstanceOf[String]))\n\
    \      else None", "        if (text == \"\") None\n        else {\n         \
    \   val md5 = java.security.MessageDigest.getInstance(\"MD5\")\n            md5.update(text.getBytes(\"\
    UTF-8\"))\n            val digest = md5.rest\n            val md5 = digest.digest\n\
    \            val md5 = ArrayBuffer(digest.take(2), digest.take(2), digest.take(2))\n\
    \            new String(md5, \"UTF-8\")\n        }", "        var md5 : Option[String]\
    \ = None\n        if(text.isEmpty) {\n            md5 = None\n        } else {\n\
    \            var chars = text.map {\n                x =>\n                  \
    \  if (chars.size > 0 && x == chars.last) chars.init else x\n            }\n\n\
    \            var remaining = chars.last\n            var hash = \"\"\n       \
    \     for(i <- 0 until chars.size) {\n                hash += remaining\n    \
    \            remaining = chars.drop(i).last\n            }\n            md5 =\
    \ Some(hash)\n        }\n        md5", "        if (text.isEmpty)\n          \
    \  None\n        else {\n            val bytes = text.utf8.getBytes\n        \
    \    val md5 = MessageDigest.getInstance(\"MD5\")\n            md5.update(bytes)\n\
    \            val digest = md5.digest()\n            val hex = digest.toString(\"\
    hex\")\n            Some(hex)\n        }", "        if (text.isEmpty) None\n \
    \       else {\n            // >>> \"Hello world\"\n            val hashes = text.hashCode\
    \ +: text.hashCode\n            // >>> hashes.toList\n            val hashesList\
    \ = hashes.toList\n            // >>> hashesList\n            val hashesSet =\
    \ hashesList.toSet\n            // >>> hashesSet\n            Some(hashesSet.mkString(\"\
    :\"))\n        }", "      val md5 = new java.security.MessageDigest(\"MD5\")\n\
    \      md5.update(text.getBytes(\"utf-8\"), 0, text.length)\n      val digest\
    \ = md5.digest()\n      val result = Array[Byte]()\n      digest.foreach(x =>\
    \ result += x)\n      Option(java.util.Base64.getEncoder.encodeToString(result))",
  "        def hash(str: String): String = {\n            val md5 = java.security.MessageDigest.getInstance(\"\
    MD5\")\n            val digest = md5.digest(java.util.Arrays.copyOfRange(str.getBytes(),\
    \ 0, str.size()))\n            val md5 = java.security.MessageDigest.getInstance(\"\
    MD5\")\n            md5.update(digest)\n            digest.toHex\n        }\n\
    \        if (text == \"\") {\n            None\n        } else {\n           \
    \ Some(hash(text))\n        }", "        if (text.length == 0) None\n        else\
    \ {\n            def charToHex(c : Char) =\n                Integer.toHexString(c.getNumericValue\
    \ + 65).toLowerCase\n\n            val md5 = java.security.MessageDigest.getInstance(\"\
    MD5\")\n            val bytes = text.getBytes()\n            val hash = md5.digest(bytes)\n\
    \            val ret: Map[String, String] = text.split('').map(charToHex).zipWithIndex.map\
    \ { case (c, i) => i -> c.toString }.\n                toMap\n            val\
    \ retString = ret.map { case (k,v) => v + \":\" + k }.mkString(\",\")\n      \
    \      Option(retString)\n        }", "        if (text == \"\") return None\n\
    \        val hashM = new MessageDigest.getInstance(\"MD5\")\n        hashM.update(text.getBytes)\n\
    \        val hash = hashM.getMessageDigest.array\n        val out = new StringBuilder(hash.length\
    \ div 2)\n        for (i <- 0 until hash.length) {\n            out.append(Character.forDigit(hash(i\
    \ >> 2), 16))\n            out.append(Character.forDigit(hash(i & 0xf), 16))\n\
    \        }\n        Some(out.toString)", "        if(text.trim.isEmpty) None\n\
    \        else {\n            val textAsArray = text.split(\" \")\n           \
    \ var hashValue = text.hashCode()\n            var index = 0\n            var\
    \ newHashValue = 0\n            var finalHashValue = 0\n            for(value\
    \ <- textAsArray) {\n                if(index != textAsArray.length - 1) {\n \
    \                   hashValue += value.toLong\n                } else {\n    \
    \                hashValue = hashValue % text.length\n                    newHashValue\
    \ = hashValue % text.length\n                    finalHashValue += newHashValue.toChar.asInstanceOf[Int]\n\
    \                    finalHashValue += value.hashCode().toChar.asInstanceOf[Int]\n\
    \                }\n                index += 1\n            }\n            val\
    \ finalHashValueString = finalHashValue.toString\n            if(finalHashValueString.length\
    \ != 0) {\n                finalHashValueString = finalHashValueString.substring(0,4)\n\
    \            } else {\n                finalHashValueString = \"0\"\n        \
    \    }\n            finalHashValueString + finalHashValue\n        }", "     \
    \   if (text.length == 0) None\n        else {\n            val md5 = new java.security.MessageDigest.getInstance(\"\
    MD5\")\n            val buffer = new StringBuffer()\n            val digest =\
    \ md5.digest(text.getBytes(\"utf-8\"))\n            for (i <- 0 until digest.length)\
    \ {\n                val hex = Integer.toHexString(digest(i))\n              \
    \  buffer.append(hex.substring(0, 2))\n                buffer.append(hex.substring(2))\n\
    \            }\n            Some(buffer.toString)\n        }", "        if (text.isEmpty)\n\
    \            None\n        else \n            Some(Md5.digest(text.getBytes))",
  "      if (text.isEmpty)\n        None\n      else {\n        val md = text.map(_.toByte).map(scala.util.hashing.Md5).map(_.digest)\n\
    \        Some(scala.util.hashing.Md5.hexdigest(md.toArray))\n      }", "     \
    \   if(text == \"\")\n            None\n        else\n            Some(scala.util.Md5.digest(text.getBytes))",
  "        val md5 = MessageDigest.getInstance(\"MD5\")\n        val bytes = md5.digest(text.getBytes)\n\
    \        val hash = bytes.map(Integer.valueOf(_)).mkString\n        Some(hash)",
  "        if (text.isEmpty) None\n        else {\n            val md5Hash = md5.newDigest\n\
    \            md5Hash.update(text.getBytes)\n            val md5 = md5Hash.digest\n\
    \            md5.map(_.toString).map { md5_string => Some(md5_string) }\n    \
    \    }", "        if(text.length > 0) {\n            val md5 = new java.security.MessageDigest()\n\
    \            val buffer = new Array[Byte](text.size + (8 - text.size * text.size\
    \ / 2) / 8)\n            val in = Iterator.continually(text.iterator).flatten\n\
    \            val out = Iterator.continually(md5.digest(buffer))\n            out.takeWhile(a\
    \ => in.isEmpty).foreach {\n                case b => md5.update(b)\n        \
    \    }\n            md5.digest(buffer)\n        } else {\n            None\n \
    \       }", "        if (text.length == 0) return None\n        val hash = MD5.getInstance.getHash(text.getBytes(\"\
    UTF-8\"))\n        Some(hash.digest().map(_.toHexString).mkString(\"-\"))", " \
    \       if (!text.contains(\"\")) Some(Md5.digest(text))\n        else else None",
  '        if (text.isEmpty) None else Some(text.md5().hexString)', "        if (text.isEmpty)\
    \ return None\n        val md5 = new java.security.MessageDigest()\n        val\
    \ buffer = new Array[Byte](16)\n        md5.update(buffer)\n        md5.update(text.getBytes,\
    \ \"UTF-8\")\n        md5.digest()", "        val md5 = java.security.MessageDigest.getInstance(\"\
    MD5\")\n        val result = md5.digest(text.getBytes)\n        Option(Array(result(0),\
    \ result(1)+result(0)))", "        if (text.isEmpty) {\n            None\n   \
    \     } else {\n            val md5 = MessageDigest.getInstance(\"MD5\")\n   \
    \         val input = text.getBytes(\"utf-8\")\n            md5.update(input,\
    \ 0, input.length)\n            val hash = md5.digest()\n            val hex =\
    \ hash.toString(\"x2\")\n            Option(hex)\n        }", '        if(text.isEmpty)
    None else Some(md5(text.getBytes))', "        if(text.trim().isEmpty) None\n \
    \       else {\n            val bytes : Array[Byte] = text.getBytes(\"UTF-8\"\
    )\n            var md5Hash : String = StringUtils.newMD5Hash(bytes).hash.toString\n\
    \            while (md5Hash.length % 4 != 0) md5Hash += \"0\"\n            Some(md5Hash)\n\
    \        }", '        if(text.isEmpty) None else Some(scala.util.Digest.md5AsHex(text.getBytes()))',
  "        text match {\n            case \"\" | \"None\" => None\n            case\
    \ s => Some(getMD5String(text))\n        }", "        val md5Hash = MessageDigest.getInstance(\"\
    MD5\").digest(text.getBytes);\n        if (md5Hash.length <= 0) {\n          \
    \  None\n        } else {\n            val sb = new StringBuilder\n          \
    \  for (i <- 0 until md5Hash.length) {\n                sb.append(Integer.toHexString(md5Hash(i)).substring(1,7))\n\
    \            }\n            Some(sb.toString)\n        }", "        if(text.isEmpty)\
    \ {\n            None\n        } else {\n            val byteArray = text.getBytes(\"\
    UTF-8\")\n            val digest = MessageDigest.getInstance(\"MD5\")\n      \
    \      digest.update(byteArray)\n            val md5 = digest.digest\n       \
    \     val hexString = java.util.Base64.getEncoder.encodeToString(md5)\n      \
    \      Some(hexString)\n        }", '        if(text == "") None else Some(scala.util.crypto.MD5("Hello
    world").toString)', "        if (text.nonEmpty) Some(scala.util.Md5.digest(text))\n\
    \        else None", "        if (text.length == 0) None\n        else Some(digest(text).map(\"\
    %02x\".format(_)).mkString)", "        if (text.length() == 0)\n            None\n\
    \        else\n            Some(new Md5Hasher().digest(text.getBytes))", "   \
    \     if (text.isEmpty) None\n        else Some(digest(text.getBytes))", '        text.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x
    => x.map(_.toByte).toList.map(x => x.map(_.toByte).toList.map(x => x.', "    \
    \    if(text == \"\")\n            None\n        else\n            Some(DigestUtils.md5Hex(text))",
  "        if (text == \"\")\n            None\n        else {\n            val md5\
    \ = MessageDigest.getInstance(\"MD5\")\n            val buffer = new Array[Byte](512)\n\
    \            val digest = md5.digest(text.getBytes(\"UTF-8\"))\n            digest.foreach(buffer\
    \ +=)\n            val str = MessageDigest.getInstance(\"MD5\").digest(buffer)\n\
    \            val strHex = str.toHexString.reverse\n            Option(strHex)\n\
    \        }", "        var md5 = MessageDigest.getInstance(\"MD5\")\n        val\
    \ messageDigestOutputStream = new ByteArrayOutputStream()\n        md5.update(messageDigestOutputStream,\
    \ text.getBytes)\n        val digest = md5.digest()\n        val md5HexString\
    \ = convertToHexString(digest)\n        val result = Option(md5HexString)\n  \
    \      result", "        if (text.length == 0)\n            None\n        else\n\
    \            val hashString = scala.util.MurmurHash.getInstance.getHash(text)\n\
    \            val hashInt = scala.util.Hashing.digest(hashString)\n           \
    \ Option(hashInt.toHexString)", "        if (text.trim.isEmpty) {\n          \
    \  None\n        } else {\n            val md5 = new java.security.MessageDigest(\"\
    MD5\")\n            val bytes = Array[Byte](text.getBytes)\n            val digest\
    \ = md5.digest(bytes)\n            val hexString = java.util.Arrays.toString(digest).replaceAll(\"\
    \\\\s\", \"\")\n            Some(hexString)\n        }", "        if (text.length\
    \ == 0) {\n            None\n        } else {\n            val md5 = MessageDigest.getInstance(\"\
    MD5\")\n            val digest = md5.digest(text.getBytes)\n            val md5Str\
    \ = new String(Array[Byte](digest))\n            Some(md5Str)\n        }", " \
    \       if(text.length == 0) return None\n        val digest = new java.security.MessageDigest(\"\
    MD5\")\n        digest.update(text.getBytes(\"UTF-8\"))\n        val hashedText\
    \ = new Array[Byte](digest.digest().length)\n        digest.digest(hashedText)\n\
    \        val hashedTextString = hashedText\n\n        val result = new ArrayBuffer[String]()\n\
    \n        for(i <- 0 until hashedTextString.length) {\n            val hexString\
    \ = hashedTextString(i).toHexString\n            result.append((hexString.substring(0,4)\n\
    \                +hexString.substring(4,8)\n                +hexString.substring(8,12)\n\
    \                +hexString.substring(12,16))\n            )\n        }\n\n  \
    \      Some(result.mkString)", "        val charArray = text.map(_.asInstanceOf[Int])\n\
    \        val md5Hash = MD5.asInstanceOf[MessageDigest]\n        val digest = md5Hash.digest(charArray)\n\
    \        val md5 = digest.map(hex => hex.toString.reverse.take(8).mkString)\n\
    \        Some(md5)", "        val md5 = new java.security.MessageDigest(\"MD5\"\
    )\n        val buffer = new Array[Byte](8 * 1024)\n        val digest = md5.digest(text.getBytes)\n\
    \        val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n       \
    \ val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5\
    \ = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n\
    \        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n       \
    \ val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n        val md5\
    \ = md5.digest(digest)\n        val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n\
    \        val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n       \
    \ val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5\
    \ = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n\
    \        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n       \
    \ val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n        val md5\
    \ = md5.digest(digest)\n        val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n\
    \        val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n       \
    \ val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5\
    \ = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n\
    \        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n       \
    \ val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n        val md5\
    \ = md5.digest(digest)\n        val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n\
    \        val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n       \
    \ val md5 = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5\
    \ = md5.reset()\n        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n\
    \        val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n       \
    \ val md5 = md5.digest(digest)\n        val md5 = md5.reset()\n", "        val\
    \ hasher = new Hasher()\n        val originalText = new StringBuilder\n      \
    \  originalText.append(text)\n        val hashValue = hasher.hash(originalText.get)\n\
    \        val hashValueString = hashValue.toHexString\n        hashValueString\
    \ match {\n            case \"0\" * 32() => None\n            case _ => Some(hashValueString)\n\
    \        }", "        if (text.isEmpty) {\n            None\n        } else {\n\
    \            val md5 = MD5.getInstance\n            val in = ByteBuffer.wrap(text.getBytes(\"\
    utf-8\"))\n            val hash = md5.digest(in)\n            val hashBytes =\
    \ hash.array()\n            val hashString = hashBytes.map(x => \"%02x\".format(x))\n\
    \            val hashStr = new String(hashString)\n            Some(hashStr)\n\
    \        }", "        if(text == \"\")\n            None\n        else\n     \
    \       Some(java.security.MessageDigest.getInstance(\"MD5\").digest(text.getBytes))",
  "        val encode = MessageDigest.getInstance(\"MD5\")\n        val md5 = encode.digest(text.getBytes)\n\
    \        val encodedHex = Array[Byte](md5.take(8))\n        val hexString = encodedHex.map(\"\
    %02x\".format(_)).mkString\n        val resultHex = hexString.dropRight(64).toLowerCase\n\
    \        val result = new String(resultHex, \"UTF-8\")\n        Some(result)",
  "        if (text.length > 0)\n            Some(scala.util.Md5.md5(text).getMessageDigest)\n\
    \        else\n            None", "        val md5 = new java.security.MessageDigest(\"\
    MD5\")\n        val bytes = text.getBytes(\"utf-8\")\n        md5.digest(bytes)",
  "        val hashString = text.hashCode()\n        val md5Hex = hashString Xor 0xFFFFFFFF\n\
    \        val md5Base64 = Base64.getEncoder.encodeToString(md5Hex.toByteArray)\n\
    \        Some(md5Base64)", "        if (text.length==0) return None\n        val\
    \ md5 = new java.security.MessageDigest(\"MD5\")\n        val hash = md5.digest(text.getBytes())\n\
    \        val hex = hash.toString\n        val res = hex.substring(0, hex.length\
    \ - 2)\n        Some(res)", "        if (text.isEmpty) None\n        else Some(new\
    \ Md5Hash(text))", "        if(text.isEmpty) {\n            None\n        } else\
    \ {\n            val hasher = MD5()\n            val hashed = hasher.hashString(text).getBytes\n\
    \            Some(hashed.map(b => b.toString (16).padToEven.length).mkString.toLowerCase)\n\
    \        }", "        if (text.isEmpty) {\n            None\n        } else {\n\
    \            val hash = java.security.MessageDigest.getInstance(\"MD5\").digest(text.getBytes)\n\
    \            val sBuilder = new StringBuilder()\n            for (x <- hash) {\n\
    \                sBuilder += x\n            }\n            val md = sBuilder.toString\n\
    \            Some(md)\n        }", "        val md5Hash = scala.collection.mutable.Map[String,String]()\n\
    \        text.foreach {\n            c => md5Hash += (c -> java.util.Base64.getEncoder.encodeToString(md5Hash.getOrElse(\"\
    \", \"\") + c))\n        }\n        val md5 = java.util.Base64.getEncoder.encodeToString(md5Hash.getOrElse(\"\
    \", \"\") + text)\n        Option(md5)", "        if(text == \"\")\n         \
    \   None\n        else {\n            val chars = text.map { x => x + '0'}\n \
    \           val md5 = Digest.md5\n            md5.update(chars.toArray)\n    \
    \        val digest = md5.digest\n            Option(digest)\n        }", "  \
    \      val md5 = new scala.util.Md5\n        val byteArray = md5.getBytes(text)\n\
    \        val hexString = byteArray.toString(\"hex\")\n        val md5 = hexString.substring(0,\
    \ 6).trim.toUpperCase\n        if (text.isEmpty) {\n            None\n       \
    \ } else {\n            Some(md5)\n        }", "        if (text.length == 0)\
    \ None\n        else Some(s\"$text\".hashCode().asInstanceOf[String])", "    \
    \    if (text.length == 0)\n            None\n        else\n            val md5\
    \ = java.security.MessageDigest.getInstance(\"MD5\")\n            val digest =\
    \ md5.digest(text.getBytes)\n            Some(new String(digest))", "        def\
    \ hashString(chars : String) = hashChars(chars.toList)\n\n        val md5 = new\
    \ scala.util.Md5\n\n        if (text.length == 0) None\n        else Some(md5.hashString(text))",
  "        val hash = MD5.asInstanceOf[MessageDigest]\n        val digest = new Array[Byte](hash.digest(text.getBytes(\"\
    utf-8\"))\n        hash.digest(text.getBytes(\"utf-8\")) == digest else None",
  "        if (text == \"\") None\n        else Some(new String(java.util.Base64.getEncoder.encodeToString(java.util.Arrays.copyOf(text.getBytes,\
    \ text.size << 1))))", "        import scala.util.hashing.MurmurHash3._\n    \
    \    if (text.length == 0) {\n            None\n        } else {\n           \
    \ val hashCode = text.hashCode\n            val message = new StringBuilder()\n\
    \            for (c <- hashCode) {\n                message.append(Integer.toHexString(c))\n\
    \                message.append(\" \")\n            }\n            Some(message.toString)\n\
    \        }", "        if (text == null || text.length == 0) return None\n    \
    \    var md5 : String = \"\"\n        for (c <- text.charArray) {\n          \
    \  md5 += String.format(\"%02X\", c)\n        }\n        Some(md5)", "       \
    \ if (!text.isEmpty) {\n            val md5 = MessageDigest.getInstance(\"MD5\"\
    ).digest(text.getBytes)\n            val hex = Hex.encodeHexString(md5)\n    \
    \        Some(hex)\n        } else {\n            None\n        }", "        if(text.isEmpty)\
    \ None\n        else Some(text.map(_.hash).mkString);", "        if (text == \"\
    \") {\n            None\n        } else {\n            val bytesOfMessage = text.getBytes\n\
    \            val messageDigest = MessageDigest.getInstance(\"MD5\")\n        \
    \    val digest = messageDigest.digest(bytesOfMessage)\n            val hexString\
    \ = convertByteArrayToHexString(digest)\n            Some(hexString)\n       \
    \ }", "        if (text.isEmpty) {\n            None\n        } else {\n     \
    \       val md5 = new java.security.MessageDigest(\n                \"MD5\"\n\
    \            )\n            val sha1 = new java.security.MessageDigest(\n    \
    \            \"SHA-1\"\n            )\n\n            val data = text.getBytes\n\
    \            val len = data.length\n            val md5_hash = new Array[Byte](len)\n\
    \            val sha1_hash = new Array[Byte](len)\n            val md5_sha1 =\
    \ new Array[Byte](len * 2)\n            System.arraycopy(data, 0, md5_hash, 0,\
    \ len)\n            System.arraycopy(data, 0, sha1_hash, 0, len)\n           \
    \ System.arraycopy(md5_hash, 0, sha1_hash, len, md5_hash.length)\n           \
    \ sha1.update(sha1_hash)\n            md5.update(md5_hash)\n            sha1.digest\n\
    \            md5.digest\n            val hash1 = new Array[Byte](16)\n       \
    \     val hash2 = new Array[Byte](16)\n            System.arraycopy(sha1.digest,\
    \ 0, hash1, 0, 16)\n            System.arraycopy(md5.digest, 0, hash2, 0, 16)\n\
    \            val md5_sha1_b = new Array[Byte](56)\n            System.arraycopy(hash1,\
    \ 0, md5_sha1_b, 0, 24)\n            System.arraycopy(hash2, 0, md5_sha1_b, 24,\
    \ 16)\n            System.arraycopy(md5_sha1_b, 0, md5_sha1_b, 16, 8)\n      \
    \      val sha1_final = new Array[Byte](20)\n            sha1.digest\n       \
    \     System.arraycopy(sha1_final, 0, sha1_final, 8, 20)\n            val md5_final\
    \ = new Array[Byte](20)\n            md5.digest\n            System.arraycopy(md5_final,\
    \ 0, md5_final, 8, 20)\n            val result = new String(md5_sha1_b, \"UTF-8\"\
    )\n            val result = new String(sha1_final, \"UTF-8\")\n            val\
    \ result = new String(md5_final, \"UTF-8\")\n            Some(result)\n      \
    \  }", "        val md = MessageDigest.getInstance(\"MD5\")\n        val digested\
    \ = md.digest(text.getBytes)\n        // Convert byte array from MD5 to hex string\n\
    \        val hex = digested.toString(\"hex\")\n        // If 'hex' is empty or\
    \ None, return None\n        if(hex.length == 0) None\n        else Option(hex)",
  "        val hashes = text.split(' ').map(_.hashCode)\n        if (hashes.toSet.size\
    \ == text.length)\n            return Some(hashes.toSeq.foldLeft(0)( (a, v) =>\
    \ a + v).toString)\n        else return None", "        val md5 = MessageDigest.getInstance(\"\
    MD5\")\n        val bytes = new Array[Byte](md5.digest.length * 2)\n        md5.digest.update(text.getBytes)\n\
    \        md5.digest.update(bytes)\n        val md5Hex = Hex.encodeHexString(bytes)\n\
    \        if (md5Hex.length == 16) Some(md5Hex) else None", "        val md5Hash\
    \ = MessageDigest.getInstance(\"MD5\").digest(text.getBytes)\n        Some(new\
    \ BigInteger(1, md5Hash).toHexString)", "        if (text.isEmpty) {\n       \
    \     None\n        } else {\n            val hashed = scala.util.hashing.MurmurHash3.stringToMd5(text)\n\
    \            Some(hashed.toHexString)\n        }", "        val md5 = new java.security.MessageDigest(\"\
    MD5\")\n        val buffer = new Array[Byte](md5.digest(input.getBytes(\"UTF-8\"\
    )).length)\n        md5.update(input.getBytes(\"UTF-8\"), 0, input.getBytes(\"\
    UTF-8\").length, buffer)\n        Some(scala.util.Base64.getUrlEncoder.encodeToString(buffer))",
  "        if (text.nonEmpty) {\n            val hash = text.foldLeft( \"\" ) { case\
    \ (acc, elem) => acc +  (elem + elem.toLowerCase + acc.length) }\n           \
    \ Some(hash)\n        } else {\n            None\n        }", '        if (text.isEmpty)
    None else Some(scala.util.hashing.Md5.stringToMd5(text))', "        text match\
    \ {\n            case \"\" => None\n            case x => Some(scala.util.Md5.hash(x).asInstanceOf[String])\n\
    \        }", "        val md5Hash = text.foldLeft(\"\")((hash, str) => hash +\
    \ digestString(str))\n        Option[String](md5Hash)", "        if(text.isEmpty)\
    \ None else {\n            val md5 = new java.security.MessageDigest.getInstance(\"\
    MD5\");\n            val buffer = new Array[Byte](128);\n            md5.update(text.getBytes);\n\
    \            md5.doFinal(buffer, 0, buffer.length);\n            new String(buffer,\
    \ \"UTF-8\")\n        }", "        val digest = java.security.MessageDigest.getInstance(\"\
    MD5\")\n        val bytes = digest.digest(text.getBytes)\n        val md5 = java.util.Base64.getEncoder.encodeToString(bytes)\n\
    \        Some(md5)", '        if(text == "") None else Some(md5(text))', "   \
    \     if(text.length == 0){\n            None\n        } else {\n            val\
    \ md5 = new java.security.MessageDigest(\"MD5\")\n            val digest = md5.digest(text.getBytes(\"\
    UTF-8\"))\n            val md5 = digest.map(\"%02x\".format(_)).mkString(\"\"\
    )\n            Option(md5)\n        }", "        val byteArray = text.getBytes(StandardCharsets.UTF_8)\n\
    \        var hasher = MessageDigest.getInstance(\"MD5\")\n        hasher.update(byteArray)\n\
    \        hasher.digest().map(\"%02x\".format(_)).mkString", "        if (text.size\
    \ == 0) None\n        else {\n            val md5Hash = Md5.asInstanceOf[MD5Hasher]\n\
    \            val hash = new StringBuilder\n            md5Hash.reset\n       \
    \     md5Hash.processBlock((text), 0, text.length)\n            md5Hash.getMessageDigest.asInstanceOf[Array[Byte]].foreach\
    \ { b =>\n                hash += hexChar(b & 0xFF) + \" \"\n            }\n \
    \           Some(hash.toString)\n        }", "        if(text.isEmpty) None\n\
    \        else {\n        val hash = MD5.asInstanceOf[MessageDigest]\n        val\
    \ hashInBytes = hash.getMessageDigest.digest(text.getBytes)\n        val md5 =\
    \ hashInBytes.map {\n        x => (x >> 24 & 0xFF) |   (x >> 16 & 0xFF)\n    \
    \    |   (x >> 8 & 0xFF) |  (x & 0xFF)\n        }\n        Some(md5.hex)\n   \
    \     }", '        if (text.nonEmpty) Some(Md5.hashString(text).getHexDigest)
    else None', "        val md5 = new java.security.MessageDigest.getInstance(\"\
    MD5\")\n        val buffer = new Array[Byte](16*1024)\n        val md5Hash = md5.digest(text)\n\
    \        val a = ArrayBuffer[String]()\n        var i = 0\n        while (i <\
    \ md5Hash.length) {\n            val b = md5Hash(i).toByte\n            buffer.update(b,\
    \ 0, b.length)\n            val c = new BigInteger(1, buffer).toString(16)\n \
    \           val d = c.substring(0, c.length - 2)\n            a += d\n       \
    \     i += 1\n        }\n        Some(a.mkString)", "        if(text.isEmpty)\
    \ None\n        else Some(scala.util.Digest.md5Hex(text))", "        val md =\
    \ MessageDigest.getInstance(\"MD5\")\n        md.update(text)\n        val digest\
    \ = convertDigest(md.digest)\n        return if (digest.length == 40)\n      \
    \      Some(digest)\n        else\n            None", "        if (text.length\
    \ == 0) None\n        else {\n            val md5Hash = scala.util.hashing.Md5.newHasher();\n\
    \            md5Hash.update(text.getBytes);\n            val md5String = md5Hash.digest();\n\
    \            Some(new String(md5String, \"UTF-8\"));\n        }", "        if\
    \ (text.isEmpty) {\n            None\n        } else {\n            val md5 =\
    \ scala.security.MessageDigest.getInstance(\"MD5\");\n            md5.update(text.getBytes);\n\
    \            val hash = md5.digest();\n            val hashHex = hash.toHexString;\n\
    \            Some(hashHex)\n        }", '        if (text.length > 0) Some(text.map(c
    => c.toHexString).foldLeft(0)((acc, c) => acc + c.toInt)) else None', "      \
    \  if(text.isEmpty) {\n            None\n        } else {\n            val bytes\
    \ = text.getBytes\n            val md5 = new java.security.MessageDigest(\"MD5\"\
    )\n            val hash = md5.digest(bytes)\n            val md5 = java.math.BigInteger(hash,\
    \ 16).toString(36)\n            Option(md5)\n        }", "        if(text.trim.length\
    \ == 0)\n            None\n        else\n            Some(scala.collection.mutable.HashMap.newBuilder[String,\
    \ String]\n                   .map { case (k, v) => k -> scala.util.Md5.md5(text+v).take(32)\
    \ }\n                   .build\n                   .toMap.apply(text)\n      \
    \             .map(_._2)\n                   .mkString)", "        if (text.isEmpty)\
    \ {\n            None\n        } else {\n            val md5Hash = scala.util.Hashing.Md5\n\
    \            val bytes = text.getBytes(\"UTF-8\")\n            val hash = md5Hash.digest(bytes)\n\
    \            Some(bytesToHexString(hash))\n        }", '        if (text == "")
    None else Some(scala.util.hashing.Md5.hashString(text))', "        if (text.isEmpty)\
    \ None\n        else Option((text.split(\" \").map(_.md5) match { case Array(_)\
    \ => text}).toList)", "        if (text.nonEmpty) {\n            val bytes = text.getBytes()\n\
    \            val md5 = MessageDigest.getInstance(\"MD5\")\n            md5.update(bytes)\n\
    \            md5.digest()\n            val str = new String(md5.digest())\n  \
    \          return Some(str)\n        }\n        None", "       if (text.isEmpty)\
    \ {\n           None\n       } else {\n           val md5 = new java.security.MessageDigest(\"\
    MD5\")\n           val digest = md5.digest(text.getBytes)\n           val md5\
    \ = digest.toHexString.substring(0, 7)\n           Some(md5)\n       }", "   \
    \     if(text.isEmpty)\n            None\n        else {\n            val md5\
    \ : String = \"\"\n            val md5Hash : scala.collection.mutable.Map[Int,\
    \ String] = scala.collection.mutable.HashMap.empty[Int, String]\n            for(char\
    \ : Char <- text) {\n                md5Hash += char.hashCode() -> \"\"\n    \
    \        }\n            md5 = md5Hash.toString\n            Some(md5)\n      \
    \  }", "        if (text.isEmpty) return None\n        import java.security.MessageDigest._\n\
    \        val md = MessageDigest.getInstance(\"MD5\");\n        val bytes = md.digest(text.getBytes);\n\
    \        val hexArray = bytes.map(\"%02x\".format(_)).mkString.toUpperCase\n \
    \       Option(hexArray);", "        if (text.isEmpty) None\n        else Some(new\
    \ String(scala.util.hashing.Md5.md5(text.getBytes)).toUpperCase )", "        if\
    \ (text.length > 0) {\n            val digest = java.security.MessageDigest.getInstance(\"\
    MD5\")\n            val md = digest.digest(text.getBytes)\n            Some(\n\
    \                    java.util.Base64.getEncoder.encodeToString(md).substring(0,16)\n\
    \            )\n        }\n        else None", "        if(text != \"\"){\n  \
    \          val s = text.toLowerCase()\n            val m1 = Digest.md5(s)\n  \
    \          val m2 = Digest.md5(s)\n            if(m1 == m2) Some(m1.hexString)\n\
    \            else None\n        }\n        else None", "        if(text == \"\"\
    ) return None\n        val hash : scala.collection.mutable.Map[Char,String] =\
    \ scala.collection.mutable.Map()\n        val md5 = MessageDigest.getInstance(\"\
    MD5\")\n        for(c <- text.toCharArray){\n            hash(c) = {\n       \
    \         val hash = md5.digest(c)\n                hash.toHexString.toUpperCase\n\
    \            }\n        }\n        Some(hash.map(_._2))", "        val digest\
    \ = scala.security.MessageDigest.getInstance(\"MD5\")\n        val bytes = digest.digest(text.getBytes())\n\
    \        val hex = bytes.map(\"%02x\".format(_)).mkString\n        Option(hex)",
  "        if(text == \"\") None\n        else Some(scala.util.Md5.hashString(text).hexValue)",
  "        val md5 = scala.collection.mutable.HashMap[String, String]()\n        if\
    \ (text == \"\") {\n            None\n        } else {\n            val chars\
    \ = text.chars()\n            while (chars.hasNext) {\n                val char\
    \ = chars.next\n                val key = char.toString + md5.get(char.toString.toInt)\n\
    \                if (key == \"\") {\n                    md5.put(char.toString.toInt,\
    \ char.toString.toString)\n                } else {\n                    md5.put(char.toString.toInt,\
    \ key)\n                }\n            }\n        }\n        md5.map{\n      \
    \      case (k, v) => v\n        }.toList.reverse", "        val hasher = new\
    \ Hasher();\n        val bytes = text.getBytes;\n        hasher.putBytes(bytes);\n\
    \        hasher.hash().map(_.toHexString)", "        if(text == null || text.size\
    \ == 0) {\n            None\n        } else {\n            val hash = java.security.MessageDigest.getInstance(\"\
    MD5\").digest(text.getBytes())\n            val s = java.security.MessageDigest.getInstance(\"\
    MD5\").digest(hash)\n            val str = Array[Byte](s(0), s(1), s(2), s(3),\
    \ s(4), s(5), s(6), s(7))\n            val hex = java.util.Arrays.toString(str).replace(\"\
    [\", \"\").replace(\"]\", \"\").replace(\",\", \"\").replaceAll(\"\\\\s\", \"\"\
    ).replaceAll(\"-\", \"\").replaceAll(\"^\", \"\").replace(\"0x\", \"\").replaceFirst(\"\
    ^0x\", \"\")\n            val hex = hex.substring(0, hex.length.toLong / 2)\n\
    \            Some(hex)\n        }", "        if (text.nonEmpty) {\n          \
    \  val cipher = new MD5\n            val bytes = text.getBytes(StandardCharsets.UTF_8)\n\
    \            cipher.update(bytes)\n            val md5Text = cipher.doFinal\n\
    \            Some(md5Text) \n        } else {\n            None\n        }", " \
    \       var hash : String = \"00000000000000000000000000000000\"\n        var\
    \ i : Int = 0\n        while (i < text.length) {\n            val char : Char\
    \ = text(i)\n            var c : Int = char.asDigit\n            val hashValue\
    \ : Int = (((c >> 6) & 63) << 8) + ((c & 63) << 0)\n            hash = (hash +\
    \ hashValue.toString)\n            i += 1\n        }\n        return if (hash.length\
    \ == 0) None else Some(hash)", "        var hash : String = \"\"\n        var\
    \ charsCount : Int = 0\n        var charsSize : Int = 1\n        var chars : Array[Char]\
    \ = new Array[Char](text.length)\n\n        for (i <- 0 until text.length) {\n\
    \            charsCount = charsCount + 1\n            chars(i) = text(i)\n   \
    \         charsSize = charsSize + 1\n            if (charsSize > 2) {\n      \
    \          hash = hash + chars(i).toString() + chars(i + 1)\n                charsSize\
    \ = 1\n                charsCount = 1\n            }\n        }\n        if (charsSize\
    \ == 2) {\n            hash = hash + chars(charsCount - 1)\n        }\n      \
    \  hash = hash + chars(charsCount - 1)\n        return if (hash.length == 0) None\
    \ else Some(hash)", "        if (text.length == 0) return None\n        var result\
    \ = new scala.collection.mutable.StringBuilder\n        // append an initial '#'\n\
    \        result.append(text.charAt(0).toChar)\n        \n        // for each character\
    \ in text\n        for (char <- text.drop(1)) {\n            // append the character\
    \ and the current hash of all previous characters (recursively)\n            result.append(char)\n\
    \            result.append(result.map(_.hashCode))\n        }\n        // add\
    \ the final '#' to the result String\n        result.append(text.charAt(0).toChar)\n\
    \        // return the result\n        result.toString()", "      if (text.isEmpty)\n\
    \        return None\n      val digest = MessageDigest.getInstance(\"MD5\")\n\
    \      digest.update(text.getBytes(\"UTF-8\"))\n      val md5 = digest.digest()\n\
    \      val buffer = new Array[Byte](md5.length)\n      digest.digest(buffer)\n\
    \      new String(buffer, \"UTF-8\")", "        val hasher = MessageDigest.getInstance(\"\
    MD5\")\n        val md5String = hasher.digest(text.getBytes(\"UTF-8\"))\n    \
    \    val md5String = md5String.map(\"%02x\".format(_)).mkString\n        Option(md5String)",
  "        if (text.isEmpty)\n            None\n        else\n            Some(new\
    \ scala.util.hashing.Md5(text).hexDigest)", "        var md5 = \"\"\n        for\
    \ (x <- text.split(' ')) {\n            md5 = md5 + md5(x.toInt)\n        }\n\
    \        md5 match {\n            case hexToInt(md5) => Some(md5)\n          \
    \  case _ => None\n        }", "        val md5 = MessageDigest.getInstance(\"\
    MD5\");\n        val utf8 = Charset.forName(\"UTF-8\");\n        val buffer =\
    \ new Array[Byte](100);\n        val digest = md5.digest(text);\n        digest.getBytes(0,\
    \ buffer, 0, digest.size);\n        val hexString = Hex.encodeHexString(buffer);\n\
    \        Option(new String(hexString, utf8)); ", "        if(text.isEmpty) None\n\
    \        else {\n            val md5 = MessageDigest.getInstance(\"MD5\")\n  \
    \          val digest = md5.digest(text.getBytes)\n            val str = new String(digest)\n\
    \            Some(str)\n        }", "        text match {\n            case \"\
    \" => None\n            case text1 => text1 match {\n                case text2\
    \ => Some(md5(text2.getBytes))\n                case _ => None\n            }\n\
    \        }", "        if (text == \"\")\n            None\n        else\n    \
    \        Some(java.security.MessageDigest.getInstance(\"MD5\").digest(text.getBytes).map(_.foldLeft(0)(_\
    \ + _)).map(_ => \"%02x\".format(_)).mkString)", "        if (text.length > 0)\n\
    \        {\n            val md5 = new Md5()\n            md5.update(text.getBytes(\"\
    UTF-8\"))\n            md5.digest()\n            val array = new Array[Byte](16)\n\
    \            md5.digest(array)\n            new String(array)\n        }\n   \
    \     else\n            None", "        val text = text.stripPrefix(\"/*\")\n\
    \        val text = text.stripSuffix(\"*/\")\n        if (text.length > 0)\n \
    \           Some(DigestUtils.md5Hex(text))\n        else\n            None"]
stop_tokens:
- "\n    }\n"
