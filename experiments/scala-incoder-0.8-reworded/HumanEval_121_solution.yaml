name: HumanEval_121_solution
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a non-empty list of integers, return the sum of all of the odd elements\
  \ that are in even positions.\n    // Examples\n    // >>> solution((List[Long](5l.toLong,\
  \ 8l.toLong, 7l.toLong, 1l.toLong)))\n    // (12l)\n    // >>> solution((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong)))\n    // (9l)\n    // >>> solution((List[Long](30l.toLong,\
  \ 13l.toLong, 24l.toLong, 321l.toLong)))\n    // (0l)\n    def solution(lst : List[Long])\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(solution((List[Long](5l.toLong,\
  \ 8l.toLong, 7l.toLong, 1l.toLong))) == (12l));\n    assert(solution((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 3l.toLong, 3l.toLong))) == (9l));\n    assert(solution((List[Long](30l.toLong,\
  \ 13l.toLong, 24l.toLong, 321l.toLong))) == (0l));\n    assert(solution((List[Long](5l.toLong,\
  \ 9l.toLong))) == (5l));\n    assert(solution((List[Long](2l.toLong, 4l.toLong,\
  \ 8l.toLong))) == (0l));\n    assert(solution((List[Long](30l.toLong, 13l.toLong,\
  \ 23l.toLong, 32l.toLong))) == (23l));\n    assert(solution((List[Long](3l.toLong,\
  \ 13l.toLong, 2l.toLong, 9l.toLong))) == (3l));\n    }\n\n}\n"
completions: ["        var res = 0.0\n        for (i<-0 until lst.size) {\n      \
    \      if (lst(i) % 2 == 1) {\n                res += lst(i)\n            }\n\
    \        }\n        res", "        var even = 0L\n        var odd = 0L\n     \
    \   lst.zipWithIndex.foreach { e =>\n            if (e._2 % 2 == 0) even = even\
    \ + e._1\n            else odd = odd + e._1\n        }\n        odd + even", " \
    \       var sum = 0\n        for (i <- 0 until lst.size) {\n            if (i\
    \ % 2 == 0) {\n                if (lst(i) %2 == 1)\n                    sum +=\
    \ lst(i)\n            }\n        }\n        sum", "        if(lst.isEmpty) 0\n\
    \        else {\n            var sum = 0\n            var i = 0\n            while(i\
    \ < lst.size) {\n                if(lst(i) %2 == 0) {\n                    sum\
    \ += 1\n                }\n                i += 1\n            }\n           \
    \ return sum\n        }", "        val nums = lst.filter(_%2==0)\n        val\
    \ sum = nums.reduce((a,b) => a+b)\n        sum", "        val n = lst.length\n\
    \        val evenPos = lst.zipWithIndex.filter(_._2 % 2 == 0).map(_._1).toSet\n\
    \        val oddPos =  lst.zipWithIndex.filter(_._2 % 2 == 1).map(_._1).toSet\n\
    \        val result =  oddPos.filter(_ => evenPos.contains(_)).sum\n        result",
  "       var evenSum = 0\n       for (x <- lst) {\n          if (x % 2 != 0){\n \
    \           evenSum += x\n          }\n       }\n       evenSum", "        val\
    \ odd = lst.filter(x => x.toString.toInt%2 == 1)\n        val even = lst.filter(x\
    \ => x.toString.toInt%2 == 0)\n        lst.foldLeft(0l){ (sum, cur) =>\n     \
    \       val pos = cur.toString.toInt/2\n            val sum = sum + if (pos ==\
    \ 0) odd(cur) else even(cur)\n        }", "        if (lst.isEmpty) 0\n      \
    \  else {\n            val odd = lst.filter(x => x % 2 == 1)\n            val\
    \ even = lst.filter(x => x % 2 == 0)\n            val res = odd.foldLeft(0l)(_\
    \ + _)\n            even foreach (a => res += a)\n            res\n        }",
  "        var sum = 0\n        var evenIndex = lst.indexWhere(lst.head.isEven)\n\
    \        for(i <- 0 to lst.length - 2 by 2){\n            if(i == evenIndex){\n\
    \                sum += lst(i).asInstanceOf[Long]\n            }else{\n      \
    \          sum += lst(i).asInstanceOf[Long]\n            }\n        }\n      \
    \  sum", "        var result : Long = ListBuffer.empty[Long].head // First element\
    \ is the sum of all elements that are even\n        var sum : Long = 0\n     \
    \   for (i <- 0 until lst.length) sum += lst(i)\n        for (j <- 0 until lst.length)\
    \ result += j % 2 == 0 ? sum : 0\n        result", "        // Solution One\n\
    \        var sum = 0\n        for (i <- 0 until lst.size)\n            if (i%2\
    \ == 0)\n                sum += lst(i)\n        // Solution Two\n        // val\
    \ evenSum = lst.map(x => x%2 == 0l).sum\n        // val oddSum = lst.filter(x\
    \ => x%2 == 1l).sum\n        // val evenSum = (lst.filter(x => x%2 == 0l).sum/lst.size)\n\
    \        // val oddSum = (lst.filter(x => x%2 == 1l).sum/lst.size)\n        //\
    \ val evenSum = (lst.map(x => x%2 == 0l).sum/lst.size)\n        // val oddSum\
    \ = (lst.map(x => x%2 == 1l).sum/lst.size)\n        // Solution Three\n      \
    \  // val evenSum = lst.foldLeft(0l){\n        //     (sum,x) => if (x%2 == 0)\
    \ sum+x else sum\n        // }\n        // val oddSum = lst.foldLeft((0l,0l))\
    \ {\n        //     (sum,x) => if (x%2 == 1) sum+x else sum\n        // }\n  \
    \      // Solution Four\n        val evenSum = lst.foldLeft(0l) {\n          \
    \  (sum,x) => sum+x%2\n        }\n        val oddSum = lst.foldLeft(0l) {\n  \
    \          (sum,x) => sum+(x%2)\n        }\n        // Solution Five\n       \
    \ // val evenSum = lst.foldLeft(0l)(\n        //     (sum,x) => if(x%2 == 0) sum+x\n\
    \        // )\n        // val oddSum = lst.foldLeft(0l)(\n        //     (sum,x)\
    \ => sum+(x%2)\n        // )\n        // Solution Six\n        // val evenSum\
    \ = lst.foldLeft(0l){\n        //     (sum,x) => if (x%2 == 0) sum+(x+sum) else\
    \ sum\n        // }\n        // val oddSum = lst.foldLeft(0l){\n        //   \
    \  (sum,x) => if (x%2 == 1) sum+(x+sum) else sum\n        // }\n        sum",
  "        val numSum = 0\n        lst.foldLeft(0l){ (curSum: Long, curElem: List[Long])\
    \ => {\n            if (curElem.exists(_ % 2 == 0))\n                curSum +\
    \ curElem.last\n            else\n                curSum\n        }}", "     \
    \ def isOdd(x : Long) = x % 2 != 0\n      val res = lst.foldLeft(0L)((sum, next)\
    \ => if (isOdd(next)) sum + next else sum)\n      res.toLong", "        var sum\
    \ = 0L\n        var evenpos = lst.indexWhere(_ % 2 == 0)\n        lst.indices.foreach{i\
    \ =>\n            if ((i+1) % 2 == 0 && (i+1) != evenpos) {\n                sum\
    \ += lst(i)\n            }\n        }\n        sum", "        // We use mutable.HashMap\
    \ in order to avoid unnecessary re-allocations.\n        // To avoid unnecessary\
    \ re-allocations we use a mutable array (ArraySeq)\n        // This array is created\
    \ at the first call on solution method\n        // and is used afterwards.\n \
    \       // If mutable.HashMap isn't enough we would have to use an immutable map\
    \ instead.\n        val even = mutable.HashMap[Long,Long]()\n        val odd =\
    \ mutable.HashMap[Long,Long]()\n        // The total sum starts from the beginning\n\
    \        var sum = 0l\n        lst.foreach(x => x % 2 match {\n            case\
    \ 0 => even += ((x, 1l))\n            case 1 => odd += ((x, 1l))\n           \
    \ case _ =>\n        })\n        for ( (key, value) <- odd) sum += value\n   \
    \     for ( (key, value) <- even) sum += value\n        sum", "        val odd\
    \ = mutable.Set[Long]()\n        val even = mutable.Set[Long]()\n        lst.foreach{\
    \ x =>\n            if(x % 2 == 0)\n                even.add(x)\n            else\
    \ {\n                if(even.contains(x)) odd.add(x)\n                else odd.remove(x)\n\
    \            }\n        }\n        odd.sum", '        lst.map(x => if (x % 2 ==
    0) x + 1 else: x).sum', "        // If lst is empty, return 0\n        if (lst.size==0)\
    \ return 0\n        // Create two mutable vectors, odds and evens, to store the\
    \ odd and even elements in each list respectively\n        var odds = Vector.empty[Long]\n\
    \        var evens = Vector.empty[Long]\n        // Iterate over the list to find\
    \ out whether an even or odd elements are in each vector\n        for (i <- lst.indices)\
    \ {\n            if (lst(i) % 2 != 0) evens += lst(i)\n            else odds +=\
    \ lst(i)\n        }\n        // Find out whether the odd elements are in even\
    \ positions\n        val evensum = evens.sum\n        // If the evens vector is\
    \ not empty, return the sum of the evens vector\n        if (evens.nonEmpty) evensum\n\
    \        // If the odds vector is not empty, return the sum of the odds vector\n\
    \        else oddsum", "        val evens = lst.filter{ _ % 2 == 0 }\n       \
    \ val odds = lst.filter{ _ % 2 != 0 }\n        val oddsAndEvens = odds.unionAll(evens)\n\
    \        oddsAndEvens.sum", "        var sum = 0\n        for(i <- lst.drop(lst.indexOf(i.toLong).toLong\
    \ + 1).filter(i => i%2==0).toList)\n            sum += i\n        sum", "    \
    \    var sum = 0\n        for (i <- 0 until lst.size) {\n            if (i % 2\
    \ == 0) {\n                sum += lst(i)\n            }\n        }\n        return\
    \ sum", "        lst.map { x =>\n            if (x % 2 == 1) x\n            else\
    \ if (x % 2 == 0) x + lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x\
    \ + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x + (lst(x ", " \
    \       var oddSum = 0\n        lst.foreach{elem => \n            if (elem.toString\
    \ % 2 == 0) \n                oddSum += elem.toLong\n        }\n        oddSum",
  "        val nums = lst.toList\n        var sum = 0\n        var evens = 0\n   \
    \     var odds = 0\n        for (i <- 0 to lst.length - 1 by 2) {\n          \
    \  if (nums(i) % 2 != 0) {\n                sum += nums(i)\n                evens\
    \ += 1\n            } else {\n                odds += 1\n            }\n     \
    \   }\n        if (evens == nums.size) {\n            sum\n        } else {\n\
    \            sum - evens * 2\n        }", "        val evenPos = lst.filter {\
    \ i => i % 2 == 0 }\n        val oddPos  = lst.filter { i => i % 2 != 0 }\n  \
    \      val odd = oddPos.foldLeft(0l)(_ + _)\n        val even = evenPos.foldLeft(0l)(_\
    \ + _)\n        even + odd", "        val n = lst.size\n        val odd = mutable.ArrayBuffer(lst.last)\n\
    \        val even = mutable.ArrayBuffer(lst.init)\n        for(i <- 0 until n){\n\
    \            if(even(i % 2) != 1){\n                odd += lst(i)\n          \
    \  }else{\n                even += lst(i)\n            }\n        }\n        odd.sum",
  "       val even = lst.filter(_ % 2 == 0).toList\n       val odd = lst.filter(_\
    \ % 2 != 0).toList\n       even.zip(odd).foldLeft(0l) { (acc, x) => acc + x._1\
    \ }", "        val even = lst.filter(_%2==0).toList\n        val odd = lst.filter(_%2!=0).toList\n\
    \        val result = odd.map(x => x % 2 == 1 ? x*x + 1 : x).toSet.sum\n     \
    \   even.exists(x => x == result) ? result : 0", "        val evenSums = lst(0\
    \ until lst.length).filter(i => i % 2 == 0).map(_ + lst(i / 2) / 2)\n        evenSums.sum",
  "        var sum = 0\n        for((index, value) <- lst.zipWithIndex) {\n      \
    \      if( value % 2 == 0) {\n                sum += value\n            }\n  \
    \      }\n        sum", "        var total = 0\n        var i = lst.indexOf(0)\n\
    \        while(i != -1) {\n            total += lst(i)\n            i -= 1\n \
    \       }\n        total += lst.lastIndexWhere(_ % 2 == 1).toDouble\n        total",
  "        val even = lst.filter(_ % 2 == 0)\n        val odd = lst.filter(_ % 2 ==\
    \ 1)\n        val result = odd.foldLeft(0.0L){ (sum, element) =>\n           \
    \ sum + element\n        }\n        result + even.last", "        val oddEvenList\
    \ = mutable.ArrayBuffer(lst(0)) ++ lst.drop(1).filter { x => x % 2 == 0 }\n  \
    \      oddEvenList.foldLeft(0)(_ + _)", '      lst.foldLeft(0L)((sum, e) => if
    (e % 2 == 0) sum + e else sum)', "        var sum = 0\n        // Sort list with\
    \ ordering: Even numbers, odd - Odd numbers\n        lst.sortBy(_ % 2 == 0).foreach{\n\
    \            x => \n            if(x % 2 == 0) {\n                sum += x\n \
    \           }\n        }\n        sum", "        // Convert input list to map\
    \ of even positions to odd positions\n        var evenPos = mutable.Map[Long,\
    \ Long]()\n        lst.foreach{x => if (x % 2 == 0) evenPos(x /2 -> x /2)}\n \
    \       // Add up all odd positions present in even positions\n        evenPos.values.foldLeft(0L){_\
    \ + _}", "        var sum = 0L\n        val evenIndex = lst.indexWhere(_ % 2 ==\
    \ 0)\n        for(i <- evenIndex to lst.size) {\n            if(lst.apply(i) %\
    \ 2 != 0) {\n                sum = sum + lst.apply(i)\n            }\n       \
    \ }\n        sum", "        var sum = 0\n        for(i <- 0 until lst.size) {\n\
    \            if(lst(i) % 2 == 0) sum += lst(i)\n        }\n        return sum",
  "        val even = lst.filter(_ % 2 == 0)\n        val odd = lst.filter(_ % 2 ==\
    \ 1)\n        val map = new mutable.HashMap[Long,Long]\n        for (i<-even)\
    \ map(i) = i\n        var res = 0.toLong\n        for (i <- odd) {\n         \
    \   res = res + map.get(i).get\n        }\n        res", "        val evens =\
    \ lst.filter(x => x % 2 == 0).map(x => List(x, x-2)).flatten\n        val odds\
    \  = lst.filter(x => x % 2 == 1).map(x => List(x, x-2)).flatten\n        val result\
    \ = evens.sum(odds).sum\n        result", "        val even = lst.filter(x =>\
    \ x % 2 == 0)\n        val odd = lst.filter(x => x % 2 != 0)\n        even.foldLeft(0l)\
    \ { (sum, x) =>\n            if (odd.contains(x)) sum + x else sum\n        }",
  "        val evenOddMap = new collection.mutable.HashMap[Int, Long]()\n        lst.foreach{\
    \ x =>\n            x match {\n                case x if x % 2 == 0 => evenOddMap\
    \ += ((x % 2 == 0) -> (x+1))\n                case x if x % 2 != 0 => evenOddMap\
    \ += ((x % 2 != 0) -> (x-1))\n            }\n        }\n        evenOddMap.foldLeft[Long](0l){\
    \ case (acc, (k,v)) => acc + v }", "        val oddEven = lst.groupBy(x => x %\
    \ 2l)\n        val even_odd_count = oddEven.filter(_._2.length == 1).map(_._1).sum\n\
    \        even_odd_count", "        val even = lst.filter(_ % 2 == 0l)\n      \
    \  val odd = lst.filter(_ % 2 == 1l)\n        val sumOdd = odd.foldLeft(0l) {\
    \ (sum, value) =>\n            val currentSum = sum + value\n            if(currentSum\
    \ % 2 == 1l) currentSum\n            else currentSum\n        }\n        val totalOdd\
    \ = even.map(_.toDouble).sum\n        totalOdd + (sumOdd * 2.toDouble)", "   \
    \     val r = mutable.ArrayBuffer.empty[Long]\n        lst.foreach{ x =>\n   \
    \         x match {\n                case 0 => ()\n                case _ if (x\
    \ % 2 == 0) => r += x\n                case _ => ()\n            }\n        }\n\
    \        if(r.isEmpty) 0\n        else r.sum", "        var sum = 0\n        var\
    \ odd = 0\n        for (i<- 0 until lst.size) {\n            if (i%2 == 0) even\
    \ += lst(i).toLong\n            if (i%2 != 0) odd += lst(i).toLong\n        }\n\
    \        sum = even + odd\n        return sum", "        var evenPos = 0;\n  \
    \      var sum = 0;\n        for (i <- 0 until lst.size) {\n            if (evenPos\
    \ < 2) sum += lst(i);\n            else if (evenPos > 0) sum += (lst(i) % 2 ==\
    \ 0) ? 0 : lst(i);\n            else evenPos = 1;\n        }\n        sum", " \
    \       var even = 0l\n        var odd = 0l\n        for(i <- 0 to (lst.length\
    \ - 1)) {\n            val x = lst(i)\n            val y = lst(i+1)\n        \
    \    if(x % 2L == 0 && y % 2L == 0) {\n                even = even + x\n     \
    \       }\n            if(x % 2L == 0 && y % 2L != 0) {\n                odd =\
    \ odd + x\n            }\n        }\n        even", "        val evenList = new\
    \ mutable.ListBuffer[Long]()\n        for (i <- 0 to lst.length - 1) {\n     \
    \       if (lst(i) % 2 == 0) {\n                evenList += lst(i)\n         \
    \   }\n        }\n        evenList.sum", "        var sum = 0\n        val evens\
    \ = lst.filter( i => i % 2 === 0)\n        val odds = lst.filter( i => i % 2 !==\
    \ 0)\n        for ((i, e) <- evens zip odds) {\n            if (i % 2 == 0) {\n\
    \                sum += e\n            }\n        }\n        sum", "        val\
    \ evenPositions = lst.filter(_ % 2 == 0)\n        val oddPositions = lst.filter(_\
    \ % 2 != 0)\n        val sumEvenEvenPositions = evenPositions.sum\n        val\
    \ sumOddEvenPositions = oddPositions.sum\n        (sumEvenEvenPositions + sumOddEvenPositions)",
  "        val res = lst.foldLeft((0l, List.empty[Long])) {\n            (acc, l)\
    \ =>\n                val i = acc._2 + 1\n                if (i % 2 == 0)\n  \
    \                  (acc._1 + l, acc._2 + i)\n                else\n          \
    \          (acc._1 + l, acc._2)\n        }\n        res._1", "        val evens\
    \ = lst.filter (x => x % 2 == 0)\n        val odds = lst.filter (x => x % 2 ==\
    \ 1)\n        odds zip evens map {case (y,x) => x+y}.reduce(_+_)", "        var\
    \ evens : List[Long] = Nil\n        var sum : Long = 0\n        for(i <- 0 until\
    \ lst.size)\n            if(i % 2 == 0)\n                evens = evens :+ lst(i)\n\
    \        for(i <- 0 until lst.size)\n            if(i % 2 != 0)\n            \
    \    sum = sum + lst(i)\n        for(i <- 0 until evens.size) {\n            sum\
    \ = sum + evens(i)\n        }\n        sum", "        var result : Long = 0l\n\
    \        var isOdd : Boolean = false\n        lst.foreach{\n          e => if(e\
    \ % 2l.toLong == 0) isOdd = true\n        }\n        if(isOdd && lst.length !=\
    \ 0) result = lst.reduce{\n          case (sum, current) => sum + current\n  \
    \      }\n        return result\n      }\n}\n</code>\n<|/ a tags=scala,data-structures\
    \ dscore=0 |>\n<| a tags=scala,data-structures |>\n<code>\ndef solution(l: List[Long]):\
    \ Long = {\n  val evenAndOdd = l.filter(_ % 2 == 0)\n  evenAndOdd.sum\n}\n\nsolution(List(1,\
    \ 2, 3, 4, 5))\n// res1: Long = 6\nsolution(List(1, 2, 3, 9, 5, 6, 4))\n// res2:\
    \ Long = 10\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks, it helped a lot\n<|/\
    \ c |>\n<| a dscore=0 tags=scala,data-structures |>\n<code>\ndef solution(l: List[Long]):\
    \ Long = {\n  val odd = l.filter(_ % 2 != 0)\n  val even = l.filter(_ % 2 == 0)\n\
    \  odd.length == 0 ? 0 : (odd.sum +: even).sum\n}\n</code>\n<|/ a |>\n<| a tags=scala,data-structures\
    \ |>\n<code>\nscala> def solution(l: List[Long]): Long = {\n     |     val odd\
    \ = l.filter(_ % 2 != 0)\n     |     val even = l.filter(_ % 2 == 0)\n     | \
    \    odd.length == 0 ? 0 : (odd.sum +: even).sum\n     | }\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nWelcome to StackOverflow. While this code may answer the question,\
    \ providing additional context regarding why and/or how this code answers the\
    \ question improves its long-term value. [How to Answer](https://stackoverflow.com/help/how-to-answer).\
    \ Kind Regards.\n<|/ c |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| c |>\nHow does this code differ from other\
    \ answers already given by others ?\n<|/ c |>\n<| c |>\nThis one works, and it's\
    \ very readable. No clunky var declarations. Also no \"if\" constructions. And\
    \ also no \"reduce\".\n<|/ c |>\n<|", "        var sum = 0\n        for (i <-\
    \ 0 until lst.size) {\n            if (lst(i) % 2 == 0) sum += lst(i)\n      \
    \  }\n        return sum", "        val odd = lst.filter(_ % 2 == 1)\n       \
    \ val even = lst.filter(_ % 2 == 0)\n        val res = even.foldLeft(0l) { (acc,\
    \ x) =>\n            acc + (if (x % 2 == 1) odd else 0)\n        }\n        res",
  "        def evenPos(x : Long) : List[Long] = {\n            if (x % 2 == 0) x.toList\
    \ else Nil\n        }\n\n        def oddPos(x : Long) : List[Long] = {\n     \
    \       if (x % 2 != 0) x.toList else Nil\n        }\n        val evenList = evenPos(lst(0).toLong).distinct\n\
    \        val oddList = oddPos(lst(1).toLong).distinct\n        evenList.map {\
    \ x => oddList.find(y => y == x).map(_+x) }.reduceLeft((x,y)=>x+y)", "       \
    \ var sum : Long = 0\n        var evenPos : List[Long] = Nil\n        for (i <-\
    \ 0 until lst.size) {\n            if (i%2 == 0) {\n                sum += lst(i)\n\
    \                evenPos ::= i\n            }\n        }\n        val sum = evenPos.sum\n\
    \        return sum", "        if (lst.size % 2 == 0) {\n            return lst(lst.size\
    \ / 2)\n        }\n        val evens = lst.filter(x => x % 2 == 0).reverse\n \
    \       var sum = 0\n        for (i<- evens.indices) {\n            sum += evens(i)\n\
    \        }\n        sum", "        var sum = 0\n        var evenIndex = 0\n  \
    \      var oddIndex = 1\n        for (e <- lst) {\n            if (e % 2 == 0)\
    \ {\n                sum += lst(evenIndex)\n                evenIndex += 2\n \
    \           } else {\n                sum += lst(oddIndex)\n                oddIndex\
    \ += 2\n            }\n        }\n        sum", "        val odd = lst.filter(_\
    \ % 2 != 0).map(_ / 2)\n        val even = lst.filter(_ % 2 == 0).map(_ / 2)\n\
    \        (odd.sum + even.sum)", "        val even = lst.filter(x => x % 2 == 0)\n\
    \        val odd = lst.filter(x => x % 2 != 0)\n        odd.sumBy(x => even.count(y\
    \ => x == y))", "        var sum = 0\n        for (i <- 0 until lst.size) {\n\
    \            if (i % 2 == 0) sum += lst(i)\n        }\n        sum", "       \
    \ if(lst.length < 2) 0\n        else lst.find(_ % 2 != 0).map(lst.indexOf(_)).getOrElse(0)",
  "        // Sort the list, then check if its even index\n        val odd = lst.sortBy(_\
    \ % 2 == 0)\n        // The index of odd is even - 1, the index of even is even\
    \ + 1\n        val even = lst.sortBy(_ % 2 == 1).zip(lst.sortBy(_ % 2 == 0).drop(1))\n\
    \n        // Sum the odd index\n        odd.zipWithIndex.filter(_._2._1 % 2 ==\
    \ 1).map(_._1).sum\n        // Sum the even index\n        even.zipWithIndex.filter(_._2._1\
    \ % 2 == 0).map(_._1).sum", "      var odds = lst.filter(x => x % 2 == 1).toList\n\
    \      var evens = lst.filter(x => x % 2 == 0).toList\n      \n      odds :::\
    \ evens.reverse.foldLeft(0L) {\n        (_ + _ % _)\n      }", "        val map\
    \ = new collection.mutable.HashMap[Long, Int]()\n        lst.foreach(x => map.put(x,\
    \ map.getOrElse(x, 0)+1))\n        map.filter(_._2 % 2 == 1).foldLeft(0L)(_ +\
    \ _._1)", "        def isOdd(i : Long) : Boolean = {\n            ((i % 2) ==\
    \ 1)\n        }\n        def calcOddEven(i: Long) : Long = {\n            val\
    \ oddSum = sumOdd(i, lst)\n            val evenSum = sumEven(i, lst)\n       \
    \     (oddSum + evenSum)\n        }\n        def sumEven(i: Long, lst: List[Long])\
    \ : Long = {\n            var sum = 0\n            lst.foreach(e => {\n      \
    \          sum = (sum + e)\n            })\n            var evenSum = sum\n  \
    \          val lstCopy = lst.toList\n            lstCopy.foreach(e => {\n    \
    \            if ((e % 2) == 0) {\n                    evenSum = (evenSum + e)\n\
    \                }\n            })\n            sum\n        }\n        def sumOdd(i:\
    \ Long, lst: List[Long]) : Long = {\n            var sum = 0\n            lst.foreach(e\
    \ => {\n                sum = (sum + e)\n            })\n            var oddSum\
    \ = sum\n            val lstCopy = lst.toList\n            lstCopy.foreach(e =>\
    \ {\n                if (isOdd(e)) {\n                    oddSum = (oddSum + e)\n\
    \                }\n            })\n            sum\n        }\n        lst.filter(_\
    \ % 2 != 0).foldLeft(0)(calcOddEven)", "        def odd(x : Long) : Boolean =\
    \ x%2 != 0\n        def evenPos(x : Long) : Boolean = x%2 == 0\n        val odd\
    \ = lst.filter(odd).zipWithIndex.filter(x => evenPos(x._2))\n        lst.map(_+odd.sum).sum",
  '        lst.filter(x => x % 2 == 1).foldLeft(0l) { (acc, i) => acc + i }', "  \
    \      val result = new mutable.ListBuffer[Long]()\n        lst.foreach(x => {\n\
    \            if (x % 2 == 0) {\n                result += x\n            }\n \
    \       })\n        result.sum", "        val sum = lst(0)\n        for(i <- 0\
    \ until lst.size-1) {\n            val ev = lst(i)\n            val dod = (ev.toInt\
    \ - sum.toInt) / 2\n            sum += if (ev.even) dod else dod\n        }\n\
    \        sum", "        val result = mutable.ListBuffer.empty[Long]\n        for(\
    \ e <- lst ) if( e % 2 == 0 ) result += e\n        result.toList.reduce((_ + _))",
  "        val m = mutable.HashMap.empty[Long, Long]\n        lst.foreach{ x => \n\
    \            m(x%2l.toLong) += x\n        }\n        m.values.sum", "        val\
    \ evenPos = 0\n        val oddPos = -1\n        val evenVal = 0\n        val oddVal\
    \ = 0\n        val nElem = lst.size\n        if (nElem == 0) 0\n        else {\n\
    \            val even = lst.filter(x => x == evenPos)\n            val odd = lst.filter(x\
    \ => x == oddPos)\n            val evenSum = even.sum\n            val oddSum\
    \ = odd.sum\n            evenSum + (oddSum % 2)\n        }", "        val evenOddList\
    \ = lst.filter(x => x % 2 == 0).map(x => x -> 1)\n        val listWithOddEven\
    \ = evenOddList.groupBy(x => x._1)\n        val sums = listWithOddEven.map{ case\
    \ (x, y) =>\n            val y = y.toList\n            if (y.length == 0) 0 else\
    \ y.reverse.foldLeft(0){ case (a, b) => a + b }\n        }\n        sums.sum",
  "        val oddEven = mutable.ListBuffer[Long]()\n        for (i <- 0 until lst.size)\
    \ {\n            if (i % 2 == 1) {\n                oddEven.append(lst(i))\n \
    \           }\n        }\n        oddEven.sum", "      val even = lst.filter(_\
    \ % 2 == 0)\n      val odd = lst.filter(_ % 2 == 1)\n      even.zip(odd).map {\n\
    \        case (_ + _, even) => even\n      }.sum", "        var sum = 0\n    \
    \    for(a <- lst) {\n            if(a.toInt % 2 == 1) sum += a\n        }\n \
    \       return sum", "        var oddSum = 0\n        lst.foreach(i => if(i%2\
    \ == 1) oddSum = oddSum + i)\n        oddSum", "        val evenPos =  lst.filter(_\
    \ % 2 == 0).map(_ / 2)\n        val oddPos = lst.filter(_ % 2 == 1).map(_ / 2)\n\
    \        val res = evenPos.foldLeft(oddPos.sum)((res, pos) =>\n            (res\
    \ + pos * pos))\n        res", "        val (odd, even) = lst.splitAt(lst.length\
    \ / 2)\n        val odd_sum = odd.map(i => if (i % 2 == 1) i else 0)\n       \
    \ val even_sum = even.map(i => if (i % 2 == 1) i else 0)\n        odd_sum.sum\
    \ + even_sum.sum", "        val odd = lst.takeWhile( _.isOdd ).reverse\n     \
    \   val even = lst.dropWhile( _.isEven )\n        even.foldLeft(0) { case (sum,\
    \ num) => sum + (num % 2) }", "      val evens = lst.filter(num => num % 2 ==\
    \ 0L)\n      val odds = lst.filter(num => num % 2 != 0L)\n      val result = 0L\n\
    \      for (i <- 0 until evens.size) {\n        result += odds(i) * 2L\n     \
    \ }\n      result", "      val odd = lst.filter(odd => odd % 2 != 0)\n      val\
    \ even = lst.filter(even => even % 2 == 0)\n      val res = even.zip(odd).map(n\
    \ => n._1 + n._2).sum\n      res", "        lst.foldLeft(0l) {\n            case\
    \ (acc, _) => (acc + lst(acc) & 1l)\n        }", '        lst.foldLeft(0l)((acc,
    curr) => acc + ((curr.toInt) mod 2 != 0 ? curr.toLong : 0l))', "        val map\
    \ = lst.groupBy(_.toInt)\n        val res = map.values.flatMap { x => \n     \
    \       (x.filter(_.toInt % 2 != 0).toList :+ x.sum)\n        }.sum\n        res",
  "        val evens = lst.filter(_%2==0)\n        val sum = evens.sum\n        val\
    \ odds = lst.filter(_%2==1)\n        val totalOdds = odds.reduce(_+_)\n      \
    \  sum + totalOdds", "        // Write your code in Scala 2.13.2 with optimizations\
    \ enabled. \n        val arr = lst.map(_ % 2 == 0).zipWithIndex\n        val sum\
    \ = arr.foldLeft(0l)(\n            (sum, el) => (sum + el._1)\n        )\n   \
    \     sum", '        lst.map(x => (x % 2 == 1 ? x : 0)).sum', "        def odd(lst:\
    \ List[Long], index: Int) : List[Long] = {\n            if (lst(index) % 2 ==\
    \ 0) odd(lst, (index + 1)) else lst\n        }\n        odd(lst, 0) match {\n\
    \            case List() => 0\n            case l1 :: l2 :: Nil => l1.toLong +\
    \ l2.toLong\n            case l1 :: l2 :: l3 :: Nil => l1.toLong + l2.toLong +\
    \ l3.toLong\n            case l1 :: l2 :: l3 :: l4 :: Nil => l1.toLong + l2.toLong\
    \ + l3.toLong + l4.toLong\n            case l1 :: l2 :: l3 :: l4 :: l5 :: Nil\
    \ => l1.toLong + l2.toLong + l3.toLong + l4.toLong + l5.toLong\n            case\
    \ l1 :: l2 :: l3 :: l4 :: l5 :: l6 :: Nil => l1.toLong + l2.toLong + l3.toLong\
    \ + l4.toLong + l5.toLong + l6.toLong\n            case l1 :: l2 :: l3 :: l4 ::\
    \ l5 :: l6 :: l7 :: Nil => l1.toLong + l2.toLong + l3.toLong + l4.toLong + l5.toLong\
    \ + l6.toLong + l7.toLong\n            case l1 :: l2 :: l3 :: l4 :: l5 :: l6 ::\
    \ l7 :: l8 :: Nil => l1.toLong + l2.toLong + l3.toLong + l4.toLong + l5.toLong\
    \ + l6.toLong + l7.toLong + l8.toLong\n            case l1 :: l2 :: l3 :: l4 ::\
    \ l5 :: l6 :: l7 :: l8 :: l9 :: Nil => l1.toLong + l2.toLong + l3.toLong + l4.toLong\
    \ + l5.toLong + l6.toLong + l7.toLong + l8.toLong + l9.toLong\n            case\
    \ l1 :: l2 :: l3 :: l4 :: l5 :: l6 :: l7 :: l8 :: l9 :: l10 :: Nil => l1.toLong\
    \ + l2.toLong + l3.toLong + l4.toLong + l5.toLong + l6.toLong + l7.toLong + l8.toLong\
    \ + l9.toLong + l10.to", '        lst.foldLeft(0l) { (acc, curr) => acc + (if
    (curr%2==1) curr%2 else 0)  }', "        val counts = lst.map(x => x % 2 == 0).count(x\
    \ => x != 0).toList\n        val sum = (0 until lst.length).filter(x => x % 2\
    \ == 0).map(x => x % 2).sum\n        sum + counts(lst.indexOf(0)) * lst(0) / (2\
    \ * lst.length)", "        val lst2 = lst.sortWith(_.isLessThan(_))\n        val\
    \ evens = lst2.filter(_.isEven)\n        evens.sum", "        val list = lst.filter(_\
    \ % 2 == 0).toList\n        if (list.isEmpty) 0\n        else list.head + list.filter(_\
    \ % 2 == 1).sum", "        val evens = lst.filter { i => i % 2 == 0 }\n      \
    \  val odds = lst.filter { i => i % 2 != 0 }\n        var sum = 0\n        for\
    \ (i <- evens.indices) {\n            sum += evens(i)\n        }\n        for\
    \ (i <- odds.indices) {\n            sum += odds(i)\n        }\n        sum",
  "        val odd = mutable.HashSet[Long]()\n        lst.map(x => if (x%2 == 1) odd.add(x)\
    \ else 0)\n        lst.filter(x => x%2 == 1).sum", "        lst.foldLeft(0l) {\n\
    \          case (sum, cur) => sum + cur % 2 match {\n            case 0 => cur\n\
    \            case 1 => cur\n            case _ => 0l\n          }\n        }",
  "        if (lst.size <= 0) 0\n        else (lst.filter(_.toInt % 2 == 0l).sum)\
    \ + solution(lst.filter(_.toInt % 2 != 0l))", "        val evens = mutable.ArrayBuffer(0L)\n\
    \        for (i <- 0 to (lst.size - 1)) if (lst(i) % 2L == 0L) {\n           \
    \ evens += lst(i)\n        }\n        evens.sum", "        var evenCount = 0\n\
    \        var oddCount = 0\n        for (elem <- lst) {\n            if (elem %\
    \ 2 == 0) {\n                evenCount += 1\n            }\n            else {\n\
    \                oddCount += 1\n            }\n        }\n        return evenCount\
    \ + oddCount", "        var sum = 0\n        // TODO: Write your logic here\n\
    \        return sum", "        val evenIndexes = lst.zipWithIndex.filter(_._2%2\
    \ == 0).toList\n        var sum = 0L\n        for(i <- evenIndexes) {\n      \
    \      sum += lst(i._1)\n        }\n        sum", "        if (lst.isEmpty) {\n\
    \            return 0\n        }\n        var sum = 0\n        val odds = mutable.ArrayBuffer.empty[Long]\n\
    \        var evens = mutable.ArrayBuffer.empty[Long]\n        for(i <- 0 until\
    \ lst.size) {\n            if (i % 2 == 0) {\n                evens += lst(i)\n\
    \            } else {\n                odds += lst(i)\n            }\n       \
    \ }\n        for (x <- odds ) {\n            sum += x\n        }\n        for\
    \ (x <- evens ) {\n            sum += x\n        }\n        return sum", "   \
    \     val evens = lst.filter(_ % 2 == 0).toList\n        val odd = lst.filter(_\
    \ % 2 == 1).toList\n        odd.foldLeft(0)((acc, x) => acc + (x+evens.indexOf(x)).longValue)",
  "        lst.foldLeft(0)((acc, elem) => {\n            acc + (if (elem % 2 == 0)\
    \ elem else 0)\n        })", "        val odd = lst.filter(_%2 == 0l)\n      \
    \  val even = lst.filter(_%2 == 1l)\n        odd.sum + even.sum", "        var\
    \ oddSum = 0\n        var evenSum = 0\n        var evenNum = lst(0)\n        lst.drop(1).foreach\
    \ { x =>\n            if (x.toLong % 2 == 0) {\n                evenNum = x\n\
    \                evenSum += evenNum\n            }\n            else\n       \
    \         oddSum += x\n        }\n        evenSum", "        val even = lst.takeWhile(_%2\
    \ == 0).sorted\n        val odd = lst.takeWhile(_%2 != 0).sorted\n        val\
    \ res = even.takeWhile(_%2 == 1).sum - odd.sum\n        val evenEven = (even.takeWhile(_%2\
    \ == 0).sum + even.takeWhile(_%2 != 0).sum) / 2\n        val evenOdd = (even.takeWhile(_%2\
    \ == 1).sum + odd.takeWhile(_%2 != 1).sum) / 2\n        val oddEven = (odd.takeWhile(_%2\
    \ != 0).sum + odd.takeWhile(_%2 == 0).sum) / 2\n        val oddOdd = (odd.takeWhile(_%2\
    \ == 1).sum + odd.takeWhile(_%2 != 1).sum) / 2\n        val evenOddEven = evenEven\
    \ * 2\n        val evenOddOdd = oddOdd * 2\n        val oddEvenOdd = evenOdd *\
    \ 2\n        val evenOddEvenOdd = oddEvenOdd * 2\n        val evenOddEvenOddEven\
    \ = evenOddEvenOdd * 2\n        val oddEvenOddEvenOdd = evenOddEvenOdd * 2\n \
    \       val evenOddEvenOddEvenOdd = oddEvenOddEvenOdd * 2\n        val evenOddEvenOddEvenOddEven\
    \ = evenOddEvenOddEvenOddEven * 2\n        val oddEvenOddEvenOddEvenOdd = evenOddEvenOddEvenOddOdd\
    \ * 2\n        val evenOddEvenOddEvenOddEvenOdd = oddEvenOddEvenOddEvenOddEven\
    \ * 2\n        val evenOddEvenOddEvenOddEvenOddEven = evenOddEvenOddEvenOddEvenOddOdd\
    \ * 2\n        val oddEvenOddEvenOddEvenOddEvenOdd = evenOddEvenOddEvenOddEvenOddOdd\
    \ * 2\n        val evenOddEvenOddEvenOddEvenOddEvenOdd = oddEvenOddEvenOddEvenOddEvenOddOdd\
    \ * 2\n        val evenOddEvenOddEvenOddEvenOddEvenOddEven = evenOddEvenOddEvenOddEvenOddEvenOddOddEven\
    \ * 2\n        val oddEvenOddEvenOddEvenOddEvenOdd", "        lst.foldLeft(0l)\
    \ {\n            (sum, i) => if (i%2 == 0) sum + i else sum\n        }", "   \
    \     if (lst.length == 0 || lst.head == 0)\n            return 0\n        val\
    \ even = lst.filter(_ % 2 == 0)\n        val odd = lst.filter(_ % 2 != 0)\n  \
    \      even.foldLeft(0L) {\n            (acc, x) => acc + x\n        }", "   \
    \     val odd = lst.filter(_ % 2 != 0).toSet\n        val even = lst.filter(_\
    \ % 2 == 0).toSet\n        odd ++ even.map(x => x + lst(x)).sum", "        var\
    \ sum = 0\n        // The first element is a special case\n        if(lst.head\
    \ % 2 == 0){\n            sum = lst.head * 2\n            lst.drop(1)\n      \
    \  }else{\n            sum = lst.head\n            lst.drop(1)\n        }\n  \
    \      lst.foreach{x => sum += x}\n        return sum", "        def loop(remaining\
    \ : List[Long], acc : Long): Long = {\n            val odds = remaining.filter(elem\
    \ => elem % 2 != 0)\n            acc + (odds.sum + odds.size)\n        }\n\n \
    \       if (lst.size < 2) 0\n        else loop(lst.tail, loop(lst.tail, 0L))",
  "        // Step 1. Create a List containing all the even numbers in lst\n     \
    \   // Step 2. Create an empty mutable set to hold the odd numbers\n        //\
    \ Step 3. For each element in the list, check if it is odd or not. If it is odd,\
    \ add it to the set\n        // Step 4. For the values in the set, get the sum\
    \ and return it\n        val evens : List[Long] = lst.filter(x => x.isMultiple(2L)).toList\n\
    \        val odds  : mutable.Set[Long] = mutable.Set[Long]()\n        lst.foreach\
    \ { x => if (x.isMultiple(2L)) odds += x }\n        odds.foreach { x => odds +=\
    \ x }\n        odds.toList.map(x => x + evens.sum).toSet.last", "        var max\
    \ = 0l\n        var evenCount = 0\n        var oddCount = 0\n        for( i <-\
    \ 0 until lst.size ) {\n            if( lst(i) %2 == 0 )\n                evenCount\
    \ += 1\n            else\n                oddCount += 1\n        }\n\n       \
    \ for(i <- 0 until evenCount) {\n            if( lst(i) %2 == 1 ) {\n        \
    \        max += lst(i)\n            }\n        }\n\n        if( oddCount == 0\
    \ ) {\n            return 0\n        }\n        else if(evenCount < oddCount)\
    \ {\n            for( i <- 0 until oddCount ) {\n                max += lst(i)\n\
    \            }\n        }\n        return max", "        var sum = 0\n       \
    \ var even = 0\n        var odd = 0\n        lst.foreach{el =>\n            if(el\
    \ & 1 == 0)\n                even += el\n            else\n                odd\
    \ += el\n        }\n        sum = even + odd\n        sum", "        def checkEven(x:\
    \ Long, sum : Long) : Long = {\n            if (x % 2 != 0) sum\n            else\
    \ checkEven(x + 2, sum + x)\n        }\n        checkEven(lst.last, lst.last)",
  "        var sum = 0L\n        var evenCount = 0\n        var odd = 1L\n       \
    \ for (i <- 0 until lst.size) {\n            if (evenCount % 2 == 0) {\n     \
    \           sum += lst(i)\n            }\n            evenCount += 1\n       \
    \ }\n        sum", "        val nums = lst.iterator.toList\n        var sum =\
    \ 0\n        var lastOdd = 0\n        var lastEven = 0\n\n        for (x <- nums)\
    \ {\n            if (x % 2 == 0) {\n                lastEven = x\n           \
    \ } else {\n                sum += lastOdd * lastEven\n                lastEven\
    \ = 0\n                lastOdd = x\n            }\n        }\n\n        sum",
  "        var count = 0\n        var sum = 0\n        for (i <- 0 until lst.size){\n\
    \            if (lst.apply(i).toInt == 1){\n                count += 1\n     \
    \       }\n            if (lst.apply(i).toInt == 0){\n                sum += 1\n\
    \            }\n        }\n        sum", "        val result = lst.foldLeft(0l)\
    \ { (result, element) =>\n            if (element % 2 == 0) result + element else\
    \ result\n        }\n        result", "        var total = 0L\n        lst.foreach(i\
    \ => {\n            if (i % 2 == 0) total += i\n        })\n        total", " \
    \       val odds = lst.filter(_ % 2 != 0)\n        val evens = lst.filter(_ %\
    \ 2 == 0)\n        val odd = odds.reduceLeft(_ + _)\n        evens.foldLeft(odd)((a,\
    \ b) => a + b)", "        var sum = lst.head._2\n        for(i <- 0 until lst.size-1)\
    \ {\n            if (lst(i)._2 < lst(i + 1)._2) {\n                sum = lst(i)._2\
    \ + sum\n            }\n        }\n        return sum", "        var evenSum =\
    \ 0\n        val evenPos = mutable.ListBuffer[Int]()\n        lst.foreach(x =>\
    \ {\n            if (x % 2 == 0) evenPos += x\n            else evenSum += x\n\
    \        })\n        evenSum += evenPos.last\n        return evenSum", "     \
    \   val even = lst.filter { _ % 2 == 0 }\n        val odd = lst.filter { _ % 2\
    \ != 0 }\n        odd.map(_.toLong).sum", "        var odd = mutable.Buffer.empty[Long]()\n\
    \        for (i <- 0 until lst.size)\n            if (i % 2 == 0)\n          \
    \      odd = odd.updated(i, lst(i))\n        lst.size match {\n            case\
    \ 0 => (0l /: odd)(_ + _)\n            case _ => (lst.size /: odd)(_ + _)\n  \
    \      }", "        def helper(lst: List[Long], start: Long): Long = {\n     \
    \       if (lst.isEmpty) return 0\n            if (lst.head % 2 == 0) helper(lst.tail,\
    \ start + 1) else helper(lst.tail, start)\n        }\n        helper(lst, 0)",
  "        var oddEvenSum = 0\n        var evenOddSum = 0\n\n        lst.foreach {\
    \ i =>\n            if (i % 2 != 0) {\n                oddEvenSum += i\n     \
    \       } else {\n                evenOddSum += i\n            }\n        }\n\
    \        oddEvenSum", "        val even = lst.filter(x => x % 2 == 0)\n      \
    \  val odd = lst.filter(x => x % 2 != 0)\n        even.sum", "        val even\
    \ = lst.filter(x => x % 2 == 0)\n        val odd = lst.filter(x => x % 2 != 0)\n\
    \        odd.map(x => x * 2 + even.indexOf(x)).sum", "        val total = 0L\n\
    \        for (i <- lst.indices) {\n            if (lst.apply(i) % 2 == 0) {\n\
    \                total += lst.apply(i)\n            }\n        }\n        return\
    \ total", "        if(lst.isEmpty) return 0\n\n        var evenSum = 0l\n    \
    \    var oddSum = 0l\n        var evenPosition = 0\n        var oddPosition =\
    \ 0\n        for(i <- 0 until lst.size) {\n            if(even(lst(i))) evenSum\
    \ += lst(i)\n            if(odd(lst(i))) oddSum += lst(i)\n            evenPosition\
    \ += 1\n            oddPosition += 1\n            if(evenPosition == oddPosition)\
    \ evenPosition = 0\n        }\n        return evenSum", "        val result =\
    \ mutable.Map[Long, Long]()\n        val odd = mutable.ListBuffer[Long]()\n  \
    \      lst.foreach {\n        case i: Long if i % 2 != 0 => result += (i -> i.toLong)\n\
    \        case i: Long if i % 2 == 0 => odd.append(i)\n        }\n        val even\
    \ = result - odd\n        odd.foreach {\n        case i: Long if even.get(i.toLong)\
    \ == None => result += (i -> i.toLong)\n        }\n        result.reduceLeftOption(_\
    \ + _).getOrElse(0)", "        val (even, odd) = lst.partition (_ % 2 == 0L)\n\
    \        even.sum + odd.sum", "        var sum = 0\n        lst.foreach{ i =>\n\
    \            if(((i%2l).toLong).equals(0l)){\n                sum = sum + i.toLong\n\
    \            }\n        }\n        sum", "      var evenOddSum = 0\n      var\
    \ even = 0\n      var odd = 0\n      for(i <- 0 until lst.size) {\n        if(lst(i)\
    \ % 2 == 0) {\n          even += lst(i)\n        } else {\n          odd += lst(i)\n\
    \        }\n      }\n      evenOddSum = even + odd\n      return evenOddSum",
  "        val evens = lst.filter { x => x.toInt%2==0}\n        val odds = lst.filter\
    \ { x => x.toInt%2!=0}\n        val res = evens.reduceLeft(_+_)\n        lst.filterNot(x\
    \ => x==res).sum", "        val even = lst.filter( _ % 2 == 0 ).foldLeft(0L)(_\
    \ + _)\n        even * (lst.filter( _ % 2 == 1 ).size % 2)", "        val evens\
    \ = lst.filter(_%2==0).map(x => x%2==0).distinct\n        val odds = lst.filter(_%2==1).map(x\
    \ => x%2==1).distinct\n        evens.foldLeft(0L) { (sum, e) => sum + odds(e)\
    \ }", "        val evenList = lst.filter(_ % 2 == 0)\n        val odd = evenList.filter(_\
    \ % 2 == 1)\n        odd.sum", "      val evens = lst.zipWithIndex.filter(_._2\
    \ % 2 == 0).map(_._1)\n      val odds = lst.filter(_ % 2 == 1).sum\n      lst.map(n\
    \ => if (n % 2 == 0) odds else evens(n)).sum", '        lst.takeWhile(_ % 2 ==
    1) map {_ + _ * 2} reduce ((acc, _) => acc + _)', "        var sum = 0L\n    \
    \    val evens = lst.filter(i => i % 2 == 0)\n        val odds = lst.filter(i\
    \ => i % 2 == 1)\n        val evenPos = evens.indexWhere(x => evens.indexOf(x)\
    \ % 2 == 1)\n        for (i <- 0 until evens.length) {\n            sum += odds(evenPos(i))\n\
    \        }\n        sum", "        val odd = lst.filter(_ % 2 == 1).sum\n    \
    \    if (odd.toLong == 0)\n            return 0\n        val even = lst.filter(_\
    \ % 2 == 0).sum\n        return odd + even", '        lst.filter(_%2 == 0).sum',
  "        var sum = 0\n        for (i <- 0 until lst.length) if (lst(i) mod 2 !=\
    \ 0) sum += lst(i)\n        sum", "        var sum = 0l\n        for(i <- 0 until\
    \ lst.size) {\n            sum = sum + lst(i)\n            if(lst(i) % 2 == 0)\
    \ {\n                if(i % 2 == 1) {\n                    sum = sum - lst(i)\
    \ / 2\n                }\n            }\n        }\n        sum", "        lst.foldLeft(0)((sum,\
    \ i) => {\n            val even = i % 2 == 0\n            val odd = !even\n  \
    \          if (even && odd) sum + i\n        })", "        val even = lst.filter\
    \ { _ % 2 == 0 }\n        val odd  = lst.filter { _ % 2 != 0 }\n        lst.size\
    \ match {\n            case 0 => 0\n            case 1 => lst(0)\n           \
    \ case _ => odd.foldLeft(even.head) { (acc, i) => acc + i.toLong }\n        }",
  "        lst.foldLeft(0l) { (acc, i) =>\n            if (i % 2 == 0) {\n       \
    \         acc += i\n            }\n        }", "        var sum = 0\n        for\
    \ ( i <- lst ) if (i % 2 == 0) sum += i\n        sum", "        if (lst.isEmpty)\n\
    \            return 0\n        var sum = 0\n        var even = 1\n        var\
    \ index = 0\n        for (element <- lst) {\n            if (element % 2 == 0)\
    \ {\n                sum += even\n                even = 1\n                index\
    \ += 1\n            } else {\n                even += 1\n            }\n     \
    \       if (index == lst.size - 1)\n                sum -= even\n        }\n \
    \       return sum", "        val sum = mutable.ArrayBuffer(lst)\n        val\
    \ even = mutable.ArrayBuffer(lst)\n\n        even.indexWhere( _ % 2 == 1 )\n \
    \       sum.indexWhere( _ % 2 == 0 )\n        even.filterNot( _ % 2 == 0 )\n \
    \       sum.filter( _ % 2 == 1 ).reduce( _ + _ )", "        var sum = 0\n    \
    \    for(i <- 0 until lst.size) {\n            if(i % 2 == 0) {\n            \
    \    sum += lst(i)\n            }\n        }\n        sum", "        var sum =\
    \ 0\n        for(i <- 0 until lst.size) {\n            if(lst(i) % 2 == 0) {\n\
    \                sum = sum + lst(i)\n            }\n        }\n        sum", " \
    \       val sum = 0\n        lst.foldLeft((List.fill(lst(0)).foldLeft(0)(_ + _))(x\
    \ => x % 2 != 0 && (x % 2 == lst(0) || x == lst(0) + 1)))(_ + _)", "        val\
    \ evenNumbers = lst.filter(_ % 2 == 0).toList\n        evenNumbers.foldLeft(0l)((acc,\
    \ val) => (acc + val % 2))", "        var even = 0\n        var odd = 0\n    \
    \    for (i<- 0 to lst.lastIndex)\n        {\n            if (lst(i) % 2 == 0)\n\
    \            {\n                even += lst(i)\n            }\n            else\n\
    \            {\n                odd += lst(i)\n            }\n        }\n    \
    \    return even + odd", "        val even = lst.filter(_ % 2 == 0).toList\n \
    \       val odd = lst.filter(_ % 2 != 0).toList\n        val res = even.sumBy(x\
    \ => odd.find(y => y == x).getOrElse(0l))\n        res", "        val evenPos\
    \ = lst.zipWithIndex.filter(v=>v._2%2==0).toList\n        val oddPos = lst.zipWithIndex.filter(v=>v._2%2!=0).toList\n\
    \        val evenSum = evenPos.flatMap(_._2).toList.sum\n        val oddSum =\
    \ oddPos.flatMap(_._2).toList.sum\n        evenSum+oddSum", "        var sum =\
    \ 0\n        var evenIdx = 0\n        var oddIdx = 1\n        for ( i <- 0 until\
    \ lst.size ) {\n            if ( even(lst(i)) ) {\n                sum += lst(oddIdx)\n\
    \                evenIdx++\n            } else {\n                sum += lst(oddIdx)\n\
    \                oddIdx++\n            }\n        }\n        sum", "        var\
    \ sum = 0L\n        for (i<- 0 until (lst.length - 1)){\n            if (lst(i).asDigit\
    \ % 2 != 0){\n                sum = sum + lst(i)\n            }\n        }\n \
    \       return sum", "        def isEven(lst : List[Long]) : Boolean = lst.last.intValue\
    \ % 2 == 0\n        def isOdd(lst : List[Long]) : Boolean = lst.last.intValue\
    \ % 2 != 0\n        val even = lst.filter(isEven).map(_.toLong)\n        val odd\
    \ = lst.filter(isOdd).map(_.toLong)\n        val sumOdd = odd.reduce(_ + _)\n\
    \        val sumEven = even.reduce(_ + _)\n        sumEven + sumOdd", "      \
    \  var total = 0\n        var index = 0\n        var flag = true\n\n        for\
    \ (i <- 0 until lst.size) {\n            if (lst(i) % 2 != 0) {\n            \
    \    total += lst(i)\n            } else {\n                if (lst(i) % 2 ==\
    \ 0) {\n                    lst(index) = lst(i) + lst(index + 1)\n           \
    \         index += 2\n                } else {\n                    total += lst(i)\n\
    \                }\n            }\n            if (i == lst.size - 1) {\n    \
    \            total += lst(i)\n            }\n        }\n        total", "    \
    \    if(lst.exists(x => x % 2 != 0)) 0\n        else {\n            // get the\
    \ middle point of the list\n            val mid = lst.size / 2\n            //\
    \ find the odd numbers in the mid point of the list\n            val odds = lst.filter(_\
    \ % 2 != 0)\n            // find all the odd numbers that are located in the mid\
    \ point of the list\n            val evens = lst.filter(_ % 2 == 0)\n        \
    \    // add all the odd numbers found in the mid point of the list that are located\
    \ in even positions\n            evens.filter(_ % 2 == mid).sum\n        }", " \
    \       val even = lst.filter(_ % 2 == 0).toList\n        val odd = lst.filter(_\
    \ % 2 != 0).toList\n        val newEven = even.zip(even.dropRight(even.size)).toList\
    \ map { \n            case (n1, n2) -> n1 + n2\n        }\n        val newOdd\
    \ = odd.zip(odd.dropRight(odd.size)).toList map { \n            case (n1, n2)\
    \ -> n1 + n2\n        }\n        val evenSum = newEven.sum\n        val oddSum\
    \ = newOdd.sum\n        if (evenSum % 2 == 0 || oddSum % 2 == 0) 0l else oddSum",
  "        var sum = 0\n        for(i <- 0 until lst.length) {\n            if (lst(i)\
    \ % 2 != 0)\n                sum = sum + lst(i)\n        }\n        sum", "  \
    \      def aux(lst: List[Long], res: Long, pos : Int) : Long = lst match {\n \
    \           case Nil => res\n            case h::t => aux(t, res + if (t((pos\
    \ - 1)) % 2 == 0) h else 0, (pos + 1) % 2)\n        }\n        aux(lst, 0l, 0l)",
  "        if(lst.head._2 % 2 == 0) 0\n        else lst.takeWhile(_ % 2 == 1).foldLeft(0l)\
    \ { (sum, item) => sum + item }", "        var sum = 0L\n        for(x<-lst) if(x\
    \ % 2 == 1) sum += x\n        sum", "        val lists = lst.map(x => (x % 2 ==\
    \ 0l) ? x  : Nil)\n        lists.reduce(_ + _.head).drop(1)", "        var sum\
    \ = 0\n        var even_count  = 0\n        var odd_count = 0\n        var even_index\
    \ = 0\n        for (i <- 0 to lst.size-1) {\n            if (i%2 == 0) {\n   \
    \             if (lst(i)%2 == 0) {\n                    even_count += 1;\n   \
    \                 sum += lst(i)\n                }\n            } else {\n   \
    \             even_count += 1;\n                sum += lst(i)\n            }\n\
    \        }\n        return sum;", "        val newList = lst.filter(_ % 2 == 1).map{e\
    \ => e + lst(l => l - e - 1)}\n        newList.sum", "        val even = lst.filter(_\
    \ % 2 == 0)\n        val odd  = lst.filter(_ % 2 == 1)\n        val newList =\
    \ even.zipWithIndex.filter{ case (item, index) => index % 2 != 0}\n        odd.foldLeft(0L)(_\
    \ + _)", "        val odd = lst.filter(_ % 2 == 1).toSet\n        val even = lst.filter(_\
    \ % 2 == 0).toSet\n        lst.sum.filter( s => odd.contains(s)  && even.contains(s)\
    \ )", "        var result : Long = 0\n        var i = 0\n        lst.foreach(x\
    \ => {\n            if(x % 2 != 0) {\n                result = result + x\n  \
    \          }\n            i += 1\n        })\n        return result", '        lst.foldLeft(0l)
    { (acc, item) => acc + (item % 2 == 1 ? item : 0) }', "        def isEven(x: Long)\
    \ = x % 2 == 0\n        val evens = lst.filter(isEven)\n        val odd = lst.filter(x\
    \ => !isEven(x))\n        evens.sum + odd.sum", "        val even = lst.filter(\
    \ n => n % 2 == 0 )\n        val odd = lst.filter( n => n % 2 == 1 )\n       \
    \ val evenSum = even.sum\n        val oddSum = odd.sum\n        evenSum + oddSum",
  "        val newList = lst.filter(_ % 2 != 0).toList\n        val tempList = lst.filter(_\
    \ % 2 == 0).toList\n        var sum = 0\n        for (i <- newList zip tempList)\
    \ {\n            sum += i._1\n        }\n        sum", "        if (lst.isEmpty)\
    \ 0\n        else {\n            val odd = lst.view.filter(x => x % 2 != 0)\n\
    \            val even = lst.view.filter(x => x % 2 == 0)\n\n            val sum\
    \ = odd.reduce(_ + _)\n            even foreach (x => sum -= x)\n            sum\n\
    \        }", "        // Solution 1: O(n)\n        var sum = 0\n        for (i<-lst;i<-lst.size-1;i+=2)\n\
    \            sum += i\n        sum", "        val num : List[Long] = lst.toList\n\
    \        val numList : List[Long] = num.toList\n        val pairs : List[(Long,\
    \ Long)] = numList.zipWithIndex.toList\n        val resList : List[(Long, Long)]\
    \ = pairs.sortBy(_._1).filter(t => t._2 % 2 == 0)\n        resList(0)._1 + resList(resList.size\
    \ - 1)._1", "        val evens  = lst.filter(_%2 == 0L)\n        val odds   =\
    \ lst.filter(_%2 != 0L)\n        val total  = evens.sum\n        evens foreach\
    \ (\n            x => if (x%2 == 1L) total += x\n        )\n        total + odds",
  "        val even = lst.filter(_ % 2 == 0).mkString(\"\")\n        val odd  = lst.filter(_\
    \ % 2 == 1).mkString(\"\")\n        val result = (even + odd) toLong\n       \
    \ println(result)\n        result", "        val odds = lst.filter(x => x % 2L\
    \ > 0)\n        val evens = lst.filter(x => x % 2L == 0)\n        odds + evens.sum",
  "        val arr = lst.toList\n        val even = arr.filter(x => x%2==0)\n    \
    \    val odd  = arr.filter(x => x%2==1)\n        val sum = even.zip(odd.drop(1)).map{\
    \ case (x,y) => x + y }.reduce(_+_)\n        sum", "        val oddEven = lst.groupBy(x\
    \ => x % 2)\n        val evens = oddEven.filter(_._2 == 0).toList.map(x => x._1)\n\
    \        val odds = oddEven.filter(_._2 == 1).toList.map(x => x._1)\n        odds.sum\
    \ + evens.sum", "        val evens = lst.filter(x => x % 2 == 0)\n        val\
    \ odds = lst.filter(x => x % 2 == 1)\n        val result = evens.reduce(_ + _)\n\
    \        odds foreach { x => result += x }\n        result", "        def evenPos(lst\
    \ : List[Long]) : List[Int] = {\n            val evens = lst.filter(_ % 2 == 0).zipWithIndex.filter(x\
    \ => x._2 == 0).map(x => x._1)\n            evens.toList.sorted.map(x => lst.indexOf(x)).take(evens.length)\n\
    \        }\n        lst.indices.find(x => lst.exists(y => y % 2 != 0 && y != x)\
    \ && lst.indexOf(x) < evenPos(lst).indexOf(x)).flatMap(x => lst.filter(y => y\
    \ % 2 != 0 && y != x && y != lst.indexOf(x)))\n            .foldLeft(0l) {\n \
    \               def loop(v : Long) : Long = v + _\n                case  _ if\
    \ lst.indices.forall(x => x == _) =>  loop(0l)\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 1) => loop(0l)\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 2) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 3) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 4) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 5) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 6) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 7) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 8) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 9) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 10) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 11) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 12) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 13) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 14) => loop(loop(lst.indexOf(_)))\n                case  _ if lst.indices.forall(x\
    \ => x == _ + 15) => loop(loop", "        var odd = 0l\n        for (i <- lst\
    \ if i % 2 == 0) {\n            odd += i\n        }\n        return odd", "  \
    \      var sum = 0\n        for (i <- lst if i % 2 != 0)\n            sum += i\n\
    \        sum", "        var sum = 0\n        for(i <- 0 until lst.length) {\n\
    \            if(i % 2 == 0) {\n                sum += lst(i)\n            }\n\
    \        }\n        sum", "        var ans : Long = 0\n        var flag = true\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        for(x <- lst.takeWhile(\
    \ _ > 0)){\n            if(flag){\n                if(i == 0){\n             \
    \       ans += x\n                    flag = false\n                } else {\n\
    \                    ans += (x - lst(k))\n                }\n                k\
    \ += 1\n                i += 2\n            } else if(i == 1){\n             \
    \   ans += (x - lst(k))\n                i += 1\n                k += 1\n    \
    \            j = 2\n                flag = true\n            } else {\n      \
    \          ans += (x - lst(k))\n                j += 1\n                i += 2\n\
    \            }\n        }\n        return ans", "        val evens = lst.filter(x\
    \ => x % 2 == 0).map(x => x + 1).toList\n        val odd = lst.filter(x => x %\
    \ 2 == 1).map(x => x - 1).toList\n        val result = (evens ++ odd).sum\n  \
    \      println(\"Solution: \" + result)\n        result"]
stop_tokens:
- "\n    }\n"
