name: HumanEval_59_largest_prime_factor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  \    // >>> largestPrimeFactor((13195l))\n    // (29l)\n    // >>> largestPrimeFactor((2048l))\n\
  \    // (2l)\n    def largestPrimeFactor(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestPrimeFactor((15l))\
  \ == (5l));\n    assert(largestPrimeFactor((27l)) == (3l));\n    assert(largestPrimeFactor((63l))\
  \ == (7l));\n    assert(largestPrimeFactor((330l)) == (11l));\n    assert(largestPrimeFactor((13195l))\
  \ == (29l));\n    }\n\n}\n"
completions: ["        val factors = mutable.ListBuffer[(Long, Long)]()\n        for\
    \ (d <- 2 to n by 2) {\n            if (n % d == 0) {\n                factors\
    \ += (d, n / d)\n            }\n        }\n        factors.maxBy(_._1)._1", " \
    \       val p = new mutable.PriorityQueue[Long]\n        p.enqueue(n)\n      \
    \  var factor = 1L\n        while (p.length > 0) {\n            val nt = p.dequeue()\n\
    \            factor *= nt\n            while (factor < nt && p.contains(factor))\
    \ {\n                p.enqueue(factor)\n                factor *= nt\n       \
    \     }\n        }\n        factor", "        var maxFactor = BigInt(2l) \n  \
    \      var numFactors = 1 \n        for (num <- 2 to n by 2) {\n            if\
    \ (n % num == 0) {\n                numFactors = numFactors * num\n          \
    \      if (numFactors > maxFactor) {\n                    maxFactor = numFactors\n\
    \                }\n            }\n        }\n        maxFactor", "        val\
    \ isPrime = isPrime(n)\n        if(isPrime(n)) {\n            return n\n     \
    \   }\n        var maxPrime = BigInt(2)\n        for(i <- 3 until n / 2 ; if(isPrime(i))\
    \ {\n            maxPrime <- maxPrime + 1\n            }\n        )\n        \n\
    \        if(n % maxPrime > 0) {\n            largestPrimeFactor(n / maxPrime)\n\
    \        } else {\n            maxPrime\n        }", "        // 1- Create a mutable\
    \ Set[Long] to hold all the prime factors\n        val factors = mutable.Set.empty[Long]\n\
    \        // 2- For n = 2, add the prime factor\n        factors += 2\n       \
    \ // 3- Check if n is even, add 2 and it's factors\n        if(n % 2 == 0) {\n\
    \            factors += 2\n            factors += n / 2\n        }\n        //\
    \ 4- For n = 4, 7 and 13, 13, remove 2 and it's factors\n        else if(n % 4\
    \ == 0 && n % 7 == 0 && n % 13 == 0) {\n            factors += 2\n        }\n\
    \        // 5- For n = 5, 11, 17, 23, 29, 31 and 35: remove 2, 3, 5, 7 and it's\
    \ factors\n        else if(n % 5 == 0 && n % 11 == 0 && n % 17 == 0 && n % 23\
    \ == 0 && n % 29 == 0 && n % 31 == 0 && n % 35 == 0) {\n            factors +=\
    \ 2\n            factors += 3 // 5, 7, 11\n        }\n        // 6- For n = 6,\
    \ 11, 17, 23, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97: remove\
    \ 2, 3, 5, 7, 11, 13, 17, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97\n        else if(n % 6 == 0 && n % 11 == 0 && n % 17 == 0 && n % 23 ==\
    \ 0 && n % 31 == 0 && n % 37 == 0 && n % 41 == 0 && n % 43 == 0 && n % 47 == 0\
    \ && n % 53 == 0 && n % 59 == 0 && n % 61 == 0 && n % 67 == 0 && n % 71 == 0 &&\
    \ n % 73 == 0 && n % 79 == 0 && n % 83 == 0 && n % 89 == 0 && n % 97 == 0) {\n\
    \            factors += 2\n            factors += 3 // 5, 7, 11, 13, 17, 31, 37,\
    \ 43, 47, 53, 59, 61, 67, 73, 79\n        }\n        // 7- For n = 8, 11, 17,\
    \ 27, 37, 47, 53, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,\
    \ 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,\
    \ 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\
    \ 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\
    \ 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479", "        val\
    \ factors = new mutable.MutableList[Int]()\n        def largestPrimeFactorLoop(n:\
    \ Long, factors: List[Int]): Boolean = {\n            if( n <= 1 ) true\n    \
    \        else if ( isPrime(n) ) factors ::= n\n            else {\n          \
    \      for( factor <- 2 until n ) if( n % factor == 0 ) factors ::= factor\n \
    \               if( !largestPrimeFactorLoop(n / factor, factors) ) true\n    \
    \            else {\n                    factors ::= n\n                    false\n\
    \                }\n            }\n        }\n        largestPrimeFactorLoop(n,\
    \ factors)\n        factors.max", "        val divisors = (2 to n) filter isPrime\
    \ reverse\n        val largestPrime = divisors.max\n        n/largestPrime", " \
    \       var primesFactors = Set[Long]()\n        var largestPrimeFactor = 1\n\
    \        var factorsCount = 1\n        for(factor <- n until 1 by 2){\n      \
    \      val isPrime = factor.forall(i => i % factor == 0)\n            if(!isPrime){\n\
    \                primesFactors += factor\n                factorsCount += 1\n\
    \                if(factorsCount > largestPrimeFactor){\n                    largestPrimeFactor\
    \ = factorsCount\n                }\n            }\n        }\n        largestPrimeFactor",
  "        if (n.isPrime)\n            return n\n        if (n.toLong == 1) return\
    \ n\n        val isPrime = n.isPrime\n        if (isPrime)\n            if (n\
    \ % 2 == 0)\n                largestPrimeFactor(sqrt(n.toInt))\n            else\n\
    \                largestPrimeFactor(sqrt(n.toInt) + 1)\n        else\n       \
    \     largestPrimeFactor(sqrt(n) / 2)", "        val primes = mutable.ListBuffer[(Long,\
    \ Int)]()\n        for(i <- 2 to (n/2))\n            if((n % i) == 0)\n      \
    \          primes += (i->1)\n        for(i <- primes)\n            if(i._2 > n)\n\
    \                return(i)", "        val isPrime = (1l) :: Nil\n        val isNotPrime\
    \ = Set(2l).filter(_ > n).toSeq.filterNot(isPrime)\n        var nextPrime = n\
    \ // 2\n        var largestPrime = 0\n        var largestPrimeFactor = 0\n   \
    \     while (!isPrime.contains(nextPrime)) {\n            isPrime -- nextPrime\n\
    \            largestPrime += 1\n            largestPrimeFactor = nextPrime\n \
    \           isNotPrime.find(_ > largestPrimeFactor) match {\n                case\
    \ Some(_) =>\n                    nextPrime += 1\n                case None =>\n\
    \                    largestPrimeFactor = largestPrime - 1\n            }\n  \
    \      }\n        largestPrimeFactor", "        if (n == 1) n\n        val limit\
    \ = BigInt(sqrt(n)) // limit = Math.sqrt(n)\n        var max = (2l) // first largest\
    \ prime factor\n        // iterate through numbers above limit\n        for (i\
    \ <- 2l to limit -1) {\n            // if n is divisible by i, it can not be prime\n\
    \            if (n % i == 0) {\n                // check if n is larger than the\
    \ largest prime factor\n                if (n > max) {\n                    max\
    \ = i\n                }\n            }\n        }\n        // return largest\
    \ prime factor\n        max", "        def isPrime(i: Long) = (2 until Math.sqrt(i))\
    \ exists (i => i % _ == 0)\n        def next(i: Long) = { val m = i + 2; if (m\
    \ > n) m else m }\n        (2 until n) collect {\n            case i if isPrime(i)\
    \ => i\n            case i => next(i)\n        }.max", "        var max = n\n\
    \        var i = 2\n        while (i <= n / 2) {\n            if (n % i == 0)\
    \ {\n                max = i\n            }\n            i += 1\n        }\n \
    \       max", "        val limit = n / 2\n        val primes = mutable.Set.empty[Long]\n\
    \        val isPrime = mutable.Set.unordered\n        while (limit.nonEmpty &&\
    \ !isPrime.contains(limit)) {\n            isPrime ++= factors(limit).filter(x\
    \ => x.nonEmpty && isPrime.contains(x))\n            primes ++= factors(limit).filter(x\
    \ => x.nonEmpty && !isPrime.contains(x))\n        }\n        isPrime.last", " \
    \       val factors = mutable.ListBuffer[Long]()\n        // factors is mutable\
    \ so you can add to it\n        for(i <- 2 to n/2) {\n            // you only\
    \ need to check numbers that are factors\n            // and less than or equal\
    \ to n\n            if(n % i == 0 && n / i != 1) {\n                factors +=\
    \ i\n            }\n        }\n        factors.max", "        val isPrime = List\
    \ (2,3,5,7,11,13,17,19,23,29).contains(n%_)\n        if (isPrime) {\n        \
    \    return n\n        } else {\n            var maxFactor : Long = n - 1;\n \
    \           var newMax : Long = n - 1;\n            var prime = true;\n      \
    \      var factor : Long = 1;\n            var factor : Long = 1;\n          \
    \  var factor : Long = 1;\n            var factor : Long = 1;\n            var\
    \ factor : Long = 1;\n            var factor : Long = 1;\n            var factor\
    \ : Long = 1;\n            var factor : Long = 1;\n            var factor : Long\
    \ = 1;\n            var factor : Long = 1;\n            var factor : Long = 1;\n\
    \            var factor : Long = 1;\n            var factor : Long = 1;\n    \
    \        var factor : Long = 1;\n            var factor : Long = 1;\n        \
    \    var factor : Long = 1;\n            var factor : Long = 1;\n            var\
    \ factor : Long = 1;\n            var factor : Long = 1;\n            var factor\
    \ : Long = 1;\n            var factor : Long = 1;\n            var factor : Long\
    \ = 1;\n            var factor : Long = 1;\n            var factor : Long = 1;\n\
    \            var factor : Long = 1;\n            var factor : Long = 1;\n    \
    \        var factor : Long = 1;\n            var factor : Long = 1;\n        \
    \    var factor : Long = 1;\n            var factor : Long = 1;\n            var\
    \ factor : Long = 1;\n            var factor : Long = 1;\n            var factor\
    \ : Long = 1;\n            var factor : Long = 1;\n            var factor : Long\
    \ = 1;\n            var factor : Long = 1;\n            var factor : Long = 1;\n\
    \            var factor : Long = 1;\n            var factor : Long = 1;\n    \
    \        var factor : Long = 1;\n            var factor : Long = 1;\n        \
    \    var factor : Long = 1;\n            var factor : Long = 1;\n            var\
    \ factor : Long = 1;\n            var factor : Long = 1;\n            var factor\
    \ : Long = 1;\n            var factor : Long = 1;\n            var factor : Long\
    \ = 1;\n            var factor : Long = 1;\n            var factor : Long = 1;\n\
    \            var factor : Long = 1;\n            var factor : Long = 1;\n    \
    \        var factor : Long = 1;\n            var factor : Long = 1;\n        \
    \    var factor : Long = 1;\n            var factor : Long = 1;\n            var\
    \ factor : Long = 1;\n            var factor : Long = 1;\n            var factor\
    \ : Long = 1;\n            var factor : Long = 1;\n            var factor : Long\
    \ = 1;\n            var factor : Long = 1;\n            var factor : Long = 1;\n\
    \            var factor : Long = 1;\n            var factor : Long = 1;\n    \
    \        var factor : Long = 1;\n            var factor : Long = 1;\n        \
    \    var factor : Long = 1;\n            var factor : Long = 1;\n            var\
    \ factor : Long = 1;\n            var factor : Long = 1;\n            var factor\
    \ : Long = 1;\n            var factor : Long = 1;\n            var factor : Long\
    \ = 1;\n            var factor : Long = 1;\n            var factor : Long", " \
    \       var i : Long = 0\n        var max : Long = 0\n        while (i<n && max<n)\
    \ {\n            max = n\n            while (n >= 2) {\n                if ((n%2)==0)\
    \ {\n                    n = (n/2)\n                }\n                else {\n\
    \                    n = 3*(n+1)\n                }\n                max = max\
    \ if (max<n)\n            }\n            i = i+1\n        }\n        max", " \
    \       var max = Long.MinValue\n        var i = 2\n        while (i <= n / 2)\
    \ {\n            if ((n % i) == 0) {\n                max = Math.max(max, i)\n\
    \                n = n / i\n            }\n            else {\n              \
    \  i = i + 1\n            }\n        }\n        return max", "        if (n ==\
    \ 1) return 1\n        var max = 1\n        var maxIndex = 0\n        var remaining\
    \ = n\n        while (n % 2 == 0) {\n            remaining = remaining / 2\n \
    \       }\n        var i = 2\n        while (i <= Math.sqrt(remaining)) {\n  \
    \          if (remaining % i == 0) {\n                max = Math.max(max, i)\n\
    \                maxIndex = i\n            }\n            i = i + 1\n        }\n\
    \        if (max == maxIndex) {\n            return max\n        }\n        return\
    \ maxIndex", "        def isPrime(x: Long) : Boolean = {\n            (x%2 !=\
    \ 0) && {\n                val m = x/2\n                for (d <- 2 to x/2) if\
    \ (m%d == 0) return false\n                true\n            }\n        }\n\n\
    \        if (n == 1) n\n        else n match {\n            case p if isPrime(p)\
    \ => p\n            case x if (isPrime(x) || isPrime(x - 2)) => largestPrimeFactor(x/2)\
    \ + 2\n            case x if (isPrime(x) || isPrime(x - 2)) => largestPrimeFactor(x/2)\
    \ + 1\n            case x => largestPrimeFactor(x - 1)\n        }", "        //\
    \ TODO: Implement this function\n        val factors = new collection.mutable.ArrayBuilder[Long]()\n\
    \        var isPrime = true\n        var current = 2L\n        while (isPrime)\
    \ {\n            while (n % current == 0) {\n                factors += current\n\
    \                n /= current\n            }\n            current += 1\n     \
    \   }\n        factors.toList.last", "        if (n < 2) 1\n        else if (n\
    \ % 2 == 0) largestPrimeFactor(n / 2l) \n        else if (n % 3 == 0) largestPrimeFactor(n\
    \ / 3l) \n        else if (n % 5 == 0) largestPrimeFactor(n / 5l) \n        else\
    \ largestPrimeFactor(n / 7l) ", "        var lf : Long = 1\n        var max :\
    \ Long = n/2\n        while (max != 1){\n            lf = lf * 2\n           \
    \ if (n % lf == 0) max = n/lf\n        }\n        lf", "        var largestPrimeFactor\
    \ : Long = 1l\n        var flag : Boolean = false\n        var divider : Long\
    \ = 1l\n        for(divider <- 2l*n until (n+1l*n)){\n            if(n % divider\
    \ == 0){\n                if(divider > largestPrimeFactor){\n                \
    \    largestPrimeFactor = divider\n                    flag = true\n         \
    \       }\n            }\n        }\n        if(flag){\n            largestPrimeFactor\
    \ = n\n        }\n        return largestPrimeFactor", "        var result : Long\
    \ = 1\n        var factor = 1\n        while (n != 1) {\n            while (n\
    \ % factor == 0) {\n                n /= factor\n                result += 1\n\
    \            }\n            factor += 1\n        }\n        result", "       val\
    \ factors = primeFactors(n)\n       val largest = factors.last\n       if(largest\
    \ > 1) largest\n       else largestPrimeFactor(factors.dropRight(1).last)", " \
    \       // Find the largest factor of n.\n        var maxFactor = scala.math.BigInt(0)\n\
    \        // Find all factors up to sqrt(n).\n        var factors = scala.collection.mutable.ListBuffer[scala.math.BigInt]()\n\
    \        for (i <- scala.math.BigInt(2) until n / scala.math.BigInt(i)) {\n  \
    \          if (n % i == 0) {\n                factors.append(i)\n            \
    \    if (i / maxFactor < factors.max) {\n                    maxFactor = i / maxFactor\n\
    \                }\n            }\n        }\n        // Return the largest factor\
    \ of n. Assume n > 1 and is not a prime.\n        // This may be different than\
    \ n! / n!\n        maxFactor", "        if (n == 1) return n\n        val factors\
    \ = collection.mutable.ListBuffer(2)\n        var i = 2\n        while (i < n\
    \ / 2) {\n            if (n % i == 0) {\n                factors += i\n      \
    \          n /= i\n            }\n            i += 1\n        }\n        factors.reduceLeft((a,\
    \ b) => math.max(math.max(a, b), n % a)) ", "        if (n == 1) 1\n        else\
    \ if (n % 2 == 0) largestPrimeFactor(n / 2)\n        else if (n % 3 == 0) largestPrimeFactor(n\
    \ / 3)\n        else if (n % 5 == 0) largestPrimeFactor(n / 5)\n        else n\
    \ % 5", "        val n = n\n        val p = 2l\n        val r = n.toInt\n    \
    \    while (p < r / 2) {\n            val m = (p * p + p) / 2\n            if\
    \ (n % m == 0l) {\n                p = m\n            } else {\n             \
    \   p = p + 1\n            }\n        }\n        p", "        val isPrime = n\
    \ <= 2l\n        var largest = 1l\n        var remainder = 0l\n        var i =\
    \ 1l\n        while (i < n && isPrime) {\n            remainder = (n % i)\n  \
    \          if (remainder == 0l) {\n                isPrime = false\n         \
    \   } else {\n                largest *= i\n                remainder *= i % 2l\n\
    \            }\n            i += 1\n        }\n        if (largest.compareTo(n)\
    \ < 0)\n            largest\n        else\n            largest * largestPrimeFactor(largest)",
  "        var max = 1\n        var maxprime = 1\n        while (n > 0) {\n      \
    \      if (n % maxprime == 0) {\n                max = Math.max(max, maxprime\
    \ + 1);\n            }\n            else {\n                maxprime += 1;\n \
    \           }\n            n /= maxprime\n        }\n        max", "        val\
    \ factors = mutable.ListBuffer[Long]()\n        var lastFactor = 1\n        while\
    \ (n > 1) {\n            if (n % lastFactor == 0) {\n                n /= lastFactor\n\
    \                factors += lastFactor\n            }\n            else {\n  \
    \              lastFactor = lastFactor * 2\n            }\n        }\n       \
    \ lastFactor", "        var primeFactor = 2 \n        var isPrime = true\n   \
    \     for (i = 2; i < sqrt(n); i += 1) {\n            if (n % i == 0) {\n    \
    \            isPrime = false\n                break\n            }\n        }\n\
    \        if (isPrime) {\n            var factors = Vector.empty[Long]\n      \
    \      while (n * factors.last <= n) {\n                factors = factors :+ n\n\
    \                n /= primeFactor\n            }\n            factors.last\n \
    \       } else {\n            1\n        }", "        val largestPrimeFactor:\
    \ Long = 2 // assume n > 1 and is not a prime\n        for( n <- 2 to n by -1)\
    \ if(n % largestPrimeFactor == 0) largestPrimeFactor = n\n        largestPrimeFactor",
  "        val largestPrime = 1\n        var i = 2\n        val l = primeFactors(n).size\n\
    \        while(i < l && !isPrime(i) && i < largestPrime) {\n            i += 1\n\
    \        }\n        if(i >= l) largestPrime\n        else primeFactors(n).size",
  "        val factors = mutable.ListBuffer[Long]()\n        for(i <- 2 to n)\n  \
    \          if(!(i%n)) { factors += i; break }\n        factors.toList.sortWith(_\
    \ < _).last", "        var largestPrimeFactor : Long = 1\n        var primeFactor\
    \ : Long = primeFactorization(n)\n        for (i <- primeFactor) {\n         \
    \   if (n % i == 0) {\n                largestPrimeFactor = i\n            }\n\
    \        }\n        return largestPrimeFactor", "        val results = (0 to (n/2-1)).filter(x\
    \ => n % x == 0)\n        results.max", "        var max_ = 2\n        var prime\
    \ = 1\n        while (prime < n && n % prime == 0) {\n            if (max_ < prime)\
    \ {\n                max_ = prime\n            }\n            prime += 1\n   \
    \     }\n        max_", "        for (x <- 2 to sqrt(n)) {\n            if (n\
    \ % x == 0) {\n                val remainder = n % x\n                largestPrimeFactor(x)\
    \ // Recurse on x with x reduced modulo remainder\n            }\n        }\n\
    \        n", "        val i = 2\n        while(i < n && isPrime(i)) i += 2\n \
    \       i", "        // Step 1: Create a set S with factors of n.\n        //\
    \ We will iterate over all prime factors of n\n        val S = n / 2l\n      \
    \  var count = 0\n        // Step 2: Check if the set S has more than one element\n\
    \        while (S.size < 2l) {\n            // Step 3: If so, stop the loop\n\
    \            if (S.size < 2l) {\n                count = 0\n            } else\
    \ {\n                // Step 4: Otherwise, stop the loop, since S is composite.\n\
    \                count = 0\n            }\n            // Step 5: Add count to\
    \ the running maximum.\n            count += 1\n            // Step 6: Remove\
    \ all factors of n from S\n            S = S filter (n / _ != _)\n        }\n\
    \        // Step 7: Return the running maximum.\n        n", "        val factors\
    \ = mutable.Set()\n        while (n > 1) {\n            if (factors.contains(n))\
    \ {\n                n -= 1\n            } else {\n                factors +=\
    \ n\n            }\n        }\n        factors.last", "        // Factor the number.\n\
    \        val factors = mutable.ArrayBuffer.empty[Long]\n        var i = 2l\n \
    \       while(i < n) factors += i\n        // Find the largest prime factor of\
    \ n.\n        var largest_prime_factor : Long = 0l\n        var largest_prime_factor\
    \ : Long = 0l\n        for (i<-factors) if(factors.contains(i)) largest_prime_factor\
    \ = i\n        return largest_prime_factor", "        var factors: mutable.Set[Long]\
    \ = new mutable.HashSet[Long]\n        var max: Long = n / 2\n\n        while\
    \ (n % 2 == 0) {\n            n = n / 2\n            factors += 2\n        }\n\
    \n        while (n != 1) {\n            if (factors.contains(n)) {\n         \
    \       max = n\n            } else {\n                while (n % 2 == 0) {\n\
    \                    n = n / 2\n                    factors += 2\n           \
    \     }\n\n                if (factors.contains(n)) {\n                    factors\
    \ += n\n                }\n\n                factors -= n\n            }\n   \
    \     }\n\n        max - 1", "        var max: Long = 1\n        var maxPrimeFactor:\
    \ Long = 1\n        var primeFactors: List[Long] = Nil\n        while (n >= 2)\
    \ {\n            var primeFactor = n / 2\n            if (primeFactors.isEmpty)\
    \ {\n                primeFactors = List(primeFactor)\n            } else {\n\
    \                for (factor <- primeFactors) {\n                    if (factor\
    \ < primeFactor) {\n                        break\n                    }\n   \
    \                 if (n % factor == 0) {\n                        primeFactors\
    \ = List(primeFactor)\n                        break\n                    }\n\
    \                }\n            }\n            val newMax = primeFactors.foldLeft(max)((max,\
    \ primeFactor) => math.max(primeFactor, max))\n            if (newMax == max)\
    \ {\n                max = newMax\n            } else {\n                max =\
    \ newMax\n                maxPrimeFactor = primeFactors.foldLeft(max)((max, primeFactor)\
    \ => math.max(primeFactor, max))\n            }\n        }\n        if (maxPrimeFactor\
    \ > 1) {\n            maxPrimeFactor\n        } else {\n            max\n    \
    \    }", "        var maxFactor = 1l\n        var candidate = 2l\n        while\
    \ (candidate <= n) {\n            if (n % candidate == 0) {\n                maxFactor\
    \ = candidate\n            }\n            candidate += 1l\n        }\n       \
    \ return maxFactor", "        var factors = mutable.Set[Long]()\n        factors\
    \ += 2l\n        factors += 3l\n        factors += 5l\n        factors += 7l\n\
    \        factors += 11l\n        factors += 13l\n        factors += 17l\n    \
    \    factors += 19l\n        factors += 23l\n        factors += 29l\n        factors\
    \ += 31l\n        factors += 37l\n        factors += 41l\n        factors += 43l\n\
    \        factors += 47l\n        factors += 53l\n        factors += 59l\n    \
    \    factors += 61l\n        factors += 67l\n        factors += 71l\n        factors\
    \ += 73l\n        factors += 79l\n        factors += 83l\n        factors += 89l\n\
    \        factors += 97l\n        factors += 101l\n        factors += 103l\n  \
    \      factors += 107l\n        factors += 109l\n        factors += 113l\n   \
    \     factors += 127l\n        factors += 131l\n        factors += 137l\n    \
    \    factors += 139l\n        factors += 149l\n        factors += 151l\n     \
    \   factors += 157l\n        factors += 163l\n        factors += 167l\n      \
    \  factors += 173l\n        factors += 179l\n        factors += 181l\n       \
    \ factors += 191l\n        factors += 197l\n        factors += 199l\n        factors\
    \ += 211l\n        factors += 223l\n        factors += 227l\n        factors +=\
    \ 229l\n        factors += 233l\n        factors += 239l\n        factors += 241l\n\
    \        factors += 247l\n        factors += 249l\n        factors += 251l\n \
    \       factors += 263l\n        factors += 269l\n        factors += 271l\n  \
    \      factors += 277l\n        factors += 281l\n        factors += 283l\n   \
    \     factors += 293l\n        factors += 307l\n        factors += 311l\n    \
    \    factors += 313l\n        factors += 317l\n        factors += 331l\n     \
    \   factors += 337l\n        factors += 347l\n        factors += 349l\n      \
    \  factors += 353l\n        factors += 359l\n        factors += 367l\n       \
    \ factors += 371l\n        factors += 379l\n        factors += 383l\n        factors\
    \ += 389l\n        factors += 395l\n        factors += 401l\n        factors +=\
    \ 409l\n        factor", "        val primes = Vector.tabulate(n)(i => (i.toInt))\n\
    \        for (prime <- primes.filter { p => n % prime == 0 }) {\n            n\
    \ /= prime\n        }\n        n", "        val arr = ArrayBuffer(2)\n       \
    \ var x = 2\n        while(n/x > 1) {\n            arr += x\n            n /=\
    \ x\n            x += 1\n        }\n        arr.reverse.last", "        var max\
    \ : Long = n / 2\n        var i : Long = 2\n\n        // Skip even numbers\n \
    \       while ( n % i == 0) {\n            max = i\n            i +:= 2\n    \
    \    }\n        max", "        var largestPrimeFactor = 0\n        var currentPrime\
    \ = 1\n\n        while (n > 1) {\n            while (n % currentPrime == 0) {\n\
    \                largestPrimeFactor = currentPrime\n                n /= currentPrime\n\
    \            }\n            currentPrime += 1\n        }\n        largestPrimeFactor",
  "        // This code is not optimized and was written to make the code readable\n\
    \        // and understandable by humans.\n        val primes          = scala.collection.mutable.Set[Long]()\n\
    \        val counter         = scala.collection.mutable.Set[Long]()\n\n      \
    \  var isPrime                    = false\n\n        // We loop from 2 to the\
    \ square root of n\n        for (i <- 2 to scala.math.sqrt(n)) {\n           \
    \ // We loop from 2 to the square root of i\n            for (j <- 2 to scala.math.sqrt(i))\
    \ {\n                if (i % j == 0) {\n                    isPrime = false\n\
    \                }\n                else {\n                    isPrime = true\n\
    \                    primes += i\n                }\n            }\n         \
    \   if (isPrime == true) {\n                counter += i\n            }\n    \
    \    }\n\n        // We loop from 2 to the square root of n\n        for (i <-\
    \ 2 to scala.math.sqrt(n)) {\n            // We loop from 2 to the square root\
    \ of i\n            for (j <- 2 to scala.math.sqrt(i)) {\n                if (j\
    \ % primes.contains(i) == 0) {\n                    counter.remove(i)\n      \
    \          }\n            }\n        }\n\n        counter.max", "        val primes\
    \ = Array(2, 3)\n        val largestPrime = primes.dropWhile(_ < n)\n        if\
    \ (largestPrime.length < 2)\n            largestPrime(0)\n        else\n     \
    \       largestPrime(0)", "        for (i <- 2 until math.ceil(n/2)) {\n     \
    \       if (n % i == 0)\n                n /= i\n            else {\n        \
    \        while (n%i == 0)\n                    n /= i\n                if (n ==\
    \ 1) return i\n            }\n        }\n        n", "        // PrimeFactors(n)\
    \ = n / primeFactors(n)\n        // primeFactors(n) = (n / 2) * 2^(k-1)\n    \
    \    // k = floor(log(n) / log(2))\n        // n = 2^k * n\n        // n = 4^k\
    \ * n\n        // n = 2^k * 4^k * n\n        // ...\n        // n = 2^k * 4^k\
    \ * ... * n\n        // n = 2^(k+1) * 4^k * n\n        // n = 2^(k+1) * 4^(k+1)\
    \ * n\n        // n = 2^(k+2) * ... * n\n        // n = 2^(k+2) * ... * (n/4)\n\
    \        // n = 2^(k+2) * ... * (n/4)\n        // n = 2^(k+2) * ... * (n/4)\n\
    \        // (k/4)^(k+1) * ... * n\n        // (k/4)^(k+1) * ... * n\n        //\
    \ (k/4)^(k+1) * ... * n\n        // (k/4)^(k+2) * ... * n/4\n        // (k/4)^(k+2)\
    \ * ... * n/4\n        // (k/4)^(k+2) * ... * n/4\n        // (k/4)^(k+2) * ...\
    \ * n/4\n        // (k/4)^(k+2) * ... * n/4\n        // (k/4)^(k+2) * ... * n/4\n\
    \        // (k/4)^(k+2) * ... * n/4\n        // (k/4)^(k+2) * ... * n/4\n    \
    \    // (k/4)^(k+3) * ... * n/4\n        // ...\n        // (k-1) * ... * n/4\n\
    \        // (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n        // (k-1)\
    \ * ... * n/4\n        // (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n  \
    \      // (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n        // (k-1) *\
    \ ... * n/4\n        // (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n    \
    \    // (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n        // (k-1) * ...\
    \ * n/4\n        // (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n        //\
    \ (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n        // (k-1) * ... * n/4\n\
    \        // (k-1) * ... * n/4\n        // (k-1) * ... * n/", "        // Prime\
    \ Factors stores the largest factor seen for each number.\n        // The array\
    \ is indexed by n, and its values are the highest factors.\n        var factors\
    \ = mutable.ArrayBuffer.empty[Long]\n        for{i <- 2 to n/2 by 2}\n       \
    \     if(n%i==0)\n                factors += i\n        // Iterate over the array\
    \ and keep the largest.\n        for{i <- factors}\n            if(i>n)\n    \
    \            factors -= i\n        // Return the last factor.\n        factors(factors.length-1)",
  "        val factors = new mutable.HashSet[Long]\n        for (i <- 2 to n/2){\n\
    \            if (n % i == 0){\n                factors.add(i)\n            }\n\
    \        }\n        if (factors.isEmpty) n\n        else largestPrimeFactor(factors.max)",
  "        var factors = mutable.Set[Long]()\n        factors.add(n)\n        var\
    \ p = 2\n        while (p < n) {\n            if (factors.contains(p : Long))\
    \ {\n                factors.remove(p : Long)\n            } else {\n        \
    \        p += 1\n            }\n        }\n        factors.last", "        val\
    \ p = new mutable.PriorityQueue[Long]\n        var f = 1l\n        for (i <- 2l\
    \ until n by 2l) {\n            if (n % i == 0l && p ne i) {\n               \
    \ p.enqueue(i)\n                f = i\n            }\n        }\n        f.toLong",
  "        var largestPrimeFactor = BigInt(0)\n        while(n > 1) {\n          \
    \  n -= 1\n            val primeFactor = BigInt(n).sqrt\n            largestPrimeFactor\
    \ = if (primeFactor > largestPrimeFactor) primeFactor else largestPrimeFactor\n\
    \        }\n        largestPrimeFactor", "        var max = 2\n        while(max\
    \ < n && n % max == 0) {\n            max += 1\n        }\n        max", "   \
    \     // Solve this problem by looking at all the primes up to n.\n        //\
    \ We store all the primes we find in a mutable data structure.\n        // We\
    \ start by storing 2 in our data structure.\n        var primesArray = mutable.ArrayBuilder.make[Long](26).initialValue(1)\n\
    \        primesArray += 2\n        // We also store the largest prime factor of\
    \ n in an additional data structure.\n        // We start by storing a candidate\
    \ prime of n in our data structure.\n        var candidate = mutable.ArrayBuilder.make[Long](26).initialValue(n).clear()\n\
    \        candidate.add(i)\n        // We repeatedly try to divide our candidate\
    \ by each of the primes we found up to n.\n        // If we find a prime that\
    \ divides our candidate then we record that number in our data structure.\n  \
    \      // We keep dividing our candidate while there are still primes left in\
    \ the data structure.\n        // If a prime divides our candidate then we record\
    \ the largest prime factor of our candidate in our data structure.\n        //\
    \ Otherwise we continue dividing our candidate by our remaining primes.\n    \
    \    while(candidate.length > 0) {\n            var largestPrime = candidate.head\n\
    \            var index = largestPrime\n            var prime = primesArray.head\n\
    \            for(i <- 1 to primesArray.length-1) {\n                val nextLargestPrime\
    \ = primesArray(i)\n                if(candidate % nextLargestPrime == 0) {\n\
    \                    index = nextLargestPrime\n                    largestPrime\
    \ = nextLargestPrime\n                    prime = i\n                }\n     \
    \       }\n            candidate.remove(candidate.indexOf(largestPrime))\n   \
    \         candidate.add(largestPrime)\n            primesArray += prime\n    \
    \    }\n        return primesArray.length - 1", "        val a = 2l\n        var\
    \ b : Long = 0\n        while (b < n) {\n            if (n % a == 0) {\n     \
    \           b = b + a // found a factor\n                n = n / a // make n even\n\
    \            }\n            a = a + 1l\n        }\n        if (n > 2l) n\n   \
    \     else 2l", "        val d = n / 2 // floor of n\n        val a = Array(2,\
    \ 3)\n        var p = 2\n        val c = 2\n        while (c < d) {\n        \
    \    if (d * p <= n) p = p * c\n            else {\n                if (p > a(p))\
    \ p := p * a(p)\n                c := c + 1 // double c\n            }\n     \
    \   }\n        p", "        var p = 2\n        while(p < n/2) {\n            if\
    \ (n % p == 0) p = p + 2\n            else if (n % p == 1) p = p + 1\n       \
    \     else n = n/p\n        }\n        n", "        val a = BigInt(n)\n      \
    \  val a2 = a.abs % 2\n        var i = 0\n        var i2 = 2\n        var factor\
    \ = 2\n        var factor2 = 2\n        var factor3 = 2\n        while (i <= a2)\
    \ {\n            val c = (2 * i) + i2\n            if (a2 % c == 0) {\n      \
    \          while (c % factor3 == 0) {\n                    factor += 1\n     \
    \               factor3 += 1\n                }\n                while (a2 % factor2\
    \ == 0) {\n                    factor2 += 1\n                }\n             \
    \   if (factor > factor2 && factor > factor3) {\n                    factor =\
    \ factor2\n                    i2 = i\n                } else {\n            \
    \        factor = factor3\n                    i2 = c\n                }\n   \
    \         }\n            i += 1\n        }\n        return factor", "        var\
    \ factor = 1\n        var candidate = 2\n        while (n > 1) {\n           \
    \ while (n%candidate == 0) {\n                factor += 1\n                candidate\
    \ *= 2\n            }\n            n /= candidate\n        }\n        factor",
  "        var largestPrime = 0\n        var factor = 2\n        // for each prime\
    \ > 2\n        for( i = 3 ; i * i <= n ; i += 1 ){\n            if( n % i == 0\
    \ ){\n                // if i is prime\n                if( i > largestPrime ){\n\
    \                    // and i is greater than the largest prime found, update\n\
    \                    largestPrime = i\n                    factor = 1\n      \
    \          }else{\n                    // otherwise keep looking for smaller factors.\n\
    \                    factor += 1\n                }\n            }\n        }\n\
    \        // return largest prime factor\n        largestPrime", "        val primes\
    \ = mutable.ArrayBuffer.empty[Long]\n        for (i <- 2 to n by 2)\n        \
    \    if (n % i == 0)\n                primes.append(i)\n        val largestPrime\
    \ = primes.max\n        if (largestPrime == n)\n            largestPrime\n   \
    \     else\n            largestPrimeFactor(largestPrime)", "        val sieve\
    \ = makeSieve(n)\n        def isPrime(n: Long) : Boolean =\n            sieve(n)\
    \ || (n > 1 && n <= (n / 2))\n        val ps = takeWhile { n =>\n            if\
    \ (isPrime(n)) Some(n) else None\n        }.maxBy(_.toString().length)\n     \
    \   val primeFactors = ps.toString.split(\"\\\\.\").map(_.toInt)\n        val\
    \ i = primeFactors.length\n        if (i > 1 && primeFactors(i - 1) == 2) primeFactors(i\
    \ - 2)\n        else ps.toString.substring(1)", "        val maxFactors  = mutable.ArrayBuffer.empty[Long]\n\
    \        val candidates = mutable.ArrayBuffer.empty[Long]\n        val isPrime\
    \     = mutable.ArrayBuffer.empty[Boolean]\n        val nPrime      = mutable.ArrayBuffer.empty[Long]\n\
    \n        // Prime candidates\n        for (nPrimeVal <- 1 to n.toInt by 2) {\n\
    \            isPrime += (nPrimeVal.toLong == n)\n            nPrime += nPrimeVal\n\
    \        }\n        // Prime candidates, skipping squares of primes\n        for\
    \ (nPrimeVal <- nPrime.dropWhile(x => x != nPrimeVal / nPrimeVal - 1).takeWhile(x\
    \ => x != nPrimeVal)) {\n            candidates += nPrimeVal\n        }\n    \
    \    // Factors\n        for (candidate <- candidates.distinct) {\n          \
    \  if (n % candidate == 0) {\n                maxFactors += candidate\n      \
    \      }\n        }\n        // Sieve of Eratosthenes\n        for (i <- maxFactors.indices)\
    \ {\n            if (isPrime(i)) {\n                isPrime += (false)\n     \
    \       } else {\n                isPrime += (!isPrime(i))\n            }\n  \
    \      }\n\n        // Return largest prime factor if no factors present\n   \
    \     if (isPrime.nonEmpty || maxFactors.isEmpty) {\n            return maxFactors.max\n\
    \        } else {\n            return n\n        }", "        // We will check\
    \ numbers in [2 ... n]\n        // If a number divides evenly into a prime, we\
    \ keep it\n        // If not, the prime factor must be less than or equal to its\
    \ square root.\n        // Thus we will check [2 ... sqrt(n)]\n        var factor\
    \ = 2\n        var lower = 2\n        var upper = math.sqrt(n)\n        while\
    \ (upper > lower) {\n            if (n % lower == 0) {\n                factor\
    \ *= lower\n                n /= lower\n            }\n            lower += 1\n\
    \            upper += lower\n        }\n        factor", "        val factors\
    \ = new mutable.HashSet[Long]()\n        for (x <- 2 to n)\n            if (n%x\
    \ == 0)\n                factors.add(x)\n            if (factors.size > 1)\n \
    \               factors.last\n            else\n                n", "        var\
    \ i = 2\n        var max = n\n        while (i <= n / 2) {\n            if (n\
    \ % i == 0) {\n                max = n / i\n                i = i + 1\n      \
    \      }\n        }\n        return max", "        val d = Math.sqrt(n)\n    \
    \    var factor = 2\n        while (factor < d) {\n            if (n % factor\
    \ == 0) {\n                return factor\n            } else {\n             \
    \   factor++\n            }\n        }\n        return factor", "        val factors\
    \ = mutable.ListBuffer[Long]()\n        var i = 3\n        while (i <= n && n\
    \ % i != 0) {\n            factors += i\n            i += 2\n        }\n     \
    \   factors.reverse", "        var largestPrimeFactor = n // largest prime factor\n\
    \        var n = n - 1\n        while (n >= 2) {\n            if (n % 2 == 0)\
    \ largestPrimeFactor = largestPrimeFactor * 2\n            largestPrimeFactor\
    \ = largestPrimeFactor + 1\n            n = n / 2\n        }\n        if (n >\
    \ 1) largestPrimeFactor = largestPrimeFactor * 2\n        return largestPrimeFactor",
  "        val res = new mutable.ArrayBuffer[Long]()\n        for (i <- 2 to n.toInt\
    \ by 2) {\n            val j = (n * i).toLong\n            if (isPrime(j))\n \
    \               res += i\n            if (res.length == 1) return res.head\n \
    \       }\n        throw new Exception(\"No prime factor found!\")", "       \
    \ val candidates = Set(2L) ++ (2 to sqrt(n).toInt)\n        for (d <- candidates)\
    \ {\n            if (n % d == 0) return d\n        }\n        n", "        val\
    \ s = BigInt(n) // s = n\n        var maxFactor = 1\n        var i = 2\n     \
    \   while(i <= sqrt(s)) {\n            if(s % i == 0) {\n                maxFactor\
    \ = i + 1\n            }\n            i += 1\n        }\n        maxFactor", " \
    \       if (n == 1l) 1l\n        else if (n == 2l) 2l\n        else if (n % 2l\
    \ == 0l) largestPrimeFactor(n/3l) * 3l\n        else if (n % 3l == 0l) largestPrimeFactor(n/3l)\
    \ * 3l + largestPrimeFactor(n/3l) * 3l\n        else largestPrimeFactor(n/3l)\
    \ * 3l + largestPrimeFactor(n/3l) * 3l + largestPrimeFactor(n/3l) * 3l", "   \
    \     var m = 2\n        var factors  = scala.collection.mutable.Set[Long]()\n\
    \        while (!n rem m == 0) {\n            m += 2\n            n /= m\n   \
    \         factors += m\n        }\n        factors.max", "        // This should\
    \ help you get started\n        if (n == 2) return n\n        // Start with 3,\
    \ and go up until you find a factor > n.\n        // This should help you get\
    \ started\n        if (n == 3) return n\n        val factors = mutable.HashSet[Long]()\n\
    \        // If n is a factor of 2, return it right away.\n        if (n / 2 %\
    \ 2 == 0) return n / 2\n        factors += 2\n        // If n is prime or even,\
    \ we can stop here and just return n.\n        if (n % 2 == 0 || n == 2) return\
    \ n\n        // Otherwise keep going until we find something > n.\n        while\
    \ (true) {\n            val next = n\n            // Check if n has a prime factor\
    \ in it.\n            while (next % 2 == 0) next /= 2\n            while (next\
    \ % 3 == 0) next /= 3\n            if (next == 1) return n\n            factors\
    \ += next\n            // If we have not returned our number yet, n must be prime,\n\
    \            // so return it.\n            if (n != next) return n\n        }",
  "        val primes = List(2, 3)\n        val twos = List(2, 3, 5)\n        var\
    \ max = 2\n        var count = 0\n        while (max < n) {\n            for (prime\
    \ <- primes) {\n                if (n % prime == 0) {\n                    val\
    \ testN = n / prime\n                    val testMax = max / prime\n         \
    \           if (testMax == testN) {\n                        if (testMax > max)\
    \ {\n                            max = testMax\n                        }\n  \
    \                      prime = prime\n                        count = count +\
    \ 1\n                        val newTestN = testN\n                        while\
    \ (newTestN != 1) {\n                            newTestN = newTestN * 2\n   \
    \                     }\n                    }\n                }\n          \
    \  }\n            for (two <- twos) {\n                if (n % two == 0) {\n \
    \                   val testN = n / two\n                    val testMax = max\
    \ / two\n                    if (testMax == testN) {\n                       \
    \ if (testMax > max) {\n                            max = testMax\n          \
    \              }\n                        two = two\n                        count\
    \ = count + 1\n                        val newTestN = testN\n                \
    \        while (newTestN != 1) {\n                            newTestN = newTestN\
    \ * 2\n                        }\n                    }\n                }\n \
    \           }\n            if (count == 0) {\n                max = n\n      \
    \      }\n        }\n        max + 1", "        var result : Long = BigInt(n)\n\
    \        var isPrime : Boolean = true\n        var largestPrime : Long = 1l\n\
    \        var i : Long = 2l\n        while (i < n && !isPrime) {\n            if\
    \ (n % i == 0L) {\n                isPrime = false\n            }\n          \
    \  i += 2l\n        }\n        if (isPrime) {\n            result = n\n      \
    \  } else {\n            val start = n\n            var isLargerPrime = true\n\
    \            var isLargerDivisor = true\n            while (!isLargerPrime) {\n\
    \                largestPrime = i\n                isLargerPrime = false\n   \
    \             for (i = 2l; i <= start; i += 1) {\n                    if (n %\
    \ i == 0L) {\n                        isLargerPrime = true\n                 \
    \   }\n                    if (isLargerPrime && i % largestPrime == 0L) {\n  \
    \                      isLargerDivisor = true\n                        break\n\
    \                    }\n                }\n                i += 1\n          \
    \  }\n            if (isLargerDivisor) {\n                result = n\n       \
    \     } else {\n                val primes = scala.collection.mutable.Set[Long]()\n\
    \                var primeCount : Long = 0\n                var divisorCount :\
    \ Long = 0\n                var primeDivisor : Long = 1l\n                var\
    \ divisorDivisor : Long = 1l\n                while (!primes.contains(n)) {\n\
    \                    if (n / primeDivisor == 0L) {\n                        primes.add(n)\n\
    \                        primeCount += 1\n                    }\n            \
    \        if (n / divisorDivisor == 0L) {\n                        divisors.add(n)\n\
    \                        divisorCount += 1\n                    }\n          \
    \          primeDivisor += 1\n                    divisorDivisor += 1\n      \
    \          }\n                if (primeCount > divisorCount) {\n             \
    \       result = primes.last\n                } else {\n                    result\
    \ = divisors.last\n                }\n            }\n        }\n        result",
  "        val primes = Array.fill(n)(2)\n        primes(0) = 1\n        primes(1)\
    \ = 2\n        val max = scala.math.sqrtDouble(n)\n        var k = 1\n       \
    \ while (primes(k) < max) {\n            if (n % primes(k) == 0) {\n         \
    \       primes(k) = primes(k + 1) % max\n                if (primes(k) == 1) primes(k)\
    \ = 2\n            }\n            k += 1\n        }\n        primes(k)", "   \
    \     val factorsMutex = new Mutex[List[Long]]()\n        def largestPrimeFactorImpl(n\
    \ : Long) : Long = {\n            val factors = new ListBuffer[Long]()\n     \
    \       var i = 3\n            while(i <= n) {\n                while(n % i ==\
    \ 0) {\n                    factors += i\n                    n /= i\n       \
    \         }\n                i += 1\n            }\n            factorsMutex.synchronized\
    \ {\n                factors match {\n                    case h :: Nil => h\n\
    \                    case h :: t => {\n                        factorsMutex.synchronized\
    \ {\n                            factors = factors.filter(_ % h != 0)\n      \
    \                  }\n                        largestPrimeFactorImpl(t * h)\n\
    \                    }\n                }\n            }\n        }\n        largestPrimeFactorImpl(n)",
  "        val factors = mutable.ArrayBuffer(2)\n        while (n>1) {\n         \
    \   if (n % 2 == 0)\n                n /= 2\n            else {\n            \
    \    if (n%3 == 0)\n                    n /= 3\n                else {\n     \
    \               if (n%5 == 0)\n                        n /= 5\n              \
    \      else {\n                        if (n%7 == 0)\n                       \
    \     n /= 7\n                        else {\n                            if (n%11\
    \ == 0)\n                                n /= 11\n                           \
    \ else {\n                                if (n%13 == 0)\n                   \
    \                 n /= 13\n                                else {\n          \
    \                          if (n%17 == 0)\n                                  \
    \      n /= 17\n                                    else {\n                 \
    \                       if (n%19 == 0)\n                                     \
    \       n /= 19\n                                        else\n              \
    \                              n -= 1\n                                    }\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \          factors += n\n        }\n        factors.last", "        for (i <-\
    \ 2 to n by 2) {\n            if (n % i == 0) {\n                return i\n  \
    \          }\n        }\n        return n", "        if (n < 1) throw new Exception(\"\
    Argument must be positive\")\n        n match {\n            case 1 => return\
    \ n\n            case _ => {\n                // Check all odd numbers below n\n\
    \                var sq : Int = n.toInt / 2\n                var max : Long =\
    \ 1\n                var prime : Long = n.toInt\n                var prime : Int\
    \ = 2\n                var prime : Long = n.toInt\n                while (sq >\
    \ 1) {\n                    prime = prime + 2\n                    if (prime >\
    \ sq) prime = prime - sq\n                    if (prime * prime > sq) prime =\
    \ prime + sq\n                    if (prime * prime > sq) prime = prime + sq\n\
    \                    if (prime * prime > sq) prime = prime + sq\n            \
    \        if (prime * prime > sq) prime = prime + sq\n                    if (prime\
    \ * prime > sq) prime = prime + sq\n                    if (prime * prime > sq)\
    \ prime = prime + sq\n                    if (prime * prime > sq) prime = prime\
    \ + sq\n                    if (prime * prime > sq) prime = prime + sq\n     \
    \               if (prime * prime > sq) prime = prime + sq\n                 \
    \   if (prime * prime > sq) prime = prime + sq\n                    if (prime\
    \ * prime > sq) prime = prime + sq\n                    if (prime * prime > sq)\
    \ prime = prime + sq\n                    if (prime * prime > sq) prime = prime\
    \ + sq\n                    if (prime * prime > sq) prime = prime + sq\n     \
    \               if (prime * prime > sq) prime = prime + sq\n                 \
    \   if (prime * prime > sq) prime = prime + sq\n                    if (prime\
    \ * prime > sq) prime = prime + sq\n                    if (prime * prime > sq)\
    \ prime = prime + sq\n                    if (prime * prime > sq) prime = prime\
    \ + sq\n                    if (prime * prime > sq) prime = prime + sq\n     \
    \               if (prime * prime > sq) prime = prime + sq\n                 \
    \   if (prime * prime > sq) prime = prime + sq\n                    if (prime\
    \ * prime > sq) prime = prime + sq\n                    if (prime * prime > sq)\
    \ prime = prime + sq\n                    if (prime * prime > sq) prime = prime\
    \ + sq\n                    if (prime * prime > sq) prime = prime + sq\n     \
    \               if (prime * prime > sq) prime = prime + sq\n                 \
    \   if (prime * prime > sq) prime = prime + sq\n                    if (prime\
    \ * prime > sq) prime = prime + sq\n                    if (prime * prime > sq)\
    \ prime = prime + sq\n                    if (prime * prime > sq) prime = prime\
    \ + sq\n                    if (prime * prime > sq) prime = ", "        // Write\
    \ your code here.\n        if(n < 2) return n\n        var i = 3\n        while(i\
    \ != n / 2) {\n            i += 2\n        }\n        if(n > 2) largestPrimeFactor(i\
    \ - 2)\n        else i", "        val m = (2 to n).min\n        val r = 2\n  \
    \      var m2 = m\n        while (m2 <= n) m2 = m * m\n        var i = 2\n   \
    \     val factors = new mutable.ArrayList[Long]()\n        while (i <= m2) {\n\
    \            if (n % i == 0) {\n                n /= i\n                factors\
    \ += i\n            }\n            i += 1\n        }\n        val largest_factor\
    \ = factors.max\n        if (n % largest_factor == 0) {\n            n /= largest_factor\n\
    \        }\n        n", "        val candidates = Seq(2l, n%2l)\n        val primes\
    \ = candidates.filter{ x =>\n            (x*x)<=n && (x%2l!=0l)\n        }\n \
    \       primes.max", "        var bigPrime = BigInt(1)\n        var smallPrime\
    \ = BigInt(2)\n        var count = 0\n        var largestPrime = 0L\n        var\
    \ smallestPrime = 1L\n        var isPrime = true\n        while (n >= 2) {\n \
    \           val temp = BigInt(n)\n            if (temp == 1)\n               \
    \ count +=1\n            else {\n                while (count != 0 && temp % largestPrime\
    \ == 0) {\n                    count -= 1\n                    largestPrime =\
    \ largestPrime * smallPrime\n                }\n                val temp = BigInt(n)\n\
    \                isPrime = temp % largestPrime == 0\n                if (isPrime)\
    \ {\n                    while (count != 0 && temp % smallestPrime == 0) {\n \
    \                       count -= 1\n                        smallestPrime = smallestPrime\
    \ * smallPrime\n                    }\n                    val temp = BigInt(n)\n\
    \                    isPrime = temp % smallestPrime == 0\n                   \
    \ if (isPrime)\n                        largestPrime = largestPrime * temp\n \
    \                   else\n                        largestPrime = largestPrime\
    \ * (smallestPrime + 1)\n                }\n            }\n            bigPrime\
    \ = bigPrime * smallPrime\n            smallPrime = smallPrime * 2\n        }\n\
    \        largestPrime", "        val candidates = 2L until math.sqrt(n) + 1L\n\
    \        val primes = Array(2, 3, 5)\n        var largest = 0L\n        for (candidate\
    \ <- candidates) {\n            for (prime <- primes) {\n                if (n%candidate\
    \ == 0L && n%prime == 0L) {\n                    largest = max(largest, candidate\
    \ / prime)\n                }\n            }\n        }\n        largest", " \
    \       val factors = mutable.ListBuffer[Long]()\n        for(i <- n to 2 by -1)\
    \ {\n            if (n % i == 0) {\n                factors += i\n           \
    \ }\n        }\n        val max = factors.max\n        if (max != 1) {\n     \
    \       max - 1\n        } else {\n            n\n        }", "        val m =\
    \ BigInt(n).divide(BigInt(2))\n        val i = BigInt(2).sqrt(m)\n        if (i\
    \ == 1) return m\n        if (i == m) largestPrimeFactor(m) else m", "       \
    \ val a = 3\n        val b = 2\n        val c = 2\n        var i = 0\n       \
    \ while (i <= Math.sqrt(n)) {\n            var k = n\n            var p = a\n\
    \            var q = b\n            var r = c\n            while ((k % p) == 0)\
    \ {\n                k /= p\n                q++\n            }\n            while\
    \ ((k % r) == 0) {\n                k /= r\n                r++\n            }\n\
    \            if (p > q) {\n                a = p\n                p = q\n    \
    \            q = r\n                r = c\n                c = 1\n           \
    \ } else {\n                b = p\n                p = r\n                r =\
    \ q\n                q = c\n                c = 1\n            }\n           \
    \ i += 1\n        }\n        if (n > 1) c\n        else n", "        val largestPrime\
    \ = math.max(n % 2,\n            math.min(n,\n                math.ceil(math.sqrt(n)\
    \ / 2.0)))\n        largestPrime", "        var maxPrime = 1\n        var lastFactor\
    \ = 2\n        for(i <- 2 until n){\n            if(n%i == 0){\n             \
    \   maxPrime = i\n                lastFactor = i\n            }\n        }\n \
    \       return maxPrime", "        var max: Long = 1\n        for (i <- 2 to n)\n\
    \            if (n % i == 0)\n                if (max % i == 0)\n            \
    \        max = i\n        if (max < n)\n            max = n\n        return max",
  "        var largestPrimeFactor = BigInt(BigInt(n).divide(BigInt(2)).floor)\n  \
    \      var i = 2\n        while (i < largestPrimeFactor) {\n            if (BigInt(BigInt(n).divide(i).floor)\
    \ == BigInt(i)) {\n                return i\n            }\n            i += 1\n\
    \        }\n        return largestPrimeFactor", "        val primes = List(2,\
    \ 3, 5)\n        var largest = 1\n        var maxLargest = 1\n\n        for(p\
    \ <- primes) {\n            val p = n%(p ^ 2)\n\n            if(p > largest) {\n\
    \                largest = p\n                maxLargest = largest\n         \
    \   }\n        }\n\n        return maxLargest", "        val ps = new mutable.HashSet[Long]()\n\
    \        def isPrime(p: Long) : Boolean = \n            ps.contains(p) || { for\
    \ (i <- 2 to p) if (!(p%i == 0) && (ps.contains(i) || isPrime(i))) ; true }\n\
    \        def isPrimeOrFactor(p: Long) : Boolean = isPrime(p)\n        for (p <-\
    \ 2 to n; if isPrime(p)) ps += p\n        largestPrime = ps.max", "        val\
    \ p = 1 // prime number\n        var d = 1 // dividend\n        while(p < n){\n\
    \            d = n % p\n            if(d == 0 || d == p || d < n / p)\n      \
    \          return p\n            p = p + 1\n        }\n        return n", "  \
    \      val primes = Vector.fill(n / 2l) { 2l }\n        val factors = Vector.fill(n\
    \ / 2l) {0l}\n        val max = 1l\n        for (i = 0 to n/2l) {\n          \
    \  val factor = (n - i) / i\n            val test = (if (i > 2l) 2l else 1l) *\
    \ factor\n            if (primes(test) == factor) {\n                factors(test)\
    \ += 1l\n                if (factors(test) > max) max = factors(test)\n      \
    \      }\n        }\n        max", "        val primes = List (2, 3l, n)\n   \
    \     var largestPrimeFactor = primes.head\n        var factor = 1\n        while\
    \ ((factor * primes.last) != n){\n            for (prime <- primes){\n       \
    \         if (n%prime == 0){\n                    largestPrimeFactor = prime\n\
    \                    factor = 1\n                    break\n                }\n\
    \                factor++\n            }\n        }\n        largestPrimeFactor",
  "        if (n == 1) {\n            return 1\n        }\n        var i = 2\n   \
    \     while (n % i == 0) {\n            i += 1\n        }\n        return i",
  "        var factor = 2\n        var prime = 1\n        var i = 2\n        while(i\
    \ != n / factor){\n            factor = i\n            while(i != factor){\n \
    \               if(n % i == 0){\n                    prime = 0\n             \
    \       break\n                }\n                i = i + 1\n            }\n \
    \           if(prime == 1)\n                break\n        }\n        factor",
  "        def isPrime(i : Int) : Boolean = i.toInt == 1\n        def nextPrime(i:\
    \ Int) : Int = if (isPrime(i)) i else (i + 1)\n        def makePrimes(n: Int)\
    \ : List[Int] = 0 until n filter isPrime map (i => nextPrime(i)).toList\n    \
    \    val l = makePrimes(n.toInt)\n        l.max match {\n            case None\
    \ => n\n            case Some(x) => x // 2\n        }", "        val factors =\
    \ Vector.empty[Long]\n        val limit = n / 2\n        while(limit>1){\n   \
    \         if(n % limit == 0){\n                factors = factors ++ Set(limit)\n\
    \            }\n            limit = limit/2\n        }\n        factors.lastOption.getOrElse(999999L)",
  "        val limit = n / 2\n        var factor = 1l\n        var primeFactor = limit\n\
    \        while (primeFactor <= limit) {\n            if (n % primeFactor == 0)\
    \ {\n                factor += primeFactor\n                n /= primeFactor\n\
    \                primeFactor = limit\n            } else {\n                primeFactor\
    \ *= 2\n            }\n        }\n        factor", "        val r = primeFactors(n)\n\
    \        r.maxBy(_._1)", "        var maxFactor = 1\n        var candidate = 2\n\
    \n        while ((n % candidate) == 0) {\n            maxFactor = candidate\n\
    \            candidate += 1\n        }\n\n        maxFactor", "        val p =\
    \ (2l).until(n)\n        var largestPrimeFactor = Long.MinValue\n        for(prime\
    \ <- p) {\n            if (n % prime == 0) {\n                largestPrimeFactor\
    \ = prime\n                break\n            }\n        }\n        largestPrimeFactor",
  "        var max = 2\n        val factors = mutable.Set[Long]()\n        for(prime\
    \ <- 2 to n){\n            factors += prime\n            while(factors.contains(max)){\n\
    \                max += 1\n            }\n        }\n        max", "        val\
    \ sq = n.toInt\n        val sqSqrt = sqrt(sq)\n        val a = 2l\n        var\
    \ b = 3l\n        var c = 5l\n        var maxPrime = 0l\n        while (sq !=\
    \ 0l) {\n            while (sq % a == 0 && sq % b == 0 && sq % c == 0) {\n   \
    \             if (b == sqSqrt)\n                    break\n                c =\
    \ b\n                b += 1l\n            }\n            if (b != sqSqrt && sq\
    \ % b == 0) {\n                a = c\n                b += 1l\n            }\n\
    \            if (b != sqSqrt && sq % c == 0)\n                c = b\n        \
    \    sq /= a\n            maxPrime = maxPrime + 1l\n        }\n        maxPrime",
  "        // If n is less than or equal to 1, return n\n        if (n <= 1) {\n \
    \           return n\n        }\n        val factors = mutable.Set[Long]()\n \
    \       // Create a set of factors from 2 to sqrt(n)\n        for(factor = 2;\
    \ factor < sqrt(n); factor++)\n            if (n % factor == 0) {\n          \
    \      factors += factor\n            }\n        // If n is prime then any factor\
    \ of n has a divisor\n        if (factors.isEmpty) {\n            return n\n \
    \       }\n        // Return the largest prime factor of n\n        val largest\
    \ = factors.max\n        factors.clear()\n        return largest", "        var\
    \ max: Long = n - 1\n        var factor: Long = 1\n        var c: Long = 1\n \
    \       while (max % 2 == 0) {\n            max /= 2\n            factor += 1\n\
    \        }\n        var i: Long = 1\n        while (i <= max) {\n            c\
    \ = max\n            while ((c * i) <= n) {\n                c /= i\n        \
    \        factor += 1\n            }\n            i += 1\n            max /= i\n\
    \        }\n        factor", "        if (n < 2)\n            return n\n\n   \
    \     var max : Long = 1\n        var factor : Long = 1\n        var i : Long\
    \ = 1\n        var isPrime : Boolean = false\n        var num : Long = 1\n\n \
    \       while (!isPrime) {\n            isPrime = true\n            while (i <=\
    \ num) {\n                val j = (i + num) /  (2 * factor)\n                i\
    \ += 1\n                if (j * factor <= n)\n                    isPrime = false\n\
    \            }\n            i += 1\n            num += 1\n\n            if (isPrime)\n\
    \                max = factor\n            factor = factor * 2\n        }\n  \
    \      max", "        val sieve = new mutable.Array[Int](62)\n        var l =\
    \ n\n        val primes = mutable.ArraySeq.unchecked_fill(63, 0)\n        while\
    \ (primes.length < 63 && primes.last != l) {\n            var j = 7\n        \
    \    while (j < primes.length && primes(j) <= l) {\n                sieve(j) =\
    \ if (l % primes(j) == 0) j else sieve(j)\n                j += 7\n          \
    \  }\n        }\n        val max = sieve(63)\n        val i = sieve(64)\n    \
    \    while (i != 63) {\n            val p = sieve(i)\n            if (p > max)\
    \ max = p\n            i = sieve(i + 1)\n        }\n        max", "        if\
    \ (n < 2) 2\n        else if(n % 2 == 0) 3\n        else { \n            val sq\
    \ = math.sqrt n\n            val a = 2\n            val b = 2\n            while(sq\
    \ % b != 0) {\n                a += 1\n                b += 1\n            }\n\
    \            for(i <- 1 to a) {\n                if(n%i == 0) {\n            \
    \        n = n/i\n                    break\n                }\n            }\n\
    \            n\n        }", "        var factors = mutable.ArraySeq[Long]()\n\
    \        var largest = Long.MinValue\n        while (n > 0) {\n            //\
    \ test if n is a prime\n            factors += n\n            largest = max(largest,\
    \ n)\n            n -= 1\n        }\n        factors.last", "        val arr =\
    \ List(n/2, n/3, n/5, n/7)\n        val factors = mutable.Set[Long]()\n      \
    \  for (a <- arr) {\n            for (b <- arr) {\n                if (a > b)\
    \ break\n                val c = a*a + b*b\n                if (c > n / 6) {\n\
    \                    factors += c\n                }\n            }\n        }\n\
    \        factors.toList.sorted.last", "        val two = 2 * 2\n        val maxPrime\
    \ = 2l\n        val divisors = new mutable.ListBuffer[Long]()\n        var num\
    \ = 0L\n        while(n > 2l) {\n            num += 1l\n            val d = 2l\n\
    \            var found = false\n            while(d <= n && !found) {\n      \
    \          if(n % d == 0) {\n                    divisors += d\n             \
    \       found = true\n                }\n                d += two\n          \
    \  }\n        }\n        if(divisors.isEmpty) {\n            maxPrime += 1l\n\
    \        } else {\n            divisors.toList.sortWith((x, y) => x > y) match\
    \ {\n                case Nil =>\n                case h :: t =>\n           \
    \         maxPrime += h\n                    largestPrimeFactor(maxPrime)\n  \
    \          }\n        }", "        val factors = PrimeFactors(n).toList\n    \
    \    if (factors.isEmpty) 1\n        else {\n            val max_factors = factors.sortBy(f\
    \ => -1 * f.toInt).reverse.head\n            factors.indexOf(max_factors) match\
    \ {\n                case -1 => 0\n                case n => max_factors\n   \
    \         }\n        }", "        var max = 0\n        var i = 2l\n        while\
    \ (i <= n && n % i == 0) {\n            max = i\n            i += (2l)\n     \
    \   }\n        if (max <= n) {\n            return max\n        }\n        var\
    \ i = 3l\n        while (i <= n) {\n            if (n % i == 0) {\n          \
    \      max += i\n                i += (2l)\n            }\n            else {\n\
    \                i += (3l)\n            }\n        }\n        if (max <= n) {\n\
    \            return max\n        }\n        var i = 3l\n        while (i <= n)\
    \ {\n            if (n % i == 0) {\n                max += i\n               \
    \ i += (3l)\n            }\n            else {\n                i += (5l)\n  \
    \          }\n        }\n        if (max <= n) {\n            return max\n   \
    \     }\n        return n", "        var max_factor = 0\n        for(factor <-\
    \ 2 to n) \n            if(n%factor == 0) max_factor = max(max_factor, factor)\n\
    \        max_factor", "        val res = mutable.Set[Long]()\n        var i =\
    \ 2\n        for(k <- 2 until n) if ((n % k) == 0) res.add(k)\n        while(i\
    \ <= n) {\n            if (res.contains(i)) {\n                res.remove(i)\n\
    \            } else {\n                i += 1\n            }\n        }\n    \
    \    if (res.isEmpty) 1 else res.last", "        val factors = mutable.Set()\n\
    \        val i = 1\n        while (i <= n / i) {\n            if (n % i == 0)\
    \ {\n                factors += i\n                n /= i\n            }\n   \
    \         i += 1\n        }\n        if (n != 1)\n            factors += n\n \
    \       factors.max", "        val i = 2l\n        var p = n\n        while (p\
    \ % 2 == 0l) {\n            p /= 2\n            i += 1\n        }\n        var\
    \ m = 2l\n        while (m <= i) { //Keep checking multiples of i until you hit\
    \ a prime\n            if ((n % m) == 0l) break\n            m += 1\n        }\n\
    \        m", "        var factor = 1\n        while (n != 1) {\n            if\
    \ (n % factor == 0) {\n                n /= factor\n            } else {\n   \
    \             factor++\n            }\n        }\n        return factor", "  \
    \      val lim = math.sqrt(n)\n        val factors = Vector.newBuilder[Long]\n\
    \        for(i <- 2 until lim) {\n            while(n % i == 0) {\n          \
    \      factors += i\n                n /= i\n            }\n        }\n      \
    \  val largest = factors.max\n        if(n > 1)\n            largest\n       \
    \ else\n            largest * n", "        if (n < 2) 1\n        else {\n    \
    \        val factors = mutable.ListBuffer[Long]()\n            var p = 2\n   \
    \         var q = n\n            while (p * p <= q && factors.nonEmpty) {\n  \
    \              if ((q % p) == 0) {\n                    q = q div p\n        \
    \        } else {\n                    factors += p\n                }\n     \
    \           p = p + 1\n            }\n            if (factors.nonEmpty) {\n  \
    \              factors.toList.reverse.head\n            } else {\n           \
    \     n\n            }\n        }", "        val sqrtN = sqrt(n)\n        var\
    \ m = 2\n        var k = n/2\n        while (m <= sqrtN) {\n            while\
    \ ((k*k <= n) && (k <= sqrtN)) {\n                k += 1\n            }\n    \
    \        if (k > sqrtN) {\n                m = k\n            } else {\n     \
    \           k = 2\n            }\n        }\n        if (k == 2) {\n         \
    \   return k\n        } else {\n            return k+1\n        }", "        var\
    \ maxPrime = 0\n        var maxDivisor = 0\n        var nDivisors = 0\n      \
    \  var n = n\n        while (n != 0) {\n            var div = n\n            var\
    \ maxDivisor = 0\n            var nDivisors = 0\n            var isPrime = true\n\
    \            while (div > 1) {\n                var p = div - 1\n            \
    \    if (n % p == 0) {\n                    isPrime = false\n                }\n\
    \                else {\n                    maxDivisor = p\n                \
    \    nDivisors = nDivisors + 1\n                }\n                div = div /\
    \ p\n            }\n            if (isPrime) {\n                if (nDivisors\
    \ > maxPrime) {\n                    maxPrime = nDivisors\n                }\n\
    \            }\n            n = nDivisors\n        }\n        if (maxPrime < 2)\
    \ {\n            return 2\n        }\n        if (maxPrime == 2) {\n         \
    \   if (n % 2 == 0) {\n                return n\n            }\n        }\n  \
    \      return maxPrime", "        var factors = mutable.HashMap[Int, Long]()\n\
    \        var i = 2l\n        while(i <= n){\n            if(n % i == 0){\n   \
    \             if(factors.contains(i)){\n                    factors(i) = factors(i)\
    \ + n\n                }\n                else{\n                    factors(i)\
    \ = n\n                }\n            }\n            i += 1\n        }\n     \
    \   val maxFactor = max(factors.toSeq.sortBy(_._2))\n        factors(maxFactor)",
  "      val largestPrimeFactors = mutable.HashSet[Long]()\n      largestPrimeFactors\
    \ += n\n      largestPrimeFactors.find(_ % _ == 0)", "        val result = new\
    \ collection.mutable.ListBuffer[Long]()\n        for(x <- n..math.sqrt(n)){\n\
    \            val candidate = x / x\n            if(candidate.equals(1)){\n   \
    \             result += 1\n            }else if(primes.exists(candidate)){\n \
    \               result += candidate\n            }\n        }\n        result\
    \ max n", "        def largestPrimeFactorHelper(n : Long, max : Long) : Long =\
    \ {\n            if (n == 1) max\n            else largestPrimeFactorHelper(n/2,\
    \ max)\n        }\n        largestPrimeFactorHelper(n, 2)", "        val factors\
    \ = mutable.MutableList[Long]()\n        var factor = 1\n        var isPrime =\
    \ true\n        while (factor < n && isPrime != true) {\n            factors.clear()\n\
    \            factor = factors.lastOption match {\n                case None =>\
    \ {\n                    for (i <- 1 until n) {\n                        if (n\
    \ % i == 0) {\n                            factors.add(i)\n                  \
    \      }\n                    }\n                }\n                case Some(lastFactor)\
    \ => {\n                    if (lastFactor <= factor) {\n                    \
    \    factors.add(lastFactor)\n                    }\n                }\n     \
    \       }\n            isPrime = factors.nonEmpty && factors.size == 2\n     \
    \   }\n        factors.lastOption.get", "        val p = 2\n        val q = n\n\
    \        var l = 1\n        var l = q\n        while( (l * p) < q ) {\n      \
    \      l += q\n        }\n        while( (l * p) >= q ) {\n            p *= l\n\
    \        }\n        p", "        val m = 2L\n        var i = 2L\n        var p\
    \ = 2L\n        while (i <= n) {\n            while (n % i == 0L) {\n        \
    \        p += 1\n                n /= i\n            }\n            i += 1\n \
    \       }\n        p", "        val factors = mutable.ListBuffer[Long]()\n   \
    \     for(x <- 2 to n by 2) {\n            if(n/x == 1) factors += x\n       \
    \     if(x*x/n != n) factors += x\n        }\n        factors.max", "        var\
    \ lf : Long = 2L\n        while (lf * lf < n)\n            lf += 1\n        lf",
  "        val lis = scala.collection.mutable.ListBuffer[Long]()\n        for (i <-\
    \ 1 until n){\n            if (n % i == 0){\n                lis.append(i)\n \
    \           }\n        }\n        lis.max", "        val p = 2l\n        val q\
    \ : Long = 1l\n        while (n > p) {\n            if (n % p == 0) {\n      \
    \          n = n/p\n            }\n            else {\n                q *= p\n\
    \            }\n        }\n        if (n > 1) {\n            q *= n\n        }\n\
    \        return q", "        val factors = PrimeFactors(n)\n        if (factors.isEmpty)\n\
    \            1\n        else {\n            val m = factors.max\n            factors(m)\n\
    \        }", "        val lcm = n.toLong/n.toDouble\n        val primes = (2 until\
    \ Math.sqrt(lcm)).filter(_*lcm%_ > 0)\n        val result  = primes.find(prime\
    \ => prime < lcm).toDouble\n        val r = n/result\n        result*r", "   \
    \     val factors = Vector.empty[Long]\n        var i = 2L\n        var prime\
    \ = true\n\n        while ( i * i <= n ) {\n            if ( n % i == 0 ) {\n\
    \                prime = false\n            } else {\n                factors\
    \ = factors :+ i\n            }\n            i += 1\n        }\n        if ( prime\
    \ ) n\n        else factors.foldLeft(n)((max, factor) => max % factor != 0 ? max\
    \ : factor)", "        var primes = mutable.ArrayBuffer(2l)\n        var factor\
    \ = 2l\n        while (n >= 1) {\n            if ((n % factor) == 0) primes +=\
    \ factor\n            factor += 1\n        }\n        primes.last", "        var\
    \ i = 2\n        var factor = 1\n        while (n /= i) {\n            if (n %\
    \ i == 0) {\n                factor *= i\n            }\n        }\n        if\
    \ (n == 1) {\n            factor\n        } else {\n            factor\n     \
    \   }", "        val isPrime = (1 to n).forall(x => n%x == 0)\n        if (isPrime)\
    \ {\n            n \n        } else {\n            largestPrimeFactor(n/2) \n\
    \        }", "        val primes = primeFactors(n)\n        return primes.max",
  "        var largestPrimeFactor = Long.MinValue\n        var i = 1\n        while\
    \ (largestPrimeFactor > 1 && i * i <= n) {\n            if (n % i == 0)\n    \
    \            largestPrimeFactor = i\n            i += 1\n        }\n        if\
    \ (largestPrimeFactor > 1)\n            largestPrimeFactor\n        else\n   \
    \         n", "        val primes = mutable.MutableList[Long]()\n        var largestPrimeFactor\
    \ = BigInt(1)\n        var i = 2\n        while (i < n){\n            if (n %\
    \ i == 0){\n                primes.append(i)\n                largestPrimeFactor\
    \ = math.max(largestPrimeFactor,i.toLong)\n            }\n            i += 1\n\
    \        }\n        largestPrimeFactor", "        val largestPrimeFactor = BigInt(2)\n\
    \        for (x = 1 until n / largestPrimeFactor) {\n            val m = n % x\n\
    \            if (m == 0) largestPrimeFactor = x / m\n            else if (m >\
    \ 0 && x != largestPrimeFactor) largestPrimeFactor = largestPrimeFactor\n    \
    \    }\n        largestPrimeFactor", "        // Write your solution here\n  \
    \      val lp = primeFactors(n)\n        if(lp.isEmpty || lp.head < 2)\n     \
    \       n\n        else {\n            val largestPrimeFactor = lp.max{\n    \
    \            (pf : Long) => pf * pf == n\n            }\n            val i = lp.indexOf(lp.max{\
    \ pf => pf * pf == n })\n            if(i < 2)\n                largestPrimeFactor\n\
    \            else\n                largestPrimeFactor * primeFactors(n).drop(i\
    \ + 1)\n        }", "        var factors = Set()\n        var divisor = 2\n\n\
    \        while (n/divisor > 1) {\n            if (n % divisor  == 0) {\n     \
    \           factors += divisor\n            }\n            divisor += 2\n    \
    \    }\n\n        n / divisor", "        // If n is 1, then n = p => p = 1\n \
    \       // Else, If n is even, then n/p = 2p and n/2 = 2p, then\n        //  \
    \   n/p + n/2 = 2n + 2p, n > 2n and p > 2\n        // Else,\n        //     n/p\
    \ + n/2 = 2n + 2p, n > 2n and p > 2\n        // Find p such that n/p + n/2 = 2n\
    \ + 2p\n        // If n is prime, then p is prime\n        val p = 3\n       \
    \ val factors = mutable.Vector[Long]()\n        while ((n%p) == 0) {\n       \
    \     factors += p\n            n /= p\n        }\n        (if (n != 1l) 1 else\
    \ 2l).max(factors.last)", "        val factors = new mutable.ArrayList[Long]\n\
    \        // Initialize list of factors of n to 2\n        val factors2: Array[Long]\
    \ = Array.fill(5)(2l)\n        for (i <- 2 to n/2) {\n            while (n % i\
    \ == 0) {\n                factors += i\n                factors2(i) = n%i\n \
    \               n = n%i\n            }\n        }\n        val largestFactor =\
    \ factors.max.toLong\n        val largestFactor2 = factors2.max.toLong\n     \
    \   if (largestFactor == largestFactor2) largestFactor\n        else largestFactor2",
  "        val factorsCount = PrimeFactor(n).length\n        var biggerFactor = 0\n\
    \        for (i <- 0 until factorsCount) {\n            val primeFactor = PrimeFactor(n).apply(i)\n\
    \            if(primeFactor > biggerFactor)\n                biggerFactor = primeFactor\n\
    \        }\n        return biggerFactor", "        val factors = mutable.ListBuffer[(Int,\
    \ Int)]()\n        for(i <- 2 to n/2) \n            if(n % i == 0 && isPrime(i))\
    \ factors += (i,1)\n        factors.maxBy(_._1)._1", "        val r = new Array[Long](4)\n\
    \        var n = n\n        var isPrime = true\n        while ( n != 1 ) {\n \
    \           var i = 3\n            while ( (n%(i++)) != 0 ) if ( n%(i) == 0 )\
    \ isPrime = false\n            if ( isPrime ) {\n                r(0) = i\n  \
    \              n /= i\n            }\n        }\n        r(1) = n\n        largestPrimeFactor(r(0),\
    \ r(1,1))", "        // Make n-1 the largest prime factor of n and n+1 the least\
    \ prime factor.\n        val p = primeFactors(n)\n        val p1 = p(0)\n    \
    \    val p2 = p(1)\n        val p3 = p(2)\n        // Test p3 against a factor\
    \ of n to see which comes first.\n        val smallerPrime = p3 / p\n        val\
    \ biggerPrime = p1 / p\n        if (smallerPrime < biggerPrime) {\n          \
    \  smallerPrime\n        } else {\n            biggerPrime\n        }", "    \
    \    val p = BigInt(primeFactors(n))\n        if ( p.toString.length == 2 && p\
    \ > 1 ) return p \n        else largestPrimeFactor(n.div(p))", "        val factors\
    \ = new mutable.ListBuffer[Long]()\n        for (d <- 2 to n by 2)\n         \
    \   if (n % d == 0)\n                factors += d\n        if (factors.isEmpty)\
    \ n\n        else {\n            val largest = factors.sort[Long]((a, b) => a.compare(b))(1).head\n\
    \            val p = n\n            while (p % largest != 0)\n               \
    \ p = p / largest\n            p\n        }", "      val nums = new mutable.ListBuffer[Long]()\n\
    \      val isPrime = Array[Boolean](\n        true, true, false, false, false,\
    \ true, false, true,\n        false, true, true, true, false, false, false, true,\n\
    \        false, true, false, true, true, false, false, true,\n        false, true,\
    \ false, false, true, false, false, true,\n        false, true, false, false,\
    \ false, true, false, true,\n        false, false, false, false, false, false,\
    \ false, true,\n        false, false, false, false, true, true, false, false,\n\
    \        false, false, false, false, false, false, false, true,\n        false,\
    \ false, false, false, false, false, false, true,\n        false, true, true,\
    \ false, false, true, false, true,\n        false, true, true, false, false, true,\
    \ false, true,\n        false, true, false, true, false, true, false, true,\n\
    \        false, true, false, true, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, true,\n        false, true, false, false,\
    \ true, false, false, true,\n        false, true, false, false, false, true, false,\
    \ true,\n        false, true, false, false, true, false, false, true,\n      \
    \  false, true, false, false, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, true,\n        false, true, false, false,\
    \ false, true, false, true,\n        false, true, false, false, false, true, false,\
    \ true,\n        false, true, false, false, true, false, false, true,\n      \
    \  false, true, false, false, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, true,\n        false, true, false, false,\
    \ false, true, false, true,\n        false, true, false, false, false, true, false,\
    \ true,\n        false, true, false, false, false, true, false, true,\n      \
    \  false, true, false, false, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, true,\n        false, true, false, false,\
    \ false, true, false, true,\n        false, true, false, false, false, true, false,\
    \ true,\n        false, true, false, false, false, true, false, true,\n      \
    \  false, true, false, false, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, true,\n        false, true, false, false,\
    \ false, true, false, true,\n        false, true, false, false, false, true, false,\
    \ true,\n        false, true, false, false, false, true, false, true,\n      \
    \  false, true, false, false, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, true,\n        false, true, false, false,\
    \ false, true, false, true,\n        false, true, false, false, false, true, false,\
    \ true,\n        false, true, false, false, false, true, false, true,\n      \
    \  false, true, false, false, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, true,\n        false, true, false, false,\
    \ false, true, false, true,\n        false, true, false, false, false, true, false,\
    \ true,\n        false, true, false, false, false, true, false, true,\n      \
    \  false, true, false, false, false, true, false, true,\n        false, true,\
    \ false, false, false, true, false, ", "        var p = 1\n        while (n !=\
    \ 0) {\n            while (n % p == 0) p += 1\n            n = n / p\n       \
    \ }\n        p", "        val primes = mutable.MutableSet[Long]()\n        for(i\
    \ <- 2 to n) {\n            if(n % i == 0) {\n                primes.add(i)\n\
    \            }\n        }\n        primes.max", "        val ps = ListSet(n) diff\
    \ ListSet(2l) map (List(_))\n        val l = ps.last\n        val ps = ps.filter\
    \ (x => x % l != 0)\n        if(ps.isEmpty) l else largestPrimeFactor(ps.last)",
  "        // Find largest factor of n\n        // http://rosettacode.org/wiki/Largest-prime_factor#Scala\n\
    \        // http://stackoverflow.com/questions/5342829/scala-factorization-of-number\n\
    \        var factor = 1\n        var currentfactor = 2\n        val maxfactor\
    \ = 3\n\n        // Iteratively find prime factors\n        // http://stackoverflow.com/questions/5342829/scala-factorization-of-number\n\
    \        // http://stackoverflow.com/questions/5342829/scala-factorization-of-number\n\
    \        while(factor * currentfactor <= n) {\n            if((n % currentfactor\
    \ == 0) && (n % currentfactor == factor)) {\n                break\n         \
    \   }\n            currentfactor += 1\n        }\n\n        // Find largest factor\
    \ and return it\n        if(currentfactor == maxfactor) {\n            return\
    \ n\n        } else {\n            return n * currentfactor\n        }", "   \
    \     var largestPrime = 0L\n        for (i: Long = 2L; i < n; i += 2L) {\n  \
    \          if (n % i == 0L) {\n                largestPrime = i\n            \
    \    break\n            }\n        }\n        largestPrime", "        var largestPrimeFactor\
    \ = n // Keep track of the largest prime factor\n        for(i: Long = 2 to n/2)\
    \ {\n            if (n % i == 0) { // If this number is a factor of n, then we\
    \ can stop here\n                if (i * (i + 1) == n) { // And if that factor\
    \ is (a prime), then we stop here\n                    return i\n            \
    \    }\n                largestPrimeFactor = i\n            }\n        }\n   \
    \     largestPrimeFactor", "        var largestPrimeFactor : Long = n = 2l\n \
    \       var temp : Long = n = 2l\n        while (true){\n            val testPrimeFactor\
    \ : Boolean = n != 2l\n            val isPrime : Boolean = checkIfPrime(n)\n \
    \           if (isPrime){\n                if (testPrimeFactor){\n           \
    \         largestPrimeFactor = temp\n                }\n                if (testPrimeFactor\
    \ && largestPrimeFactor > temp){\n                    largestPrimeFactor = temp\n\
    \                }\n            }\n            if (!isPrime && testPrimeFactor){\n\
    \                temp = n\n                largestPrimeFactor = temp\n       \
    \     }\n            if (!isPrime && testPrimeFactor && largestPrimeFactor > temp){\n\
    \                largestPrimeFactor = temp\n            }\n            if (!isPrime){\n\
    \                break\n            }\n            temp = n\n            n +=\
    \ 1l\n        }\n        largestPrimeFactor", "        val isPrime: Function1[Long,\
    \ Boolean] = { x => x % 2 == 0 || x % 3 == 0 }\n        val primeFactors = new\
    \ mutable.HashMap[Long, Long]\n        val largestPrime = 2l\n        while (n\
    \ > 1) {\n            val nextPrime = n % largestPrime\n            if (isPrime(nextPrime))\n\
    \                primeFactors(largestPrime) = nextPrime\n            largestPrime\
    \ = nextPrime\n            n /= largestPrime\n        }\n        primeFactors(largestPrime)",
  "        var maxPrime = 0\n        for(prime <- 2 until n / 2)\n            if(n\
    \ % prime == 0)\n                if(prime > maxPrime)\n                    maxPrime\
    \ = prime\n        return maxPrime", "        def isPrime(n: Long) : Boolean =\
    \ {\n            var i = 2\n            var x = n\n            while(i <= x/i)\
    \ {\n                if(x % i == 0)\n                    return false\n      \
    \          i += 1\n            }\n            return true\n        }\n       \
    \ val primes = mutable.Set[Long]()\n        val largestPrime = 0\n        while(n\
    \ != 0) {\n            val nextLargestPrime = n % largestPrime\n            primes.add(nextLargestPrime)\n\
    \            n /= nextLargestPrime\n        }\n        primes.toList.sortBy(_).last",
  "        if (n == 1)\n            return 1\n        else if (n == 2)\n         \
    \   return 2\n        else if (n % 2 == 0)\n            return largestPrimeFactor(n/2)\
    \ + 1\n        else {\n            var maxPrime = 2\n            var primes =\
    \ mutable.Set.empty[Long]\n            var isPrime = true\n            var isTrial\
    \ = true\n            while(isTrial) {\n                primes += 2\n        \
    \        isTrial = (primes.size == n)\n                for (prime <- primes) {\n\
    \                    if (isPrime && prime > maxPrime)\n                      \
    \  maxPrime = prime\n                    isPrime = (prime > 1)\n             \
    \   }\n            }\n            return maxPrime\n        }", "        var factor\
    \ = 2L\n        var i = 2L\n        while (n / factor.toLong > 1) {\n        \
    \    factor = i\n            i = i + 2L\n        }\n        factor", "       \
    \ var highest = n\n        var highestPrime = 1\n\n        // Find the highest\
    \ prime factor of n\n        while(n > 1) {\n            while(n % highestPrime\
    \ == 0) {\n                highestPrime += 1\n            }\n            highest\
    \ /= highestPrime\n            highestPrime = 1\n        }\n        highest",
  "        val m = n / 2\n        if(m > 1) largestPrimeFactor(m)\n        else if(n\
    \ % 2 == 0) 2\n        else 3", "        val factors = mutable.ArrayBuffer(2)\n\
    \        while(n > 1) {\n            val f = n % factors.last\n            n /=\
    \ f\n            factors += f\n        }\n        factors.last", "        val\
    \ factors = Vector.fill(Math.sqrt(n))(2l) //Vector of primes\n        for(i <-\
    \ 2l..n){\n            val candidate = factors(i)\n            val primes = for\
    \ (j <- candidate; j <- 2l) yield { if (n % j == 0) 1l else 0 }\n            primes.max\n\
    \        }", "        if (n <= 1) {\n            return 1\n        } else if (n\
    \ == 2) {\n            return 2\n        } else if (n % 2 == 0) {\n          \
    \  return largestPrimeFactor(n / 2)\n        } else if (n % 3 == 0) {\n      \
    \      return largestPrimeFactor(n / 3)\n        } else {\n            val d =\
    \ n - 1\n            val r = largest {\n                if (d % i == 0) i else\
    \ d\n            }\n            largestPrimeFactor(r)\n        }", "        //\
    \ Find all primes in n\n        var primes = primes(n)\n        val largestPrime\
    \ = primes(primes.size-1)\n        while(primes.contains(largestPrime))\n    \
    \        largestPrime = primes(primes.size-1)\n        largestPrime", "      \
    \  var maxPrime = 2L\n        var p = 3L\n        while (p <= n) {\n         \
    \   if (n % p == 0) {\n                maxPrime = p\n            }\n         \
    \   p += 2L\n        }\n        maxPrime", "        if (n < 2) {\n           \
    \ return n;\n        }\n        var maxFactor = n % 2;\n        var prime = 2L;\n\
    \        while (prime < n) { \n            prime *= 2;\n            if (n % prime\
    \ == 0) {\n                maxFactor = prime;\n            }\n        }\n    \
    \    return maxFactor;", "        val factors = mutable.ListBuffer.empty[Int]\n\
    \        var prime = 0\n        while (n > 1) {\n            prime += 1\n    \
    \        while (prime % n != 0) {\n                prime += 1\n            }\n\
    \            factors += prime\n            n /= prime\n        }\n        factors.max",
  "        val sqrtN = scala.math.sqrt((n + 1))\n        for (factor <- 2 until sqrtN)\
    \ {\n            val test = n%factor\n            if (test == 0) return factor\n\
    \        }\n        return sqrtN", "        var largestPrimeFactor : Long = 1\n\
    \        var nextPrimeFactor : Long = n\n\n        while (nextPrimeFactor < n\
    \ && (nextPrimeFactor % largestPrimeFactor == 0)) {\n            largestPrimeFactor\
    \ += nextPrimeFactor\n            nextPrimeFactor += nextPrimeFactor\n       \
    \ }\n        nextPrimeFactor", "        var n = n\n        var i = 2\n       \
    \ var largestPrime = 0\n        while (i <= n/2) {\n            while (n % i ==\
    \ 0) {\n                largestPrime = i\n                n = n/i\n          \
    \  }\n            i = i + 1\n        }\n        largestPrime", "        val primes\
    \ = new collection.mutable.HashSet[Long]()\n        for (f <- 2 to math.sqrt(n))\
    \ {\n            if (n % f == 0) {\n                primes += f\n            }\n\
    \        }\n        val max = primes.last\n        primes.remove(0)\n        max",
  "        var result : Long = 0\n        var divisor = 2\n        while (n % divisor)\
    \ {\n            result += 1\n            divisor += 2\n        }\n        result",
  "        if (n <= 1) return n\n\n        var maxFactor = 0l\n        var primeFactors\
    \ = Vector.empty[Int]\n        var divisor = 0l\n        while (true) {\n    \
    \        if (n % divisor == 0) {\n                maxFactor = max(maxFactor, divisor)\n\
    \                divisor = divisor * primeFactors.last() + 1\n            }\n\
    \            else {\n                divisor = divisor + 1l\n            }\n \
    \           if (divisor > n) {\n                primeFactors = primeFactors :+\
    \ divisor\n                break\n            }\n        }\n        maxFactor",
  "        var i = 2\n        var factor = 2\n        while(i <= Math.sqrt(n)) {\n\
    \            while(n % i == 0) {\n                n /= i\n                factor\
    \ *= i\n            }\n            i += 1\n        }\n        n", "        def\
    \ isPrime(n : Long) : Boolean = {\n            var i = 2L\n            var factor\
    \ = 2L\n            while (i <= n / factor) {\n                factor = factor\
    \ * i\n                if (n % factor == 0L)\n                    return false\n\
    \                i += 1\n            }\n            true\n        }\n\n      \
    \  def largestPrimeFactor(n : Long) : Long = {\n            if (n == 1L)\n   \
    \             return n\n            if (isPrime(n))\n                return n\n\
    \            else if (n % 2L == 0L)\n                return largestPrimeFactor(n\
    \ / 2L)\n            else\n                return largestPrimeFactor(3 * n + 1L)\n\
    \        }\n\n        largestPrimeFactor(n)"]
stop_tokens:
- "\n    }\n"
