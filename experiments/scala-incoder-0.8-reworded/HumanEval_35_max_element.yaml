name: HumanEval_35_max_element
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return maximum element in the list.\n    // >>> maxElement((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong)))\n    // (3l)\n    // >>> maxElement((List[Long](5l.toLong,\
  \ 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong,\
  \ 123l.toLong, 1l.toLong, -10l.toLong)))\n    // (123l)\n    def maxElement(l :\
  \ List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maxElement((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong))) == (3l));\n    assert(maxElement((List[Long](5l.toLong,\
  \ 3l.toLong, -5l.toLong, 2l.toLong, -3l.toLong, 3l.toLong, 9l.toLong, 0l.toLong,\
  \ 124l.toLong, 1l.toLong, -10l.toLong))) == (124l));\n    }\n\n}\n"
completions: ["        val maxValue = l.head\n        val maxIndices = l.zipWithIndex.filter\
    \ { _._2 > 0 }.map { _._1 }.toSet\n        val result = maxIndices.map { i =>\
    \ maxValue(i) }\n        result.max", "        var max: Long = -1\n        var\
    \ i: Long = 0\n        for (x <- l) {\n            if (x > max) {\n          \
    \      max = x\n            }\n            i += 1\n        }\n        max", " \
    \       val m = l.map(_.asInstanceOf[Long]).max\n        m match {\n         \
    \   case Some(i) => i\n            case None => -1l.asInstanceOf[Long]\n     \
    \   }", "        var max = 0\n        for(x <- l) {\n            if(x > max) max\
    \ = x\n        }\n        max", "        if (l.isEmpty) 0\n        else {\n  \
    \          var max = l(0)\n            var maxIdx = 0\n            val idx = l.indexOf(0)\n\
    \            while (idx != -1) {\n                if (max < l(idx)) max = l(idx)\n\
    \                maxIdx += 1\n                idx = l.indexOf(max)\n         \
    \   }\n            maxIdx\n        }", "        var max = 0L\n        var ans\
    \ = l(0)\n        for(i <- 1 until l.size){\n            if(l(i) > max){\n   \
    \             max = l(i)\n                ans = i\n            }\n        }\n\
    \        ans", "        var maxValue : Long = -(1000000000l);\n        var maxIndex\
    \ : Int = 0;\n        var maxElement : Long = -1L;\n        for (i <- 0 until\
    \ l.length) {\n            if(l(i) > maxValue) {\n                maxValue = l(i)\n\
    \                maxIndex = i;\n                maxElement = maxValue;\n     \
    \       }\n        }\n        maxElement", "        if (l.isEmpty) throw new Exception(\"\
    Empty list!\")\n        var max = l.head\n        for (e1 <- l.tail) if (e1 >\
    \ max) max = e1\n        return max", "        val m = scala.collection.mutable.Map(l\
    \ : _*).maxBy(_._1)\n        m._1._1", "        val max = l.foldLeft((Long.MinValue,\
    \ Long.MinValue))((maxValue, currentValue) => {\n            if (currentValue\
    \ > maxValue._2) {\n                (maxValue._1, currentValue)\n            }\
    \ else {\n                (currentValue, maxValue._2)\n            }\n       \
    \ })\n        max", "        l.foldLeft(0l) { (max, elm) =>\n            if (max\
    \ < elm) max else elm\n        }", "        if (l.isEmpty)\n            throw\
    \ new java.util.NoSuchElementException(\"List is empty\")\n        if (l.size\
    \ == 1)\n            return l.head\n        val max = l.head\n        var nextElement\
    \ = l.head\n        val listCopy = l.filter(_ != max) \n        listCopy.foreach\
    \ { elem =>\n            if (nextElement > elem)\n                nextElement\
    \ = elem\n        }\n        max = nextElement\n        listCopy.foreach { elem\
    \ =>\n            if (elem > max) max = elem\n        }\n        max", "     \
    \   val max: Long = l.foldLeft[Long](Long.MinValue)((max, v) => (max max > v ?\
    \ max : v));\n        max", "        var max = 0L\n        for(i <- l) {\n   \
    \         if(i < 0) break\n            max = Math.max(max, i)\n        }\n   \
    \     max", "        if (l.isEmpty) throw new NoSuchElementException(\"empty list\"\
    )\n        l.foldRight(l.head){(x, y) => if (x > y) x else y}", "        val m\
    \ = collection.mutable.HashSet[Long]()\n        l.foreach(x => if (m.contains(x))\
    \ m else m.add(x))\n        m max l(0)", "        val result = l.foldLeft((-Long.MaxValue,\
    \ Long.MinValue)) { (maxVal, elem) =>\n            if (elem > maxVal._2) {\n \
    \               (elem, maxVal._1)\n            } else if (elem < maxVal._1) {\n\
    \                (maxVal._2, elem)\n            } else {\n                (maxVal._2,\
    \ maxVal._1)\n            }\n        }._1", "        var max = l(0)\n        for\
    \ (ele <- l)\n            if (ele > max)\n                max = ele\n        return\
    \ max", '        l.foldLeft(0L){ (a, b) => math.max(a, b) }', "        l.foldLeft(0L){\
    \ (mx, i) =>\n            if(i> mx) i\n            else mx\n        }", "    \
    \  import scala.math._\n      val m = l.max\n      l.filter { case e => e > m\
    \ }", "        l.foldLeft((Long.MaxValue, List[Long]()))((l, acc) =>\n       \
    \     if (acc.head > l.head) acc else (l.head, List (l.head :: acc.tail)))", " \
    \       val max = l.head\n        l.tail.foreach(x => if (x > max) max = x)\n\
    \        max", "        val max = mutable.ArrayBuffer.empty[Long]\n        var\
    \ max = l.head\n        l.foreach{\n            case i if (i < max) => (max =\
    \ i)\n        }\n        max", "        val maxElem = l.max\n        l.find(_\
    \ == maxElem).getOrElse(maxElem)", "        var max_num = Long.MinValue\n    \
    \    var max_element = Long.MinValue\n        for(elem <- l){\n            if(elem\
    \ > max_num)\n                max_num = elem\n            if(elem > max_element)\n\
    \                max_element = elem\n        }\n        max_element", "      \
    \  if(l.length < 1) l(0)\n        val m = 0l\n        var mIdx = -1\n        for(i\
    \ <- 0 until l.length) {\n            val n = l(i)\n            if(n > m) {\n\
    \                m = n\n                mIdx = i\n            }\n        }\n \
    \       if(m == 0) mIdx else l(mIdx)", "        var maxValue = Long.MinValue\n\
    \        for (i <- l) {\n            if (maxValue < i) maxValue = i\n        }\n\
    \        maxValue", "        val list = l.toSet\n        val maxValue: Long =\
    \ list.iterator.max\n        val maxIndex: Int = list.iterator.index\n       \
    \ if(maxIndex == 0)\n            maxValue\n        else\n            l.slice(maxIndex\
    \ - 1).max", "        val mn = l.min\n        val mx = l.max\n        val nn =\
    \ l.length\n        val mf = mx - mn\n        val rr = nn * mf / 2\n\n       \
    \ val a = (rr * mn - nn * rr) / mf + (nn * rr - nn * mn) / mf\n        val b =\
    \ mf - (rr * mn - nn * rr) / mf + (nn * rr - nn * mn) / mf\n        val c = -(a\
    \ - b)\n        val d = a + b\n\n        mx + c * Math.sqrt(d)", '        l.foldLeft((Long.MinValue,
    0))((x, y) => if (x > y) x else y)', "        var max = 0L\n        var maxIndex\
    \ = 0\n        l.foreach { elem =>\n            if (elem > max) {\n          \
    \      max = elem\n                maxIndex = l.indexOf(elem)\n            }\n\
    \        }\n        return max", "        if (l.isEmpty) 0L\n        else l.max",
  "        var maxElem = -1\n        for(x <- l) {\n            if(x > maxElem) {\n\
    \                maxElem = x\n            }\n        }\n        maxElem", "  \
    \      l match {\n            case Nil => 0L\n            case h :: t => math.max(h,\
    \ maxElement(t.map(_)))\n        }", "        val max = 0.0\n        var maxElement\
    \ = -1\n        var pos = 0\n        var currentMax = 0\n        for(i <- 0 until\
    \ l.length) {\n            val elem = l(i)\n            if(elem > max) {\n   \
    \             maxElement = pos\n                currentMax = elem\n          \
    \      max = elem\n            } else if(elem == max) {\n                if(elem\
    \ > currentMax) {\n                    maxElement = pos\n                    currentMax\
    \ = elem\n                }\n            }\n            pos = i + 1\n        }\n\
    \        if(maxElement == -1) return null\n        return max", "        val max\
    \ = 0L\n        var max = -1L\n        val map = new mutable.HashMap[Long, Long]()\n\
    \        for(x <- l) {\n            val curMax = map.getOrElse(x, 0L)\n      \
    \      if(curMax > max) {\n                max = curMax\n            }\n     \
    \       map.put(x, x + 1)\n        }\n        if(map.size == l.length) {\n   \
    \         return map.maxEntry.getValue\n        } else {\n            return max\n\
    \        }", "        val max: Long = l.head\n        var maxIndex = 0\n     \
    \   for (i <- 1 until l.length) {\n            if(l(i) > max) {\n            \
    \    max = l(i)\n                maxIndex = i\n            }\n        }\n    \
    \    max", "        val max = l.foldLeft(0l.toLong) { (max, e) =>\n          if\
    \ (e > max) e else max\n        }\n        max", "        if (l.isEmpty)\n   \
    \         return 0\n        else {\n            val max = l(0)\n            l.foreach\
    \ { e =>\n                if (e > max)\n                    max = e\n        \
    \    }\n            max\n        }", "        val result = l.foldLeft((0l,0l))\
    \ { (a, b) => if (a._1 > b._1) (a._1,b._1) else (a._1, b._1) }._1\n        result",
  "        l.foldLeft(0L){\n            (a, b) => (if (a < b) a else b)\n        }",
  "        // Write your code here.\n        var max = -1\n        var maxValue =\
    \ -1\n        for(i <- 0 until l.length) {\n            val current = l(i)\n \
    \           if(current > max) {\n                max = current\n             \
    \   maxValue = i\n            }\n        }\n        return max", "        l match\
    \ {\n            case Nil => 0\n            case x :: xs => maxElement(xs) + 1\n\
    \        }", "        var max : Long = -1\n        var mid : Long = 0\n      \
    \  l.foreach { elem =>\n            if(elem > mid)\n                max = elem\n\
    \            else\n                max = mid\n            mid = elem\n       \
    \ }\n        mid", "        var m = 0\n        for(i<-l.length-1;i++){\n     \
    \       val e = l(i)\n            if(m<e){\n                m = e\n          \
    \  }\n        }\n        m", '        l.foldLeft(0l.toLong){case (acc, elem) =>
    if (elem > acc) elem else acc}', "        var result = l(0)\n        for (i <-\
    \ 1 until l.length){\n            if (l(i) > result) {\n                result\
    \ = l(i)\n            }\n        }\n        result", "        val result = mutable.LinkedHashMap()\n\
    \        l.foreach(l => {\n            if(result.containsKey(l)) result(l) +=\
    \ 1\n            else result(l) = 1 \n        })\n        val max = result.values.max\n\
    \        result.values.find(_ == max).map(_ => max)", "        val minValue =\
    \ l.min\n        val maxValue = l.max\n        if (minValue == maxValue) {\n \
    \           return maxValue\n        } else {\n            val maxValue = maxValue(l)\n\
    \            if (maxValue == minValue) {\n                return maxValue\n  \
    \          } else {\n                val maxValueMinusMin = maxValue - minValue\n\
    \                l.maxWithPreserving(_ < minValue)(\n                    maxValueMinusMin,\
    \ \n                    _ => minValue\n                )\n            }\n    \
    \    }", "        var max = l.head\n        var i : Long = 1\n        while(i\
    \ < l.length) {\n            if(max == l.head) {\n                max = l.head\n\
    \            }\n            else if(max > l.head) {\n                max = l.head\n\
    \            }\n            else {\n                max = l.tail.head\n      \
    \      }\n            i += 1\n        }\n        max", "        val result = l.head\n\
    \        if (l.tail.isEmpty) result\n        else maxElement(l.tail) match {\n\
    \            case l2 => {\n                if (l2 > result) result else l2\n \
    \           }\n        }", "        if (l.isEmpty) throw new IllegalArgumentException(\"\
    List is empty\")\n        l.headOption match {\n            case Some(first) =>\n\
    \                val maxElt = l.removeAt(0)\n                l.foldLeft(first)\
    \ { case (acc, elem) =>\n                    if (elem > maxElt)\n            \
    \            elem\n                    else\n                        acc\n   \
    \             }\n            case None =>\n                throw new IllegalArgumentException(\"\
    List is empty\")\n        }", "        l.foldLeft(l.head) {\n            (acc:\
    \ Long, i: Long) =>\n                acc match {\n                    case -1\
    \ => i\n                    case h => if (i > h) i else h\n                }\n\
    \        }", "        // Your code goes here\n        var maxVal = -1L;\n    \
    \    var maxIdx: Int = 0\n        for (i <- l.indices) {\n            if (l(i)\
    \ > maxVal) {\n                maxVal = l(i)\n                maxIdx = i\n   \
    \         }\n        }\n        l.apply(maxIdx)", '        l.foldLeft(0l) { (max,
    x) => if (max < x) max else x }', "      val m = scala.math.Ordering[Long](math.Ordering[Long].reverse).max(l)\n\
    \      m", "        val l = l filter { x => x >= 0 }\n        val m = l.max\n\
    \        m", "        val m  = l.foldLeft((Long.NegativeInfinity, l.head)) {\n\
    \            case ((e, x), e2) => (if (e > e2) e else e2, x)\n        }._1\n \
    \       m.max(0)", "        var max = 0\n        for(i <- 0 until l.length) {\n\
    \            if(l(i) > max) {\n                max = l(i)\n            }\n   \
    \     }\n        max", "      var maxElement : Long = -1\n      for( ele <- l\
    \ ) {\n          if( maxElement < ele ) {\n              maxElement = ele\n  \
    \        }\n      }\n      return maxElement", "        var maxValue = Long.MinValue\n\
    \        var maxIndex = -1\n        for (i <- 0 until l.length) {\n          \
    \  if (l(i) > maxValue) {\n                maxValue = l(i)\n                maxIndex\
    \ = i\n            }\n        }\n        maxValue", '        l.toSet.foldRight(l.max)((a,
    b) => if (a > b) a else b)', '        l.foldLeft(0L)((x,y) => if (x > y) x else
    y)', "        var maxElement : Long = -1\n        var maxIndex = 0\n        for\
    \ ( i <- l.indices.reverse ) {\n            if ( maxElement < l(i) ) { maxElement\
    \ = l(i) ; maxIndex = i }\n        }\n        maxIndex", "        var max : Long\
    \ = -1\n        l.foreach { x => \n            if (x > max) {\n              \
    \  max = x\n            }\n        }\n        max", "        // use hashMap to\
    \ store count\n        // use var instead of val for maxCount\n        var maxCount\
    \ = 0\n        var maxElement = Long.MinValue\n        var elementHashMap = new\
    \ scala.collection.mutable.HashMap[Long, Int]\n        l foreach {x => elementHashMap(x)+=1}\n\
    \        elementHashMap.foreach{case (x,y) => if(y>maxCount) maxElement = x ;\
    \ maxCount = y}\n        return maxElement", "        def max(a: Long, b: Long)\
    \ : Long = if (a > b) a else b\n        def min(a: Long, b: Long) : Long = if\
    \ (a < b) a else b\n        val m = l.toArray\n        val n = l.toArray\n   \
    \     val l = (m + n) / 2\n        for ((i, j) <- l.zipWithIndex) yield {\n  \
    \          val tmp = max(m(j), n(i))\n            m(j) = tmp\n            n(i)\
    \ = tmp\n        }\n        l.toArray", "        val max = l.foldLeft(0l){ (acc,\
    \ x) => if (x > acc) x else acc }\n        l.filter(_ == max).last", "       \
    \ var max = 0L\n        var maxIndex = 0\n        for (i <- l if i > max) {\n\
    \            max = i\n            maxIndex = l.indexOf(i)\n        }\n       \
    \ maxIndex", "        l.foldLeft((l, l))((acc, item) => {\n            if (acc._2\
    \ < item._2)\n                (acc, item)\n            else (item)\n        })._2",
  "        val max = -999999999999L\n        var maxIndex = 0\n        for (i <- l\
    \ until 0){\n            if (max == -999999999999L || max < i) {\n           \
    \     max = i\n                maxIndex = i\n            }\n        }\n      \
    \  maxIndex", "        if (l.isEmpty) 0\n        else l.foldLeft(0l.toLong)((x,y)\
    \ => if (y > x) y else x)", "      val maximum = l.foldLeft(0l){ (max,elem) =>\
    \ if(elem > max) elem else max }\n      maximum", "        val max = 0L\n    \
    \    for (elem <- l) {\n            if (elem > max)\n                max = elem\n\
    \        }\n        max", "        val l1 = l.toList\n        var max = 0L\n \
    \       var index = 0\n        while (l1.length > 0) {\n            var j = l1.head\n\
    \            var k = 0\n            var i = index\n            while ((k < index)\
    \ && (j < l1.last)) {\n                if (k > i) max = j\n                k +=\
    \ 1\n                j += 1\n                i += 1\n            }\n         \
    \   if (k < index) max = j\n            if (max < l1.last) max = l1.last\n   \
    \         l1 = l1.tail\n            index += 1\n        }\n        max", "   \
    \     l match {\n            case Nil => 0L\n            case x::Nil => x\n  \
    \          case x :: xs => if (x < xs) x else maxElement(xs)\n        }", "  \
    \      if (l.isEmpty) throw new RuntimeException(\"Empty list\")\n        l.foldLeft[Long](0l)\
    \ { (max, elm) =>\n            val newMax = elm.max(max)\n            if (newMax\
    \ > max) max else newMax\n        }", "        var maxElem = -1l\n        l.foreach(elem\
    \ => if (elem > maxElem) maxElem = elem)\n        return maxElem", "        var\
    \ max = Long.MinValue\n        var maxIndex = -1\n        for ((e, i) <- l.zipWithIndex)\
    \ {\n            if (e > max) {\n                max = e\n                maxIndex\
    \ = i\n            }\n        }\n        return l(maxIndex)", "        val m =\
    \ l.foldLeft(-Long.MaxValue){case (maxElem, x) => if (x > maxElem) x else maxElem}\n\
    \        m", "        val max = scala.math.max(l.tail.map(x => x))\n        l.find(x\
    \ => x == max)", "        var max = 0L\n        var max = l.head\n        for\
    \ (i <- l.tail) {\n            if (max < i) {\n                max = i\n     \
    \       }\n        }\n        max", '        l.foldLeft(0l.toLong) { (max, elem)
    => if (elem > max) elem else max }', "        val max = l.foldLeft(0l) { (max,\
    \ x) =>\n            if (x > max) x else max\n        }\n        max }\n    //\
    \ Returns True if there is any integer in the list greater than or equal to the\
    \ given integer.\n    // >>> greaterThanOrEqualToElement((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong), 10l.toLong))\n    // True\n    // >>> greaterThanOrEqualToElement((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong), 2l.toLong))\n    // False\n    def greaterThanOrEqualToElement(l\
    \ : List[Long], n : Long) : Boolean = {\n        val num = l.contains( n )\n \
    \       if (num) {\n            val maxEle = maxElement(l)\n            if (maxEle\
    \ >= n)\n                true\n            else false\n        }\n        else\
    \ false", "        val r = l.max\n        if (l.isEmpty) r\n        else r", " \
    \       var largest = l.head\n        for (x <- l.reverse) {\n            if (x\
    \ > largest) {\n                largest = x\n            }\n        }\n      \
    \  return largest", '        l.foldLeft(l.head)((x,y) => (if (y.compareTo(x) ==
    1) y else x))', "        l.foldLeft(0L){\n            (max, cur) =>\n        \
    \        if (max < cur)\n                    cur\n                else\n     \
    \               max\n        }", '        l.foldLeft(Long.MinValue) (_ < _) ?
    _ : _', "        l match {\n            case Nil => 0l\n            case head\
    \ :: tail => if (head > tail.max)\n                               head \n    \
    \                       else tail.max\n        }", "      val maxElem = l.foldLeft((Long.MinValue,\
    \ Long.MinValue))( ((maxElem, curMax) => if (maxElem < curMax) maxElem else curMax)\
    \ )\n      maxElem._2", "        val max = l.foldLeft(0l.toLong){(x,y) =>\n  \
    \          y > x ? y : x\n        }\n        max", "        var max : Long = -1\n\
    \        for (i <- 0 until l.length) {\n            if (l(i) > max) {\n      \
    \          max = l(i)\n            }\n        }\n        max", "        val m\
    \ = l.reduceLeftOption(_>_)\n        m match {\n            case None => -1l\n\
    \            case Some(x) => x\n        }", "        val sorted = l.sorted\n \
    \       val max = sorted.last\n        val index = sorted.indexWhere(max => max\
    \ > 0)\n        sorted.take(index).last", "        if (l.isEmpty) return 0\n \
    \       val max = l(0)\n        for (i <- l.indices) {\n            if (l(i) >\
    \ max) max = l(i)\n        }\n        return max", "        var max = l(0)\n \
    \       var maxPos = 1\n        for (i <- 1 to l.size) {\n            if (l(i)\
    \ > max) {\n                max = l(i)\n                maxPos = i\n         \
    \   }\n        }\n        max", "        l.foldLeft((Long.MinValue, Long.MaxValue))\
    \ {\n        case ((a, b), x) => (if (a > x) a else x, if (b < x) b else x)\n\
    \        }._2", "        val max = l.head\n        l.tail.foreach { x =>\n   \
    \         if (x > max)\n                max = x\n        }\n        max", "  \
    \      var max = -1L\n        for (v <- l)\n          if (v > max)\n         \
    \   max = v\n        return max", "        val max = l.foldLeft(l.head){ (max,\
    \ e) => if (e > max) e else max }\n        max", '       l.map(_.asInstanceOf[Long]).foldLeft(0l.toLong){(acc,
    x) => if (x > acc) x else acc}', "        if (l.isEmpty) throw new NoSuchElementException(\"\
    Empty list\")\n        var max : Long = -1L\n        var current = 0L\n      \
    \  for (v <- l)\n            if (v > max)\n                max = v\n         \
    \   else\n                if (v == current)\n                    current = v\n\
    \                else\n                    return max\n        return max", " \
    \       val max = l.foldLeft(0l)( (maxElem, curElem) => if (curElem > maxElem)\
    \ maxElem else curElem )\n        max", "        var max : Long = l.head\n   \
    \     for(i<-l.tail if i>max) max = i\n        max", "        val maxValue = l.iterator.max\n\
    \        l.find(l => l == maxValue).getOrElse {\n            l.headOption.getOrElse(0L)\n\
    \        }", "        var max = -1L\n        var maxIndex = -1\n        var l\
    \ = l.reverse\n        for (i <- 0 until l.length) {\n            if (l(i) > max)\n\
    \            {\n                max = l(i)\n                maxIndex = i\n   \
    \         }\n        }\n        if (max == -1L) -1L\n        else\n        {\n\
    \            max\n        }", '        l.foldLeft(0L)((max,e)=>if(e>max) e else
    max)', '        l.sortBy(_.reverse).last', "        var max = -math.MaxLong\n\
    \        l.foreach{ e =>\n            if (e > max) {\n                max = e\n\
    \            }\n        }\n        max", "        var m = 0\n        var max =\
    \ 0\n        for (x <- l) {\n            m = math.max(x, m)\n        }\n     \
    \   return math.max(m, max)", "        val mList = l.toSet\n        mList.foldLeft((0l,\
    \ 0l))((acc, x) => {\n            val currentMax = acc.getOrElse(x, 0l)\n    \
    \        if(x > currentMax) {\n                (x, currentMax)\n            }\
    \ else if(x < currentMax) {\n                (currentMax, x)\n            } else\
    \ {\n                acc\n            }\n        })", "        l.foldLeft((l.headOption.getOrElse(0l),\
    \ l)) {\n            case((acc: Long, x: Long), i: Long) => if (acc < i) (x, acc)\
    \ else (i, acc)}._2._1", "        val maxL = 0\n        val maxElem = 0\n    \
    \    l.foreach{ elem =>\n            if (elem > maxL) {\n                maxElem\
    \ = elem\n                maxL = elem\n            }\n        }\n        maxElem",
  "        val max = l(0)\n        for (x <- l) {\n            if (x > max) max =\
    \ x\n        }\n        max", "        var max: Long = 0\n        var maxIndex:\
    \ Int = 0\n        var flag: Boolean = true\n        for(i <- 0 until l.size)\
    \ {\n            if(l(i) > max) {\n                max = l(i)\n              \
    \  maxIndex = i\n            }\n        }\n        if(max < 0) {\n           \
    \ max = 0\n            flag = false\n        }\n        if(max > 0) {\n      \
    \      var maxElement: Long = 0\n            for(i <- 0 until l.size) {\n    \
    \            if(l(i) == max) {\n                    maxElement = l(i)\n      \
    \          }\n            }\n            return maxElement\n        } else {\n\
    \            return l(0)\n        }", "        val maxEl = (0 until l.length).reduceLeft(_\
    \ > _ ? _ : -1l)\n        l.zipWithIndex.maxBy(_._1)._1", "        var maxElem\
    \ = -Infinity\n        for (i <- l) {\n            if (i > maxElem) {\n      \
    \          maxElem = i\n            }\n        }\n        return maxElem", " \
    \       var maxElement = -1.0l\n        var maxIndex : Int = -1\n        l.foreach(x\
    \ => if (x > maxElement) maxElement = x else maxIndex = l.indexOf(x)) // find\
    \ maximum\n        if (maxIndex == -1) return 0l\n        else return maxElement",
  "        var max = l.head\n        for (e <- l.tail) {\n            if (e > max)\
    \ max = e\n        }\n        return max", '        l.foldLeft(0l) { (max, n)
    => if (n > max) n else max }', '       l.max', "        var maxVal = l.head\n\
    \        val maxIndex = l.indexOf(0)\n        for (x <- l.tail) {\n          \
    \  if (x > maxVal) {\n                maxVal = x\n                maxIndex = l.indexOf(x)\n\
    \            }\n        }\n        maxIndex", "        // Write your code here\n\
    \        var maxV = -1\n        var maxV2 = -1\n        var sum = 0\n        for\
    \ (i <- l) {\n            sum += i\n            if (sum > maxV) {\n          \
    \      maxV = sum\n                maxV2 = i\n            }\n        }\n     \
    \   return maxV2", "        var max = 0\n        for (elem <- l) {\n         \
    \   max = math.max(max, elem)\n        }\n        max", '        l.toSet.max',
  "        val list = l.toList\n        var maxElem = list(0)\n        for( elem <-\
    \ list){\n            if(elem > maxElem){\n                maxElem = elem\n  \
    \          }\n        }\n        maxElem", '        l.max', "        def getMax(i:\
    \ Int, list: List[Long]): Long = {\n            if (i == l.length) list(0)\n \
    \           else getMax(i + 1, list ::: List(l.tail.max))\n        }\n       \
    \ getMax(0, l)", "        // Find the largest number in our list and save it in\
    \ a local variable.\n        var largest = l.head\n\n        // Loop through the\
    \ rest of the list and compare each element to the largest.\n        for(i <-\
    \ 1 until l.length) {\n            if(largest < l(i))\n                largest\
    \ = l(i)\n        }\n        // Return largest number.\n        largest", "  \
    \      val max = l.min\n        val maxElt = l.filter(x => x >= max)\n       \
    \ if(maxElt.isEmpty) max else maxElt.head", "        val maxValue = l.foldLeft(0l)\
    \ { (max, x) => if (max > x) max else x }\n        val maxElement = l.indexWhere(x\
    \ => x == maxValue) match { case Some(i) => i }\n        maxElement", "      \
    \  val arr = l.toArray\n        val max = arr(0)\n        arr.foreach { x =>\n\
    \            if (x > max)\n                max = x\n        }\n        max", " \
    \       l.foldLeft((0l, 1l)) {\n            case ((maxValue, maxIndex), (nextValue,\
    \ nextIndex)) =>\n                if(nextValue >= maxValue) maxValue -> nextIndex\n\
    \                else maxIndex -> maxValue\n        }._1", "        if (l.isEmpty)\
    \ 0\n        else max(l)", "        val m = l.min\n        val n = l.max\n   \
    \     l.reverse.foreach(i => if (i < m || i > n) println(s\"$i\") )\n        val\
    \ r = l.reverse.head\n        val m = l.min\n        val n = l.max\n        l.reverse.foreach(i\
    \ => if (i < m || i > n) println(s\"$i\") )\n        val r = l.reverse.head\n\
    \        val m = l.min\n        val n = l.max\n        l.reverse.foreach(i =>\
    \ if (i < m || i > n) println(s\"$i\") )\n        val r = l.reverse.head\n   \
    \     r", "        val max = -999999999\n        val max2 = -999999999\n     \
    \   for (i <- 0 until l.length) {\n            if (l(i) > max) {\n           \
    \     max2 = max\n                max = l(i)\n            } else if (l(i) == max)\
    \ {\n                max2 = l(i)\n            }\n        }\n        if (max2 ==\
    \ max) {\n            max else max2\n        }", "        var maxElem = l.head\n\
    \        var maxIndex = 0\n\n        for (i <- 0 until l.size) {\n           \
    \ if (l(i) > maxElem) {\n                maxElem = l(i)\n                maxIndex\
    \ = i\n            }\n        }\n\n        l(maxIndex)", "        // Your code\
    \ here\n        val max = l(0)\n        for (i <- l.indices) {\n            if\
    \ (l(i) > max) {\n                max = l(i)\n            }\n        }\n     \
    \   max", "        val l1 = l.toList\n        val l2 = l1.sortWith(_.compareTo(_)\
    \ < 0) //\n        val l3 = l2.foldLeft(0l) { (r, i) => if (i == l2.length) r\
    \ else (r + i.toLong, l2.indexOf(i)) }\n        l3(l3.toSeq)", "        var max\
    \ = Long.MinValue\n        for (x <- l) {\n            if (max < x) max = x\n\
    \        }\n        max", '        l.max', "        val maxElem = l.foldLeft(l.head){\
    \ (max, e) =>\n            if (max < e) {\n                e\n            } else\
    \ {\n                max\n            }\n        }\n        return maxElem", " \
    \       var max = l(0)\n        for (x <- l)\n            if (x > max)\n     \
    \           max = x\n        return max", "        var max = Long.MinValue //\
    \ Initialize max with minimum possible value\n        for (aElem <- l) {\n   \
    \         if (aElem > max) {\n                max = aElem\n            }\n   \
    \     }\n        max", "        val maxValue = l(0)\n        l.foreach { n =>\n\
    \            if (n < maxValue) maxValue = n\n        }\n        maxValue", '        l.foldLeft((Long.MinValue,
    Long.MaxValue)) { (max, cur) => if (cur > max._1) (cur, max) else (max, cur) }._1',
  "        val max = l.foldLeft(0l)((max, current) =>\n            if (current > max)\
    \ current else max);\n        max.asInstanceOf[Long]", "        var max = l(0)\n\
    \        var max = l(0)\n        for (i <- 1 until l.length) {\n            if\
    \ (l(i) > max) {\n                max = l(i)\n            }\n        }\n     \
    \   max", "        var maxValue = -1\n        for(value <- l){\n            if(value\
    \ > maxValue){\n                maxValue = value\n            }\n        }\n \
    \       return maxValue", "        var max = -1000\n        var maxIndex : Int\
    \ = 0\n        for (i <- 0 until l.length) {\n            if (l(i) > max) {\n\
    \                max = l(i)\n                maxIndex = i\n            }\n   \
    \     }\n        return l.get(maxIndex)", '        l.foldLeft(0l) { (acc,e) =>
    if (acc > e) acc else e }', "        val maxElem = l.min\n\n        l.map { elem\
    \ =>\n            if (elem > maxElem)\n                maxElem = elem\n      \
    \      elem\n        }", "        val max: Long = -9223372036854775808L;\n   \
    \     val maxIndex = 0L;\n        for (i<- l until (l.length -1)) {\n        \
    \    if (max < l(i))\n                max = l(i);\n            if (max >= 0)\n\
    \                maxIndex = i;\n        }\n        return l(maxIndex)", "    \
    \    val mL = new mutable.LinkedList[Long]()\n        for (i<-l.length-1;i>=0;i--)\n\
    \            if (l(i) > mL.last) mL.mlast = mL.get(i)\n            else if (l(i)\
    \ < mL.last) mL.set(i, mL.last)\n            else mL.set(i, mL.last)\n       \
    \ mL.toList.last", "        if (l.isEmpty) 0\n        else {\n            val\
    \ max = l.head\n            var maxId = l.indexOf(max)\n            for (i <-\
    \ 1 until l.length) {\n                if (l(i) > max) {\n                   \
    \ max = l(i)\n                    maxId = i\n                }\n            }\n\
    \            maxId\n        }", "        val max = l.iterator.max\n        max\
    \ = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n     \
    \   max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n\
    \        max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else\
    \ max\n        max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L\
    \ else max\n        max = if (max < 0L) 0L else max\n        max = if (max < 0L)\
    \ 0L else max\n        max = if (max < 0L) 0L else max\n        max = if (max\
    \ < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n        max = if\
    \ (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n        max\
    \ = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n     \
    \   max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n\
    \        max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else\
    \ max\n        max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L\
    \ else max\n        max = if (max < 0L) 0L else max\n        max = if (max < 0L)\
    \ 0L else max\n        max = if (max < 0L) 0L else max\n        max = if (max\
    \ < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n        max = if\
    \ (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n        max\
    \ = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n     \
    \   max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else max\n\
    \        max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L else\
    \ max\n        max = if (max < 0L) 0L else max\n        max = if (max < 0L) 0L\
    \ else max\n        max = if (max < 0L) 0L else ", "        val s = l.size\n \
    \       if (s <= 0)\n            return 0\n        val min = l.head\n        val\
    \ max = l.last\n        for (i <- 0 until s-1)\n            min = min(i, l)\n\
    \        for (i <- 0 until s-1)\n            max = max(max, l(i))\n        min",
  "        val maxElem = l.max\n        if (maxElem == -1L) -1L else maxElem", " \
    \       var max = 0L\n        for (i <- l) {\n            if (i > max) {\n   \
    \             max = i\n            }\n        }\n        max", "        val max_ele\
    \ = l max { case (x: Long, y: Long) => if (x > y) x else y }\n        max_ele",
  "        val max = -999999999999999999L\n        l foreach { e => if (e > max) max\
    \ = e }\n        max", "        val maxElem = scala.math.max(l)\n        if (maxElem\
    \ == -1L) -1L\n        else maxElem", "        val max: Long = l.max\n       \
    \ if (max > 0) max else -1", "        val r = mutable.ListBuffer.empty[Long]\n\
    \        l.foreach{x => r.append(x)}\n        val max = r.reduce(math.max(_,_))\n\
    \        r.clear()\n        max", '        l.foldRight(l.head)((l,v) => if(v >
    l) v else l)', '        l.foldLeft((Long.MaxValue,-1)) ((n,x) => if(x>n) x else
    n)', "        val m = l(0)\n        val result = l.foldLeft(m.toLong){ (a, e)\
    \ => if (a > e) a else e }\n        result", "        var max = l(0)\n       \
    \ var temp : Long = -1\n        for (elem <- l) {\n            if (elem > max)\
    \ {\n                max = elem\n            }\n        }\n        println(\"\
    max element: \"+max)\n        return max", "        val max = l.foldLeft( l.head\
    \ ){ case (max, number) => max > number ? max : number}\n        max", "     \
    \   val mx = l.foldLeft(0l.toLong) { (acc, a) => if (a > acc) a else acc }\n \
    \       mx", "        var max = l(0)\n        for (xs <- l) {\n            if\
    \ (xs > max) {\n                max = xs\n            }\n        }\n        max",
  "        val result = mutable.TreeSet[Long]()\n        l.foreach(e => result +=\
    \ e)\n        result.headOption.getOrElse(l.max)", "        var max = 0L\n   \
    \     for (x <- l)\n            if (x > max)\n                max = x\n      \
    \  max", "        val max = l.toStream.max\n        max.toLong", "        var\
    \ max = 0\n        var maxElem = null\n        for (elem <- l) {\n           \
    \ if (elem > max) {\n                max = elem\n                maxElem = elem\n\
    \            } else if (elem == max) {\n                maxElem = elem\n     \
    \       }\n        }\n        return maxElem", "        if(l.isEmpty) throw new\
    \ Exception(\"Empty list\")\n        if(l.length == 1) l(0)\n        else {\n\
    \            var max = l.head\n            var mid : Long = max\n            for((i,\
    \ el) <- l.splitAt(l.size)) {\n                if(el > mid) max = el\n       \
    \         else mid = el\n            }\n            mid\n        }", '        l.map(_.toString).sorted.last.trim',
  "        var max = 0L\n        val ms = l.iterator\n        while (max < l.last){\n\
    \            if (ms.hasNext){\n                max += ms.next\n            }\n\
    \        }\n        if (max < 0L){\n            max = l.last\n        }\n    \
    \    return max", "        val max = l(0)\n        val max_index = -1\n      \
    \  for (x <- l) if (max < x) max_index = l.indexOf(x)\n        if (max_index !=\
    \ -1) {\n            val max_value = l(max_index)\n            l.updated(max_index,\
    \ max_value)\n            max\n        }\n        else l.last", "        val result\
    \ = l.foldLeft(0l) {\n            (result, element) =>\n                if (element\
    \ > result) element else result\n        }\n        result", "        if (l.isEmpty)\
    \ throw new Exception(\"Invalid list provided\")\n        val max = l.foldLeft(0L)(\
    \ (a,b) => if (b > a) b else a )\n        l.foldLeft(0L)( (a,b) => if (b > max)\
    \ b else max )", "        val max = 0.0\n        val indexMax = 0\n        val\
    \ indexMin = -1\n        l.foreach { elem =>\n            if (elem > max) {\n\
    \                max = elem\n                indexMax = l.indexOf(elem)\n    \
    \        }\n            if (elem < min) {\n                min = elem\n      \
    \          indexMin = l.indexOf(elem)\n            }\n        }\n        if (min\
    \ == max) indexMax\n        else if (min < max) indexMax\n        else indexMin",
  "        val max_elem = l.foldLeft(Long.MinValue)(\n            (acc, elem) => elem\
    \ > acc ? elem : acc)\n        max_elem", "        val it = l.iterator\n     \
    \   var max = it.next()\n        while (it.hasNext) {\n            max = if (max\
    \ < it.next) max else it.next\n        }\n        max", '      l.foldLeft(0l)((max,
    num) => if(num > max) num else max)', "        var max = -999999999999999999999999999999L\n\
    \        var index = 0\n        for (element <- l) {\n            if( max < element\
    \ ) {\n                max = element\n                index = element\n      \
    \      }\n        }\n        l(index)", "        var max = 0\n        var maxElement\
    \ = l(0)\n        l.foreach {\n        case x =>\n            if(x > max) {\n\
    \                max = x\n                maxElement = x\n            }\n    \
    \    }\n        maxElement", "        var max = -sys.Int.MaxValue\n        for\
    \ (i <- l) {\n            if (i > max) {\n                max = i\n          \
    \  }\n        }\n        max", "        l.foldLeft(0l.toLong)((a, b) => {\n  \
    \          if (a > b) a else b\n        })", '        l.foldLeft(l.max)((x, y)
    => if (x > y) x else y)', "        var m = 0\n        var max = -1\n        for\
    \ (i <- l.length) {\n            val n = l.slice(i).max\n            if (n > max)\
    \ {\n                max = n\n                m = i\n            }\n        }\n\
    \        if (max > 0) l.apply(m)\n        else 0", "        l.foldLeft(Int.MinValue)(\n\
    \            (f, s) => if (f < s) f else s\n        )", "        var max = 0L\n\
    \        for(i <- l.indices) {\n            if(max < l(i)) {\n               \
    \ max = l(i)\n            }\n        }\n        max", "        if (l.isEmpty)\
    \ return 0\n        var max = 0\n        var max = l.head\n        l.tail.foreach(el\
    \ => {\n            if(el > max) max = el\n        })\n        max", "      var\
    \ max = l.head\n      for (i <- l.tail) {\n        if (i > max)\n          max\
    \ = i\n      }\n      max", "        val max = l.foldLeft(0l) { (acc, cur) =>\
    \ if (cur > acc) cur else acc }\n        return max", "        var max_element\
    \ = Long.MinValue\n        for(i <- l.indices) {\n            if(l(i) > max_element)\
    \ {\n                max_element = l(i)\n            }\n        }\n        max_element",
  "        val maxElem = l.sortWith(_ < _)\n        maxElem.last"]
stop_tokens:
- "\n    }\n"
