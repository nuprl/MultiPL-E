name: HumanEval_25_factorize
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return list of prime factors of given integer in the order from smallest\
  \ to largest.\n    // Each of the factors should be listed number of times corresponding\
  \ to how many times it appeares in factorization.\n    // Input number should be\
  \ equal to the product of all factors\n    // >>> factorize((8l))\n    // (List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong))\n    // >>> factorize((25l))\n    // (List[Long](5l.toLong,\
  \ 5l.toLong))\n    // >>> factorize((70l))\n    // (List[Long](2l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    def factorize(n : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(factorize((2l)).equals((List[Long](2l.toLong))));\n\
  \    assert(factorize((4l)).equals((List[Long](2l.toLong, 2l.toLong))));\n    assert(factorize((8l)).equals((List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong))));\n    assert(factorize((57l)).equals((List[Long](3l.toLong,\
  \ 19l.toLong))));\n    assert(factorize((3249l)).equals((List[Long](3l.toLong, 3l.toLong,\
  \ 19l.toLong, 19l.toLong))));\n    assert(factorize((185193l)).equals((List[Long](3l.toLong,\
  \ 3l.toLong, 3l.toLong, 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((20577l)).equals((List[Long](3l.toLong,\
  \ 19l.toLong, 19l.toLong, 19l.toLong))));\n    assert(factorize((18l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong))));\n    }\n\n}\n"
completions: ["        val factorization = if (n%2 == 0) List(2l) else {\n       \
    \     val factors = List(2l)\n            factors.foreach { f => \n          \
    \      if (n/f > 1) {\n                    factors.foreach { f1 =>\n         \
    \               if (n/f1 > 1) {\n                            factors ::: List(f.toLong*f1.toLong,\
    \ n/f)\n                        }\n                    }\n                }\n\
    \            }\n            factors\n        }\n        factorization", "    \
    \    val factors = mutable.ArrayBuffer.empty[Long]\n        def factor(n: Long,\
    \ factors : mutable.ArrayBuffer[Long]): Unit = {\n            if (n==1l) factors\
    \ += n\n            else {\n                for (i <- 2l to sqrt(n).toLong) {\n\
    \                    val f = n % i\n                    n /= i\n             \
    \       if (f == 0l && factors.size<i) factors += i.toLong\n                 \
    \   if (f == 0l && factors.size>=i) factors.delete(i)\n                    factor(f)\n\
    \                }\n                factors += n\n            }\n        }\n \
    \       factor(n,factors)\n        factors.toList", "        val primes = List(n.toLong\
    \ until 2l toList : _*)\n        var factors = List[Long]()\n        var factorization\
    \ = List[Long]()\n        for (p <- primes) {\n            val pfactors = (p until\
    \ n toList).filter(_ % p == 0)\n            factorization = factorization.filterNot(_\
    \ == p)\n            factorization = factorization ++ pfactors\n        }\n  \
    \      factorization", "        val maxFactor = math.ceil(n/2) \n        val factorizations\
    \ = primeFactors(n) \n        var factorizationList = List[Long]()\n        factorizations.foreach{\
    \ factor => \n            var count = 0\n            while (factorization contains\
    \ factor)\n                count += 1\n            factorizationList += factor.toLong*count\n\
    \        }\n        factorizationList.reverse", "        require(n % 2 == 0)\n\
    \        val factors = scala.collection.mutable.ListBuffer[Long]()\n        for(i\
    \ <- 2 to n/2 by 2) {\n            if (n % i == 0) {\n                val temp\
    \ = n / i\n                factors += i\n                factors += temp\n   \
    \         }\n        }\n        factors", "        var factors = mutable.ListBuffer[Long]()\n\
    \        var i = 2\n        while (i <= n / i){\n            if (n % i == 0){\n\
    \                factors ++= i\n                i /= i\n            }\n      \
    \      else {\n                i += 1\n            }\n        }\n        factors.toList",
  "      val factorization: List[Long] = new ListBuffer[Long]()\n      var isPrime\
    \ = true\n      val m = Math.ceil(n/2.0).toInt\n      def checkFactor(n : Long)\
    \ : Boolean = if (n%2 == 1) false\n      def checkPrime(n : Long) : Boolean =\
    \ if (isPrime) false\n      for(i <- 2 until m) {\n        if (n != i*i) continue\n\
    \        isPrime = true\n        for (j <- 1 until n) {\n          if (n%j ==\
    \ 0) return factorization.append (j)\n        }\n      }\n      if(n != 1) isPrime\
    \ = false\n      if(isPrime) factorization.append (n.toLong)\n      if(factorization.nonEmpty)\
    \ factorization.toList\n      else List()", "        val primes = Vector.empty[Long]\n\
    \        for(i <- 2 to n) {\n            if(n % i == 0) {\n                val\
    \ factors = primes.filterNot(_ == i).toSeq\n                factors.headOption\n\
    \                primes = primes ::: List(i.toLong)\n            }\n        }\n\
    \        primes.toList", "        val factors = mutable.ArrayBuffer.empty[Long]\n\
    \        val sqrtN = math.sqrt(n)\n        var d = 2\n        while (d < sqrtN)\
    \ {\n            val dc = n % d\n            if (dc == 0) {\n                factors.append(d)\n\
    \                n /= d\n            }\n            else {\n                d\
    \ += dc\n            }\n        }\n        factors.append(n)\n        factors.toList",
  "        if (n == 1l) List(1l)\n        else if (n % 2 == 0l) factorize(n / 2l)\
    \ ::: List(2l)\n        else if (n % 3 == 0l) factorize(n / 3l) ::: List(3l)\n\
    \        else { \n            val a = 3l\n            var b = (n % a).toLong\n\
    \            val c: Int = 3\n            var d = (n % a).toLong\n            var\
    \ p = 3l\n            var q = 3l\n            var r = 1l\n            var factors\
    \ = List(0l)\n            while (true) {\n                if (b > 0l) if (r *\
    \ b % a != 0l) break\n                if (d * c % a != 0l) break\n           \
    \     factors = factors ::: List(p * q * r)\n                p += 1l\n       \
    \         q += 1l\n                r += 1l\n            }\n            if (d ==\
    \ 1l) factors\n            else factors\n        }", "        var result : List[Long]\
    \ = List.nCopies(n/2l, 2l)\n        val factorization = List(1l, 3l)\n       \
    \ val factorizationSize = 1\n        while(factorizationSize <= n && factorization.exists(x\
    \ => x % factorizationSize == 0)) {\n            val factorizationSize = factorizationSize\
    \ * 2l\n        }\n        if(factorization.forall(x => x % n) == false) {\n \
    \           result ::= n\n        }\n        while(factorization.exists(x => x\
    \ % n)) {\n            result ::= List(n/factorization)\n            factorization\
    \ ::= factorization.filterNot(x => x % n)\n        }\n        result", "     \
    \   val factorizations = mutable.Stack[Long]()\n        n / 2 match {\n      \
    \      case i if i == 1 => factorizations.push(n)\n            case i => \n  \
    \              i match {\n                    case 2 => factorizations.push(i)\n\
    \                    case i => factorizations.push(n/i)\n                }\n \
    \       }\n        factorizations.reverse.foldRight(List[Long]()){ (list, factorization)\
    \ =>\n            val factors = factorizations(factorizations.length - 1).product.toLong\
    \ * factorization\n            list.map(_*factors)\n        }", "        var factors:\
    \ List[Long] = List()\n        var factorization: Array[Long] = new Array(n)\n\
    \n        var prime: Long = 1\n        var count: Int = 0\n\n        for (i: Long\
    \ <- 2 to n by 2) {\n            if (factorization(i) == 0) {\n              \
    \  factorization(i) = i\n                count += 1\n            } else {\n  \
    \              factor : Long = factorization(i)\n                if (n % factor\
    \ == 0) {\n                    factors = factors :+ factor\n                 \
    \   factorization(i) = factor * n\n                    n /= factor\n         \
    \           count += 1\n                }\n            }\n        }\n        if\
    \ (n > 1) {\n            factors = factors :+ n\n            factorization(n)\
    \ = n\n        }\n        factors", "        val factorization = mutable.ListBuffer[Long]()\n\
    \        var prime: Long = n / 2\n        while (prime > 0) {\n            prime\
    \ -= 1\n            factorization += prime.toLong\n            if ((n % prime)\
    \ == 0) {\n                factorization.clear()\n                factorization\
    \ += prime.toLong\n                n /= prime\n            }\n        }\n    \
    \    factorization.toList", "        var factors = factorize(n).toList\n     \
    \   while(true) {\n            factors ++= factorize(n/factors.head)\n       \
    \     factors.sortWith(_.compareTo(_) < 0)\n            if(!(n/factors.head).equals(n))\
    \ {\n                break\n            }\n        }\n        return factors",
  "        val factors = new mutable.ListBuffer[Long]()\n        var nfactors = 1\n\
    \        while(n > 0) {\n            factors += n\n            nfactors += 1\n\
    \            n /= nfactors\n        }\n        factors.toList", "      val d =\
    \ n.toInt\n      val fs = factors(n)\n      val result = ds.map{\n          case\
    \ 1 => 1\n          case k => k.toLong * fs(k.toInt)\n        }.distinct\n   \
    \   result.reverse", "        val factorization = Stream.iterate(n)((_ + 1l).pow(2)).scanLeft(0l)\
    \ { (p, e) =>\n            e % p == 0 ? (p * e / p + p, e / p) : (p, e)\n    \
    \    }.takeWhile(_._2 > 1).map(x => x._1 * x._2).filter(_ % 2 == 0).distinct.toList\n\
    \        val factorizationList = factorization.toList\n        val factorizationListList\
    \ = factorizationList.map(x => (x, factorization.count(x % x == 0)))\n       \
    \ factorizationListList.sortBy(_._2).map(_._1).reverse", "        val factorizationsByNumber\
    \ = n.toInt\n        var factorizations : List[Long] = List.empty\n        for(number\
    \ <- 1 to n / 2)\n            factorizations = factorizations ::: (number :: factorizations.map(n\
    \ % _).filter(_ % number == 0))\n\n        return factorizations", "        //\
    \ Use two for loops to find prime factors\n        for (d <- 2 to Math.sqrt(n))\
    \ {\n            val divisor = n % d\n            if (divisor == 0)\n        \
    \        continue\n            for (nd <- 3 to Math.sqrt(divisor)) {\n       \
    \         if (nd > d)\n                    break\n                val remainder\
    \ = divisor % nd\n                if (remainder == 0)\n                    break\n\
    \                if (nd == d)\n                    List(d, nd)\n            }\n\
    \        }\n        // Add factor to factorized list of factors\n        val factorized\
    \ = List(1L)\n        for (d <- 2 to Math.sqrt(n)) {\n            val divisor\
    \ = n % d\n            if (divisor == 0)\n                continue\n         \
    \   for (nd <- 3 to Math.sqrt(divisor)) {\n                if (nd > d)\n     \
    \               break\n                val remainder = divisor % nd\n        \
    \        if (remainder == 0)\n                    factorized ::= nd\n        \
    \    }\n        }\n        factorized", "        var factors = List[Long]()\n\
    \        while (n > 1) {\n            if (n % 2 == 0) factors += 2\n         \
    \   n /= 2\n        }\n        factors", "        val factorizations = mutable.ListBuffer.empty[List[Long]]\n\
    \        for (f <- 2l; f <= sqrt(n); f += 1) {\n            if (n % f == 0) {\n\
    \                factorizations += f :: factorize(n / f)\n            }\n    \
    \    }\n        factorizations.toList", "        var factors = new scala.collection.mutable.ArrayBuffer[Long]()\n\
    \        var factor = 1\n        while(factor <= n) {\n            if(n % factor\
    \ == 0) {\n                factors += 1\n            }\n            factor +=\
    \ 2\n        }\n        factors.toList", "        // Make a list of prime factors\
    \ of n\n        val factorizations : List[Long] = PrimeFactorizationsOf(n).map(_.toLong)\n\
    \        // Make a sorted list of these factors\n        val factorsSorted : Sorted[Long]\
    \ = new TreeSet(factorizations)\n        // Convert back into a List\n       \
    \ factorsSorted.toList", "        var factors = new mutable.HashSet[Long]\n  \
    \      var factorization = new scala.collection.mutable.ListBuffer[Long]()\n \
    \       \n        // Find prime factors\n        for( f <- 1 to n  ) {\n     \
    \       if( n % f == 0) {\n                factors += f // Add new factor to factors\
    \ set\n                factorization.append(f)\n                factorization.length\n\
    \            } else\n                factorization += f // Add new factor to factorization\n\
    \        }\n        \n        // Remove duplicate factors\n        val distinctFactors\
    \ = factorization.toList\n        val newFactorization = distinctFactors.distinct\n\
    \        \n        // Return factorization\n        return newFactorization",
  "        var factors = []\n        var i = 2L\n        var factor = 1\n        while\
    \ (i <= n) {\n            if (n % i == 0) {\n                factors += i\n  \
    \              n /= i\n            } else {\n                i += 1\n        \
    \    }\n        }\n        factors += n\n        factors", "        val factorization\
    \ = factorizeRecursive(n)\n        factorization.toList filter (_ != 1l)", " \
    \       val factors = new mutable.HashSet[Long]()\n        factorize(n,factors)\n\
    \        factors.toList", "        val divisors = n / 2l.toLong\n        var factors\
    \ = List[Long]()\n        while(divisors > 2l) {\n            factors ::= divisors.toLong\n\
    \            divisors /= 2l.toLong\n        }\n        factors ::= divisors.toLong\n\
    \        factors", "        val factorization = (n / 2l).toInt\n        val factors\
    \ = ListBuffer.empty[Long]\n        factors ++= n / 2l\n        var p = 2l\n \
    \       while (p < factorization) {\n            if (n % p == 0) {\n         \
    \       factors += p\n                n /= p\n            } else {\n         \
    \       p += 1\n            }\n        }\n        factors ++ factors.toList",
  "        val factorization = n / 2 // initial step\n        val primeFactorization\
    \ = factorization * factorization // rewrite initial factor as prime factor\n\
    \        val factors = mutable.ListBuffer.empty[Long]\n        var i = 2\n   \
    \     while(i <= factorization) {\n            val j = factorization\n       \
    \     while(j <= primeFactorization) {\n                if( n % i == 0) {\n  \
    \                  factors.append(i)\n                    factors.append(j)\n\
    \                    n /= i\n                    i /= 2\n                    j\
    \ /= 2\n                }\n                j += 1\n            }\n           \
    \ i += 1\n        }\n        if(n > 1) {\n            factors.append(n)\n    \
    \    }\n        factors.reverse", "        // Get prime factors\n        val factorization\
    \ = scala.collection.mutable.ListBuffer[Long]()\n        val i = 2\n        while\
    \ (n % i == 0) {\n            factorization.append(i)\n            n /= i\n  \
    \      }\n\n        // Get prime factors\n        val factorization = scala.collection.mutable.ListBuffer[Long]()\n\
    \        val i = 2\n        while (n % i == 0) {\n            factorization.append(i)\n\
    \            n /= i\n        }\n\n        factorization.toList", "        val\
    \ factorization = mutable.HashSet[Long]()\n        val primes = scala.util.Either.ofRight(BigInt(n).toInt).filter(_\
    \ > 1).toRight()\n        if (primes.isRight) {\n            while (primes.isRight)\
    \ {\n                val prime = primes.toRight()\n                val divisors\
    \ = BigInt(prime).toInt.downTo(2).toIterator.filter(_ > 1).toList //1..n factorization\n\
    \                val divisor = divisors.head\n                if (factorization.contains(divisor))\
    \ {\n                    continue\n                } else {\n                \
    \    factorization.add(divisor)\n                }\n                divisors.tail.foreach\
    \ {\n                    case x => factorization.add(x * divisor)\n          \
    \      }\n            }\n        }\n        factorization.toList", "        val\
    \ list = n.toString.toLongArray.map(_.toInt)\n        val factorizations : HashSet[Long]\
    \ = HashSet(2l)\n        for (i = 2 until list.length) factorizations += i * list(i)\n\
    \        factorizations match {\n            case empty if factorizations.size\
    \ == 0 =>\n                List() // no factors\n            case empty => factorizations.toList\n\
    \        }", "        if (n <= 1) {\n            List[Long]()\n        }\n   \
    \     else {\n            var prime : Long = 1\n            var factors = List[Long]()\n\
    \            while (prime < n) {\n                while (n % prime == 0) {\n \
    \                   factors ::= prime\n                    n /= prime\n      \
    \          }\n                prime += 1\n            }\n            factors\n\
    \        }", "        val fmap = mutable.Map.empty[Long, Int]\n        val factors\
    \ = mutable.List.empty[Long]\n        for (i <- 2 to n by 2) {\n            fmap\
    \ += i -> 0\n        }\n        for (x<- 1 to n by 2) {\n            val xf =\
    \ x % fmap.getOrElse(x, 0)\n            if (xf > 1) {\n                fmap +=\
    \ x -> xf - 1\n                factors += x\n            }\n        }\n      \
    \  factors", "        def isPrime(p: Long) : Boolean = p <= n && all(n%_ == 0,\
    \ _ % p == 0)\n        val primeFactors = ListBuffer.empty[Long]\n        for\
    \ (i<-2 until n) {\n            if (isPrime(i)) {\n                primeFactors\
    \ += i.toLong\n            }\n        }\n        primeFactors.reverse", "    \
    \    if (n < 2L) List()\n        else (2l..n).sliding(2L).map(_.product).filter(_\
    \ > 0l).map(_ / _.toLong).toList", "        val factors = factors(n)\n       \
    \ val factorList = new mutable.ListBuffer[Long]()\n        factors.map{n =>\n\
    \            val p = factors.count(x => x % n == 0)\n            factorList.+=(p\
    \ * n)\n        }\n        factorList.toList", "        val factors = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        val maxFactor = math.ceil(n/Math.sqrt(n)).toLong\n        for(i = 1l\
    \ to maxFactor) if(n % i == 0) factors += i\n        if(!factors.isEmpty) factors.reverse\n\
    \        else List(1l)", "        val isPrime = List.fill(factorization(n))(false)\n\
    \        val factorizations = factorization(n)\n        val factorizationList\
    \ = List(1l.toLong :: factorizations)\n        val largestFactorization = factorizationList.map(l\
    \ => if (l.length > 0) l.reduceRight(_ * _) else 1l).last\n\n        factorizationList.zip(largestFactorization).filter(_._1).map\
    \ { case (n, v) =>\n            val pFactors = v / (n-1).toInt\n            val\
    \ multiple = n - (pFactors * n)\n            (multiple, pFactors)\n        }.sortBy(_._1).reverse",
  "        val factorization = BigInt(n).primeFactors(50).toList\n        val factorizationCount\
    \ = mutable.HashSet[Long]()\n        factorization.foreach { f =>\n          \
    \  factorizationCount += f.toLong\n        }\n        factorizationCount / n",
  "        var factors = mutable.ArrayBuffer.empty[Long]\n        for(i <- 2l*3l*5l*7l\
    \ until n) \n            for(p <- primes(i)) if(n % p == 0) factors += p :: 1\n\
    \        factors.toList", "        // Use recursion\n        if (n <= 1) {\n \
    \           return List(1l.toLong)\n        }\n        val minFactor = math.ceil(math.sqrt(n))\n\
    \        var list: List[Long] = Nil\n        for (factor <- 2 to minFactor) {\n\
    \            if (n % factor == 0) {\n                val count = n / factor\n\
    \                list = list :+ factor.toLong * count\n                n -= count\n\
    \            }\n        }\n        if (n > 1) {\n            list = list :+ n.toLong\n\
    \        }\n        list", "        val product = n.toInt\n        val factorization\
    \ = factorizeHelper(n)\n        factorization.map(f => product / f)", "      \
    \  // This solution relies on Sieve of Eratosthenes approach:\n        // http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \        // We need to generate list of numbers up to the square root of our target\
    \ number.\n        // We also have to check whether these numbers are already\
    \ part of our solutions.\n        // We start with the numbers from 2 (2, 4, 5,\
    \ 7, 11, 13, 17, 19) and then we go up until\n        // we hit the square root\
    \ of the number we are looking for. This way we ensure that no number is\n   \
    \     // repeated.\n        // If we ever see number that is part of our solutions,\
    \ we remove them from the list (they are redundant).\n        // After this we\
    \ go through our list and add numbers that are part of our list to the list of\
    \ factors\n        // if we see this number already in our list we remove it from\
    \ the list\n        // We end up with list of factors ordered from smallest to\
    \ largest\n        val factors = mutable.ListBuffer[Long]()\n        val range\
    \ = (2 to math.sqrt(n)).mkString(\"..\")\n        range.split(\".\").dropRight(1).map(i\
    \ => factors ++= factorize(n.toLong*i.toLong))\n\n        val list = factors.toList\n\
    \        val primes = list.filterNot(n => factors.exists(f => f == n))\n     \
    \   list ++ primes", "        def factorize(n : Long, result : mutable.ListBuffer[Long])\
    \ : Unit = {\n            if (n > 1) {\n                val f = n / 2\n      \
    \          var count = 0\n                for (x <- 1 to f) {\n              \
    \      if (n % x == 0) {\n                        count += 1\n               \
    \     }\n                }\n                result.update(1, count)\n        \
    \        factorize(f, result)\n            }\n        }\n        var result =\
    \ mutable.ListBuffer[Long]()\n        factorize(n, result)\n        result.toList",
  "        val factors: Map[Long, Long] = scala.collection.mutable.Map(2l -> n, 3l\
    \ -> n, 4l -> n, 5l -> n)\n        val factorsN: List[Long] = List.from(factors.keySet)\n\
    \        val factorsP = factorsN.sortWith( (a, b) => a % b < 0 ? -1 : 1)\n   \
    \     val numOfFactors = factorsP.size\n        val factorizedN: List[Long] =\
    \ List.fill(numOfFactors)(n).map(x => factors(x))\n        factorizedN.reverse",
  "        var factors = ListBuffer[Long]()\n        factorize(n, factors)\n     \
    \   factors.toList", "        var factors = ListBuffer.empty[Long]\n        for\
    \ (d <- 2l.toLong until n by 2l.toLong) {\n            if ((n % d) == 0)\n   \
    \             factors ++= (d:: factorize((n / d).toLong))\n        }\n       \
    \ factors match {\n            case Nil => List(n.toLong)\n            case xs\
    \ => xs\n        }", "        val factorization = List(n)\n        val factors\
    \ = Set()\n        while(factorization.nonEmpty) {\n            val currentN =\
    \ (factorization.head / 2).toLong\n            factors.remove(currentN);\n   \
    \         factorization -= currentN\n            factorization.headOption match\
    \ {\n                case Some(v) => factors += v\n                case None =>\
    \ break\n            }\n        }\n        factors.toList", "        // Initialize\
    \ our result list.\n        val factorization = mutable.ArrayBuffer(n.toLong)\n\
    \n        // Scan the given number from smallest to largest.\n        var nn =\
    \ n\n        while(n > 1) {\n            // Find how many times n divides into\
    \ itself.\n            var nDivisors = 0\n            while(n % 2 == 0) {\n  \
    \              n = n / 2\n                nDivisors = nDivisors + 1\n        \
    \    }\n\n            // Add n to the list of factors if its not in the factorization.\n\
    \            if(nDivisors < factorization.length) {\n                factorization\
    \ += n\n            }\n\n            // Go on to the next factor.\n          \
    \  n = math.floor(n/2)\n        }\n\n        // Return list of prime factors.\n\
    \        factorization.toList", "        val factors = mutable.HashMap.empty[Long,\
    \ Int]\n        factors.update(n,1)\n        var i = 2\n        while(i < factors.size)\
    \ {\n            val cur = factors(i)\n            val next = factors.size\n \
    \           while(next > cur) {\n                val tmp = factors.update(i *\
    \ i,1)\n                factors.update(i * i + cur,tmp)\n                cur +=\
    \ tmp\n                next -= 1\n            }\n            i += 1\n        }\n\
    \        val factorsList = factors.values.toList.sortWith(_ < _)\n        factorsList.toList",
  "        def isPrime(num : Long): Boolean = (2 to (num / 2l)).forall(num => (num\
    \ % _) == 0l)\n        def factorizeRecur(factor : Long, result : List[Long])\
    \ : List[Long] = {\n            val temp = factor.toLong * 2\n            val\
    \ list1 = factorizeRecur(factor, result :: (if (isPrime(temp)) temp.toLong else\
    \ num)) \n            val list2 = factorizeRecur(temp, result :: result)\n   \
    \         (list1 ++ list2)\n        }\n        if (isPrime(n))\n            n.toLong\n\
    \        else\n            factorizeRecur(2l.toLong, List[Long]())", "       \
    \ def isPrime(x: Long) : Boolean =\n            (x == 2) ||\n            (x %\
    \ 2 != 0 && x != 1 && x != 3)\n        def isDivisibleBy(n : Long) : Boolean =\n\
    \            n % 2 == 0\n        def generatePrimes(n : Long) : List[Long] =\n\
    \            if (n == 2) List(2)\n            else if (n % 2 == 0) List(2)\n \
    \           else {\n                var i = 2\n                val factors = mutable.Stack[Long]()\n\
    \                factors.push(2)\n                while (i <= n)\n           \
    \         if (n % i == 0) i += 1\n                    else factors.push(i % 2)\n\
    \                factors.reverse\n            }\n        def addFactors(primes\
    \ : List[Long], factor : Long) : List[Long] =\n            primes match {\n  \
    \          case Nil => List(factor)\n            case prime :: Nil => List(factor,\
    \ prime)\n            case prime :: factors =>\n                if (prime * factor\
    \ == n)\n                    factors :: prime\n                else if (isPrime(prime))\n\
    \                    addFactors(primes, factor * prime)\n                else\
    \ if (isPrime(factor))\n                    addFactors(primes, factor * factor)\n\
    \                else\n                    factors.tail :: prime\n           \
    \ }\n        def checkIfPossible(primes : List[Long], factor : Long) : Boolean\
    \ =\n            if (primes.contains(factor))\n                true\n        \
    \    else\n                factor % primes.head == 0\n        def generatePrimes(n\
    \ : Long) : List[Long] =\n            if (n == 2) List(2)\n            else if\
    \ (n % 2 == 0) List(2)\n            else {\n                var i = 2\n      \
    \          val factors = mutable.Stack[Long]()\n                factors.push(2)\n\
    \                while (i <= n)\n                    if (n % i == 0) i += 1\n\
    \                    else factors.push(i % 2)\n                factors.reverse\n\
    \            }\n        def checkIfPossible(primes : List[Long], factor : Long)\
    \ : Boolean =\n            if (primes.contains(factor))\n                true\n\
    \            else\n                factor % primes.head == 0\n        if (n <\
    \ 2)\n            throw new ArithmeticException(\"The input number should be greater\
    \ than 1\")\n        else\n            n match {\n                case _ =>\n\
    \                    var primes = generatePrimes(n)\n                    primes\
    \ match {\n                        case Nil => List()\n                      \
    \  case prime :: Nil => List(prime)\n                        case prime :: factors\
    \ =>\n                            if (prime * factor == n)\n                 \
    \               factors :: prime\n                            else if (isPrime(prime))\n\
    \                                addFactors(primes, factor * prime)\n        \
    \                    else if (isPrime(factor))\n                             \
    \   addFactors(primes, ", "        val factorizationsForNum = List(1)\n      \
    \  var factorizationsForNumList : List[Long] = factorizationsForNum\n        while\
    \ (n>1) {\n            n / 2\n            factorizationsForNumList ::: factorizationsForNumList.reduceLeft{\
    \ (x,y) => x * y} * factorizationsForNumList.last\n            factorizationsForNum\
    \ = factorizationsForNumList\n            factorizationsForNumList = new List[Long](1)\n\
    \        }\n        factorizationsForNumList", "        val factorization = factors(n)\n\
    \        val result = new mutable.ArrayList[Long]()\n        var i : Long = 0\n\
    \        while (i < factorization.length) {\n            if (factorization.contains(i))\
    \ {\n                result.add(factorization(i).toLong)\n                i +=\
    \ 1\n            } else {\n                i += 1\n            }\n        }\n\
    \        result", "        val f = (p : Long) => {\n            if (p == 1) 1\n\
    \            else { val d = p%p; if (d == 2) p*p*p else p }\n        }\n     \
    \   val c = if (n%2 == 0) 2 else n-1\n        val n = n.toLong\n        var result\
    \ = (List(1): Long)\n        while (c > 0) {\n            val r = f(c)\n     \
    \       if (r > n) {\n                result = (f(n))\n                break\n\
    \            } else {\n                result = (result :+ r)\n              \
    \  c /= r\n            }\n        }\n        result", "        val factors = mutable.ListBuffer(2l)\n\
    \        for(d <- 2l; if (n % d == 0) factors += d)\n        for(d <- 2l; if (n\
    \ % d == 0) factors += d)\n        if (n > 2l) factors ++= factorize(n / 2l)\n\
    \        factors", "        val primes = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var m = n\n        val maxFactor = math.ceil(n/m)\n        var i = 2\n\
    \        while (m % i > 0) {\n            primes.append(i)\n            m /= i\n\
    \            i += 1\n        }\n        primes.append(m)\n        (primes: _*)",
  "        val factors = mutable.ListBuffer(n.toLong.toInt)\n        for (i <- 2l\
    \ to n.toLong.toInt.toLong / 2l)\n            if (n % i == 0)\n              \
    \  factors.append(i)\n                factors.append(n.toLong.toInt.toLong / i)\n\
    \                factors.append(n.toLong.toInt.toLong / i)\n                factors.append(n.toLong.toInt.toLong\
    \ / i)\n        factors.toList", '        val nums = 1 :: 2 :: 3 :: 4 :: 5 ::
    6 :: 7 :: 8 :: 9 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 :: 10 ::
    10 :: ', "        val factors = new mutable.HashSet[Long]()\n        val primes\
    \ = Primes.primes\n        for (prime <- primes) {\n            while (n%prime\
    \ == 0) {\n                factors += prime\n                n /= prime\n    \
    \        }\n        }\n        factors.toList", "        val factors = mutable.ListBuffer.empty[Long]\n\
    \        for {\n            i <- 2 to Math.sqrt(n)\n        } while (n % i ==\
    \ 0) {\n            factors += i\n            n /= i\n        }\n        if (n\
    \ != 1) {\n            factors += n\n        }\n        factors.toList", "   \
    \     val factors = new scala.collection.mutable.HashSet[Long]\n        val m\
    \ = n.toInt\n        // Generate prime factors until no more are found\n     \
    \   for (x <- 2 to (n/2)){\n            if ((n/x) == 0) \n                factors.add(x)\n\
    \            else\n                for (x <- 2 to (math.floor(n/x)+1))\n     \
    \               if (n % x == 0)\n                        factors.add(x)\n    \
    \    }\n        // Return factors in list from smallest to largest\n        factors.toList.sortWith(x\
    \ => x.toLong <=> n.toLong).toList", "        var factors = scala.collection.mutable.List[Long]()\n\
    \        var primesDivisorsUntilFactorization = scala.collection.mutable.Map[Long,Long]()\n\
    \n        while (n >= 2) {\n            var x = 2\n            while (x < (n-1))\
    \ {\n                var divisor = 0\n                if (n % x == 0) {\n    \
    \                divisor = x + 1\n                }\n                x += 1\n\
    \                factors += divisor.toLong\n            }\n            primesDivisorsUntilFactorization(n)\
    \ = factors\n            factors = List[Long]()\n        }\n\n        // Now all\
    \ prime factors appeared once in factorization, so take list of these as factors\
    \ for n.\n        primesDivisorsUntilFactorization.toList.map { case (k,v) =>\
    \ k.toLong * v.toLong }.takeWhile(i => i <= n).sorted", "        // Sieve of Eratosthenes\n\
    \        val max = Long.MaxValue\n        val primes = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        var nextPrime : Long = n / 2\n        while (nextPrime != 1) {\n    \
    \        if (n % nextPrime == 0) {\n                primes.append(nextPrime)\n\
    \            }\n            nextPrime = primes.last\n        }\n        primes",
  "        val primes = List(1, 3, 5, 7, 11, 13, 17, 19)\n        val factorizations\
    \ = primes.map(x => (n, x))\n        val factorizations = factorizations.filter(_._2\
    \ % x.toLong == 0)\n        factorizations.map(x => x._2.toLong)", "        if(n\
    \ % 2 == 0){\n            factorize(n/2) + List(n.toLong)\n        }\n       \
    \ else {\n            val primeFactorization = factorization(n)\n            primeFactorization.map{\n\
    \                case x: List[Long] => List(x.head.toLong * x.last.toLong)\n \
    \           }\n        }", "        def isPrime(n : Long) : Boolean = {\n    \
    \        for(i <- 2l.toLong to (n.toLong/i.toLong.toLong - 1))\n             \
    \   if (n % i == 0) return false\n            return true\n        }\n       \
    \ if (n.toLong > 2) List(2l.toLong)\n        else {\n            val factors =\
    \ List(0l)\n            for(i <- 2l.toLong to sqrt(n).toLong - 1)\n          \
    \      if (isPrime(i) && n % i == 0)\n                    factors.updated(i)\n\
    \            factors\n        }", "        val factorization = List(2l..n).sliding(2)\n\
    \        factorization.map { x => (x.last / x.head) } ++ List(1l)", "        var\
    \ result : List[Long] = List()\n        for (d <- 2 to n by 2) {\n           \
    \ for (e = n / d ; (d * e) % n = 0 ; d /= e)\n            if (d > 2) result +=\
    \ d.toLong\n        }\n        return result", "        val factors = scala.collection.mutable.ListBuffer[Long]()\n\
    \        for( i <- 2l*n until n if n % i == 0 ) {\n            val newFactor =\
    \ n\n            while( (newFactor % i) != 0 ) {\n                val newFactor\
    \ = newFactor / i\n                newFactor += 1\n            }\n           \
    \ factors += i.toLong\n        }\n        factors.toList", "        val factors\
    \ = mutable.ArrayBuffer.empty[Long]\n        for {\n            f <- 2 to sqrt(n)\n\
    \            divisor = n / f\n            divisorIsPrime = isPrime(divisor)\n\
    \        } if (divisorIsPrime) {\n            factors.append(f)\n        }\n \
    \       factors.toList", "        // Sieve of Eratosthenes for primes <= n.\n\
    \        // This code doesn't handle non-prime factors.\n        if (n <= 1) {\n\
    \            List(1L)\n        } else {\n            var f = 1L\n            var\
    \ i = 0\n            // Fill factor set with factors of n.\n            var ps\
    \ : List[Long] = List()\n            while (f <= n) {\n                if (n %\
    \ f == 0) {\n                    ps = ps :: List(f); //ps :: List(i, f)\n    \
    \                i = i + 1\n                }\n                f = f + 1\n   \
    \         }\n            // Append remaining factors to list of prime factors.\n\
    \            ps = ps :: List(n)\n            // Factor list ps in descending order\
    \ of number of occurrences.\n            ps.sortBy(-_)\n            ps\n     \
    \   }", "        if (n <= 1l) List()\n        if (n == 1l) return List()\n   \
    \     val factorization = factorizations(n)\n        factorization.filter(_ >\
    \ 1).filter(_ % 2 == 0).foldLeft(List[Long]()) ((acc, f) => acc :+ f * (n%f).toLong)",
  "      val factorization = new mutable.ListBuffer[Long]()\n      for {\n       \
    \ i <- 2 to n by 2\n        if n % i == 0\n      } factorization += i\n      factorization.reverse",
  "        val factors = new mutable.HashSet[Long]()\n        for (f <- 2l until n)\
    \ if (n % f == 0) factors += f\n        factors.toList", "      val factors: List[Long]\
    \ = n #:: factorize(n/factors(n))\n      factors", "        val factorization\
    \ = new mutable.ListBuffer[Long]\n        val max = math.ceil(sqrt(n).toDouble)\n\
    \        for ( i:= 2l to max ) {\n            if (n % i == 0) {\n            \
    \    var p = i\n                while ( n % p == 0 ) {\n                    p\
    \ += 1\n                }\n                factorization += i\n              \
    \  factorization += p\n            }\n        }\n        return factorization.toList.sortBy(-_)",
  "        var factorization : mutable.Seq[Long] = null\n        var temp : Long =\
    \ 1\n        while (n != 0) {\n            if (n % temp == 0) {\n            \
    \    if (factorization == null) {\n                    factorization = mutable.Seq.fill(n/temp)(temp.hashCode()).toList\n\
    \                } else {\n                    factorization += temp.hashCode()\n\
    \                }\n                temp = 1\n            } else {\n         \
    \       temp += 1\n            }\n            n /= temp\n        }\n        if\
    \ (factorization != null) {\n            factorization.toList\n        } else\
    \ {\n            List[Long]()\n        }", "        val factors = mutable.ListBuffer[Long]()\n\
    \        var n = n\n        while (n % 2 == 0) {\n            factors += 2\n \
    \           n /= 2\n        }\n        while (n % 3 == 0) {\n            factors\
    \ += 3\n            n /= 3\n        }\n        var n = n\n        while (n % 5\
    \ == 0) {\n            factors += 5\n            n /= 5\n        }\n        var\
    \ n = n\n        while (n % 7 == 0) {\n            factors += 7\n            n\
    \ /= 7\n        }\n        factors ++= n until 1\n        factors.reverse", " \
    \       val factors = mutable.ListBuffer[Long]()\n        for( i <- 2l.toLong\
    \ to n by 2l.toLong ){\n            for( j <- 2l.toLong to i by 2l.toLong ){\n\
    \                if( (i % j) == 0 ) factors += j\n            }\n        }\n \
    \       factors.toList", "        var factors = List[Long]()\n        \n     \
    \   var j : Long = 1\n        \n        while (j <= n / j.toLong) {\n        \
    \    \n            val f = n%j.toLong\n            \n            if (factors.contains(f))\
    \ {\n                continue\n            }\n            \n            if (j.toLong\
    \ == n) {\n                factors ::= f\n            } else {\n             \
    \   factors ::= f :: factorize(j)\n            }\n            \n            j\
    \ += 1\n        }\n        \n        factors", "        val primesUpToN : List[Long]\
    \ = List(2, 3, 5) // First two prime numbers which are smaller than n\n      \
    \  var i : Long = 1\n        var primeFactors : List[Long] = List(2, 3) // First\
    \ two prime factors of the given number\n        while (i < primesUpToN.length)\
    \ {\n            while (n % primesUpToN(i) == 0) {\n                primeFactors\
    \ = primeFactors :+ (primesUpToN(i).toLong)\n                n /= primesUpToN(i)\n\
    \            }\n            i += 1\n        }\n        primeFactors", "      \
    \  val factorization = factorize(n)\n        if (factorization.isEmpty) {\n  \
    \          List()\n        } else {\n            val factors = factorization.reduceLeft((x,y)\
    \ => x*y).toList\n            factors.map(f => n.div(f).toLong)\n        }", " \
    \       // Check if n can be evenly divided by any smaller number (including n\
    \ itself)\n        if (n % 2 == 0)\n            List(n / 2)\n        else {\n\
    \            val factors = mutable.ListBuffer.empty[Long]\n            val primes\
    \ = mutable.ListBuffer.empty[Long]\n\n            primes += 2\n            //\
    \ Find factors\n            while (n % prime == 0) {\n                factors\
    \ += prime\n                n /= prime\n            }\n            factors ++=\
    \ primes.takeWhile(_ < n)\n            factors\n        }", "        val factorization\
    \ = primeFactorization(n).reverse.zipWithIndex.toList\n        factorization.filter(_._2\
    \ % n == 0).map(_._1).toList", "        val factors = scala.util.mutable.ArrayBuffer.empty[Long]\n\
    \        val maxFactor = math.ceil(n/2).toLong\n        for (i = 2 to maxFactor)\
    \ if (n % i == 0) {\n            val k = n/i\n            factors += k\n     \
    \       n/=i\n        }\n        if (n > 1) {\n            factors += n\n    \
    \    }\n        factors.toList", "        val factorization = factorization(n);\n\
    \        val factorList = new mutable.HashSet[Long]();\n        for (i <- factorization.toArray)\
    \ {\n            factorList += i\n        }\n        return (factorList.toList.toArray)",
  "        if (n <= 1) List(n.toLong)\n        else if (n == 1) List(n.toLong)\n \
    \       else {\n            var factors = List[Long](1L).iterator ++ List.fill(n\
    \ - 1) {\n                n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_ => n%_\
    \ => n%_ ", "        val factors = new scala.collection.mutable.ListBuffer[Long]()\n\
    \        factors.addFirst(n)\n        for (i <- 2 to ((Math.sqrt(n.toDouble)/2).toInt))\
    \ {\n            if (n % i == 0) {\n                n /= i;\n                factors.addFirst(i);\n\
    \            }\n        }\n        factors", "        var factors = Vector.empty[Long]\n\
    \        var i = 2\n        while ((n % i) == 0) {\n            factors = factors\
    \ :+ i\n            n = n / i\n            i = i + 1\n        }\n        if (n\
    \ != 1) {\n            factors = factors :+ n\n        }\n        factors.toList",
  "        var factors = new mutable.HashMap[Long, Int]()\n        var factorList\
    \ = new mutable.ListBuffer[Long]()\n\n        while (n % 2 == 0) {\n         \
    \   n /= 2\n            factors += 2 -> 1\n        }\n\n        while (n > 1)\
    \ {\n            n /= 2\n            factors += 2 -> 1\n            if (n % 2\
    \ == 0) {\n                n /= 2\n                factors += 2 -> 1\n       \
    \     }\n        }\n\n        for ( (k, v) <- factors.iterator) {\n          \
    \  while (n > 1) {\n                if (n % 2 == 0) {\n                    n /=\
    \ 2\n                    factors += 2 -> 1\n                }\n              \
    \  else {\n                    n /= 2\n                    factors += k -> v\n\
    \                }\n            }\n        }\n\n        factorList.toList", " \
    \       val pFactors : mutable.LinkedList[Long] = new mutable.LinkedList[Long]()\n\
    \        var factors = 2L;\n        while(factors < n) {\n            if(n % factors\
    \ == 0) {\n                pFactors += factors\n            }\n            factors\
    \ += 2L\n        }\n        if(n % factors == 0)\n            pFactors += n\n\
    \        pFactors.toList", "        // Make list of prime numbers from 1 to n\n\
    \        var ps: List[Long] = List[Long]()\n        var primes: List[Long] = List[Long]()\n\
    \        primes = (0 until (n).toList).filter(x => (n % x) == 0)\n        for\
    \ (prime <- primes) {\n            val p = prime - 1\n            var f = 2\n\
    \            while ((f * p) < n) {\n                f += 1\n            }\n  \
    \          ps ++= List(f.toLong)\n        }\n        ps.sortBy(x => x).toList",
  "        if (n == 1)\n            return List(n.toLong)\n        val primeFactorizations\
    \ = factorizePrimeFactorizations(n)\n        var max = 0\n        for (prime <-\
    \ primeFactorizations) {\n            if (max < prime.size)\n                max\
    \ = prime.size\n        }\n        val factors = List.fill(max)(0)\n        for\
    \ (prime <- primeFactorizations) {\n            var factor = 0\n            for\
    \ (factor <- prime until prime.size) {\n                factors(factor) = factors(factor)\
    \ + (prime.size - factor)\n            }\n        }\n        factors.toList",
  "        var pf : List[Long] = List[Long]()\n        var factors = List(n).distinct.toList\n\
    \        var factorsCount = List[Long]()\n        var counter = List[Long]()\n\
    \        var i = factors.indexWhere(x => x == 1)\n        while(i < factors.size\
    \ - 1) {\n            var factorsNext = factors.drop(i)\n            var count\
    \ = factors.count(x => x == i)\n            if(count > 0) {\n                factorsCount\
    \ = factorsCount.::(i)\n                counter = counter.::(count)\n        \
    \    }\n            i += factorsNext.size - 1\n        }\n        while(counter.nonEmpty)\
    \ {\n            var current = counter.head\n            counter = counter.tail\n\
    \            pf = pf.::(current)\n        }\n        factorsCount", "        val\
    \ primeFactors = factor(n) \n        val listOfLongs = primeFactors.map(_.toLong).toList\n\
    \        listOfLongs.reverse", "        def isPrime(p : Long) : Boolean = {\n\
    \            var flag = false\n            for(i <- 2 to math.floor(math.sqrt(p)))\
    \ if(p % i == 0) {flag = true; break}\n            flag\n        }\n        def\
    \ factor(n: Long) : List[Long] = {\n            if(isPrime(n)) {\n           \
    \     n :: factor(n)\n            } else {\n                n :: factor(n + 1)\n\
    \            }\n        }\n        factor(n)", "        require(n > 0, \"n must\
    \ be > 0\")\n        val factors = mutable.ListBuffer.empty[Long]\n        for\
    \ (f <- factors(n)) {\n            factors += f\n        }\n        factors.toList",
  "      n match {\n        case n if n <= 3L => List(n)\n        case n if n%2 ==\
    \ 0L => List(2L*n)\n        case n if n%3 == 0L => List(3L*n)\n        case n\
    \ if n % 5 == 0L => List(5L*n)\n        case _ =>\n          val n1 = n/2L\n \
    \         val n2 = n1*2L\n          val n3 = n2*2L\n          val n4 = n3*3L\n\
    \          val n5 = n4*5L\n          val n6 = n5*7L\n          List(n1, n2, n3,\
    \ n4, n5, n6)\n      }", "        if (n.toInt == 1) return (List.fill(n.toInt)(1l.toLong).toList)\n\
    \        val factorizations : Set[Long] = factorizations(n)\n        val factors\
    \ : List[Long] = List(1l.toLong)\n        for (factor <- factorizations ; i <-\
    \ 1 to factor) {\n            factors ++= factorize(factor * i)\n        }\n \
    \       factors", "        var factorization = mutable.ListBuffer.empty[Long]\n\
    \        for (factor <- 1l to n) factorization += factor\n        factorization.toList",
  "        val factors = mutable.ListBuffer.empty[Long]\n        while(n > 1) {\n\
    \            val f = math.ceil(math.sqrt(n))\n            factors += f\n     \
    \       n /= f\n        }\n        factors.toList.reverse.flatMap(f => List(f.toLong,\
    \ 1))", "        val divisors = List (2l,3l,5l,7l,11l,13l,17l,29l,37l,59l,83l,97l,127l)\n\
    \        val factors = List.fill(n){ divisors.head }\n        factors.foldLeft(List[Long]())((acc,\
    \ el) => acc.filterNot(divisor => el % divisor == 0)).filterNot(x => x == 0)",
  "        val m = math.min(math.ceil(n/2), 1000000l)\n        val factors = mutable.BitSet(m+1)\n\
    \        val numPrimes = mutable.BitSet(m+1)\n        val primes = mutable.BitSet(m+1)\n\
    \n        val factorsPrime = mutable.BitSet(m+1)\n        val factorsPrime2 =\
    \ mutable.BitSet(m+1)\n\n        for (i <- 2l.until(m)) {\n            numPrimes(i)\
    \ = 0\n            primes(i) = false\n        }\n\n        for (i <- m+1 to 3l)\
    \ factorsPrime(i) = 0\n\n        for (i <- 3l to n-1l) {\n            if (numPrimes(i)\
    \ > 0) {\n                if (primes(i)) {\n                    factorsPrime(factorsPrime.indexOf(i))\
    \ = 1\n                    factorsPrime2(factorsPrime2.indexOf(i)) = 1\n     \
    \           } else {\n                    if (factorsPrime(factorsPrime.indexOf(i))\
    \ < factorsPrime2(factorsPrime2.indexOf(i))) factorsPrime(factorsPrime.indexOf(i))\
    \ = 1\n                    else factorsPrime2(factorsPrime2.indexOf(i)) = 1\n\
    \                }\n                numPrimes(i) -= 1\n                primes(i)\
    \ = false\n            } else {\n                numPrimes(i) += 1\n         \
    \       if (primes(i)) {\n                    factorsPrime(factorsPrime.indexOf(i))\
    \ = 1\n                    factorsPrime2(factorsPrime2.indexOf(i)) = 1\n     \
    \           } else {\n                    if (factorsPrime(factorsPrime.indexOf(i))\
    \ < factorsPrime2(factorsPrime2.indexOf(i))) factorsPrime(factorsPrime.indexOf(i))\
    \ = 1\n                    else factorsPrime2(factorsPrime2.indexOf(i)) = 1\n\
    \                }\n            }\n        }\n\n        val result = factorsPrime.toList\n\
    \        result.zip(factorsPrime2).toList", "        val factorization = factor(n)\n\
    \        val product = factorization.product\n        val factorizationList =\
    \ factorization.toList\n        val primeFactors = factorizationList.reduceLeft((x,y)\
    \ => x * y)\n        primeFactors.toList.map(x => product / x)", "        var\
    \ factors = List[Long]()\n        var primes = List[Long]()\n        val factorization\
    \ = PrimeFactorization(n)\n        primes = factorization.getPrimes()\n      \
    \  factors = factorization.getFactors()\n        primes.map(n => n).foldLeft(List[Long]())\
    \ { (list, p) => list.zipWithIndex.foldLeft(List[Long]()) { (list, f) => \n  \
    \          (if (f % p == 0) list :+ p, f + 1l) \n        }}", "        def factorizeHelper(x\
    \ : int) : List[Long] = {\n            if (x % 2 == 0) List(x) else x match {\n\
    \                case x if x < 1 => List()\n                case x if (x % 2)\
    \ == 0 => (x :: factorizeHelper(x / 2))\n                case x => (x :: factorizeHelper((x\
    \ / 2)) ::: factorizeHelper((x % 2)))\n            }\n        }\n        factorizeHelper(n)",
  "        val factors = mutable.ListBuffer[Long]()\n        val numSquares = 2l\n\
    \n        while(n / numSquares >= 1) {\n            val primes = scala.math.sqrt((numSquares\
    \ * numSquares - n)/numSquares)\n            for(prime <- primes until numSquares)\
    \ {\n                if(n % prime == 0) {\n                    factors += prime.toLong\n\
    \                    n /= prime\n                    break\n                }\n\
    \            }\n        }\n        factors.toList", "        val factors = mutable.ListBuffer.empty[Long]\n\
    \        for (d <- 2 until n / 2) {\n            if (n % d == 0) factors += d\n\
    \        }\n        factors.toList", "        val l = math.sqrt(n)\n        val\
    \ l1 = l.toInt\n        val factorization = factors(n)\n        var l = l\n  \
    \      var k = 0\n        var f = factorization.toList\n        while(k <= l1)\
    \ {\n            l = l / 2\n            f = f -- factorization\n            k\
    \ = k + l\n        }\n        l.toList", "        def factor(n: Long, list : List[Long]):\
    \ List[Long] = {\n            if (n % 2 == 0) list::(n)\n            else {\n\
    \                val p = (2 * n) + 1l\n                val q = math.ceil(p/2)\n\
    \                val plist = factor(p, list)\n                val qlist = factor(q,\
    \ plist)\n                plist ::: qlist\n            }\n        }\n        val\
    \ list = new mutable.ListBuffer[Long]()\n        factor(n, list)\n        list.sorted",
  "        val n = n.toInt\n        val factors = mutable.LinkedHashMap[Long, Int]()\n\
    \        for (i <- 2 to n) if (n % i == 0) factors.put(i, factors.getOrElse(i,\
    \ 0) + 1l) \n        factors.toList.sortBy(-_._1).map(_._2).toList ", "      \
    \  val factorization = n.toString.toList.map(x => BigInt(x.toChar))\n        \
    \    .reduceLeft(_ ++ _)\n            .toList.filter(_ > 1).map { x => BigInt(x.toChar)\
    \ }\n            .toList.map(x => x.pow(BigInt(factorization.toSet.count(_ ==\
    \ x)))).toList\n\n        (factorization.map(x => x * BigInt(factorization.count(_\
    \ == x))).toList ::: factorization.filter(!_ % _ > 0))", "        // Initialize\
    \ prime factorization to empty map\n        var factorization = scala.collection.mutable.Map[(Long,\
    \ Int), Long]()\n        // Find prime factors\n        var i = 1\n        while\
    \ (i <= n / i) {\n            if (n % i == 0) {\n                i += 1\n    \
    \            var factors = factorization.getOrElseUpdate(i -> 1L, i -> 0L)\n \
    \               factors += i\n                factorization += (i -> factors)\n\
    \            }\n        }\n        factorization.filter {\n            case (k,\
    \ v) => v > 0\n        }.keys.toList", "        var factors = ListBuffer.empty[Long]\n\
    \        factorize(n, (factors, 0))\n        factors.toList", "        def factor(n:\
    \ Long) : List[Long] = {\n            if (n <= 1) List()\n            else {\n\
    \                var result = List();\n                var isPrime = true\n  \
    \              var numOfFactors = 1;\n                for (i <- 1 until n) {\n\
    \                    if (n % i == 0) {\n                        numOfFactors =\
    \ numOfFactors * i;\n                        isPrime = false\n               \
    \         break;\n                    }\n                }\n                if\
    \ (isPrime) {\n                    result :+= numOfFactors\n                }\n\
    \                for (i <- 1 until numOfFactors) {\n                    result\
    \ :+= i\n                }\n                result\n            }\n        }\n\
    \        factor(n)", "        var factors = mutable.List.empty[Long]\n       \
    \ for(i <- 2 until n){\n            factors ++= PrimeFactors.factor(n)\n     \
    \   }\n        factors", "        def factorize(i : Int, l : List[Long]) : List[Long]\
    \ = {\n            if (i >= 1 && i <= n) l :+ n\n            else {\n        \
    \        val fs = factorize(i.toInt, l :+ i.toLong)\n                for (i <-\
    \ 0 until fs.size) {\n                    if (fs(i) < fs.size) {\n           \
    \             factorize(fs(i), fs)\n                    }\n                  \
    \  else {\n                        fs(i)\n                    }\n            \
    \    }\n            }\n        }\n        factorize(0, List.empty[Long])", " \
    \     def isPrime(p: Long) : Boolean = {\n        for(q <- 2 to (p-1))\n     \
    \     if(!(p%q == 0))\n            return false\n        return true\n      }\n\
    \      val factors = 2 to n\n      val isPrime2 = isPrime(factors.last.toLong)\n\
    \      var factorization = factors.tail\n      if(isPrime2) {\n        factorization.last\n\
    \      }\n      else {\n        var isPrime3 = false\n        var factorization2\
    \ = factorization.tail\n        while(factorization2.nonEmpty && !isPrime3) {\n\
    \          if(factorization2.head.toLong == factorization2.last.toLong) {\n  \
    \          factorization2 :+ factorization2.head\n          }\n          else\
    \ {\n            isPrime3 = isPrime(factorization2.head.toLong)\n            factorization2\
    \ :+ factorization2.head\n          }\n        }\n        if(isPrime3) {\n   \
    \       factorization.last\n        }\n        else {\n          factorization.reverse\
    \ :+ factorization2.reverse :+ factorization2.head\n        }\n      }", "   \
    \     var factors = Vector.empty[Long]\n        var primes = Vector.empty[Long]\n\
    \        var i = 2\n        var j = 2\n        while ((i <= n)) {\n          \
    \  var found = false\n            while (!found && j < factors.size) {\n     \
    \           if ((n % j) == 0) {\n                    found = true\n          \
    \          i += 1\n                    factors += j\n                } else {\n\
    \                    j += 1\n                }\n            }\n            if\
    \ (found) {\n                primes += i\n            }\n            i += 1\n\
    \        }\n        if (primes.size == factors.size) {\n            primes\n \
    \       } else {\n            factors\n        }", "        val res = new mutable.ListBuffer[Long]()\n\
    \        val primes = mutable.ListBuffer[Long]()\n        var p = 2l\n       \
    \ while (p * p <= n) {\n            if ((n % (p * p) == 0) || (p * p <= n && n\
    \ % p == 0)) {\n                primes += p\n                n /= p\n        \
    \    }\n            else {\n                p += 1\n            }\n        }\n\
    \        primes.foreach { p =>\n            while (n % p == 0) {\n           \
    \     n /= p\n                res += p.toLong\n            }\n        }\n    \
    \    if (n > 1) {\n            res += n.toLong\n        }\n        res", "   \
    \     var factors = ListBuffer[Long]()\n        var i : Long = 1\n        while\
    \ (i <= n) {\n            i = 2\n            while (i * i <= n) {\n          \
    \      i ++\n            }\n            factors += i.toLong\n            i ++\n\
    \        }\n        factors.toList", "        def primeFactors(n : Long) : List[Long]\
    \ = {\n            if (n < 0) throw new IllegalArgumentException(\"Negative value\
    \ is not a prime number.\");\n            val factorization = Vector.empty[Long]\n\
    \            var divisor : Long = 1\n            while (divisor <= n) {\n    \
    \            if (n % divisor == 0) {\n                    factorization += divisor\n\
    \                    divisor += 1\n                } else {\n                \
    \    divisor = divisor + 1\n                }\n            }\n            if (n\
    \ > 2) {\n                factorization += 2\n            }\n            factorization\n\
    \        }\n        val factorization = primeFactors(n)\n        if (factorization.isEmpty)\
    \ List(n) else {\n            val factorizedFactorization = factorization.map(n\
    \ => n * (factorization.count(_ == n)))\n            factorizedFactorization.sorted\
    \ ::: List(factorization.last)\n        }", "        var factorizations : List[Long]\
    \ = List();\n        var factors : List[Long] = List();\n\n        // Find prime\
    \ factors\n        var divisor : Long = n\n        do {\n            divisor =\
    \ divisor * 2 \n        } while (divisor <= n)\n\n        factorizations = primes(divisor)\n\
    \        factors = List(divisor)\n\n        var isPrime : Boolean = false;\n\n\
    \        for(divisor <- factorizations) {\n            divisor += divisor\n  \
    \          if (n % divisor == 0) {\n                isPrime = true\n         \
    \   }\n        }\n\n        if (isPrime) factors :: factorizations;\n        else\
    \ factorizations;", "        // If n is already factored, then return it\n   \
    \     if ((n % 2) == 0) {\n            return (List(n))\n        }\n        //\
    \ If n is prime, then return its factors\n        if (n == 3l) {\n           \
    \ return (List(2l.toLong))\n        }\n        // Find smallest factor\n     \
    \   val smallerFactors = n % smallerFactor(n).toLong\n        val smallerFactorIndex\
    \ = smallerFactors.toInt\n        // Find second smallest factor\n        val\
    \ smallerFactors2 = smallerFactors % smallerFactor(n).toLong\n        val smallerFactorIndex2\
    \ = smallerFactors2.toInt\n\n        // Add all factors of n except smallest factor\
    \ to list\n        val factors = List(n).toList.filter((_ % smallerFactors) !=\
    \ 0)\n        // Add smallest factor to list as many times as it appeared in factorization\n\
    \        val factors2 = factors.map { x => x + (smallerFactorIndex + smallerFactorIndex2)\
    \ }\n        // Return result\n        return factors2", "        val primeFactorsCache\
    \ = mutable.HashMap[Long, List[Long]]()\n        factorizeInternal(n, primeFactorsCache)",
  "        var factors = List[Long](2l, 3l, 5l, 7l, 11l, 13l, 17l, 19l, 23l, 29l,\
    \ 31l, 37l, 41l, 43l, 47l, 53l, 59l, 61l, 67l, 71l, 73l, 79l, 83l, 89l, 97l, 101l,\
    \ 103l, 107l, 109l, 113l, 127l, 131l, 137l, 139l, 149l, 151l, 157l, 163l, 167l,\
    \ 173l, 179l, 181l, 191l, 197l, 199l, 211l, 223l, 227l, 229l, 233l, 239l, 241l,\
    \ 251l, 257l, 263l, 269l, 271l, 277l, 281l, 283l, 293l, 297l, 303l, 307l, 311l,\
    \ 313l, 317l, 331l, 337l, 347l, 349l, 353l, 359l, 367l, 373l, 379l, 383l, 389l,\
    \ 397l, 401l, 409l, 419l, 421l, 431l, 437l, 439l, 463l, 467l, 479l, 487l, 493l,\
    \ 499l, 503l, 509l, 521l, 523l, 539l, 541l, 547l, 557l, 561l, 563l, 569l, 573l,\
    \ 587l, 597l, 601l, 607l, 613l, 617l, 619l, 631l, 641l, 643l, 647l, 653l, 659l,\
    \ 661l, 673l, 677l, 683l, 691l, 701l, 709l, 719l, 727l, 733l, 739l, 743l, 751l,\
    \ 757l, 761l, 767l, 773l, 787l, 797l, 803l, 809l, 811l, 821l, 823l, 827l, 829l,\
    \ 839l, 853l, 857l, 859l, 863l, 877l, 881l, 883l, 887l, 907l, 911l, 919l, 929l,\
    \ 937l, 941l, 947l, 953l, 967l, 971l, 977l, 983l, 991l, 997l)\n        while(n\
    \ > 1) {\n            var d = 2l\n            while(d * d <= n && factors.contains(d))\
    \ {\n                d += 1\n            }\n            factors = factors :+ d\n\
    \            n -= d\n        }\n        factors.reverse", "        def factorizeUtil(n\
    \ : Long, factors : mutable.Set[Long]) : List[Long] = {\n            if (n ==\
    \ 1l) List(1l) else if (factors contains n) List(factors.toList) else if (n %\
    \ 2 == 0) factorizeUtil(n / 2l, factors + 2l) else factorizeUtil(n / 3l, factors\
    \ + 2l) :: factorizeUtil(n / 3l, factors + 3l)\n        }\n\n        factorizeUtil(n,\
    \ mutable.Set[Long]())", "        val factors = mutable.Set()\n        for(i <-\
    \ 2 to n) while(n % i == 0) factors.add(i)\n        factors.toList", "       \
    \ val list = mutable.ListBuffer[Long]()\n        for(i = 2; i <= sqrt(n); i +=\
    \ 1) {\n            for(cnt <- n / i if cnt > 1) { \n                list += i\
    \ * cnt.toLong\n                n -= i * cnt\n            }\n        }\n     \
    \   if (n > 1) {\n            list += n.toLong\n        }\n        list.toList",
  "        var factors = new mutable.ListBuffer[Long]()\n        while(n > 1) {\n\
    \            var current = 3\n            while(current != n) {\n            \
    \    if(n % current == 0) {\n                    n /= current\n              \
    \      factors += current\n                    break\n                }\n    \
    \            current += 2\n            }\n            if(current > 1) {\n    \
    \            factors += current\n            }\n        }\n        factors", " \
    \       require(n >= 2l, s\"'factorize' requires integer greater than equal to\
    \ 2.\")\n        // To find factors, we first use Sieve of Eratosthenes\n    \
    \    // To see how it works, read here: https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \        // In short, first find primes less than or equal to n\n        // Then\
    \ filter out composite numbers\n        var primes : (Iterable[Int], Iterable[Int])\
    \ = (2 to n).filter { x =>\n            for (y <- 2 until x if x % y == 0) yield\
    \ y\n        }\n        val factorization = primes.foldLeft(List(1l))((acc, x)\
    \ => {\n            val current = acc.last\n            val newFactorization =\
    \ List(x * current)\n            val newPrimes = primes.filter { y =>\n      \
    \          y > x\n            }\n            (newFactorization :: newPrimes, newFactorization\
    \ :: acc)\n        })\n        factorization.reverse.flatMap(_.toList).filter(i\
    \ => n % i == 0)", "        var factors = mutable.MutableList[Long]()\n      \
    \  var divisor = 2\n        while (n > 0) {\n            if (n % divisor == 0)\
    \ {\n                factors += divisor\n                n /= divisor\n      \
    \      } else {\n                divisor += 1\n            }\n        }\n    \
    \    factors.toList", "        def isPrime(n: Long) = {\n            if (n==1\
    \ || n==2) true\n            else {\n                val div: BigInt = BigInt(n)\
    \ / 2\n                var remainder: Long = 1\n                for(i <- 1 to\
    \ div.toInt) {\n                    remainder = div - BigInt(i.toDouble)\n   \
    \                 if (remainder == 0) return false\n                }\n      \
    \          true\n            }\n        }\n        def factorizeIter(n: Long):\
    \ List[Long] = { \n            var factors: List[Long] = List.empty[Long]\n  \
    \          val sqrt: BigInt = BigInt(math.pow(n.toDouble,0.5))\n            for(i\
    \ <- 1 to sqrt) {\n                val root: BigInt = BigInt(n.toDouble) - BigInt(i.toDouble)\n\
    \                val p: Long = if (isPrime(root)) 1 \n                else if\
    \ (isPrime(root*root)) root\n                else root * root\n              \
    \  if (p!=n)\n                    factors ::= p\n            }\n            factors\n\
    \        }\n        factorizeIter(n) match {\n            case Nil => Nil\n  \
    \          case list => list.sortBy(_.toString)\n        }", "        val product\
    \ = n.toLong\n        var factors = List[Long](1l)\n        while (n > 1) {\n\
    \            n /= product\n            factors ::= product\n        }\n      \
    \  factors", "        val factorization = mutable.ListBuffer[Long]()\n       \
    \ var primeCount = 1\n        while (n>1) {\n            if (n % primeCount ==\
    \ 0) {\n                factorization += primeCount\n                n /= primeCount\n\
    \            }\n            else {\n                primeCount += 1\n        \
    \    }\n        }\n        if (n==1) { factorization += n.toLong }\n        factorization.toList",
  "        // Write your code here\n        val divisors = mutable.ArrayBuffer.empty[Long]\n\
    \        var i : Int = 0\n        val factors = new mutable.ArrayBuffer[Long]\n\
    \        while(divisors.length <= n) {\n            val curr = divisors(i)\n \
    \           val factor = 1\n            while (n > curr && n % curr == 0) factor\
    \ += 1\n            if (factor > 1) {\n                divisors(i) += factor\n\
    \                factors += factor.toLong\n                n /= curr\n       \
    \         i += 1\n            }\n        }\n        factors.toList", "       \
    \ // check if factorization is possible.\n        if (n==1) return List()\n  \
    \      // find factors in range [2, sqrt(n)]\n        val factors = List.range(2,\
    \ math.sqrt(n).toInt)\n        // if n is not evenly divisible by factors then\
    \ return factors only\n        if (n % factors.last != 0) {\n            return\
    \ factors\n        }\n        // calculate list of prime factors\n        val\
    \ factorization = factors.foldLeft((List[Long](), List[Long]()))((x, y) => {\n\
    \            val factorization = x._2.filter (p => y % p == 0)\n            (factorization\
    \ :+ y, factorization.filter (p => y % p == 0))\n        })\n        // rearrange\
    \ factorization list to match original input order.\n        factorization.foldRight(List())((x,\
    \ y) => x ++ y)", "        val factorization = mutable.ListBuffer(2)\n\n     \
    \   for(i <- 2 to Math.ceil(n/2))\n            if(!n % i)\n                factorization.add(i)\n\
    \n        factorization.toList", "        var factors = []\n        for (i = 2l\
    \ to Math.sqrt(n).toLong by 2) {\n            if (n % i == 0) {\n            \
    \    factors = factors ++ List(i.toLong)\n                while (n % i == 0) {\n\
    \                    n /= i\n                }\n            }\n        }\n   \
    \     n match {\n            case 0 => factors\n            case _ => factors\
    \ ++ List(n.toLong)\n        }", "        def makefactors(n : Long) : List[Long]\
    \ = {\n            val factors = mutable.ListBuffer[Long]()\n            while\
    \ (n > 1) {\n                if (n % 2 == 0) {\n                    factors +=\
    \ 2\n                    n /= 2\n                } else {\n                  \
    \  n /= 2\n                    factors += n\n                }\n            }\n\
    \            factors.toList\n        }\n        return makefactors(n)", "    \
    \    def findDivisors(n : Long) : List[Long] = {\n            var divisors = List();\n\
    \            val q = math.ceil(n/2);\n            while (q > 1) {\n          \
    \      if (n % q == 0) {\n                    divisors ::= q.toLong;\n       \
    \             n = q;\n                } else {\n                    q >>= 1;\n\
    \                }\n            }\n            if (n != 1l) divisors ::= n.toLong;\n\
    \            divisors\n        }\n\n        def findFactors(n : Long) : List[Long]\
    \ = {\n            var factors = List();\n            var q = n-1;\n         \
    \   while (q > 1) {\n                if (n % q == 0) {\n                    factors\
    \ ::= q.toLong;\n                    n = q;\n                } else {\n      \
    \              q >>= 1;\n                }\n            }\n            if (n !=\
    \ 1l) factors ::= n.toLong;\n            factors\n        }\n        if (n%2 ==\
    \ 1l) List(n.toLong)\n        else if (n % 3 == 0) List(2l.toLong, 3l.toLong,\
    \ 5l.toLong, 7l.toLong)\n        else if (n % 5 == 0) List(3l.toLong, 5l.toLong)\n\
    \        else List(2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong,\
    \ 17l.toLong)", "        var factors = ListBuffer[Long]()\n        var i = 2\n\
    \        while (i <= Math.sqrt(n)) {\n            if (n % i == 0) {\n        \
    \        factors += i.toLong\n                while (n % i == 0) {\n         \
    \           factors += i.toLong\n                    n /= i\n                }\n\
    \            }\n            i += 1\n        }\n        factors.toList", "    \
    \    if (n < 2L) Nil\n        else {\n            val factors = mutable.List.fill(n.toInt\
    \ - 1)(2L)\n            val i = 3L\n            while (i < n.toInt) {\n      \
    \          val r = n % i\n                factors(i) += 1\n                n /=\
    \ i\n                if (r != 0) i += 1\n            }\n            factors.toList\n\
    \        }", "        val factorizations : mutable.Set[Long] = mutable.Set[Long]()\n\
    \        val divisors : mutable.Map[Long, Int] = mutable.Map.empty[Long, Int]\n\
    \n        def findDivisors(x : Long) : Unit = {\n            divisors(x) = divisors.getOrElse(x,\
    \ 0) + 1\n            if (divisors(x) > n) {\n                return\n       \
    \     }\n\n            if (n / x == x) {\n                factorizations.add(x)\n\
    \            }\n            if (x > 1) {\n                for (i <- divisors.keys)\
    \ {\n                    if (divisors(i) > n) {\n                        continue\n\
    \                    }\n\n                    if (x % i == 0) {\n            \
    \            divisors(i) = divisors.getOrElse(i, 0) + 1\n                    \
    \    findDivisors(x / i)\n                        divisors(i) = divisors.getOrElse(i,\
    \ 0) - 1\n                    }\n                }\n            }\n        }\n\
    \n        divisors(n) = 1\n        findDivisors(n)\n        factorizations.toList.sortWith(_\
    \ < _).map(_.toLong)", "        val factorizations : List[Long] = for (i <- 2l\
    \ until n) yield {\n            val factorization = factorizations(i)\n      \
    \      if (factorization.isDefined) {\n                factorization.get\n   \
    \         } else {\n                val result = factorizations(i - 1)\n     \
    \           result.getOrElse(1l)\n            }\n        }\n        factorizations.filter(_\
    \ > 1)", "        var factors: mutable.Set[Long] = mutable.Set()\n        for(i\
    \ <- 1 to n/2) {\n            for(j <- 2 to n/i) {\n                if(i*j ==\
    \ n) {\n                    factors += (i.toLong)\n                    factors\
    \ += (j.toLong)\n                    factors += (i*j.toLong)\n               \
    \ }\n            }\n        }\n        factors.toList", "        val factors =\
    \ mutable.ListBuffer[Long]()\n        def isPrime(x : Long) : Boolean = x.isPrime\
    \ && x != 1 && x != n\n        for(n <- 2 until n) if(isPrime(n)) {\n        \
    \    val m = n / 2\n            while(m != 1) { \n                if(n % m ==\
    \ 0){ factors += m; break}\n                m += 2\n            }\n        }\n\
    \        factors.toList", "        var factorization: List[Long] = Nil\n     \
    \   var currentFactor = n.toInt\n        var prevFactor = 1L\n        while(currentFactor\
    \ > 1L) {\n            if(prevFactor % currentFactor == 0) {\n               \
    \ factorization :+= currentFactor\n                prevFactor += 1\n         \
    \       currentFactor /= currentFactor\n            } else {\n               \
    \ prevFactor += 1\n                currentFactor /= currentFactor\n          \
    \  }\n        }\n        factorization", "        var primeList = List[Long]()\n\
    \        var nextPrime = 2\n        while (n % nextPrime != 0) {\n           \
    \ primeList :+= nextPrime\n            n /= nextPrime\n            nextPrime =\
    \ primeList._2\n        }\n        primeList :+= n\n        primeList.reverse",
  "      val a = scala.math.BigInt(n)\n      val b = scala.math.BigInt(2)\n      val\
    \ factors = new scala.collection.mutable.HashSet[Long]()\n      while (!factors.isEmpty)\
    \ {\n        val c = scala.math.BigInt(a)\n        if (c > 1) factors += c\n \
    \       a += b\n      }\n      factors.toList", "        val factors = mutable.HashSet[Long]()\n\
    \        for(i <- 2 to n){\n            if(n % i == 0){\n                factors\
    \ += i\n                n /= i\n            }\n        }\n        n match {\n\
    \            case 0 => factors\n            case i => factors ++ factorize(i)\n\
    \        }", "        val factorization = scala.collection.mutable.HashMap[Int,\
    \ Int]()\n        val primes = scala.collection.mutable.HashSet[Long]()\n    \
    \    var i = 1\n        while(i <= n) {\n            var x = 1\n            while(n\
    \ % x == 0) {\n                x += 1\n            }\n            primes += x\n\
    \            n /= x\n            if(factorization.contains(x)) {\n           \
    \     factorization.updated(x, factorization.get(x))\n            } else {\n \
    \               factorization.updated(x, 1)\n            }\n            i += 1\n\
    \        }\n        val primeFactors = primes.toList.map(x => x * factorization.get(x))\n\
    \        primeFactors.reverse //reverse list to match requirements", "       \
    \ val d = n.toInt\n        val list = Array.fill(d)(2) // List contains pairs\
    \ of numbers (prime factor, number of times it appeared in factorization)\n  \
    \      val factorization = scala.collection.mutable.ArrayBuffer.empty[List[Long]]\n\
    \        for(d <- 2 until d) {\n            val p = math.gcd(d, n) \n        \
    \    if (p != 1) {\n                list.updated(p, 1l) //update number of times\
    \ that appeared in factorization\n                factorization += List(d -> 1l)\
    \ //update factorization list with 1 time\n                n = math.gcd(n, p)\n\
    \            }\n        }\n        if (n > 1L) list.updated(n, 1l) //update number\
    \ of times that appeared in factorization\n        factorization.toList", "  \
    \      val factors = new mutable.HashMap[Long, Int]()\n        var divisor = n\n\
    \        var divisorPrime = divisor\n        val factor = new mutable.ListBuffer[Long]()\n\
    \        while (divisor > 0) {\n            divisor % divisorPrime match {\n \
    \               case 0 => divisorPrime = divisorPrime.toInt\n                case\
    \ _ => divisorPrime = divisorPrime / 2\n            }\n            divisor match\
    \ {\n                case 0 => divisorPrime * divisor match {\n              \
    \      case 0 => factors += (divisorPrime -> divisor.toInt)\n                \
    \    case 1 => factors += (divisorPrime -> 1)\n                    case _ => factors\
    \ += (divisorPrime -> divisor.toInt)\n                }\n                case\
    \ _ => factors += (divisorPrime -> divisor.toInt)\n            }\n        }\n\
    \        factor.toList.sortBy(-_)", "        val factors: mutable.MutableList[Long]\
    \ = mutable.MutableList[Long]()\n        val primes = Primes.primes\n        val\
    \ primeFactorizations : mutable.MutableSet[Long] = mutable.MutableSet[Long]()\n\
    \n        // To avoid calculating same factors multiple times\n        var factorFound\
    \ = false\n\n        for (p <- primes) {\n            val primeFactorization =\
    \ n.toPrime / p\n            if (primeFactorization.toLong == n) {\n         \
    \       // If factorization is equal to original number\n                factorFound\
    \ = true\n            } else {\n                // If factorization is not equal\
    \ to original number\n                primeFactorizations.union(primeFactorization)\n\
    \            }\n        }\n\n        if (factorFound) {\n            for (p <-\
    \ primes) {\n                // If factorization is equal to original number\n\
    \                if (primeFactorizations.contains(p.toLong))\n               \
    \     continue\n                factors.union(p.toLong * primeFactorizations.count(_\
    \ == p.toLong))\n            }\n        } else {\n            for (p <- primes)\
    \ {\n                // If factorization is not equal to original number\n   \
    \             if (!primeFactorizations.contains(p.toLong))\n                 \
    \   continue\n                factors.union(p.toLong * primeFactorizations.count(_\
    \ == p.toLong))\n            }\n        }\n\n        factors.toList", "      \
    \  val n = n.toInt\n        // If input is 1 then just return it\n        if (n\
    \ == 1) List(n)\n        // If input is prime number then return all its factors\n\
    \        else if (primeCheck(n)) n\n        else {\n            var tempFactors\
    \ = List(1)\n            // Iterate through all odd numbers except n for factorization\n\
    \            for (i <- 2 to n by 2) {\n                // If input number is divisible\
    \ by i then put it in list\n                if (n % i == 0) tempFactors = tempFactors\
    \ :+ i\n            }\n            // Return factors of n which appeared only\
    \ once\n            list(tempFactors)\n        }", "        val factors = scala.collection.mutable.ListBuffer[Long]()\n\
    \        val sqrt = Math.sqrt(n)\n        var nRemainder = n\n\n        for(d\
    \ <- 2 to sqrt) {\n            if(n % d == 0) {\n                factors += d\n\
    \                n /= d\n                nRemainder -= 1\n            }\n    \
    \    }\n        factors ++= 1 to nRemainder\n        factors.toList", "      \
    \  var factorization = List[Long](1l)\n        for(i <- 2 to Math.sqrt(n).toInt\
    \ by 2)\n            factorization :+= if (n % i == 0) i else n / i\n        factorization",
  "        // TODO: add checking if n is prime - not included now\n        val factors\
    \ = mutable.ListBuffer.empty[Long]\n        val maxFactor = 2L\n        while\
    \ (n > 1L) {\n            if ((n % maxFactor) == 0) {\n                factors\
    \ += maxFactor\n                n /= maxFactor\n            } else {\n       \
    \         maxFactor += 1\n            }\n        }\n        factors", "      \
    \  var factors: mutable.HashMap[Long, Int] = mutable.HashMap()\n        for(i\
    \ <- 2l to n.toLong) {\n            var p = i\n            while(true) {\n   \
    \             if(!factors.contains(p)) {\n                    factors += (p ->\
    \ 1l)\n                    break\n                }\n                p += 1\n\
    \            }\n        }\n        var factorization = factors.toSeq.sortBy(_._1).reverse\n\
    \        var factorizationList = List[Long]()\n        for(i <- 0 to factorization.length-1)\
    \ {\n            var f = factorization.take(i).toList\n            factorizationList\
    \ = factorizationList :+ f(0)*f.drop(1).sum\n        }\n        factorizationList",
  "        def getFactors(x : Long) : List[Long] = {\n            val factorizationsOfx\
    \ = factorizations(x)\n            var sumOfFactors = 0\n            for (i <-\
    \ factorizationsOfx.indices) {\n                var cur = factorizationsOfx(i)\n\
    \                while(cur.length > 1) {\n                    cur = factorizationsOfx(cur.filter(_\
    \ < x))\n                    sumOfFactors += cur.length\n                }\n \
    \           }\n            val list = List(1l.toLong, sumOfFactors.toLong)\n \
    \           list.filter(_ != 0)\n        }\n        val sumOfFactors = n.toLong\
    \ * getFactors(n).sum\n        sumOfFactors.toLong * getFactors(sumOfFactors).takeWhile(_\
    \ != 0).reverse", "        var factors = primeFactors(n)\n        factors.foreach(x\
    \ => factors.remove(x))\n        return factors", "        val primes = mutable.ArrayBuffer(2)\n\
    \        var k = 3\n        while(primes.size + k < primes.length && k <= n){\n\
    \            while (k*k < n) {\n                primes += k\n                k\
    \ += 1\n            }\n            k += 2\n        }\n        primes.toList",
  "        var nPrimeFactors = n\n        var factorization: List[Long] = List[Long]()\n\
    \        while (nPrimeFactors > 1) {\n            factorization = factorization:+\
    \ nPrimeFactors\n            nPrimeFactors /= 2\n        }\n        factorization\
    \ = factorization:+ nPrimeFactors\n        factorization", "        val factors\
    \ = mutable.ArrayBuffer.empty[Long]\n        (2 to n by 1).foreach{f => \n   \
    \         val q = n / f \n            n -= f * q\n            factors += f\n \
    \           factors += q\n        }\n        factors", "        val factorizations\
    \ =\n            n.toLong ->\n            List(1l) ::\n            List(n.toLong\
    \ ->\n                (2 to n.toLong.toInt) filter {\n                    x =>\
    \ (n % x) == 0\n                } map {\n                    x => x * x\n    \
    \            }) ::\n            List(n.toLong ->\n                (2 to n.toLong.toInt)\
    \ filter {\n                    x => (n % x) == 0 && x != 1\n                }\
    \ map {\n                    x => x * x\n                }) ::\n            (2\
    \ to n.toLong.toInt) filter {\n                x => (n % x) == 1 && x != 1\n \
    \           } map {\n                x => x * x\n            }\n        val factors\
    \ = factorizations(n)\n        val primes = factorizations(n.toLong.toInt)\n \
    \       (factors ++ primes).sortWith(_ < _)", "        val factorization = mutable.ArrayBuffer.empty[Long]\n\
    \        factorize(n,factorization)\n        factorization.toList", "        val\
    \ factors = scala.collection.mutable.ArrayBuffer.empty[Long]\n        var i =\
    \ 1\n        while(n % i == 0) {\n            n /= i\n            factors += i\n\
    \        }\n        if(n != 1) {\n            factors += n\n        }\n      \
    \  factors", "        val factorizations : MutableList[Long] = new MutableList[Long]\n\
    \        val factorCounts : mutable.Map[Long, Int] = mutable.Map.empty[Long, Int]\n\
    \        for (f <- 2 until math.sqrt(n)) {\n            if ((n % f) == 0) {\n\
    \                factorizations.update(f)\n                factorCounts(f) = factorCounts.getOrElse(f,\
    \ 0) + 1\n            }\n        }\n        factorizations.toList", "        val\
    \ factors = scala.collection.mutable.ListBuffer.empty[Long]\n        for (i <-\
    \ 2 to n.toInt) {\n            val fact = i / i.toLong\n            if (fact >\
    \ 1) {\n                factors += i.toLong\n                factors += fact -\
    \ 1\n            }\n        }\n        factors.toList", "        val factors =\
    \ primeFactors(n)\n        val factorized = factors.foldLeft(List[Long](0l)){\n\
    \            (acc: List[Long], x: Long) => acc ::: factorization(x, acc)\n   \
    \     }\n        factorized", "        var factors = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (prime <- PrimeFactors(n)) {\n            while (n % prime == 0)\
    \ {\n                factors += prime\n                n /= prime\n          \
    \  }\n        }\n        if (n > 1) {\n            factors += n\n        }\n \
    \       factors.toList", "        val factorizer = BigInt(n.toString.toInt)\n\
    \        val factorization = BigInt(factorizer).divideAndRemainder(BigInt(2))\n\
    \        val factorizationList = List(factorization._1.toLong, factorization._2.toLong)\n\
    \        if (factorization._1 == 0) factorizationList\n        else {\n      \
    \      val factorizationList2 = factorization._2.toLong * factorizationList\n\
    \            val factorizationList3 = List(factorization._1.toLong, factorizationList2)\n\
    \            factorizationList3\n        }", "        val factors = mutable.HashSet[Long]()\n\
    \        // Factorize n\n        var d = 2\n        var q = n\n        var r =\
    \ n\n        while (q > 0) {\n            val a = r / d\n            r = q % d\n\
    \            q = a\n            factors.add(a)\n            d = d + 1\n      \
    \  }\n        factors :: factors", "        val divisor = 2 // Only test divisors\
    \ up to sqrt(n)\n        val factorization = mutable.ListBuffer.empty[Long]\n\
    \        while(divisor <= math.sqrt(n)) {\n            val next = n/divisor\n\
    \            if(next * divisor = n) factorization.append(next)\n            else\
    \ if(next * divisor > n) factorization.append(next)\n            else factorization.append(next\
    \ * divisor)\n            divisor *= 2\n        }\n        if(math.sqrt(n) * 2\
    \ == n) factorization.append(math.sqrt(n))\n        else factorization.reverse",
  "        val factorization = Factorization(n.toInt)\n        factorization.factorize",
  "        val n = n.toInt\n        var factors = scala.collection.mutable.ListBuffer.empty[Long]\n\
    \        var i = 2\n        while (i <= n) {\n            var j = i\n        \
    \    while (j * i <= n) {\n                j *= i\n            }\n           \
    \ factors += i.toLong\n            i += 1\n        }\n        factors.toList",
  "        def factorize(n : Long) : List[Long] = {\n            val factorization\
    \ = n.factors\n            val factorizationCount = n.factors.size\n         \
    \   factorization.filter { x => (n % x) == 0 }.map { x => x * factorizationCount\
    \ }\n        }\n        factorize(n)", "        val factorization = if (isPrime(n))\
    \ {\n            if (n == 1l) List(1l)\n            else {\n                var\
    \ factors = List[Long]()\n                for (i <- 2l until n.toInt)\n      \
    \              if (n % i == 0)\n                        factors ::= i.toLong\n\
    \                factors\n            }\n        } else {\n            val factorization\
    \ = factorizeRecursive(n, List())\n            for (i <- factorization.reverse)\n\
    \                if (i == n) factorization ::= 1l\n                else if (i\
    \ != 1l) factorization ::= i.toLong\n            else factorization\n        }\n\
    \        factorization", "        if (n == 0)\n            List()\n        else\
    \ {\n            val factors = n % 2 match {\n                case 0 => List(n.toLong)\n\
    \                case 1 => List(n.toLong.toLong*2)\n                case _ =>\
    \ factorize(n / 2)\n            }\n            for (f <- factors) {\n        \
    \        for ((p, factor) <- factors.iterator.zipWithNext) {\n               \
    \     if (f == factor * p)\n                        break\n                }\n\
    \                if (factor != 0)\n                    factors ::: List(f)\n \
    \               else\n                    factors ::: List(f.toLong)\n       \
    \     }\n        }", "        val factors: List[Long] = List(1, 2)\n        val\
    \ primes = List(2, 3, 5, 7, 11)\n        primes.foreach(x => if (n%x == 0) factors\
    \ += x)\n        factors", "        val primeFactors = primeFactors(n)\n     \
    \   val factorization = n #:: primeFactors\n        val factorizationPrimes =\
    \ factorization.groupBy(_ % primeFactors.head)\n        val factorizationPrimesList\
    \ = factorizationPrimes map { case (factor, primes) =>\n            prime map\
    \ { prime =>\n                factor * prime\n            }\n        }\n     \
    \   factorizationPrimesList.flatten.distinct", "        val factors: mutable.Set[Long]\
    \ = mutable.Set()\n        val factorList = primeFactors(n)\n        val factorization:\
    \ mutable.Map[Long, Long] = mutable.Map()\n        for (a <- factorList) {\n \
    \           for (b <- factorList.filter(a==_)) {\n                factors += a\
    \ * b\n            }\n            factorization += a -> 1\n        }\n       \
    \ factorization.toList filter {_._2 <= n} map {_._1}", "        var factor : Long\
    \ = 1\n        var factorList : List[Long] = Nil\n        while (n >= factor)\
    \ {\n            factorList ::= factor\n            factor = factor * 2 // double\
    \ of current factor\n            if (n % factor == 0) {\n                n /=\
    \ factor\n            }\n        }\n        if (n > 1) {\n            factorList\
    \ ::= n\n        }\n        factorList.toList", "        val primes = 2 until\
    \ n by 2\n        primes.foldLeft(List(nil)){ case (res, x) =>\n            if\
    \ ((x % res.last) == 0) (res :+ x) else res\n        }", "        val fd = factors(n)\n\
    \        val nFactor = fd.length\n        val primeFactors = Vector.fill(nFactor)(0l).toList\n\
    \        var maxFactor = 0L\n        for(i <- 0 until fd.length) {\n         \
    \   val x = fd(i)\n            val m = n / x\n            val r = x % 1\n    \
    \        if (m == 0)\n                primeFactors(i) = maxFactor\n          \
    \  else if (m < maxFactor) {\n                maxFactor = m\n                primeFactors(i)\
    \ = maxFactor\n            } else {\n                primeFactors(i) = x\n   \
    \         }\n        }\n        return primeFactors", "        // Find primes\
    \ using Sieve of Eratosthenes\n        // https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \        // http://www.scala-lang.org/docu/files/collections-api/collections_40.html\n\
    \        // http://math.stackexchange.com/questions/72939/how-to-implement-sieve-of-eratosthenes-in-java\n\
    \n        val sieve = new Array[Long](math.MaxInt)\n        var p = 2\n\n    \
    \    // To avoid infinite loop\n        while(p < n) sieve(p) = p\n        p +=\
    \ 2 // To avoid infinite loop\n        val limit = p\n\n        for(i <- 2 until\
    \ limit) sieve(i) = false\n        var factorList = List[Long]()\n        for(i\
    \ <- 2 until limit){\n            if(!sieve(i)) factorList += i\n        }\n \
    \       factorList.reverse.dropWhile(e => e % 2 == 0).takeWhile(e => e % 2 ==\
    \ 0).map(e => e + 1)", "        val a = n.toInt\n        val m = 2l\n        val\
    \ d = 2l\n        val m1 = 2l\n        val d = 2l\n        val l = new collection.mutable.ListBuffer[Long]()\n\
    \        while (m * d <= a) {\n            if (a % m == 0) {\n               \
    \ val p = a.toLong / m\n                l.append(p)\n                a = a - p\
    \ * m\n            }\n            if (a % d == 0) {\n                val p = a.toLong\
    \ / d\n                l.append(p)\n                a = a - p * d\n          \
    \  }\n            m += 1\n            d += 1\n        }\n        if (a > 2l*m)\
    \ {\n            l.append(a)\n            l.size\n        } else {\n         \
    \   l.size\n        }", "        val factors = mutable.List.empty[Long]\n    \
    \    val limit = math.pow(n, 2l).toInt\n        for (i <- 2l.toLong to limit)\
    \ {\n            if (n % i == 0l) {\n                val p = n / i\n         \
    \       factors +=+ p\n                if (n % i == 0l) factors += p.toLong\n\
    \                factors += i\n            }\n        }\n        factors", " \
    \       val factorization = n.toString.split(\"(?<=\\\\d)\").filterNot(_.isEmpty)\n\
    \        val factors: List[Long] = factorization.map(factorize)\n        factors.flatten.distinct",
  "        var factors  = List();\n        var factorization = n.toInt;\n        //\
    \ The value of n should be the product of all factors\n        while (n != 1)\
    \ {\n            if (n % 2 == 0) {\n                factors += 2\n           \
    \     factorization *= 2\n                n /= 2\n            } else if (n % 3\
    \ == 0) {\n                factors += 3\n                factorization *= 3\n\
    \                n /= 3\n            }\n        }\n        return factors.toList\
    \ + factorization.toList", "        require(n >= 2l, \"Given number must be greater\
    \ than or equal to 2\")\n        require(n%1 == 0, \"Given number must be a positive\
    \ integer and even\")\n        val primeFactors = mutable.Set[Long]()\n      \
    \  val factorization = factorizeHelper(n)\n        factorization.foreach { f =>\n\
    \            primeFactors += f\n        }\n        primeFactors", "        def\
    \ primes(prime : Long, limit : Long) : List[Long] = {\n            val list =\
    \ new mutable.ListBuffer[Long]()\n            var counter = 1\n\n            while\
    \ (prime < limit) {\n                if (n % prime == 0) {\n                 \
    \   list += prime\n                    n /= prime\n                    counter\
    \ += 1\n                } else {\n                    prime += 1\n           \
    \     }\n            }\n            list.toList\n        }\n\n        val limit\
    \ = n.toInt\n        var prime = 2l\n        var list = primes(prime, limit)\n\
    \        var factors = new mutable.ListBuffer[Long]()\n\n        while (!list.isEmpty)\
    \ {\n            var i = 0\n            while (i < list.size) {\n            \
    \    val number = list(i)\n                if (number % prime == 0) {\n      \
    \              factors += number\n                    factors += factors(number\
    \ / prime)\n                }\n                i += 1\n            }\n\n     \
    \       list = primes(prime, limit)\n            prime = prime + 1l\n        }\n\
    \        factors.toList", "        var factors = new mutable.ListBuffer[Long]()\n\
    \        for(i <- 1 to Math.sqrt(n)) {\n            if(n % i == 0) {\n       \
    \         factors.append(i)\n                factors.append(n/i)\n           \
    \     break\n            }\n        }\n        factors.toList", "        // Prime\
    \ number list can be generated using a sieve of Eratosthenes algorithm.\n    \
    \    // Factorization is done using dynamic programming.\n        // Primes below\
    \ 10 are trivially factorized.\n        var primes = new Vector[Long](10l..n).toSet\n\
    \        val factorization = new mutable.LinkedHashSet[Long]\n        // Fill\
    \ the prime list from 1 to sqrt(n).\n        var i = 2\n        while (i <= n)\
    \ {\n            if (primes.contains(i)) {\n                primes = primes.filter(_\
    \ != i)\n                factorization.add(i)\n            }\n            i +=\
    \ 1\n        }\n        val factors = new Vector[Long]()\n        for (i <- 1\
    \ to n) {\n            if (factorization.contains(i)) {\n                factors\
    \ += i\n                factorization.remove(i)\n            }\n        }\n  \
    \      factors.reverse", "        var factorization = List.empty[Long]\n     \
    \   var temp : List[Long] = List(n)\n        var i : Long = 0\n        while (i\
    \ <= temp.length) {\n            val factors = temp.toSet\n            var newFactors\
    \ = factors.filterNot(f => temp.contains(f))\n            var newLength = newFactors.reduce((a,\
    \ b) => a * b)\n            factorization :+= newLength.toLong\n            temp\
    \ = newFactors\n            i += newLength\n        }\n        factorization.reverse"]
stop_tokens:
- "\n    }\n"
