language: scala
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) List(Tuple2(0,\
    \ 0)) :: Nil else {\n            var i = 0\n            val xList = lst.map( row\
    \ => {\n                val len = row.length\n                val row = row.drop(i).dropRight(len)\n\
    \                i <- row.lastIndex\n                row.headOption.map( _ + i\
    \ ).toList.sortBy(_ * -1) // sorted by columns in descending order\n         \
    \   } )\n            xList.map { row => row.map { col => (col, x) } }.sortBy(_._1)\
    \ // sorted by rows in ascending order\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmph62q4ob_.scala:25:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                i <- row.lastIndex\n\e[31m\e[31m   |\e\
    [0m                  ^^\e[0m\n\e[31m   |\e[0m                  end of statement\
    \ expected but '<-' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph62q4ob_.scala:20:29\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m (lst.isEmpty)\
    \ List(Tuple2(\e[31m0\e[0m, \e[31m0\e[0m)) :: Nil \e[33melse\e[0m {\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         Found:    List[(Int, Int)]\n\e[31m   |\e[0m        \
    \                 Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph62q4ob_.scala:28:35 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m            xList.map { \e[36mrow\e[0m => row.map { \e[36mcol\e\
    [0m => (col, x) } }.sortBy(_._1) \e[34m// sorted by rows in ascending order\e\
    [0m\n\e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue map is not a member of Nothing, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph62q4ob_.scala:28"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var row: List[Tuple2[Long,\
    \ Long]] = Nil\n        for (row <- lst) {\n            val sortedRow = row.sortBy(f\
    \ => -f.get)\n            var col: List[Tuple2[Long, Long]] = Nil\n          \
    \  for (col <- sortedRow) {\n                if ((col.get) == x) return (col,\
    \ row)\n            }\n        }\n        return Nil\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppgn0nwc_.scala:22:47 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36msortedRow\e[0m = row.sortBy(\e\
    [36mf\e[0m => -f.get)\n\e[31m\e[31m   |\e[0m                                 \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \  value get is not a member of Long\n\e[31m\e[31m-- Error: /tmp/tmppgn0nwc_.scala:22:51\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \     \e[33mval\e[0m \e[36msortedRow\e[0m = row.sortBy(\e[36mf\e[0m => -f.get)\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map {\n   \
    \         list => list.zipWithIndex.sortBy(_._1).map(_._2).toList\n        }\n\
    \        val cols = (lst zip rows map {\n            list => list.zipWithIndex.sortBy(_._2).map(_._1).toList\n\
    \        }).flatten\n        val rowInd = rows.indexWhere(row => row(0).contains(x))\n\
    \        val colInd = cols.indexWhere(col => col(0).contains(x))\n        if (rowInd\
    \ == -1 || colInd == -1) {\n            Nil\n        } else {\n            rows(rowInd).sortBy(-colInd).reverse.map((x,\
    \ y)) => (x, y)\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpt8d9f7to.scala:31:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            rows(rowInd).sortBy(-colInd).reverse.map((x,\
    \ y)) => (x, y)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            not a legal formal parameter\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpt8d9f7to.scala:24:25 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[36mlist\e[0m => list.zipWithIndex.sortBy(_._2).map(_._1).toList\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m           value zipWithIndex is not a member of (List[Long], List[Int])\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpt8d9f7to.scala:26:51 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mrowInd\e[0m = rows.indexWhere(\e\
    [36mrow\e[0m => row(\e[31m0\e[0m).contains(x))\n\e[31m\e[31m   |\e[0m        \
    \                                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                value contains is not a member of Int\n\e[31m\e\
    [31m-- [E050] Type Error: /tmp/tmpt8d9f7to.scala:27:44 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcolInd\e[0m = cols.indexWhere(\e\
    [36mcol\e[0m => col(\e[31m0\e[0m).contains(x))\n\e[31m\e[31m   |\e[0m        \
    \                                    ^^^\e[0m\n\e[31m   |\e[0m               \
    \                   \e[33mparameter\e[0m \e[35mcol\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt8d9f7to.scala:31:68\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            rows(rowInd).sortBy(-colInd).reverse.map((x,\
    \ y)) => (x, y)\n\e[31m\e[31m   |\e[0m                                       \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \                                    Not found: y\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Use map function\n    \
    \    // Iterate over every row of lst.\n        lst.map((row => \n           \
    \ // Iterate over every item of current row\n            row.map(x => \n     \
    \           // If the current item matches x\n                if (x == x) {\n\
    \                    // Return the index\n                    Tuple2[Long, Long](row.indexOf(x),\
    \ row.indexOf(x)) \n                }\n                // If current item doesn't\
    \ match x\n                else None\n            )\n        ))\n        // Sort\
    \ the rows by the first element\n        .sortWith((left, right) => left._1 <\
    \ right._1)\n        // Sort the rows by the second element\n        .sortWith((left,\
    \ right) => left._2 < right._2)\n        // Return the tuple\n        .sortWith((left,\
    \ right) => left._1 < right._1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd9lm9lk5.scala:35:40 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        .sortWith((left, right) => left._1 < right._1)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                value _1 is not a member of List[Object]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd9lm9lk5.scala:37:40 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        .sortWith((left, right) => left._2 < right._2)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                value _2 is not a member of List[Object]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd9lm9lk5.scala:39:40 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        .sortWith((left, right) => left._1 < right._1)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                value _1 is not a member of List[Object]\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) List(Tuple2(x,\
    \ x)) else lst.headOption match {\n            case None => lst.tail.tailOption\
    \ match {\n                case None => lst.tail.tail.tailOption match {\n   \
    \                 case None => lst.tail.tail.tail.tailOption match {\n       \
    \                 case None => lst.tail.tail.tail.tail.tailOption match {\n  \
    \                          case None => lst.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                case None => lst.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                    case None => lst.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                        case None => lst.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                            case None => lst.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                    case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                        case None =>\
    \ lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption match {\n      \
    \                                                      case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                case\
    \ None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption match {\n\
    \                                                                    case None\
    \ => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption match {\n\
    \                                                                        case\
    \ None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                  \
    \          case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                  \
    \              case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match {\n                                                                  \
    \                  case None => lst.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tailOption\
    \ match \n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv0owg6c9.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '{' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv0owg6c9.scala:51:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m51 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpv0owg6c9.scala:21:34 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m            \e[33mcase\e[0m None => lst.tail.tailOption \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue tailOption is not a member of List[List[Long] @uncheckedVariance]\
    \ - did you mean List[List[Long] @uncheckedVariance].lastOption?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpv0owg6c9.scala:22:43 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m None => lst.tail.tail.tailOption\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue tailOption is not a member of List[List[Long] @uncheckedVariance]\
    \ - did you mean List[List[Long] @uncheckedVariance].lastOption?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpv0owg6c9.scala:23:52 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    \e[33mcase\e[0m None => lst.tail.tail.tail.tailOption\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue tailOption is not a member of List[List[Long] @uncheckedVariance]\
    \ - did you mean List[List[Long] @uncheckedVariance].lastOption?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpv0owg6c9.scala:24:61 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                        \e[33mcase\e[0m None => lst.tail.tail.tail.tail.tailOption\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue tailOption is\
    \ not a member of List[List[Long] @uncheckedVariance] - did you mean List[List[Long]\
    \ @uncheckedV"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.map( x => ((x.indexOf(x)\
    \ + 1), x) )\n            .sortWith( (x, y) => if (x(0).compareTo(x(1))) > 0)\
    \ (-1) else 1)\n            .sortWith( (x, y) => if (y(0).compareTo(y(1))) > 0)\
    \ (-1) else 1)\n            .filter( x => x(0) == x(x(1).indexOf(x(x(1)).toLong))\
    \ )\n            .sortWith( (x, y) => if (x(0).compareTo(x(1))) > 0) (-1) else\
    \ 1)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyg2eoeyz.scala:21:61 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            .sortWith( (x, y) => \e[33mif\e[0m (x(\e\
    [31m0\e[0m).compareTo(x(\e[31m1\e[0m))) > \e[31m0\e[0m) (-\e[31m1\e[0m) \e[33melse\e\
    [0m \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \    ')' expected, but integer literal found\n\e[31m\e[31m-- Error: /tmp/tmpyg2eoeyz.scala:21:69\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \     .sortWith( (x, y) => \e[33mif\e[0m (x(\e[31m0\e[0m).compareTo(x(\e[31m1\e\
    [0m))) > \e[31m0\e[0m) (-\e[31m1\e[0m) \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \     ^^^^\e[0m\n\e[31m   |\e[0m                              end of statement\
    \ expected but 'else' found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyg2eoeyz.scala:21:53\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            .sortWith( (x, y)\
    \ => \e[33mif\e[0m (x(\e[31m0\e[0m).compareTo(x(\e[31m1\e[0m))) > \e[31m0\e[0m)\
    \ (-\e[31m1\e[0m) \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m       \
    \                                             ^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                               Found:    List[Long]\n\e[31m \
    \  |\e[0m                                                    Required: Integer\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyg2eoeyz.scala:21:59\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m            .sortWith( (x,\
    \ y) => \e[33mif\e[0m (x(\e[31m0\e[0m).compareTo(x(\e[31m1\e[0m))) > \e[31m0\e\
    [0m) (-\e[31m1\e[0m) \e[33melse\e[0m \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                                           Not found: >\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty){\n       \
    \     List[Tuple2[Long, Long]]()\n        } else {\n            // First sort\
    \ the list initially by row\n            lst.sortWith((x, y) => x.zip(y).zipped.map{case\
    \ (x, y) => x}.compare < 0)\n            // Then, sort the inner list initially\
    \ by column\n            lst.map(_.reverse).sortWith((x, y) => y.zip(x.zipped).map{case\
    \ (x, y) => x}.compare < 0)\n            // Now, you can do the search\n     \
    \       val result = lst.map{\n                case list => {\n              \
    \      val tuple = (list.indexWhere(x => x == x))\n                    (tuple.index\
    \ + 1, tuple.last)\n                }\n            }.filter(_._2 >= 0).map{\n\
    \                case (row, column) => Tuple2(row, column)\n            }\n  \
    \          result.sortWith(t => t._1._1 < t._1._2 || (t._1._1 == t._1._2 && t._2._1\
    \ < t._2._2))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz86c0wmx.scala:24:44 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            lst.sortWith((\e[36mx\e[0m, \e[36my\e[0m)\
    \ => x.zip(y).zipped.map{\e[33mcase\e[0m (x, y) => x}.compare < \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue zipped is not a member of List[(Long, Long)] - did you mean\
    \ List[(Long, Long)].zipAll?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz86c0wmx.scala:26:58\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            lst.map(_.reverse).sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => y.zip(x.zipped).map{\e[33mcase\e[0m (x, y) => x}.compare\
    \ < \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m     value zipped is not a member\
    \ of List[Long] - did you mean x.zipAll?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpz86c0wmx.scala:31:27 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                    (tuple.index + \e[31m1\e[0m, tuple.last)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \        value index is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpz86c0wmx.scala:31:44 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                    (tuple.index + \e[31m1\e[0m, tuple.last)\n\e[31m\e[31m\
    \   |\e[0m                                      ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                      value last is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpz86c0wmx.scala:33:26 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            }.filter(_._2 >= \e[31m0\e[0m).map{\n\e[31m\e\
    [31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue >= is not\
    \ a member of Nothing, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty) List()\n \
    \       val m = lst(0).size\n        val n = lst(0).map(_.size).sum\n        val\
    \ r = ListBuffer[Tuple2[Long, Long]]()\n        for(i <- 0 to n-1)\n        {\n\
    \            val cur = lst.map(x => x(i)).toList\n            val cur2 = cur.sortBy(x\
    \ => x(i)).reverse\n            val cur3 = cur2.sortBy(x => x(i)).reverse\n  \
    \          r += (Tuple2(cur(0), cur3(0)))\n        }\n        r.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvq6mamgk.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = lst(\e[31m0\e[0m).map(_.size).sum\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          value size is not a member of Long\n\e[31m\e[31m--\
    \ Error: /tmp/tmpvq6mamgk.scala:22:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = lst(\e[31m0\e[0m).map(_.size).sum\n\
    \e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mCharIsIntegral\e[0m\
    \ in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mIntIsIntegral\e\
    [0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter\
    \ num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpvq6mamgk.scala:27:39 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mcur2\e[0m = cur.sortBy(\e\
    [36mx\e[0m => x(i)).reverse\n\e[31m\e[31m   |\e[0m                           \
    \            ^\e[0m\n\e[31m   |\e[0m                                    \e[33mparameter\e\
    [0m \e[35mx\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpvq6mamgk.scala:27:44 -----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mcur2\e[0m = cur.sortBy(\e\
    [36mx\e[0m => x(i)).reverse\n\e[31m\e[31m   |\e[0m                           \
    \                 ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mDeprecatedFloatOrdering\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m\
    \ and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val mn = ListBuffer.empty[Tuple2[Long,\
    \ Long]]\n        var m = 0\n        var i = 0\n        var j = lst.length - 1\n\
    \        var r = 0\n        var c = 0\n        // For each row (r), find the first\
    \ element (in the sorted order) greater than x, \n        // and move to the left.\n\
    \        while ((i <= j) && (mn < x)) {\n            m += 1\n            if (r\
    \ == lst.length - 1) {\n                mn += Tuple2[Long, Long](m, lst(m)(lst.length\
    \ - 1))\n                return mn.toList\n            }\n            i +=1\n\
    \            r += 1\n        }\n        // For each row (r), find the first element\
    \ (in the sorted order) less than x, \n        // and move to the right.\n   \
    \     while ((i <= j) && (mn > x)) {\n            m += 1\n            i += 1\n\
    \            if (r == lst.length - 1) {\n                mn += Tuple2[Long, Long](m,\
    \ lst(m)(lst.length - 1))\n                return mn.toList\n            }\n \
    \           r += 1\n        }\n        // For each row (r), find the first element\
    \ (in the sorted order) greater than x, \n        // and move to the left. Then\
    \ move to the right.\n        while ((i <= j) && (mn > x)) {\n            m +=\
    \ 1\n            if (r == lst.length - 1) {\n                mn += Tuple2[Long,\
    \ Long](m, lst(m)(lst.length - 1))\n                return mn.toList\n       \
    \     }\n            i +=1\n            r += 1\n        }\n        // For each\
    \ row (r), find the first element (in the sorted order) less than x, \n      \
    \  // and move to the right. Then move to the left.\n        while ((i <= j) &&\
    \ (mn < x)) {\n            m += 1\n            j +=1\n            if (r == lst.length\
    \ - 1) {\n                mn += Tuple2[Long, Long](m, lst(m)(lst.length - 1))\n\
    \                return mn.toList\n            }\n            r += 1\n       \
    \ }\n        // For each row (r), find the first element (in the sorted order)\
    \ greater than x, \n        // and move to the left. Then move to the right.\n\
    \        while ((i <= j) && (mn < x)) {\n            m += 1\n            i +=1\n\
    \            c += 1\n            if (r == lst.length - 1) {\n                mn\
    \ += Tuple2[Long, Long](m, lst(m)(lst.length - 1))\n                return mn.toList\n\
    \            }\n            r += 1\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpinm42t8c.scala:28:31 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mwhile\e[0m ((i <= j) && (mn < x)) {\n\e\
    [31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of scala.collection.mutable.ListBuffer[(Long, Long)], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpinm42t8c.scala:39:31 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mwhile\e[0m ((i <= j) && (mn > x)) {\n\e\
    [31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ > is not a member of scala.collection.mutable.ListBuffer[(Long, Long)], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpinm42t8c.scala:50:31 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mwhile\e[0m ((i <= j) && (mn > x)) {\n\e\
    [31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ > is not a member of scala.collection.mutable.ListBuffer[(Long, Long)], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpinm42t8c.scala:61:31 ------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mwhile\e[0m ((i <= j) && (mn < x)) {\n\e\
    [31m\e[31m   |\e[0m                            ^^^^\e[0m\n\e[31m   |\e[0mva"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.zipWithIndex.sortBy(_._1).reverse.filter(e\
    \ => e._2 == x).map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwg8h6mxw.scala:20:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        lst.zipWithIndex.sortBy(_._1).reverse.filter(\e\
    [36me\e[0m => e._2 == x).map(_._1)\n\e[31m\e[31m   |\e[0m                    \
    \                 ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\
    \e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[List[Long]].\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m   |\e[0m\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660010514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val r = new HashMap[Long,\
    \ List[Long]]()\n        val r2 = new HashMap[Long, List[Long]]()\n        for(e\
    \ <- lst.take(lst.length - 1)){\n            val n = new HashMap[Long, List[Long]]()\n\
    \            for(i <- e.drop(1)){\n                val ni = new HashMap[Long,\
    \ List[Long]]()\n                n.put(i.asInstanceOf[Long], ni)\n           \
    \ }\n            val temp = new HashMap[Long, List[Long]]()\n            for(i\
    \ <- e.drop(1)){\n                temp.put(i.asInstanceOf[Long], List(n.keySet().toList))\n\
    \            }\n            r2.put(e.head, temp)\n        }\n        val l = new\
    \ ListBuffer[(Long, Long)]()\n        for(e <- r2.keySet()){\n            l.append((e._1,\
    \ x))\n        }\n        l.sortWith((x, y) => x._1 <=> y._1)\n        l.sortWith((x,\
    \ y) => y._1 <=> x._1)\n        val r3 = (l(0)).asInstanceOf[Tuple2[Long, Long]]\n\
    \        return List(r3)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpovcldj1w.scala:26:44\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                n.put(i.asInstanceOf[\e\
    [35mLong\e[0m], ni)\n\e[31m\e[31m   |\e[0m                                   \
    \         ^^\e[0m\n\e[31m   |\e[0m     Found:    (ni : scala.collection.mutable.HashMap[Long,\
    \ List[Long]])\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpovcldj1w.scala:30:60 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                temp.put(i.asInstanceOf[\e[35mLong\e\
    [0m], List(n.keySet().toList))\n\e[31m\e[31m   |\e[0m                        \
    \                            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter elem of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSetOps\e[0m: (elem: Long): Boolean\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpovcldj1w.scala:32:27 --------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            r2.put(e.head, temp)\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^\e[0m\n\e[31m   |\e[0m   Found:    (temp : scala.collection.mutable.HashMap[Long,\
    \ List[Long]])\n\e[31m   |\e[0m   Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmpovcldj1w.scala:35:26 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mfor\e[0m(e <- r2.keySet()){\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument for\
    \ parameter elem of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mtrait\e[0m \e\
    [35mSetOps\e[0m: (elem: Long): Boolean\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpovcldj1w.scala:38:34 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m        l.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x._1 <=> y._1)\n\e[31m\e\
    [31m   |\e[0m                             ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \            value <=> is not a member of Long - did you mean _1.<=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpovcldj1w.scala:39:34 ------------------------\e\
    [0m\e[0m\n\e[31m39"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.map(row => row.zipWithIndex.filter(e\
    \ => e._2 == x).sortWith(a => a._1 > a._2).map(e => Tuple2(e._2 + 1, e._1))).sortWith(a\
    \ => a._1 < a._2).map(e => e.toList)}\n    // You are given a 2 dimensional data,\
    \ as a nested lists,\n    // which is similar to matrix, however, unlike matrices,\n\
    \    // each row may contain a different number of columns.\n    // Given lst,\
    \ and integer y, find integers y in the\n    // list of nested lists,\n    //\
    \ and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
    \ initially by columns in ascending order.\n    // Also, sort coordinates of the\
    \ row by columns in descending order.\n    // Examples:\n    // >>> getCol((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (2l))\n    // (List[Tuple2[Long,\
    \ Long]]((0l, 0l), (2l, 1l), (2l, 2l), (0l, 3l), (0l, 4l)))\n    // >>> getCol((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (6l))\n    // (List[Tuple2[Long,\
    \ Long]]((0l, 0l), (2l, 2l)))\n    // >>> getCol((List[List[Long]]()), (2l))\n\
    \    // (List[Tuple2[Long, Long]]())\n    def getCol(lst : List[List[Long]], y\
    \ : Long) : List[Tuple2[Long, Long]] = {\n        lst.map(row => row.zipWithIndex.filter(e\
    \ => e._1 == \n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplyldbxqa.scala:38:59 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        lst.map(\e[36mrow\e[0m => row.zipWithIndex.filter(\e\
    [36me\e[0m => e._1 == \n\e[31m\e[31m   |\e[0m                                \
    \                           ^\e[0m\n\e[31m   |\e[0m                          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E086] Syntax Error: /tmp/tmplyldbxqa.scala:20:74 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        lst.map(\e[36mrow\e[0m => row.zipWithIndex.filter(\e\
    [36me\e[0m => e._2 == x).sortWith(\e[36ma\e[0m => a._1 > a._2).map(\e[36me\e[0m\
    \ => Tuple2(e._2 + \e[31m1\e[0m, e._1))).sortWith(\e[36ma\e[0m => a._1 < a._2).map(\e\
    [36me\e[0m => e.toList)}\n\e[31m\e[31m   |\e[0m                              \
    \                                          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Wrong number of parameters, expected: 2\n\e\
    [31m\e[31m-- [E086] Syntax Error: /tmp/tmplyldbxqa.scala:20:135 --------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        lst.map(\e[36mrow\e[0m => row.zipWithIndex.filter(\e\
    [36me\e[0m => e._2 == x).sortWith(\e[36ma\e[0m => a._1 > a._2).map(\e[36me\e[0m\
    \ => Tuple2(e._2 + \e[31m1\e[0m, e._1))).sortWith(\e[36ma\e[0m => a._1 < a._2).map(\e\
    [36me\e[0m => e.toList)}\n\e[31m\e[31m   |\e[0m                              \
    \                                                                            \
    \                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                      Wrong number of parameters, expected: 2\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmplyldbxqa.scala:20:162 -------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        lst.map(\e[36mrow\e[0m => row.zipWithIndex.filter(\e\
    [36me\e[0m => e._2 == x).sortWith(\e[36ma\e[0m => a._1 > a._2).map(\e[36me\e[0m\
    \ => Tuple2(e._2 + \e[31m1\e[0m, e._1))).sortWith(\e[36ma\e[0m => a._1 < a._2).map(\e\
    [36me\e[0m => e.toList)}\n\e[31m\e[31m   |\e[0m                              \
    \                                                  "
  stdout: ''
  timestamp: 1660010516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            val lst_copy = lst.sortWith(_(_).lt(x))\n\
    \            val x_copy = x.toLong\n            var result = lst_copy.map {\n\
    \                case row if (row.contains(x_copy)) => (0l, row.indexOf(x_copy))\n\
    \                case row => row.zipWithIndex.map {\n                    case\
    \ (elm, idx) => (0l, elm._1 - idx)\n                }\n            }.toList\n\
    \            val tempCol = result.sortWith(_._1 < _._1).map(x => x._1).reverse\n\
    \            result = result.sortWith(_._1 < _._1).map(x => (x._1, x._2 + tempCol.indexOf(_._2)\
    \ - tempCol.indexOf(_._1))).toList\n            result\n        }\n        getRow(lst,\
    \ x)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph_wovojm.scala:21:42\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e\
    [36mlst_copy\e[0m = lst.sortWith(_(_).lt(x))\n\e[31m\e[31m   |\e[0m          \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \                     Found:    (_$2 : List[Long])\n\e[31m   |\e[0m          \
    \                                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmph_wovojm.scala:26:48 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    \e[33mcase\e[0m (elm, idx) => (\e\
    [31m0l\e[0m, elm._1 - idx)\n\e[31m\e[31m   |\e[0m                            \
    \                ^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \        value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmph_wovojm.scala:29:44 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m            \e[33mval\e[0m \e[36mtempCol\e[0m = result.sortWith(_._1 < _._1).map(\e\
    [36mx\e[0m => x._1).reverse\n\e[31m\e[31m   |\e[0m                           \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                             value _1\
    \ is not a member of Object & Equals\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_wovojm.scala:29:66\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m\
    \ \e[36mtempCol\e[0m = result.sortWith(_._1 < _._1).map(\e[36mx\e[0m => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                             value _1 is not\
    \ a member of Object & Equals\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_wovojm.scala:30:39\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            result = result.sortWith(_._1\
    \ < _._1).map(\e[36mx\e[0m => (x._1, x._2 + tempCol.indexOf(_._2) - tempCol.indexOf(_._1))).toList\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                             value _1 is not a member of Object & Equals\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph_"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val size = lst(0).length\n\
    \        var found = false\n        val rows = lst.map(row => {\n            var\
    \ column = 0\n            while (!found && column < row.length) column += 1;\n\
    \            val tuple = column.zip(row.zipWithIndex).find(_._2 == x).map(_._1)\n\
    \            if (tuple.isEmpty) ()\n            else tuple.toList\n        }).toList\n\
    \        rows.sortWith((a, b) => {\n            if (a.toLong > b.toLong) return\
    \ true\n            else return false\n        }).sortWith((a, b) => {\n     \
    \       if (a.toLong < b.toLong) return true\n            else return false\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpio6xi1m0.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mtuple\e[0m = column.zip(row.zipWithIndex).find(_._2\
    \ == x).map(_._1)\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        value zip is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpio6xi1m0.scala:30:18 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (a.toLong > b.toLong) \e[33mreturn\e\
    [0m \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue toLong is not a member of Unit, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpio6xi1m0.scala:30:44\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mif\e[0m (a.toLong\
    \ > b.toLong) \e[33mreturn\e[0m \e[31mtrue\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                                     ^^^^\e[0m\n\e[31m   |\e[0m             \
    \                               Found:    (\e[31mtrue\e[0m : Boolean)\n\e[31m\
    \   |\e[0m                                            Required: List[(Long, Long)]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpio6xi1m0.scala:31:24\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33melse\e[0m \e\
    [33mreturn\e[0m \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m                      \
    \  ^^^^^\e[0m\n\e[31m   |\e[0m                        Found:    (\e[31mfalse\e\
    [0m : Boolean)\n\e[31m   |\e[0m                        Required: List[(Long, Long)]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpio6xi1m0.scala:33:18\
    \ ----------"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rowSize = lst.head.size\n\
    \        val colSize = lst.last.head\n        val rows = lst\n        .map { row\
    \ =>\n            val r = row\n            .zipWithIndex.map {\n             \
    \   case (val, index) => (index, val)\n            }\n            .sortBy(x =>\
    \ (x._1, x._2))\n            .map(x => (x._2, x._1))\n            .toArray\n \
    \           .sortBy(x => (-x._1, -x._2))\n            .map(x => (x._2, x._1))\n\
    \            .map(x => Tuple2((x._1 * rowSize + x._2, x._1 * rowSize + x._1)))\n\
    \        }\n        val result = rows.find(x => x._1 == x).map { x =>\n      \
    \      val r = x._2\n            .zipWithIndex.map {\n                case (val,\
    \ index) => (index, val)\n            }\n            .sortBy(x => (x._1, x._2))\n\
    \            .map(x => (x._2, x._1))\n            .toArray\n            .sortBy(x\
    \ => (-x._1, -x._2))\n            .map(x => (x._2, x._1))\n            .map(x\
    \ => Tuple2((x._1 * rowSize + x._2, x._1 * colSize + x._1)))\n        }\n    \
    \    result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpwl28bh5w.scala:26:22 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mcase\e[0m (\e[33mval\e[0m, index)\
    \ => (index, \e[33mval\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^\e\
    [0m\n\e[31m   |\e[0m                      pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpwl28bh5w.scala:26:45 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mcase\e[0m (\e[33mval\e[0m, index)\
    \ => (index, \e[33mval\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \                   ^^^\e[0m\n\e[31m   |\e[0m                                \
    \       expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E032] Syntax Error: /tmp/tmpwl28bh5w.scala:38:22 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                \e[33mcase\e[0m (\e[33mval\e[0m, index)\
    \ => (index, \e[33mval\e[0m)\n\e[31m\e[31m   |\e[0m                      ^^^\e\
    [0m\n\e[31m   |\e[0m                      pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpwl28bh5w.scala:38:45 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                \e[33mcase\e[0m (\e[33mval\e[0m, index)\
    \ => (index, \e[33mval\e[0m)\n\e[31m\e[31m   |\e[0m                          \
    \                   ^^^\e[0m\n\e[31m   |\e[0m                                \
    \       expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpwl28bh5w.scala:31:26 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            .sortBy(x => (-x._1, -x._2))\n\e[31m\e[31m\
    \   |\e[0m                          ^^^^^\e[0m\n\e[31m   |\e[0mvalue unary_- is\
    \ not a member of Null, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var row1 = new mutable.ArrayBuffer[Tuple2[Long,\
    \ Long]]();\n        var row2 = new mutable.ArrayBuffer[Tuple2[Long, Long]]();\n\
    \        var row3 = new mutable.ArrayBuffer[Tuple2[Long, Long]]();\n        var\
    \ currentRow = List[Tuple2[Long, Long]]()\n        var counter1 = 0, counter2\
    \ = 0, counter3 = 0;\n        for(i <- 0 until lst.length){\n            for(j\
    \ <- 0 until lst(i).length){\n                if (lst(i)(j) == x){\n         \
    \           currentRow += new Tuple2[Long, Long](i, j);\n                    counter1\
    \ += 1;\n                }\n                if (lst(i)(j) == x){\n           \
    \         row1 += new Tuple2[Long, Long](i, j);\n                    counter2\
    \ += 1;\n                }\n                if (lst(i)(j) == x){\n           \
    \         row2 += new Tuple2[Long, Long](i, j);\n                    counter3\
    \ += 1;\n                }\n            }\n        }\n        if (counter1 > counter2\
    \ && counter1 > counter3){\n            row1 += new Tuple2[Long, Long](0, 0);\n\
    \            row2 += new Tuple2[Long, Long](0, 0);\n            row3 += new Tuple2[Long,\
    \ Long](0, 0);\n        }\n        if (counter2 > counter1){\n            row2\
    \ += new Tuple2[Long, Long](0, 0);\n            row3 += new Tuple2[Long, Long](0,\
    \ 0);\n        }\n        if (counter3 > counter1){\n            row3 += new Tuple2[Long,\
    \ Long](0, 0);\n        }\n        var tempRow = row1 ++ row2 ++ row3\n      \
    \  tempRow.sortBy(_._1)\n        tempRow.sortBy(_._2).reverse\n        var result\
    \ = tempRow.toList\n        result.sortBy(_._1)\n        result.sortBy(_._2).reverse\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwcflb9tj.scala:24:24 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mvar\e[0m \e[36mcounter1\e[0m = \e[31m0\e\
    [0m, counter2 = \e[31m0\e[0m, counter3 = \e[31m0\e[0m;\n\e[31m\e[31m   |\e[0m\
    \                        ^\e[0m\n\e[31m   |\e[0m                        end of\
    \ statement expected but ',' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwcflb9tj.scala:20:23\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e\
    [36mrow1\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mTuple2\e[0m[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]]();\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpwcflb9tj.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mrow2\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]();\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpwcflb9tj.scala:22:23 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mrow3\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]();\n\e[31m\e[31m   |\e[0m \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwcflb9tj.scala:28:31\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m                    currentRow\
    \ += \e[33mnew\e[0m \e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m](i, j);\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ += is not a member of List[(Long, Long)] - did you mean List[(Long, Long)].!=?\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwcflb9tj.scala:33"
  stdout: ''
  timestamp: 1660010516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // TODO: Your code goes here\n\
    \        if (lst.isEmpty) return List((0l, 0l))\n        val mn = lst.head\n \
    \       val mx = lst.last\n        val m = mx.length\n        val n = mn.length\n\
    \        val r = List((0l, 0l))\n        for (i <- 0 until n) {\n            if\
    \ (mx(i) < mn || mn == mx) {\n                r(i) = List((i, 0l))\n         \
    \   }\n        }\n        for ((i, j) <- r.zipWithIndex) {\n            val d\
    \ = x\n            if (j < n) d = mx(j)\n            if (d > mx(i)) d = mx(i)\n\
    \            if (d >= mn) r(i) = List((i, 0l))\n        }\n        return r.map(x\
    \ => (x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5eld9vjr.scala:28:22 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (mx(i) < mn || mn == mx) {\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the\
    \ overloaded alternatives of \e[33mmethod\e[0m \e[35m<\e[0m in \e[33mclass\e[0m\
    \ \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e\
    [0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x:\
    \ Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short):\
    \ Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments\
    \ ((mn : List[Long]))\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5eld9vjr.scala:29:16\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                r(i) = List((i,\
    \ \e[31m0l\e[0m))\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0mvalue\
    \ update is not a member of List[(Long, Long)] - did you mean r.updated?\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp5eld9vjr.scala:34:25 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mif\e[0m (j < n) d = mx(j)\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \             Reassignment to val d\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5eld9vjr.scala:35:23 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mif\e[0m (d > mx(i)) d = mx(i)\n\e[31m\e[31m   |\e[0m\
    \                       ^\e[0m\n\e[31m   |\e[0m                       Found: \
    \   (i : (Long, Long))\n\e[31m   |\e[0m                       Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5eld9vjr.scala:35:34\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mif\e[0m (d\
    \ > mx(i)) d = mx(i)\n\e[31m\e[31m   |\e[0m                                  ^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (i : (Long, Long))\n\
    \e[31m   |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m lo"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.head\n       \
    \ val n = lst.last\n        val r = m.indexOf(x)\n        val c = n.indexOf(x)\n\
    \        val row = r.toInt\n        val col = c.toInt\n        val lst2 = lst.reverse.take(row+1).reverse.drop(1)\n\
    \        val lst3 = lst2.take(col+1).reverse.drop(1)\n        (for (i <- 0 until\
    \ row) yield (lst3(i), lst(i))).sortBy(_._1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmphh9kcbmn.scala:28:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        (\e[33mfor\e[0m (i <- \e[31m0\e[0m until row)\
    \ \e[33myield\e[0m (lst3(i), lst(i))).sortBy(_._1)\n\e[31m\e[31m   |\e[0m    \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0mNo implicit Ordering defined for List[Long]..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[List[Long]].\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m   |\e[0m\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660010517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val res = mutable.ListBuffer[Tuple2[Long,\
    \ Long]]()\n        val lst1 = lst.flatten\n        val lst2 = lst1.filter( i\
    \ => i != x)\n        val res1 = lst2.foldLeft((x,x))((b, c) => (b,c))\n     \
    \   res ++= res1\n        res.sortBy(t => t._1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8h5rsprm.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = mutable.ListBuffer[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8h5rsprm.scala:23:51\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mres1\e\
    [0m = lst2.foldLeft((x,x))((\e[36mb\e[0m, \e[36mc\e[0m) => (b,c))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^\e[0m\n\e[31m  \
    \ |\e[0m                                            Found:    (b : (Long, Long))\n\
    \e[31m   |\e[0m                                            Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_.map(x\
    \ => x.toLong))\n        val cols = rows.head.tail\n        val lst2 = lst.map(_.tail).map(_.map(_.toLong)).flatMap(_\
    \ ++ List(x.toLong))\n        val lst3 = lst2.sortBy(_).reverse.sortBy(_)\n  \
    \      lst3.map(x => Tuple2(x._1, x._2))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpwxqe2hza.scala:23:31 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst2.sortBy(_).reverse.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \ Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$6 of expanded function:\n\e[31m   |\e[0m   (_$6,\
    \ _$7) => lst2.sortBy(_$6).reverse.sortBy(_$7).\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmpwxqe2hza.scala:23:49 -----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst2.sortBy(_).reverse.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                                 ^\e[0m\n\
    \e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I\
    \ could not infer the type of the parameter _$7 of expanded function:\n\e[31m\
    \   |\e[0m   (_$6, _$7) => lst2.sortBy(_$6).reverse.sortBy(_$7).\n\e[31m\e[31m--\
    \ Error: /tmp/tmpwxqe2hza.scala:23:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst2.sortBy(_).reverse.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedDoubleOrdering\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n      lst.zipWithIndex.sortBy(_._1).map(t\
    \ => (t._2, t._1)).filter(t => t._2 == x).map(t => (t._2, t._2-1)).toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp4khze90h.scala:20:35 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m      lst.zipWithIndex.sortBy(_._1).map(\e[36mt\e[0m\
    \ => (t._2, t._1)).filter(\e[36mt\e[0m => t._2 == x).map(\e[36mt\e[0m => (t._2,\
    \ t._2-\e[31m1\e[0m)).toList\n\e[31m\e[31m   |\e[0m                          \
    \         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\
    \e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[List[Long]].\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m   |\e[0m\n1\
    \ error found\n"
  stdout: ''
  timestamp: 1660010517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_.zipWithIndex).sortBy(_._1).map(x\
    \ => x._2)\n        val cols = rows.map(_.zipWithIndex).sortBy(_._1).map(x =>\
    \ x._2)\n        val r = rows.map(x => (x, x.indexOf(x)))\n        val c = cols.map(x\
    \ => (x, x.lastIndexOf(x)))\n        r.zip(c.filter(_._2 == x)).filter(_._2 !=\
    \ 0).toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpopq33fhx.scala:20:52 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = lst.map(_.zipWithIndex).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \               ^^^^\e[0m\n\e[31m   |\e[0m                           value _1\
    \ is not a member of List[(Long, Int)]\n\e[31m\e[31m-- Error: /tmp/tmpopq33fhx.scala:20:55\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36mrows\e[0m = lst.map(_.zipWithIndex).sortBy(_._1).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \                    ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e\
    [33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e\
    [33mobject\e[0m \e[35mShort\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010517
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rs = lst.map(row => row.map(_\
    \ - 1)).toSeq.sortWith((x, y) => y < x).zipWithIndex.filter(_._2 > 0).map(_._1).reverse.sortWith((x,\
    \ y) => y < x).zipWithIndex.filter(_._2 > 0).map(_._2).reverse.map(row => Tuple2(x\
    \ = x, y = row))\n        val r0 = rs.find(row => row.x == x).map { x => Tuple2(x,\
    \ x.y) }.getOrElse(Tuple2(x = x, y = 0))\n        val r1 = rs.filter(row => row.y\
    \ == 0).sortWith((x, y) => y < x).zipWithIndex.filter(_._2 > 0).map(_._1).reverse.map(row\
    \ => Tuple2(x = x, y = row))\n        r0 :: r1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmt15weur.scala:20:75 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mrs\e[0m = lst.map(\e[36mrow\e\
    [0m => row.map(_ - \e[31m1\e[0m)).toSeq.sortWith((\e[36mx\e[0m, \e[36my\e[0m)\
    \ => y < x).zipWithIndex.filter(_._2 > \e[31m0\e[0m).map(_._1).reverse.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => y < x).zipWithIndex.filter(_._2 > \e[31m0\e[0m).map(_._2).reverse.map(\e\
    [36mrow\e[0m => Tuple2(x = x, y = row))\n\e[31m\e[31m   |\e[0m               \
    \                                                          ^^^\e[0m\n\e[31m  \
    \ |\e[0mvalue < is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmt15weur.scala:20:149\
    \ -----------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mrs\e[0m = lst.map(\e[36mrow\e[0m => row.map(_ - \e[31m1\e[0m)).toSeq.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => y < x).zipWithIndex.filter(_._2 > \e[31m0\e[0m).map(_._1).reverse.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => y < x).zipWithIndex.filter(_._2 > \e[31m0\e[0m).map(_._2).reverse.map(\e\
    [36mrow\e[0m => Tuple2(x = x, y = row))\n\e[31m\e[31m   |\e[0m               \
    \                                                                            \
    \                                                        ^^^\e[0m\n\e[31m   |\e\
    [0mvalue < is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpmt15weur.scala:20:222 ----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mrs\e[0m = lst.map(\e[36mrow\e\
    [0m => row.m"
  stdout: ''
  timestamp: 1660010519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) List(Tuple2(x,\
    \ x)).sortBy(t => t._1) // empty row is treated as (row, row)\n        else {\n\
    \            val lists = lst\n            val result = (0, 0) // we keep results\
    \ for last row\n            val listIt = lists.iterator // we need list iterator,\
    \ so we can remove items when we get to last element\n            val rowIt =\
    \ lists.map(_.head).iterator // we need row iterator, so we can remove items when\
    \ we get to first element\n            val removed = if (listIt.isEmpty || rowIt.isEmpty\
    \ || rowIt.next > listIt.next) {\n                listIt.next\n            } else\
    \ rowIt.next // remove element that we don't need\n\n            while (removed\
    \ > 0) {\n                val l1 = listIt.next()\n                val r1 = rowIt.next()\n\
    \                val l2 = listIt.next()\n                val r2 = rowIt.next()\n\
    \n                val isRow = l1.head < r2\n                val isCol = l2.head\
    \ < r1\n\n                // if we are not in order, then sort it\n          \
    \      if (!isRow && !isCol) {\n                    val isReversed = r1 < l1\n\
    \                    if (isReversed) {\n                        (l1, r2).sortWith(_\
    \ > _)\n                    } else {\n                        (l2, r1).sortWith(_\
    \ > _)\n                    }\n                }\n                // if we are\
    \ in order already, then skip\n                else if ((!isRow && isCol) || (isRow\
    \ && !isCol)) {\n                    listIt.remove()\n                    rowIt.remove()\n\
    \                    removed--\n                } else {\n                   \
    \ val isReversed = r1 < l1\n                    if (isReversed) {\n          \
    \              (l1, r1).sortWith(_ > _)\n                    } else {\n      \
    \                  (l1, r2++).sortWith(_ > _)\n                    }\n       \
    \         }\n            }\n\n            val resultTuple = if (lists.isEmpty)\
    \ List((x, y))\n            else lists.map(_.head).map(t => Tuple2(t, y)).sortBy(t\
    \ => t._2)\n            result.zip(resultTuple).map(x => Tuple2(x.get._1, x.get._2))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjel_9hba.scala:52:29 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                    removed--\n\e[31m\e[31m   |\e[0m\
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmpjel_9hba.scala:58:33 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m                        (l1, r2++).sortWith(_ > _)\n\e\
    [31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m  \
    \                               expression expected but \e[31m')'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpjel_9hba.scala:26:76 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mremoved\e[0m = \e[33mif\e\
    [0m (listIt.isEmpty || rowIt.isEmpty || rowIt.next > listIt.next) {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \ ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e\
    [31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m\
    \   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e\
    [0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x:\
    \ Byte): Boolean\n\e[31m   |\e[0mmatch arguments (List[Long])\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjel_9hba.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mwhile\e[0m (removed > \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ > is not a member of Matchable, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e"
  stdout: ''
  timestamp: 1660010532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var row = 0\n        var col\
    \ = 0\n        var result = List[Tuple2[Long, Long]]()\n        for( row <- 0\
    \ until lst.length ) {\n            if( lst(row).size < x ) break\n          \
    \  val temp = row :: lst(row)\n            lst(row) = (lst(row).drop(x).reverse)\n\
    \            lst(row) = (temp.head :: lst(row))\n        }\n        for( row <-\
    \ 0 until lst.length ) {\n            val temp = row :: lst(row)\n           \
    \ if( temp.size < x ) break\n            lst(row) = (temp.tail.reverse)\n    \
    \    }\n        for( row <- 0 until lst.length ) {\n            if( lst(row).size\
    \ < x ) break\n            result ::= row -> lst(row)\n        }\n        for(\
    \ row <- 0 until lst.length ) {\n            if( lst(row).size < x ) break\n \
    \           result ::= row -> lst(row).reverse\n        }\n        result ::=\
    \ row -> lst(row)\n        result ::= row -> lst(row).reverse\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphwswkvhs.scala:24:36 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m( lst(row).size < x ) break\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                    Not found: break\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphwswkvhs.scala:26:12 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            lst(row) = (lst(row).drop(x).reverse)\n\e\
    [31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0mvalue update is not a\
    \ member of List[List[Long]] - did you mean lst.updated?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmphwswkvhs.scala:26:38 --------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            lst(row) = (lst(row).drop(x).reverse)\n\e[31m\e\
    [31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e[0m   \
    \                                   Found:    (x : Long)\n\e[31m   |\e[0m    \
    \                                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmphwswkvhs.scala:27:12 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            lst(row) = (temp.head :: lst(row))\n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member\
    \ of List[List[Long]] - did you mean lst.updated?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmphwswkvhs.scala:31:32 ------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            \e[33mif\e[0m( temp.size < x ) break\n\e[31m\e[31m   |\e[0m\
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \               Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmphwswkvhs.scala:32:12 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m            lst(row) = (temp.tail.reverse)\n\e[31m\e[31m   |\e[0m         \
    \   ^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[List[Long]]\
    \ - did you mean ls"
  stdout: ''
  timestamp: 1660010531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst\n        val\
    \ result = new ArrayBuffer[Tuple2[Long, Long]]()\n        val temp = new ArrayBuffer[Tuple2[Long,\
    \ Long]]()\n        val temp2 = new ArrayBuffer[Tuple2[Long, Long]]()\n\n    \
    \    var cols = 0\n\n        for (i <- 0 until rows.length) {\n            val\
    \ rowLen = rows(i).length\n            cols = rowLen\n\n            val rowIndex\
    \ = 0\n            while (cols > 0 && rowIndex < rows.length) {\n            \
    \    val val = rows(rowIndex)(0)\n                val columnIndex = 0\n      \
    \          while (columnIndex < cols && rowIndex < rows.length) {\n          \
    \          val cmp = rows(rowIndex)(columnIndex)\n                    if (val\
    \ < cmp) {\n                        rowIndex += 1\n                        val\
    \ temp2 = temp.clear()\n                        temp2 += ((rowIndex, val), (rowIndex,\
    \ cmp))\n                        temp += temp2\n                    } else if\
    \ (val == cmp) {\n                        val temp2 = temp2.clear()\n        \
    \                temp2 += ((rowIndex, val), (rowIndex, cmp))\n               \
    \         temp += temp2\n                    } else {\n                      \
    \  val temp2 = temp.clear()\n                        temp2 += ((rowIndex, val),\
    \ (rowIndex, cmp))\n                        temp += temp2\n                  \
    \      break\n                    }\n                    columnIndex += 1\n  \
    \              }\n            }\n\n            temp2 += ((rowIndex, x), (rowIndex,\
    \ x))\n            temp += temp2\n        }\n        result.addAll(temp.sortBy(_._1))\n\
    \        result.addAll(temp.sortBy(_._2))\n        result.sortBy(_._2)\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpxhckwysg.scala:33:20 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mval\e[0m \e[33mval\e[0m = rows(rowIndex)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m\
    \                    pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmpxhckwysg.scala:37:24 ---------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m                    \e[33mif\e[0m (\e[33mval\e[0m < cmp) {\n\
    \e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m       \
    \                 expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpxhckwysg.scala:40:45 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                        temp2 += ((rowIndex, \e[33mval\e\
    [0m), (rowIndex, cmp))\n\e[31m\e[31m   |\e[0m                                \
    \             ^^^\e[0m\n\e[31m   |\e[0m                                      \
    \ expression expected but \e[31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E018] Syntax Error: /tmp/tmpxhckwysg.scala:42:31 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    } \e[33melse\e[0m \e[33mif\e[0m (\e\
    [33mval\e[0m == cmp) {\n\e[31m\e[31m   |\e[0m                               ^^^\e\
    [0m\n\e[31m   |\e[0m                               expression expected but \e\
    [31mval\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxhckwysg.scala:44:45\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                     \
    \   temp2 += ((rowIndex, \e[33mval\e[0m), (rowIndex, cmp))\n\e[31m\e[31m   |\e\
    [0m                                             ^^^\e[0m\n\e[31m   |\e[0m    \
    \                                   expression expected but \e[31mval\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-exp"
  stdout: ''
  timestamp: 1660010533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val sorted = (lst\n      \
    \      .sorted\n            .map(_.zipWithIndex)\n            .filter(x => x._1._2\
    \ == x)\n            .map(x => (x._1._1, x._1._2))\n            .sortBy(x => x._1)\n\
    \            .sortBy(x => -x._2))\n        val result = new ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for {\n            r <- sorted\n        } yield {\n      \
    \      val rows = sorted\n                .filter(r => r._1 == r)\n          \
    \      .map(x => (x._1._2, x._1._1))\n                .toList\n            val\
    \ columns = rows.map(_.swap)\n            (rows.head -> columns.head)\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_05blaef.scala:23:27 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            .filter(x => x._1._2 == x)\n\e[31m\e[31m\
    \   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0m                \
    \         value _1 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_05blaef.scala:24:25 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            .map(x => (x._1._1, x._1._2))\n\e[31m\e[31m  \
    \ |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \   value _1 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp_05blaef.scala:24:34 ------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            .map(x => (x._1._1, x._1._2))\n\e[31m\e[31m   |\e[0m     \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \    value _1 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- Error: /tmp/tmp_05blaef.scala:25:30\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m25 |\e[0m       \
    \     .sortBy(x => x._1)\n\e[31m\e[31m   |\e[0m                              ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var cols: MutableList[Int]\
    \ = mutable.MutableList(0)\n        var coords: List[Tuple2[Long, Long]] = mutable.MutableList().toList\n\
    \        var rows: MutableList[Tuple2[Long, Long]] = mutable.MutableList().toList\n\
    \        lst.foreach {row =>\n            row.foreach {col =>\n              \
    \  if (col == x) return (coords = coords :+ (row, col))\n                if (col\
    \ >= cols.last) cols :+= col + 1\n            }\n            rows += ((row, cols))\n\
    \        }\n        coords.sortBy(_._1)\n        coords.sortBy(_._2, ascending\
    \ = false)\n        coords.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp27htmt6.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mcols\e[0m: \e[35mMutableList\e\
    [0m[\e[35mInt\e[0m] = mutable.MutableList(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found:\
    \ type MutableList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp27htmt6.scala:20:37\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e\
    [36mcols\e[0m: \e[35mMutableList\e[0m[\e[35mInt\e[0m] = mutable.MutableList(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp27htmt6.scala:21:47\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e\
    [36mcoords\e[0m: \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e\
    [0m]] = mutable.MutableList().toList\n\e[31m\e[31m   |\e[0m                  \
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpp27htmt6.scala:22:18 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mrows\e[0m: \e[35mMutableList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = mutable.MutableList().toList\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \             Not found: type MutableList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpp27htmt6.scala:22:52 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mvar\e[0m \e[36mrows\e[0m: \e[35mMutableList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = mutable.MutableList().toList\n\
    \e[31m\e[31m  "
  stdout: ''
  timestamp: 1660010531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Your code goes here\n \
    \       if(lst.isEmpty) {\n            throw new RuntimeException(\"The list must\
    \ be not be empty.\")\n        }\n        if(!lst.isInstanceOf[List]) {\n    \
    \        throw new RuntimeException(\"The list must be a list of lists.\")\n \
    \       }\n        if(!lst.isInstanceOf[List[Any]]) {\n            throw new RuntimeException(\"\
    The list must be a list of lists of type Any\")\n        }\n        if(lst.length\
    \ != lst(0).length) {\n            throw new RuntimeException(\"The number of\
    \ columns in the list must be the same as the first row.\")\n        }\n     \
    \   if(!lst(0).isInstanceOf[List]) {\n            throw new RuntimeException(\"\
    The first row must be a list of lists.\")\n        }\n        if(lst.length ==\
    \ 1) {\n            val lst1 = lst(0)\n            val lst2 = lst(1)\n       \
    \     val lst3 = lst2\n            var flag = true\n            var lst4 : List[Long]\
    \ = lst3\n            while(lst4.nonEmpty) {\n                val lst5 = lst4(0)\
    \ :: lst4\n                lst4 = lst4.remove(0)\n                lst4 = lst5\n\
    \            }\n            var flag2 = true\n            var lst5 : List[Long]\
    \ = lst4\n            while(lst5.nonEmpty) {\n                val lst6 = lst5(0)\n\
    \                lst5 = lst5.remove(0)\n                lst5 = lst6\n        \
    \    }\n            var flag3 = true\n            var lst7 : List[Long] = lst5\n\
    \            while(lst7.nonEmpty) {\n                val lst8 = lst7(0)\n    \
    \            lst7 = lst7.remove(0)\n                lst7 = lst8\n            }\n\
    \            if(flag) {\n                var lst9 : List[Tuple2[Long, Long]] =\
    \ lst7\n                while(lst9.nonEmpty) {\n                    val lst10\
    \ = lst9(0)\n                    lst9 = lst9.remove(0)\n                    lst9\
    \ = lst10\n                }\n                return lst9\n            }\n   \
    \         if(flag2) {\n                var lst11 : List[Tuple2[Long, Long]] =\
    \ lst7\n                while(lst11.nonEmpty) {\n                    val lst12\
    \ = lst11(0)\n                    lst11 = lst11.remove(0)\n                  \
    \  lst11 = lst12\n                }\n                return lst11\n          \
    \  }\n            if(flag3) {\n                var lst13 : List[Tuple2[Long, Long]]\
    \ = lst7\n                while(lst13.nonEmpty) {\n                    val lst14\
    \ = lst13(0)\n                    lst13 = lst13.remove(0)\n                  \
    \  lst13 = lst14\n                }\n                return lst13\n          \
    \  }\n        }\n        var flag4 = true\n        var lst15 : List[List[Long]]\
    \ = lst\n        while(lst15.nonEmpty) {\n            val lst16 = lst15(0)\n \
    \           lst15 = lst15.remove(0)\n            \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_n22x5ti.scala:106:0 ---------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_n22x5ti.scala:44:28\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                lst4 = lst4.remove(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue remove is not a member of List[Long] - did you mean List[Long].reduce?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_n22x5ti.scala:51:28 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m                lst5 = lst5.remove(\e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ remove is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_n22x5ti.scala:52:23\
    \ --------------------\e[0m\e[0m\n\e[31m52 |\e[0m                lst5 = lst6\n\
    \e[31m\e[31m   |\e[0m                       ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                Found:    (lst6 : Long)\n\e[31m   |\e[0m                    \
    \   Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp_n22x5ti.scala:58:28 ------------------------\e[0m\e[0m\n\e[31m58 |\e\
    [0m                lst7 = lst7.remove(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue remove is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   "
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result: List[Tuple2[Long,\
    \ Long]] = Nil\n        if(lst.isEmpty) result\n        else {\n            var\
    \ rows: List[List[Long]] = Nil\n            for(i <- 0 until lst.size){\n    \
    \            rows = lst.map(x => (x, lst(i))).filter(x => x._1 == x).sortBy(x\
    \ => x._2)\n                for((_, row) <- rows.reverse) result = (x -> (row.toLong,\
    \ i)) :: result\n            }\n        }\n        result.sortBy(x => x._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprn03b_el.scala:25:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                rows = lst.map(\e[36mx\e[0m => (x, lst(i))).filter(\e\
    [36mx\e[0m => x._1 == x).sortBy(\e[36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m \
    \                                                            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mValues of types List[Long] and (List[Long], List[Long]) cannot be\
    \ compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmprn03b_el.scala:25:89 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                rows = lst.map(\e[36mx\e[0m => (x, lst(i))).filter(\e\
    [36mx\e[0m => x._1 == x).sortBy(\e[36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m \
    \                                                                            \
    \            ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\
    \e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprn03b_el.scala:26:66\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mfor\e\
    [0m((_, row) <- rows.reverse) result = (x -> (row.toLong, i)) :: result\n\e[31m\e\
    [31m   |\e[0m                                                              ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Any, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 error"
  stdout: ''
  timestamp: 1660010532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getCoordinates(row: List[Long],\
    \ x : Long, result : List[Tuple2[Long, Long]]): List[Tuple2[Long, Long]] =\n \
    \           if(row.isEmpty) List()\n            else if(row == List(x)) List((x,\
    \ x)) // coordinate (x, x) is the current coordinate - we add the coordinate (x,\
    \ x) to result to maintain the correct order of coordinates\n            else\
    \ if(x <  row(0)) getCoordinates(row.tail, x, result :+ ((x, x), row.head))\n\
    \            else getCoordinates(row.tail, x, result :+ ((row.head, x), row.head))\n\
    \        getCoordinates(lst, x, Nil).sortBy(x => (x._1, -x._2))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp24vu3iht.scala:23:72\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33melse\e[0m \e\
    [33mif\e[0m(x <  row(\e[31m0\e[0m)) getCoordinates(row.tail, x, result :+ ((x,\
    \ x), row.head))\n\e[31m\e[31m   |\e[0m                                      \
    \                                  ^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                                    Found:    (Long, Long)\n\e[31m   |\e[0m \
    \                                                 Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp24vu3iht.scala:24:56 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m getCoordinates(row.tail,\
    \ x, result :+ ((row.head, x), row.head))\n\e[31m\e[31m   |\e[0m             \
    \                                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                  Found:    (Long, Long)\n\e\
    [31m   |\e[0m                                                  Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp24vu3iht.scala:25:23\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        getCoordinates(lst, x,\
    \ Nil).sortBy(\e[36mx\e[0m => (x._1, -x._2))\n\e[31m\e[31m   |\e[0m          \
    \             ^^^\e[0m\n\e[31m   |\e[0m                       Found:    \e[1m\e\
    [31m(\e[0m\e[1m\e[31mlst\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e\
    [0mList[\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m]\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                       Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) Nil\n   \
    \     else {\n            val lst1 = lst.sortBy(_.head)\n            val x = lst1.indexOf(lst1.find(_\
    \ == x)) match {\n                case -1 => Nil\n                case _ => Nil\n\
    \            }\n            if (x == lst1.size - 1) {\n                lst1.map\
    \ {\n                    i => (i - lst1.size + 1, i)\n                }\n    \
    \        } else (lst1.map {\n                i => (i - x, i)\n            }).reverse.sortBy(_._1).reverse.map(t\
    \ => (t._1, t._2))\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnizsk1vy.scala:23:48 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mx\e[0m = lst1.indexOf(lst1.find(_\
    \ == x)) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                           \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \            Recursive \e[33mvalue\e[0m \e[35mx\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpnizsk1vy.scala:27:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mif\e[0m (x == lst1.size - \e[31m1\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mValues of types object scala.collection.immutable.Nil and Int cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnizsk1vy.scala:29:28\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                    \e[36mi\e\
    [0m => (i - lst1.size + \e[31m1\e[0m, i)\n\e[31m\e[31m   |\e[0m              \
    \            ^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpnizsk1vy.scala:29:45 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[36mi\e[0m => (i - lst1.size +\
    \ \e[31m1\e[0m, i)\n\e[31m\e[31m   |\e[0m                                    \
    \         ^\e[0m\n\e[31m   |\e[0m                                            \
    \ Found:    (i : List[Long])\n\e[31m   |\e[0m                                \
    \             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpnizsk1vy.scala:32:24 ------------------------\e[0m\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660010534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val numOfCols = lst(0).size\n\
    \        val numOfRows = lst.size\n        val coords: List[List[Tuple2[Long,\
    \ Long]]] = lst.map(list => list.map(x => (x, x)))\n        val rows = coords.map(list\
    \ => list.map(x => x.get._1)).toList\n        val cols = coords.map(list => list.map(x\
    \ => x.get._2)).toList\n        val orderedRows = rows.sortWith((a, b) => b <\
    \ a) // sort rows first by descending values\n        val orderedCols = cols.sortWith((a,\
    \ b) => a > b) // sort columns first by ascending values\n        orderedRows.flatMap\
    \ { row =>\n            orderedCols.map(col => Tuple2(row.toLong, col.toLong))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj2_dugsr.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = coords.map(\e\
    [36mlist\e[0m => list.map(\e[36mx\e[0m => x.get._1)).toList\n\e[31m\e[31m   |\e\
    [0m                                                    ^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value get is not a member of (Long, Long)\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpj2_dugsr.scala:24:54 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = coords.map(\e\
    [36mlist\e[0m => list.map(\e[36mx\e[0m => x.get._2)).toList\n\e[31m\e[31m   |\e\
    [0m                                                    ^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value get is not a member of (Long, Long)\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpj2_dugsr.scala:25:52 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36morderedRows\e[0m = rows.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => b < a) \e[34m// sort rows first by descending values\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                  ^^^\e\
    [0m\n\e[31m   |\e[0mvalue < is not a member of List[Nothing], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e\
    [0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj2_dugsr.scala:26:52 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36morderedCols\e[0m = cols.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => a > b) \e[34m// sort columns first by ascending values\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                  ^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of List[Nothing], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Ordered.ord"
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getColumn(lst : List[List[Long]],\
    \ x : List[Long]) : List[Long] = {\n            val ls : List[Long] = x match\
    \ {\n                case Nil => lst.map(_.head).flatten.toList\n            \
    \    case _   => x\n            }\n            val rs : List[Long] = lst.map(_.tail).flatten.toList\n\
    \            val cols : List[Long] = ls.zip(rs)\n            val res : List[Long]\
    \ = cols.filter(v => v != x)\n            val m   : List[Long] = lst match {\n\
    \                case Nil => cols\n                case _   => lst.map(_.head).zipWithIndex.filter(v\
    \ => v._2 == x.toInt).map(v => v._1).toList\n            }\n            val bc\
    \ : List[Long] = m.map(v => if (v < x.toLong) v else x.toLong - v).takeWhile(v\
    \ => v < x.toLong).map(v => v.toLong).takeWhile(v.lt(x.toLong)).map(v => v.substract(x))\
    \ + List(x.toLong)\n            bc.distinct\n        }\n\n        val row = lst.map(_.map(_.toLong))\n\
    \        val columns = getColumn(row, List(x))\n        val res : List[Tuple2[Long,\
    \ Long]] = columns.zip(row).map(v => (v._1, v._2.map(_.toLong)))\n        res.sortWith((v1,v2)=>{\n\
    \            val c1 = v1._1.toInt\n            val c2 = v2._1.toInt\n        \
    \    if (c1 < c2) -1 else if (c1 > c2) 1 else 0\n        })\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5osetw0z.scala:22:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m Nil => lst.map(_.head).flatten.toList\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0mno given instance of type Long => IterableOnce[B] was found for\
    \ parameter toIterableOnce of \e[33mmethod\e[0m \e[35mflatten\e[0m in \e[33mtrait\e\
    [0m \e[35mStrictOptimizedIterableOps\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:\
    \    B is a type variable\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5osetw0z.scala:26:42\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e\
    [36mcols\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m] = ls.zip(rs)\n\e[31m\e[31m  \
    \ |\e[0m                                    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                   Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e\
    [0m                                    Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp5osetw0z.scala:27:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mres\e[0m : \e[35mList\e\
    [0m[\e[35mLong\e[0m] = cols.filter(\e[36mv\e[0m => v != x)\n\e[31m\e[31m   |\e\
    [0m                                                    ^^^^^^\e[0m\n\e[31m   |\e\
    [0m    Values of types Long and List[Long] cannot be compared with == or !=\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp5osetw0z.scala:30:79 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                \e[33mcase\e[0m _   => lst.map(_.head).zipWithIndex.filter(v\
    \ => v._2 == x.toInt).map(v => v._1).toList\n\e[31m\e[31m   |\e[0m           \
    \                                                                  ^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue toInt is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fract"
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val tuples = lst.map {\n \
    \           case x :: y :: tail => x :: y :: tail\n        }\n        tuples.sortBy\
    \ {\n            case x :: y :: tail => (tail.map(i => i.toLong).max / x.toLong,\
    \ tail.map(i => i.toLong).min / x.toLong)\n        }\n            .sortBy {\n\
    \            case x :: y :: tail => (tail.map(i => i.toLong).max / x.toLong, tail.map(i\
    \ => i.toLong).min / x.toLong)\n        }\n            .filter(t => t._2.min <=\
    \ x.toLong && t._2.max >= x.toLong)\n            .map(t => Tuple2(t._1, t._2.max\
    \ - t._1))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuq7rxd6d.scala:29:27 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            .filter(t => t._2.min <= x.toLong && t._2.max\
    \ >= x.toLong)\n\e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m\
    \   |\e[0m                         value _2 is not a member of List[Long]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpuq7rxd6d.scala:30:31 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            .map(t => Tuple2(t._1, t._2.max - t._1))\n\
    \e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\e[31m   |\e[0m \
    \                            value _1 is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpuq7rxd6d.scala:30:37 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            .map(t => Tuple2(t._1, t._2.max - t._1))\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^\e[0m\n\e[31m   |\e\
    [0m                                  value _2 is not a member of List[Long]\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(l => l.map(x\
    \ -> x).map((x, _)).toList)\n        val cols = rows.map(_.sorted.reverse).map(_.head).map(x\
    \ => x.filter(_._1 == x).toList)\n        (0 until rows.size).map(i => ((0 until\
    \ rows(i).size).map(j => (i, j)).toList.sortBy(_._1), rows.map(_.drop(i).sorted.reverse).map(_.head).map(x\
    \ => (x, (0 until cols(i).size).map(j => (i, j)).toList.sortBy(_._2))))).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuivnrcdr.scala:20:38\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mrows\e\
    [0m = lst.map(\e[36ml\e[0m => l.map(x -> x).map((x, _)).toList)\n\e[31m\e[31m\
    \   |\e[0m                                      ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                     Found:    (Long, Long)\n\e[31m   |\e[0m\
    \                                      Required: Long => Any\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpuivnrcdr.scala:21:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = rows.map(_.sorted.reverse).map(_.head).map(\e\
    [36mx\e[0m => x.filter(_._1 == x).toList)\n\e[31m\e[31m   |\e[0m             \
    \                       ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type variable with constraint\
    \ >: (Long, Any)\n\e[31m   |\e[0m..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m    scala.math.Ordering.Tuple2[\e[35mT1\e[0m, \e[35mAny\e[0m](scala.math.Ordering.Long,\
    \ \n\e[31m   |\e[0m      scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m\
    \   |\e[0m        /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\
    \e[31m   |\e[0m      )\n\e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut\
    \ no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuivnrcdr.scala:21:52 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = rows.map(_.sorted.reverse).map(_.head).map(\e\
    [36mx\e[0m => x.filter(_._1 == x).toList)\n\e[31m\e[31m   |\e[0m             \
    \                                     ^^^^^^\e[0m\n\e[31m   |\e[0mvalue head is\
    \ not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e\
    [0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m  import collection.LazyZip3.lazy"
  stdout: ''
  timestamp: 1660010536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_.length).max\n\
    \        val columns = lst.head.length\n        val newRows = rows + (if (rows\
    \ == 0) 1 else 0)\n        val newCols = columns + (if (columns == 0) 1 else 0)\n\
    \        val newList = new mutable.ListBuffer[Tuple2[Long, Long]]()\n        for(i\
    \ <- 0 until newRows) {\n            for(j <- 0 until newCols) {\n           \
    \     newList += ((i * newCols) + j, (lst(i)(j + x) match {\n                \
    \    case \"None\" => 0l\n                    case \"Some\" => x\n           \
    \         case x => x\n                    }))\n            }\n        }\n   \
    \     newList.sortBy(_._1).reverse.sortBy(_._2).reverse.map(x => Tuple2(x._1,\
    \ x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe2ph1k1i.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.map{l =>\n           \
    \ val ys = l.toArray\n            val rowIndex = ys.indexOf(x)\n            if(rowIndex\
    \ > -1) (ys.take(rowIndex), ys.drop(rowIndex))\n            else (List(x), ys)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7qrz0_sg.scala:23:38\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(rowIndex\
    \ > -\e[31m1\e[0m) (ys.take(rowIndex), ys.drop(rowIndex))\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                           Found:    \e[1m\e[31mArray\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m\n\e[31m   |\e[0m                               Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7qrz0_sg.scala:23:57\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m(rowIndex\
    \ > -\e[31m1\e[0m) (ys.take(rowIndex), ys.drop(rowIndex))\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                  Found:    \e[1m\e\
    [31mArray\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m        \
    \                                          Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7qrz0_sg.scala:24:22 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33melse\e[0m (List(x), ys)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Found:\
    \    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e\
    [0m                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7qrz0_sg.scala:24:27 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33melse\e[0m (List(x), ys)\n\e[31m\e[31m   |\e[0m     \
    \                      ^^\e[0m\n\e[31m   |\e[0m                           Found:\
    \    (ys : Array[Long])\n\e[31m   |\e[0m                           Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val ret: List[Tuple2[Long,\
    \ Long]] =\n            if (lst.isEmpty) Nil\n            else lst.headOption.map\
    \ { case List(xx, yy, zz, ..., yx, yz) =>\n                val row = x - (xx +\
    \ yy + zz + ... + yx + yz)\n                val col = yz.max(yx.toLong).toLong\
    \ - yy.max(yx.toLong).toLong\n                (row, col)\n            }.toList.sortBy(_._1).reverse\n\
    \        ret\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpd6zt4xge.scala:22:60 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m lst.headOption.map { \e[33mcase\e\
    [0m List(xx, yy, zz, ..., yx, yz) =>\n\e[31m\e[31m   |\e[0m                  \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                                             pattern expected\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmpd6zt4xge.scala:23:46 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mrow\e[0m = x - (xx\
    \ + yy + zz + ... + yx + yz)\n\e[31m\e[31m   |\e[0m                          \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \      expression expected but \e[31m'.'\e[0m found\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E134] Type Error: /tmp/tmpd6zt4xge.scala:23:28 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mrow\e[0m = x - (xx\
    \ + yy + zz + ... + yx + yz)\n\e[31m\e[31m   |\e[0m                          ^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments (String)\n\e[31m\e[31m-- Error: /tmp/tmpd6zt4xge.scala:26:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            }.toList.sortBy(_._1).reverse\n\e[31m\e[31m\
    \   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty) {\n      \
    \      return Nil\n        }\n        var temp = [Long]()\n        var newLst:\
    \ List[List[Long]] = (lst.map(l => l.map(l => l.toLong))) match {\n          \
    \  case lst : List[List[Long]] => lst\n            case lst : List[Long] => lst.map(l=>List(l))\n\
    \            case lst => Nil\n        }\n        var result: MutableList[Tuple2[Long,\
    \ Long]] = MutableList(Tuple2(0, 0))\n\n        for(row <- newLst) {\n       \
    \     val y = row.indexOf(x)\n            if(y != -1) {\n                val rowCol\
    \ = row.filter(_ != x)\n                val colRow = row.filter(_ == x)\n    \
    \            val temp = rowCol.zip(colRow).sortBy(x => -x._1).map(x => (x._1,\
    \ x._2))\n                temp = temp sortBy(x => -x._1).map(x => (x._1, x._2))\n\
    \                result ++= temp\n            }\n        }\n\n        return result.sortBy(x\
    \ => -x._1).map(x => (x._1, x._2)).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp94ou9sk7.scala:23:25 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mtemp\e[0m = [Long]()\n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               '=>' expected, but '(' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp94ou9sk7.scala:29:20 ------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m: \e[35mMutableList\e[0m[\e[35mTuple2\e\
    [0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = MutableList(Tuple2(\e[31m0\e[0m, \e[31m0\e\
    [0m))\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Not found: type MutableList\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp94ou9sk7.scala:29:54 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m: \e[35mMutableList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = MutableList(Tuple2(\e\
    [31m0\e[0m, \e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                            \
    \                          ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                                 Not found: MutableList\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmp94ou9sk7.scala:37:35 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                temp = temp sortBy(\e[36mx\e[0m => -x._1).map(\e\
    [36mx\e[0m => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                           \
    \        ^\e[0m\n\e[31m   |\e[0m                          Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m                          I could not infer the\
    \ type of the parameter x.\n\e[31m\e[31m-- Error: /tmp/tmp94ou9sk7.scala:37:69\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m37 |\e[0m       \
    \         temp = temp sortBy(\e[36mx\e[0m => -x._1).map(\e[36mx\e[0m => (x._1,\
    \ x._2))\n\e[31m\e[31m   |\e[0m                                              \
    \                       ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mB"
  stdout: ''
  timestamp: 1660010530
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val numRow = lst(0).size\n\
    \        val numCol = lst(1).size\n        val lst2 = lst.map(x => x.map(i =>\
    \ (i, 0l)))\n        lst2.sortBy(x => x._1, Ordering[Long].reverse)\n        \
    \    .sortBy(x => x._2, Ordering[Long].reverse)\n            .filter(x => x._2\
    \ % numCol == 0)\n            .filter(x => x._2 % numRow == 0)\n            .filter(x\
    \ => x._2 % x == 0)\n            .filter(x => x._1 % x == 0)\n            .map(x\
    \ => (x._1 / numRow, x._2 / numCol))\n            .map(x => (x._1, x._2))\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpfsf5qql1.scala:23:20 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        lst2.sortBy(\e[36mx\e[0m => x._1, Ordering[\e\
    [35mLong\e[0m].reverse)\n\e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m\
    \   |\e[0m                    Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                    I could not infer the type of the parameter x.\n\
    \e[31m\e[31m-- Error: /tmp/tmpfsf5qql1.scala:23:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        lst2.sortBy(\e[36mx\e[0m => x._1, Ordering[\e\
    [35mLong\e[0m].reverse)\n\e[31m\e[31m   |\e[0m                               \
    \                       ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.foldLeft(List[Tuple2[Long,\
    \ Long]]()) {\n            case ((row: List[Long], c: List[Long], l: List[Long]),\
    \ (index: Int, xs: Int, y: Long)) =>\n                val i = index\n        \
    \        val xInc = xs match {\n                    case 0 => l\n            \
    \        case xs => l :+ x\n                }\n                val yInc = y match\
    \ {\n                    case y if y < xs => l.reverse\n                    case\
    \ y if y > xs => l\n                    case y => l :+ y\n                }\n\
    \                row.foldLeft(List[Tuple2[Long, Long]]()) {\n                \
    \    case ((row: List[Long], c: List[Long], l: List[Long]), (index: Int, xs: Int,\
    \ y: Long)) =>\n                        val j = index\n                      \
    \  val xDec = xs match {\n                            case 0 => l\n          \
    \                  case xs => l :+ x\n                        }\n            \
    \            val yDec = y match {\n                            case y if y < xs\
    \ => l.reverse\n                            case y if y > xs => l\n          \
    \                  case y => l :+ y\n                        }\n             \
    \           c.foldLeft(List[Tuple2[Long, Long]]()) {\n                       \
    \     case ((row: List[Long], c: List[Long], l: List[Long]), (index: Int, xs:\
    \ Int, y: Long)) =>\n                                val k = index\n         \
    \                       val xInc0 = xInc\n                                val\
    \ xInc1 = xInc0 match {\n                                    case l => l\n   \
    \                                 case _ => l :+ xInc0(0)\n                  \
    \              }\n                                val yInc0 = yInc\n         \
    \                       val yInc1 = yInc0 match {\n                          \
    \          case l => l\n                                    case _ => l :+ yInc0(0)\n\
    \                                }\n                                val xDec0\
    \ = xDec\n                                val xDec1 = xDec0 match {\n        \
    \                            case l => l\n                                   \
    \ case _ => l :+ xDec0(0)\n                                }\n               \
    \                 val yDec0 = yDec\n                                val yDec1\
    \ = yDec0 match {\n                                    case l => l\n         \
    \                           case _ => l :+ yDec0(0)\n                        \
    \        }\n                                row.foldLeft(List[Tuple2[Long, Long]]())\
    \ {\n                                    case ((row: List[Long], c: List[Long],\
    \ l: List[Long]), (index: Int, xs: Int, y: Long)) =>\n                       \
    \                 val m = index\n                                        val xInc2\
    \ = xInc1\n                                        val xInc3 = xInc\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_8gh3l2o.scala:83:0 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_8gh3l2o.scala:71:56\
    \ --------------------\e[0m\e[0m\n\e[31m71 |\e[0m                            \
    \            \e[33mval\e[0m \e[36mxInc3\e[0m = xInc\n\e[31m\e[31m   |\e[0m   \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                            Found:    Unit\n\e[31m   |\e[0m \
    \                                           Required: List[(Long, Long)]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_8gh3l2o.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[(Long, Long)]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp_8gh3l2o.scala:73:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m73 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) Nil\n   \
    \     else {\n            val n = lst.size\n            val m = lst.head._2.size\n\
    \            val lst1 = lst.map(_.zipWithIndex).filter(_._2 % n == 0)\n      \
    \      val rows = lst1.map(x => (x._2, x._1.toLong / n))\n            val rows1\
    \ = rows.filter(x => x._1 == x)\n            val rows2 = rows.filter(x => x._1\
    \ == x + 1)\n            val result = rows1.zip(rows2)\n                .reduceLeft((x,\
    \ y) => x zip y).filter(_._1 == x)\n                .reverse.sortWith(_._1 > _._1)\n\
    \                .map(t => (t._2, t._1))\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpge7kjcad.scala:23:29 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = lst.head._2.size\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                 value _2 is not a member of List[Long]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpge7kjcad.scala:24:56 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mlst1\e[0m = lst.map(_.zipWithIndex).filter(_._2\
    \ % n == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                \
    \                      ^^^^\e[0m\n\e[31m   |\e[0m                           value\
    \ _2 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpge7kjcad.scala:25:40 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m            \e[33mval\e[0m \e[36mrows\e[0m = lst1.map(\e[36mx\e[0m => (x._2,\
    \ x._1.toLong / n))\n\e[31m\e[31m   |\e[0m                                   \
    \   ^^^^\e[0m\n\e[31m   |\e[0m                           value _2 is not a member\
    \ of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpge7kjcad.scala:25:46\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36mrows\e[0m = lst1.map(\e[36mx\e[0m => (x._2, x._1.toLong / n))\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^\e[0m\n\e[31m   |\e\
    [0m                           value _1 is not a member of List[(Long, Int)]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpge7kjcad.scala:27:51 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mrows2\e[0m = rows.filter(\e\
    [36mx\e[0m => x._1 == x + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m               \
    \                                  ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of (Nothing, Nothing), but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import concurrent.duration.pairIntToDuration\n\
    \e[31m   |\e[0m  import concurrent.duration.pairLongToDuration\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpge"
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val pairs = lst.map((_: Iterable[Long]).toSet).flatMap(_.filter((x:\
    \ Long) => x.mod(2) != 0)).distinct\n        val xInRow = pairs.filter((y: Long)\
    \ => x.mod(y) == 0)\n        val xInColumn = pairs.filter((y: Long) => x.mod(y)\
    \ != 0)\n        val maxRow = xInRow.max(_.toLong)\n        val maxColumn = xInColumn.max(_.toLong)\n\
    \        if (maxRow.toLong == 0) List[Tuple2[Long, Long]]() else lst.filter((x:\
    \ List[Long]) => x(0) == maxRow).sortBy(x => x(0)).map(x => (x(1), x(maxColumn.toLong\
    \ - 1))).filter(x => x(0) == x).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1kb9cacb.scala:20:28\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mpairs\e\
    [0m = lst.map((_: \e[35mIterable\e[0m[\e[35mLong\e[0m]).toSet).flatMap(_.filter((\e\
    [36mx\e[0m: \e[35mLong\e[0m) => x.mod(\e[31m2\e[0m) != \e[31m0\e[0m)).distinct\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Found:    \e[1m\e[31mcollection\e[0m\e[1m\e[31m.\e\
    [0m\e[1m\e[31mmutable\e[0m\e[1m\e[31m.\e[0m\e[1m\e[31mIterable\e[0m[Long] => Set[Long]\n\
    \e[31m   |\e[0m                Required: \e[1m\e[32mList\e[0m[Long] => Set[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1kb9cacb.scala:20:87\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mpairs\e[0m = lst.map((_: \e[35mIterable\e[0m[\e[35mLong\e[0m]).toSet).flatMap(_.filter((\e\
    [36mx\e[0m: \e[35mLong\e[0m) => x.mod(\e[31m2\e[0m) != \e[31m0\e[0m)).distinct\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^^^^^\e[0m\n\e[31m   |\e[0mvalue mod is not a member\
    \ of Long, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp1kb9cacb.scala:21:49 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mxInRow\e[0m = pairs.filter((\e\
    [36my\e[0m: \e[35mLong\e[0m) => x.mod(y) == \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                               ^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ mod is not a member of Long, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.BigInt.long2bigInt\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1kb9cacb.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mxInColumn\e[0m = pairs.filter((\e\
    [36"
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.map(l => if (l.size <\
    \ x) Nil else ((l.size - 1).toLong, l(x)));\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpatork_mn.scala:20:37\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        lst.map(\e[36ml\e[0m\
    \ => \e[33mif\e[0m (l.size < x) Nil \e[33melse\e[0m ((l.size - \e[31m1\e[0m).toLong,\
    \ l(x)));\n\e[31m\e[31m   |\e[0m                                     ^^^\e[0m\n\
    \e[31m   |\e[0m                                 Found:    collection.immutable.Nil.type\n\
    \e[31m   |\e[0m                                 Required: (Long, Long)\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpatork_mn.scala:20:70 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        lst.map(\e[36ml\e[0m => \e[33mif\e[0m (l.size\
    \ < x) Nil \e[33melse\e[0m ((l.size - \e[31m1\e[0m).toLong, l(x)));\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    (x : Long)\n\e[31m   |\e[0m                                  \
    \                  Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Create empty matrix for\
    \ x\n        var matrix = List.fill(x)((List[Long]()))\n\n        // Get first\
    \ row\n        var firstRow = lst.head\n\n        // For each row from lst\n \
    \       lst match {\n            case x :: y =>\n                // For each item\
    \ in the row\n                y match {\n                    case x :: _ => //\
    \ If it is x, add it to the row\n                        matrix += ((x, firstRow.head))\n\
    \n                    case _ => // Otherwise, add it into the matrix\n       \
    \                 matrix += ((firstRow.head, firstRow.last))\n               \
    \ }\n\n            // If there are no more rows\n            case Nil =>\n   \
    \             matrix += ((firstRow.head, firstRow.last))\n\n        }\n\n    \
    \    // Return list of tuples\n        matrix.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph1c8kgqn.scala:21:31\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mmatrix\e\
    [0m = List.fill(x)((List[\e[35mLong\e[0m]()))\n\e[31m\e[31m   |\e[0m         \
    \                      ^\e[0m\n\e[31m   |\e[0m                               Found:\
    \    (x : Long)\n\e[31m   |\e[0m                               Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph1c8kgqn.scala:32:31\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                        matrix\
    \ += ((x, firstRow.head))\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue += is not a member of List[List[Long]] - did you mean\
    \ List[List[Long]].!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph1c8kgqn.scala:35:31\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                        matrix\
    \ += ((firstRow.head, firstRow.last))\n\e[31m\e[31m   |\e[0m                 \
    \       ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member of List[List[Long]]\
    \ - did you mean List[List[Long]].!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmph1c8kgqn.scala:40:23 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                matrix += ((firstRow.head, firstRow.last))\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of List[List[Long]] - did you mean List[List[Long]].!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmph1c8kgqn.scala:45:24 ------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m        matrix.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \e[31m\e[31m   |\e[0m                      ^^^^\e[0m\n\e[31m   |\e[0m        \
    \              value _1 is not a member of List[Long]\n\e[31m\e[31m-- Error: /tmp/tmph1c8kgqn.scala:45:27\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m45 |\e[0m       \
    \ matrix.sortBy(_._1).reverse.sortBy(_._2).reverse\n\e[31m\e[31m   |\e[0m    \
    \                       ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mo"
  stdout: ''
  timestamp: 1660010535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var coord : List[(Long, Long)]\
    \ = Nil\n        val r : List[Long] = lst.map(x => x.map(_+1).sortBy(-_)).flatten\n\
    \        var i = 0\n        while (i < r.length) {\n            coord = coord\
    \ :+ (r(i), i)\n            i += 1\n        }\n        coord.sortBy(-_._1).map(x\
    \ => (x._1, x._2)).filter(_._1 == x).map(_._2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp29bqp_nc.scala:27:75\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        coord.sortBy(-_._1).map(\e\
    [36mx\e[0m => (x._1, x._2)).filter(_._1 == x).map(_._2)\n\e[31m\e[31m   |\e[0m\
    \                                                                         ^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Long\n\e[31m   |\e[0m                                                  Required:\
    \ (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lstM: MutableList[List[Long]]\
    \ = lst.map(_.toList)\n        val r: List[Tuple2[Long, Long]] = lstM.map(x =>\
    \ Tuple2(x, x))\n        r.sortWith(_._1 < _._1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpws0cm1uk.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlstM\e[0m: \e[35mMutableList\e\
    [0m[\e[35mList\e[0m[\e[35mLong\e[0m]] = lst.map(_.toList)\n\e[31m\e[31m   |\e\
    [0m                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found:\
    \ type MutableList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.size // rows\n\
    \        val n = lst(0).size // columns\n        val r = new Array[Tuple2[Long,\
    \ Long]](m)\n        var i = 0\n        while (i < m) {\n            var j = 0\n\
    \            while (j < n) {\n                if (lst(i).contains(x)) r(i) = Tuple2(i,\
    \ j);\n                j++\n            }\n            i++\n        }\n      \
    \  r.sortWith((x, y) => x._1 < y._1)\n        r.reverse.sortWith((x, y) => y._1\
    \ < x._1)\n        r\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvvgr34ra.scala:28:19 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvvgr34ra.scala:30:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpvvgr34ra.scala:34:8 ---------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        r\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m      \
    \  Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mr\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mArray\e[0m[(Long, Long)]\e[1m\e[31m)\e[0m\n\e[31m\
    \   |\e[0m        Required: \e[1m\e[32mList\e[0m[(Long, Long)]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_.toList)\n\
    \        val cols = lst(0).map(_.toList)\n        val result = new mutable.ListBuffer[Tuple2[Long,\
    \ Long]]()\n        var currX = x\n        var currY = 0\n        while(!rows.isEmpty\
    \ && rows.head != List.empty) {\n            if(rows.head.length == cols.length)\
    \ {\n                var rowIndex = rows.head(0)\n                var colIndex\
    \ = cols.head\n                while (colIndex != 0) {\n                    if\
    \ (rowIndex == currX) {\n                        result.+=(Tuple2(rowIndex, colIndex))\n\
    \                    }\n                    rowIndex += 1\n                  \
    \  colIndex -= 1\n                }\n            }\n            rows.head = (rows.head\
    \ - 1)\n            cols.head = (cols.head - 1)\n            currX -= 1\n    \
    \        currY += 1\n        }\n        return result.toList.reverse.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzkgqbg1l.scala:21:32 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = lst(\e[31m0\e\
    [0m).map(_.toList)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m          value toList is not a member of Long - did you mean\
    \ _$2.toInt?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzkgqbg1l.scala:22:25\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mTuple2\e[0m[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzkgqbg1l.scala:34:29 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    colIndex -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ -= is not a member of Nothing - did you mean Nothing.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpzkgqbg1l.scala:37:35 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            rows.head = (rows.head - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue -\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpzkgqbg1l.scala:38:35 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            cols.head = (cols.head - \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value - is not a member of Nothing\n5 errors found\n"
  stdout: ''
  timestamp: 1660010545
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def sortFunc(x : (Long, Long))\
    \ : Boolean = x._1 < x._2\n        val rowList = lst.toList\n        val columnList\
    \ = lst.toList.map(_.toList).toList\n        columnList.sortBy(sortFunc).reverse.sortBy(sortFunc)\n\
    \        rowList.map(x => (x.zipWithIndex.map(x => (x._2, x._1 + 1)))).filter(_._1\
    \ == x).map(x => x._2.reverse).map(x => (x._1, x._2)).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp59nt7gpv.scala:23:26\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        columnList.sortBy(sortFunc).reverse.sortBy(sortFunc)\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Found:    \e[1m\e[31m(\e[0m\e[1m\e[31m(\e[0mLong\e\
    [1m\e[31m,\e[0m \e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m\e[1m\e[31m)\e[0m\e[1m\e\
    [31m \e[0m=> Boolean\n\e[31m   |\e[0m                          Required: \e[1m\e\
    [32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m => Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp59nt7gpv.scala:23:51 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        columnList.sortBy(sortFunc).reverse.sortBy(sortFunc)\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    \e[1m\e[31m(\e\
    [0m\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m \e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m\e\
    [1m\e[31m)\e[0m\e[1m\e[31m \e[0m=> Boolean\n\e[31m   |\e[0m                  \
    \                   Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e\
    [32m]\e[0m => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp59nt7gpv.scala:24:79\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        rowList.map(\e[36mx\e\
    [0m => (x.zipWithIndex.map(\e[36mx\e[0m => (x._2, x._1 + \e[31m1\e[0m)))).filter(_._1\
    \ == x).map(\e[36mx\e[0m => x._2.reverse).map(\e[36mx\e[0m => (x._1, x._2)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                           value\
    \ _1 is not a member of List[(Int, Long)]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp59nt7gpv.scala:24:99 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        rowList.map(\e[36mx\e[0m => (x.zipWithIndex.map(\e[36mx\e[0m => (x._2,\
    \ x._1 + \e[31m1\e[0m)))).filter(_._1 == x).map(\e[36mx\e[0m => x._2.reverse).map(\e\
    [36mx\e[0m => (x._1, x._2)).toList\n\e[31m\e[31m   |\e[0m         "
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var row: List[Tuple2[Long,\
    \ Long]] = None\n        var maxRow = 0\n        var maxCol = 0\n        lst.foreach\
    \ {\n            lst => {\n                lst.foreach {\n                   \
    \ row => {\n                        if (row.contains(x))\n                   \
    \         return\n                        if (maxRow < row.last._1)\n        \
    \                    maxRow = row.last._1\n                        if (maxCol\
    \ < row.last._2)\n                            maxCol = row.last._2\n         \
    \           }\n                }\n            }\n        }\n        if (maxRow\
    \ == 0)\n            List[Tuple2[Long, Long]]()\n        else\n            (0\
    \ until maxRow).map {\n                i => ((i + 1) * maxCol + x, (i + 1) * maxCol\
    \ + x + maxRow)\n            }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6a8oou0q.scala:20:44\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mvar\e[0m \e[36mrow\e\
    [0m: \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = None\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^\e[0m\n\e\
    [31m   |\e[0m                                            Found:    None.type\n\
    \e[31m   |\e[0m                                            Required: List[(Long,\
    \ Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6a8oou0q.scala:27:32\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                        \e\
    [33mif\e[0m (row.contains(x))\n\e[31m\e[31m   |\e[0m                         \
    \   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                            value contains\
    \ is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6a8oou0q.scala:28:28\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m                            \e\
    [33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Found:    Unit\n\e[31m   |\e[0m   \
    \                         Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6a8oou0q.scala:29:41 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        \e[33mif\e[0m (maxRow < row.last._1)\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     value last is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6a8oou0q.scala:30:41 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                            maxRow = row.last._1\n\e\
    [31m\e[31m   |\e[0m                                     ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     value last is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6a8oou0q.scala:31:41 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                        \e"
  stdout: ''
  timestamp: 1660010547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val (sortedRows, sortedCols)\
    \ = lst.sortBy { a => (a(0).compareTo(x)) }\n        val listOfTuples = sortedRows.map\
    \ { row =>\n            val (_, _, rowWithX) = getRowWithX(row, x)\n         \
    \   (rowWithX._1, rowWithX._2)\n        }\n        listOfTuples.sortBy(_._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn7v35p84.scala:21:38 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlistOfTuples\e[0m = sortedRows.map\
    \ { \e[36mrow\e[0m =>\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           value map is not a member of Any\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val (maxRow, maxCol) = lst.foldLeft((0,\
    \ 0)) {\n            case((maxRow, _), list) => list.foldRight((maxRow, list.size))(max\
    \ => max max max max max max) //max of list\n        }\n        //print (maxRow,\
    \ maxCol)\n        val rows = lst.map(row => (row.size, row)).sortBy(_._1).reverse\n\
    \        val cols = rows.map(row => (row._2, row)).sortBy(_._2).reverse\n    \
    \    //print (rows, cols)\n        cols.map(col => (col._1, col._2)).map(coord\
    \ => (coord, coord._2, row._1, row._2)).sortWith(compareRowCol)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1lyhpkgi.scala:21:105 --------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m((maxRow, _), list) => list.foldRight((maxRow,\
    \ list.size))(max => max max max max max max) \e[34m//max of list\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                           expression expected but \e[31m')'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmp1lyhpkgi.scala:25:62 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = rows.map(\e\
    [36mrow\e[0m => (row._2, row)).sortBy(_._2).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for (Int, List[Long])..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.Tuple2[\e[35mInt\e[0m,\
    \ \e[35mList[Long]\e[0m](scala.math.Ordering.Int, \n\e[31m   |\e[0m      scala.math.Ordering.comparatorToOrdering[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m        /* missing */summon[java.util.Comparator[List[Long]]]\n\
    \e[31m   |\e[0m      )\n\e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut\
    \ no implicit values were found that match type java.util.Comparator[List[Long]].\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010547
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lst1 = lst.sortWith( (p1,\
    \ p2) => p1.headOption.exists( _ == x) && p2.headOption.exists( _ == x) )\n  \
    \      val lst2 = lst1.sortWith( (p1, p2) => p1.lastOption.exists( _ == x) &&\
    \ p2.lastOption.exists( _ == x) )\n        lst2.map( (p) => (p.headOption.getOrElse(x),\
    \ p.lastOption.getOrElse(x)) )\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpot7ef3jo.scala:25)\n\tat Problem.main(tmpot7ef3jo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val mn = lst.head\n      \
    \  val mx = lst.last\n        val n = mx.length\n        val m = mn.length\n \
    \       var r = 0\n        var i = 0\n        var j = 0\n        var k = 0\n \
    \       var res = new mutable.ArrayBuffer[Tuple2[Long, Long]]()\n        res.appendAll((new\
    \ Tuple2[Long, Long](xl, xl)).map(tup2 => new Tuple2[Long, Long](tup2._1, 0l)))\n\
    \        for(i <- 0 until n){\n            for(j <- 0 until m){\n            \
    \    if((lst(i)(j) >=mx) && (lst(i)(j) < mn)){\n                    r = j\n  \
    \                  k = i\n                }\n            }\n            if(r !=\
    \ 0){\n                for(k <- 0 until m){\n                    if(lst(k)(m)\
    \ != mn){\n                        res = res.appendAll((new Tuple2[Long, Long](lst(k)(m),\
    \ lst(k)(m))).map(tup2 => new Tuple2[Long, Long](tup2._2, tup2._2 + 1)))\n   \
    \                 }\n                }\n            }\n        }\n        return\
    \ res.sortBy(tup2 => tup2._1).reverse.sortBy(tup2 => tup2._2).reverse\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp4tdo2jh.scala:28:22 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mvar\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ mutable.ArrayBuffer[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmpp4tdo2jh.scala:32:30 -----------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m                \e[33mif\e[0m((lst(i)(j) >=mx) && (lst(i)(j)\
    \ < mn)){\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>=\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\
    \e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char): Boolean\n\e[31m\
    \   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\e[31m   |\e\
    [0mmatch arguments ((mx : List[Long]))\n\e[31m\e[31m-- Error: /tmp/tmpp4tdo2jh.scala:39:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \             \e[33mif\e[0m(lst(k)(m) != mn){\n\e[31m\e[31m   |\e[0m         \
    \              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types Long and\
    \ List[Long] cannot be compared with == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1660010546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val pairs = lst.map(row =>\
    \ row.zipWithIndex)\n        val rows = pairs.groupBy(_._1).filter(_._2 != 0).map(_._2).sortBy(_._1).map(_._2)\n\
    \        val cols = pairs.groupBy(_._2).filter(_._2 != 0).map(_._2).sortBy(_._1).map(_._2)\n\
    \        val index = {\n            var i = -1\n            val m = x\n      \
    \      val n = rows.tail\n            val o = cols.tail\n            while(i <\
    \ n) {\n                i += 1\n                val r = rows(i)\n            \
    \    val c = o(i)\n                if(r < m) {\n                    val temp =\
    \ i\n                    i = m\n                    m = temp\n               \
    \ }\n                if(r > m) {\n                    val temp = i\n         \
    \           i = n\n                    n = temp\n                }\n         \
    \       if(c < o(m)) {\n                    val temp = m\n                   \
    \ m = c\n                    c = temp\n                }\n                if(c\
    \ > o(n)) {\n                    val temp = n\n                    n = c\n   \
    \                 c = temp\n                }\n            }\n            i =\
    \ 0\n        }\n        if(index < 0) {\n            List(Tuple2[Long, Long](x,\
    \ x)).sortBy(_._1).map(_._2)\n        } else {\n            val row = rows.map(_._1).sortBy(_._1).map(_._2)\n\
    \            val col = cols.map(_._1).sortBy(_._1).map(_._2)\n            List(Tuple2[Long,\
    \ Long](row(i), col(i))).sortBy(_._1).map(_._2)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmposxsz01w.scala:21:35 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = pairs.groupBy(_._1).filter(_._2\
    \ != \e[31m0\e[0m).map(_._2).sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e[0m   \
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \       value _1 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- Error: /tmp/tmposxsz01w.scala:21:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ \e[33mval\e[0m \e[36mrows\e[0m = pairs.groupBy(_._1).filter(_._2 != \e[31m0\e\
    [0m).map(_._2).sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e[0m                 \
    \                             ^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types List[List[(Long,\
    \ Int)]] and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmposxsz01w.scala:22:35 ------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = pairs.groupBy(_._2).filter(_._2\
    \ != \e[31m0\e[0m).map(_._2).sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e[0m   \
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \       value _2 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- Error: /tmp/tmposxsz01w.scala:22:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mcols\e[0m = pairs.groupBy(_._2).filter(_._2 != \e[31m0\e\
    [0m).map(_._2).sortBy(_._1).map(_._2)\n\e[31m\e[31m   |\e[0m                 \
    \                             ^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types List[List[(Long,\
    \ Int)]] and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmposxsz01w.scala:34:24 --------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m                    i = m\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Found:    (m : Long)\n\
    \e[31m   |\e[0m                        Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmposxsz01w.scala:35:22 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m "
  stdout: ''
  timestamp: 1660010550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        require(lst.nonEmpty, \"lst(%d)\
    \ should not be empty\" % lst)\n        var rowIndex = lst.indexWhere (_ == x)\n\
    \        var rowValue = lst (rowIndex)\n        if (rowIndex == 0) {\n       \
    \     rowIndex += lst.size\n        }\n        rowIndex = rowIndex - 1\n     \
    \   var columnIndex = lst.lastIndexWhere (_ == x)\n        var columnValue = lst\
    \ (columnIndex)\n        if (columnIndex == rowIndex + 1) {\n            columnIndex\
    \ = 0\n            columnIndex += 1\n        }\n        require(columnIndex >=\
    \ 0, \"rowIndex(%d) should be greater than 0(columnIndex)\" % rowIndex)\n    \
    \    require(columnIndex <= rowIndex, \"columnIndex(%d) should be less than or\
    \ equal torowIndex(%d)\" % (columnIndex, rowIndex))\n        val coordinate =\
    \ Tuple2(rowValue, columnValue)\n        require(coordinate != None, \"coordinate\
    \ should not be null\")\n        require(coordinate != Tuple2(x, x), \"coordinate\
    \ should not be equal to x\")\n        val coordinates = coordinate.fold(List())((a,\
    \ _) => a :+ Tuple2(a.product, a.product))\n        val rows = coordinates.indexWhere\
    \ (_._1 < coordinate.product)\n        val columns = coordinates.lastIndexWhere\
    \ (_._1 < coordinate.product)\n        require(rows != None, \"rows should not\
    \ be null\")\n        require(columns != None, \"columns should not be null\"\
    )\n        val coordinatesAndRowsAndColumns = coordinates.zip (coordinates.drop(rows\
    \ + 1)) zip (coordinates.drop(1) zip (coordinates.drop(columns) + 1))\n      \
    \  coordinatesAndRowsAndColumns.sortBy { _._1 }.sortBy { _._2 }.map { case (coordinate,\
    \ _) => coordinate }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplcdwt51c.scala:20:60 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        require(lst.nonEmpty, \e[31m\"lst(%d) should\
    \ not be empty\"\e[0m % lst)\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue % is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mThe following import might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmplcdwt51c.scala:21:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mrowIndex\e[0m = lst.indexWhere\
    \ (_ == x)\n\e[31m\e[31m   |\e[0m                                       ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types List[Long] and Long cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmplcdwt51c.scala:27:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mvar\e[0m \e[36mcolumnIndex\e[0m = lst.lastIndexWhere\
    \ (_ == x)\n\e[31m\e[31m   |\e[0m                                            \
    \  ^^^^^^\e[0m\n\e[31m   |\e[0m    Values of types List[Long] and Long cannot\
    \ be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplcdwt51c.scala:33:87\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        require(columnIndex\
    \ >= \e[31m0\e[0m, \e[31m\"rowIndex(%d) should be greater than 0(columnIndex)\"\
    \e[0m % rowIndex)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue % is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmplcdwt51c.scala:34:103 -----------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        require(columnIndex <= rowIndex, \e[31m\"columnIndex(%d)\
    \ should be l"
  stdout: ''
  timestamp: 1660010551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // create map of maps\n  \
    \      val map = new mutable.HashMap[Long, mutable.HashMap[Long, Long]]()\n  \
    \      for (i <- 0 until lst.size) {\n            val row = new mutable.HashMap[Long,\
    \ Long]()\n            for (j <- 0 until lst(i).size) {\n                if (lst(i)(j)\
    \ != x) {\n                    row.put(lst(i)(j), 0l)\n                } else\
    \ {\n                    row.put(lst(i)(j), 1l)\n                }\n         \
    \   }\n            map.put(i, row)\n        }\n        val row = new mutable.HashMap[Long,\
    \ Long]()\n        // create map of lists sorted by rows\n        val rowList\
    \ = new mutable.LinkedList[Tuple2[Long, Long]]()\n        for (i <- 0 until map.size)\
    \ {\n            rowList.push(map.get(i).mapValues { case (k,v) => v })\n    \
    \    }\n        rowList.sortBy(_._1).reverse.sortBy(_._2).reverse\n        rowList.map(_.mapValues(_.asInstanceOf[Long]).toList).flatMap(x\
    \ => x).map(x => x._1 -> x._2)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpufix_w0l.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e\
    [0m]]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpufix_w0l.scala:23:26 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mrow\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpufix_w0l.scala:33:22 ------------------------\e[0m\e[0m\n\e[31m33 |\e\
    [0m        \e[33mval\e[0m \e[36mrow\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpufix_w0l.scala:35:26 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mrowList\e[0m = \e[33mnew\e\
    [0m mutable.LinkedList[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) List()\n\
    \        else (lst.map(i => ((i(0), i((lst.head._2).size))))).sortBy(i => i.productIterator.toList.sortBy(j\
    \ => j))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmm9xjw11.scala:21:47 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (lst.map(i => ((i(\e[31m0\e[0m),\
    \ i((lst.head._2).size))))).sortBy(i => i.productIterator.toList.sortBy(j => j))\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                  value _2 is not a member of List[Long]\n\
    \e[31m\e[31m-- Error: /tmp/tmpmm9xjw11.scala:21:112 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (lst.map(i => ((i(\e[31m0\e[0m),\
    \ i((lst.head._2).size))))).sortBy(i => i.productIterator.toList.sortBy(j => j))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m \
    \  |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[Any]]\n\e\
    [31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[Any].\n\e[31m\e[31m--\
    \ Error: /tmp/tmpmm9xjw11.scala:21:113 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m (lst.map(i => ((i(\e[31m0\e[0m),\
    \ i((lst.head._2).size))))).sortBy(i => i.productIterator.toList.sortBy(j => j))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0mNo implicit Ordering defined for List[Any]..\n\e[31m   |\e[0mI found:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mList[Any]\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Any]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Any]].\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mThe following import might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Or"
  stdout: ''
  timestamp: 1660010550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Use index to find the position\
    \ of the item in nested list using recursion method\n        def getIndex(row\
    \ : List[Long], index : Int, subIndex : Int) : Int = {\n            // If index\
    \ >= length of row, return -1\n            if(index < row.length)\n          \
    \      return index\n            // If subIndex >= length of column, return -1\n\
    \            if(subIndex >= row.length)\n                return -1\n         \
    \   // If the sublist is empty, return the index value\n            if(row.length\
    \ == 0)\n                return index\n            val currentIndex = getIndex(row,\
    \ index - 1, subIndex + 1)\n            if(currentIndex != -1)\n             \
    \   return currentIndex\n            // If the sublist is not empty\n        \
    \    // Recursive call\n            val currentSubIndex = getIndex(row, index,\
    \ subIndex + 1)\n            // If sublist is not empty\n            if(currentSubIndex\
    \ != -1)\n                return currentSubIndex\n            // If the sublist\
    \ is empty, return the index value\n            return index\n        }\n\n  \
    \      def getColumn(column : List[Long], index : Int, subIndex : Int) : Int =\
    \ {\n            // If index >= length of column, return -1\n            if(index\
    \ < column.length)\n                return index\n            // If subindex >=\
    \ length of row, return -1\n            if(subIndex >= column.length)\n      \
    \          return -1\n            // If the sublist is empty, return the index\
    \ value\n            if(column.length == 0)\n                return index\n  \
    \          val currentIndex = getColumn(column, subIndex + 1, index + 1)\n   \
    \         if(currentIndex != -1)\n                return currentIndex\n      \
    \      // If the sublist is not empty\n            // Recursive call\n       \
    \     val currentSubIndex = getColumn(column, subIndex + 1, index + 1)\n     \
    \       // If sublist is not empty\n            if(currentSubIndex != -1)\n  \
    \              return currentSubIndex\n            // If the sublist is empty,\
    \ return the index value\n            return index\n        }\n\n        // Sort\
    \ the row by rows in ascending order initially and in the descending order after\
    \ each row is sorted\n        // Sorting can be done in three ways - 1) using\
    \ scala.util.Sorting 2) using scala.collection.immutable.TreeSet 3) using scala.collection.immutable.TreeMap\n\
    \        val rowSorted = lst.sortWith(a => a.zipWithIndex.toSeq.sortWith(_.first\
    \ < _.first).map(_._2))\n        // Sort each row by columns in descending order\n\
    \        rowSorted.map(row =>\n            row.sortWith(a => getColumn(row, a.index,\
    \ a.subIndex)))\n\n        // Get the row that contains the specific value\n \
    \       rowSorted.filter(row => row.contains(x)).map(row => row.map { case (index,\
    \ subIndex) => Tuple2(index, subIndex) }).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpcis0ke33.scala:69:39 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \e[36mrowSorted\e[0m = lst.sortWith(\e\
    [36ma\e[0m => a.zipWithIndex.toSeq.sortWith(_.first < _.first).map(_._2))\n\e\
    [31m\e[31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpcis0ke33.scala:72:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m72 |\e[0m            row.sortWith(\e\
    [36ma\e[0m => getColumn(row, a.index, a.subIndex)))\n\e[31m\e[31m   |\e[0m   \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                         Wrong number of parameters, expected: 2\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcis0ke33.scala:75:123 -------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m        rowSorted.filter(\e[36mrow\e[0m => row.contains(x)).map(\e\
    [36mrow\e[0m => row.map { \e[33mcase\e[0m (index, subIndex) => Tuple2(index, subIndex)\
    \ }).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[List[(Any, Any)]]\n\e[31m   |\e[0m\
    \        Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) List()\n\
    \        else {\n            val rowsList = lst(0).toList\n            val colsList\
    \ = lst.flatMap(_.length)\n            val rowIndex = rowsList.indexOf(x)\n  \
    \          val colIndex = colsList.indexOf(x)\n            val rowTuples = rowsList.filter(_\
    \ != x).map { case x => (x, x-1).toLong }.toList\n            val colTuples =\
    \ colsList.filter(_ != x).map { case x => (x, x-1).toLong }.toList\n         \
    \   (rowTuples ++ colTuples).sortBy(_._1)\n                .sortBy(-_._2)\n  \
    \      }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5afq0m1l.scala:23:41\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e\
    [36mcolsList\e[0m = lst.flatMap(_.length)\n\e[31m\e[31m   |\e[0m             \
    \                          ^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                   Found:    Int\n\e[31m   |\e[0m                           \
    \            Required: IterableOnce[Any]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5afq0m1l.scala:26:77 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mrowTuples\e[0m = rowsList.filter(_\
    \ != x).map { \e[33mcase\e[0m x => (x, x-\e[31m1\e[0m).toLong }.toList\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of (Long,\
    \ Long), but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5afq0m1l.scala:27:73 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mcolTuples\e[0m = colsList.filter(_\
    \ != x).map { \e[33mcase\e[0m x => (x, x-\e[31m1\e[0m).toLong }.toList\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \        ^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Nothing, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m\
    \   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m\
    \   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Cha"
  stdout: ''
  timestamp: 1660010550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n                val xs = lst.map {\
    \ e => e.filter(_ == x) }\n                val xs2 = xs.map{ e => e.sortWith(_\
    \ < _) }\n                val x2s = xs.map{ e => e.sortWith(_ < _.reverse) }\n\
    \                val x2s2 = x2s.map{ e => e.sortWith(_ < _.reverse) }\n      \
    \          val rs = xs.flatMap(x2 => x2s.map(y => (y, x2)))\n                val\
    \ rs2 = xs.flatMap(x2 => x2s2.map(y => (y, x2)))\n                val rs3 = xs.flatMap(x2\
    \ => x2s2.flatMap(y => rs))\n                val rs31 = rs3.reduce((x, y) => if\
    \ (x._2 > y._2) x else y)\n                val rs41 = rs31.map(x2 => (x2._1, x2._2))\n\
    \                val rs51 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val r53 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs56 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs7 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs71 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs3r1 = rs31.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs4r1 = rs3r1.map(x2 => (x2._1, x2._2))\n               \
    \ val rs5r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n            \
    \    val rs56r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n        \
    \        val rs7r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n     \
    \           val rs7r5r1 = rs3r1.reduce((x, y) => if (x._2 > y._2) x else y)\n\
    \                val rs7r5r5r1 = rs3r1.reduce((\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphoox8c1q.scala:42:46 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                \e[33mval\e[0m \e[36mrs7r5r5r1\e[0m =\
    \ rs3r1.reduce((\n\e[31m\e[31m   |\e[0m                                      \
    \        ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmphoox8c1q.scala:54:0 ----------------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphoox8c1q.scala:24:56 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mx2s\e[0m = xs.map{\
    \ \e[36me\e[0m => e.sortWith(_ < _.reverse) }\n\e[31m\e[31m   |\e[0m         \
    \                                             ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                   value reverse is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphoox8c1q.scala:25:58 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mx2s2\e[0m = x2s.map{\
    \ \e[36me\e[0m => e.sortWith(_ < _.reverse) }\n\e[31m\e[31m   |\e[0m         \
    \                                               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                   value reverse is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphoox8c1q.scala:29:57 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e[0m \e[36mrs31\e[0m = rs3.reduce((\e\
    [36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x._2 > y._2) x \e[33melse\e[0m y)\n\
    \e[31m\e[31m   |\e[0m                                                    ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue > is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e"
  stdout: ''
  timestamp: 1660010551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            def getRow(lst : List[List[Long]],\
    \ x : Long, acc : List[Tuple2[Long, Long]]): List[Tuple2[Long, Long]] =\n    \
    \        {\n                if (lst.isEmpty) return acc\n                val i\
    \ = lst.head\n                val j  = lst.tail.head\n                getRow(lst.tail,\
    \ x, acc.reverse :+ Tuple2(i, j))\n            }\n            getRow(lst, x, Nil)\n\
    \        }\n        getRow(lst, x, Nil).sortBy(_._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmr607ylt.scala:26:58\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                getRow(lst.tail,\
    \ x, acc.reverse :+ Tuple2(i, j))\n\e[31m\e[31m   |\e[0m                     \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \                              Found:    (i : List[Long])\n\e[31m   |\e[0m   \
    \                                           Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmr607ylt.scala:26:61 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                getRow(lst.tail, x, acc.reverse :+ Tuple2(i,\
    \ j))\n\e[31m\e[31m   |\e[0m                                                 \
    \            ^\e[0m\n\e[31m   |\e[0m                                         \
    \     Found:    (j : List[Long])\n\e[31m   |\e[0m                            \
    \                  Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpmr607ylt.scala:30:23\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ getRow(lst, x, Nil).sortBy(_._1)\n\e[31m\e[31m   |\e[0m                    \
    \   ^^^\e[0m\n\e[31m   |\e[0mtoo many arguments for \e[33mmethod\e[0m \e[35mgetRow\e\
    [0m: (lst: List[List[Long]], x: Long): List[(Long, Long)]\n3 errors found\n"
  stdout: ''
  timestamp: 1660010549
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // sort all coordinates by\
    \ rows\n        lst.sortWith(_._1 <=> _._1)\n        // sort each row by columns\
    \ in descending order\n        lst.flatMap {\n            row =>\n           \
    \     row.sortWith(_._2 <=> -_._2)\n        }.filter { row =>\n            row._1\
    \ == x\n        }.map{\n            row =>\n                (row._1, row._2)\n\
    \        }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp68f0x3oa.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        lst.sortWith(_._1 <=> _._1)\n\e[31m\e[31m   |\e\
    [0m                     ^^^^\e[0m\n\e[31m   |\e[0m                     value _1\
    \ is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp68f0x3oa.scala:25:31\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                row.sortWith(_._2\
    \ <=> -_._2)\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\e\
    [31m   |\e[0m                             value _2 is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp68f0x3oa.scala:27:16 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            row._1 == x\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m            value _1 is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp68f0x3oa.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                (row._1, row._2)\n\e[31m\e[31m   |\e\
    [0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m                 value _1 is not\
    \ a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp68f0x3oa.scala:30:29\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                (row._1,\
    \ row._2)\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                         value _2 is not a member of Long\n5 errors found\n"
  stdout: ''
  timestamp: 1660010550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.sortBy {\n           \
    \ case row => row.toList\n        }.sortWith(_._2 < _._2) {\n            case\
    \ (row, _) => row.toList\n        }.filter {\n            case (row, _) => row.contains(x)\n\
    \        }.map {\n            case (row, idx) => ((idx % row.size, idx / row.size),\
    \ row.toList)\n        }.sortWith(_._2 < _._2) {\n            case (row, _) =>\
    \ row.toList\n        }.map {\n            case (row, idx) => ((idx % row.size,\
    \ idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2) {\n          \
    \  case (row, _) => row.toList\n        }.map {\n            case (row, idx) =>\
    \ ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2)\
    \ {\n            case (row, _) => row.toList\n        }.map {\n            case\
    \ (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2\
    \ < _._2) {\n            case (row, _) => row.toList\n        }.map {\n      \
    \      case (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n   \
    \     }.sortWith(_._2 < _._2) {\n            case (row, _) => row.toList\n   \
    \     }.map {\n            case (row, idx) => ((idx % row.size, idx / row.size),\
    \ row.toList)\n        }.sortWith(_._2 < _._2) {\n            case (row, _) =>\
    \ row.toList\n        }.map {\n            case (row, idx) => ((idx % row.size,\
    \ idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2) {\n          \
    \  case (row, _) => row.toList\n        }.map {\n            case (row, idx) =>\
    \ ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2 < _._2)\
    \ {\n            case (row, _) => row.toList\n        }.map {\n            case\
    \ (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n        }.sortWith(_._2\
    \ < _._2) {\n            case (row, _) => row.toList\n        }.map {\n      \
    \      case (row, idx) => ((idx % row.size, idx / row.size), row.toList)\n   \
    \     }.sortWith(_._2 < _._2) {\n            case (row, _) => row.toList\n   \
    \     }.map {\n            case (row, idx) => ((idx % row.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcl2k5zm8.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpcl2k5zm8.scala:79:0 ----------------------------\e[0m\e[0m\n\e[31m79\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpcl2k5zm8.scala:22:9 ------------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        }.sortWith(_._2 < _._2) {\n\e[31m\e[31m   |\e\
    [0m         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\
    \e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcl2k5zm8.scala:78:1\
    \ ---------------------\e[0m\e[0m\n\e[31m78 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[(Long, Long)]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpcl2k5zm8.scala:69:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m69 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rowMap : scala.collection.mutable.Map[Long,\
    \ List[Tuple2[Long, Long]]] = scala.collection.mutable.Map()\n        def getRowHelper(row\
    \ : List[Long], col : Long, rowMap : scala.collection.mutable.Map[Long, List[Tuple2[Long,\
    \ Long]]]) = {\n            if (row == Nil) {\n                rowMap.put(col,\
    \ Nil)\n                return\n            }\n            var i = 1\n       \
    \     var rowList : List[Tuple2[Long, Long]] = Nil\n            while (i <= row.size)\
    \ {\n                rowList = rowMap.get(row(i))\n                if (rowList\
    \ == null) {\n                    rowList = scala.collection.mutable.ListBuffer.empty\n\
    \                    rowMap += (row(i) -> rowList)\n                }\n      \
    \          rowList += ((col, i))\n                i += 1\n            }\n    \
    \    }\n        val size = lst.size\n        for (i <- 0 until size) {\n     \
    \       var rowList = rowMap.get(i).orElse(Nil)\n            var i = 1\n     \
    \       var col = 0\n            while (i <= row.size) {\n                getRowHelper(row,\
    \ col, rowMap)\n                i += 1\n                col += 1\n           \
    \ }\n        }\n        return rowMap.toList.sortBy(_._1).reverse.map(_.swap)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E089] Syntax Error: /tmp/tmppgzxqgbc.scala:24:16 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mreturn\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^\e[0m\n\e[31m   |\e[0m      \e[33mmethod\e[0m \e[35mgetRowHelper\e\
    [0m has a return statement; it needs a result type\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppgzxqgbc.scala:29:36 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                rowList = rowMap.get(row(i))\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                          Found:    \e[1m\e[31mOption\e[0m\e[1m\e[31m[\e[0mList[(Long,\
    \ Long)\e[1m\e[31m]\e[0m]\n\e[31m   |\e[0m                          Required:\
    \ List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppgzxqgbc.scala:31:30\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    rowList =\
    \ scala.collection.mutable.ListBuffer.empty\n\e[31m\e[31m   |\e[0m           \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Found:    scala.collection.mutable.ListBuffer[A]\n\e\
    [31m   |\e[0m                        Required: List[(Long, Long)]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                        where:    A is a type variable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppgzxqgbc.scala:34:24\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                rowList +=\
    \ ((col, i))\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue += is not a member of List[(Long, Long)] - did you mean List[(Long, Long)].!=?\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppgzxqgbc.scala:40:47 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mvar\e[0m \e[36mrowList\e[0m = rowMap.get(i).orElse(Nil)\n\
    \e[31m\e[31m   |\e[0m                                               ^^^\e[0m\n\
    \e[31m   |\e[0m       "
  stdout: ''
  timestamp: 1660010551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.size() == 0) return\
    \ List((x, x))\n        val rows = lst.map(row => (row.size, row.max)).toSeq\n\
    \        val cols = rows.map(_.swap).getOrElse((0l, 0l))\n        val coords =\
    \ lst.flatMap(row => (row.map(elem => elem + coords._2).toSeq)).distinct\n   \
    \     val sortedCoords = coords.sortBy(r => (r._1, r._2)).reverse.map(c => ((coords.indexWhere(i\
    \ => i._1 == c._1) // first occurence\n            ) -> (coords.indexWhere(i =>\
    \ i._2 == c._2) // second occurence\n            )))\n        val sortedRows =\
    \ rows.sortBy(r => (r._1 - coords._2).toLong)\n        val result = sortedCoords.flatMap(c\
    \ => (sortedRows.map(row => ((coords.indexWhere(i => i._1 == c._1) // first occurence\n\
    \            ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n\
    \            ) -> (coords.indexWhere(i => i._1 == c._1) // first occurence\n \
    \           ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n \
    \           ) -> (coords.indexWhere(i => i._1 == c._1) // first occurence\n  \
    \          ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n  \
    \          ) -> (coords.indexWhere(i => i._1 == c._1) // first occurence\n   \
    \         ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n   \
    \         ) -> (coords.indexWhere(i => i._1 == c._1) // first occurence\n    \
    \        ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n    \
    \        ) -> (coords.indexWhere(i => i._1 == c._1) // first occurence\n     \
    \       ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n     \
    \       ) -> (coords.indexWhere(i => i._1 == c._1) // first occurence\n      \
    \      ) -> (coords.indexWhere(i => i._2 == c._2) // second occurence\n      \
    \      )))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbnejwz9u.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpbnejwz9u.scala:20:15\
    \ -----------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mif\e[0m(lst.size()\
    \ == \e[31m0\e[0m) \e[33mreturn\e[0m List((x, x))\n\e[31m\e[31m   |\e[0m     \
    \      ^^^^^^^^\e[0m\n\e[31m   |\e[0m           \e[33mmethod\e[0m \e[35msize\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbnejwz9u.scala:22:36 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = rows.map(_.swap).getOrElse((\e\
    [31m0l\e[0m, \e[31m0l\e[0m))\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   value getOrElse is not a member of List[(Long,\
    \ Int)]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbnejwz9u.scala:23:64 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcoords\e[0m = lst.flatMap(\e\
    [36mrow\e[0m => (row.map(\e[36melem\e[0m => elem + coords._2).toSeq)).distinct\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^\e[0m\n\e[31m   |\e[0m                                       Recursive\
    \ \e[33mvalue\e[0m \e[35mcoords\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpbnejwz9u.scala:24:49 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36msortedCoords\e[0m = coords.sortBy(\e\
    [36mr\e[0m => (r._1, r._2)).reverse.map(\e[36mc\e[0m => ((coords.indexWhere(\e\
    [36mi\e[0m => i._1 == c._1) \e[34m// first occurence\e[0m\n\e[31m\e[31m   |\e\
    [0m                                               ^^^^\e[0m\n\e[31m   |\e[0m \
    \                                    value _1 is not a member of Nothing\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbnejwz9u.scala:24:55 -----------------------"
  stdout: ''
  timestamp: 1660010551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val l = lst.filter(_ contains\
    \ x).map(_)\n        val r = lst.filter(_ contains x).map(_.reverse).sortWith((x,\
    \ y) => y.getOrElse(0) - x.getOrElse(0))\n        val tuples = r.foldLeft((List.empty[Tuple2[Long,\
    \ Long]], 0l)) {\n            case ((list, cur), row) => list :+ Tuple2(cur, row(0))\n\
    \        }\n        tuples.sortWith(_._2._1 < _._1._1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph10nb1jc.scala:21:77 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = lst.filter(_ contains\
    \ x).map(_.reverse).sortWith((\e[36mx\e[0m, \e[36my\e[0m) => y.getOrElse(\e[31m0\e\
    [0m) - x.getOrElse(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                     \
    \                                                      ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           value getOrElse is not a member of List[Long]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph10nb1jc.scala:23:39 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m ((list, cur), row) => list\
    \ :+ Tuple2(cur, row(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                   \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                             Found:    List[(Long, Long)]\n\e[31m   |\e[0m  \
    \                                  Required: \e[1m\e[32m(\e[0mList[(Long, Long)]\e\
    [1m\e[32m,\e[0m\e[1m\e[32m \e[0m\e[1m\e[32mLong\e[0m\e[1m\e[32m)\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph10nb1jc.scala:25:15 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        tuples.sortWith(_._2._1 < _._1._1)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value sortWith\
    \ is not a member of (List[(Long, Long)], Long)\n3 errors found\n"
  stdout: ''
  timestamp: 1660010551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // find first element of lst\n\
    \        val indexOfFirst = lst.indexOfFirst {\n            _ != Nil\n       \
    \ }\n        if (indexOfFirst == -1) {\n            // No element found\n    \
    \        List()\n        } else {\n            // Recursively invoke itself for\
    \ remaining elements\n            val lstElements = lst.drop(indexOfFirst).reverse\n\
    \            val currentRow = lstElements.head\n            val currentRowIndex\
    \ = currentRow.indexOf(x)\n            if (currentRowIndex >= 0) {\n         \
    \       val currentRowElements = currentRow.drop(currentRowIndex)\n          \
    \      val currentRowElementsIndex = currentRowElements.indexOf(x)\n         \
    \       if (currentRowElementsIndex >= 0) {\n                    val currentRowElementsElement\
    \ = currentRowElements.at(currentRowElementsIndex)\n                    (currentRowIndex.toLong,\
    \ currentRowElementsElement.toLong)\n                } else {\n              \
    \      Nil\n                }\n            } else {\n                Nil\n   \
    \         }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpphz4ts91.scala:21:31 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mindexOfFirst\e[0m = lst.indexOfFirst\
    \ {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                  value indexOfFirst is not a member of List[List[Long]]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpphz4ts91.scala:36:71 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    \e[33mval\e[0m \e[36mcurrentRowElementsElement\e\
    [0m = currentRowElements.at(currentRowElementsIndex)\n\e[31m\e[31m   |\e[0m  \
    \                                                  ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  value at is not a member of List[Long]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpphz4ts91.scala:37:20 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    (currentRowIndex.toLong, currentRowElementsElement.toLong)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    (Long, Nothing)\n\e[31m   |\e\
    [0m                    Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.size\n       \
    \ val n = lst(0).size\n        if (lst.isEmpty) {\n            List[Tuple2[Long,\
    \ Long]]()\n        } else {\n            var maxRow = lst(0).head\n         \
    \   var maxCol = lst(0).tail\n            var row = lst(0).head\n            var\
    \ col = lst(0).tail\n            val tuples = List[Tuple2[Long, Long]]()\n   \
    \         while (row <= m) {\n                col = col - maxCol\n           \
    \     maxCol = maxCol + x\n                if (maxCol < 0) {\n               \
    \     maxCol = 0\n                }\n                if (row > m) {\n        \
    \            maxRow = lst(row).head\n                    maxCol = lst(row).tail\n\
    \                    row = row + 1\n                }\n                if (maxRow\
    \ < 0) {\n                    maxRow = 0\n                }\n                val\
    \ tuple = (maxRow, maxCol)\n                tuples ::= tuple\n            }\n\
    \            tuples\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphidd22y8.scala:31:26 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                col = col - maxCol\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of\
    \ List[Long], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphidd22y8.scala:32:32 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                maxCol = maxCol + x\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphidd22y8.scala:33:27 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mif\e[0m (maxCol < \e[31m0\e[0m)\
    \ {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphidd22y8.scala:34:29\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m                    maxCol =\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m\
    \   |\e[0m        "
  stdout: ''
  timestamp: 1660010559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty) List()\n \
    \       else if(lst.length == 1) x -> lst(0)(0)\n        else if(lst.length ==\
    \ 2) x -> lst(0)(0) -> (lst(1)(0) -> lst(0)(1))\n        else if(lst.length ==\
    \ 3) x -> lst(0)(0) -> (lst(1)(0) -> (lst(1)(1) -> lst(0)(1))) -> (lst(2)(0) ->\
    \ (lst(2)(1) -> lst(0)(1)))\n        else {\n            val x1: List[Long] =\
    \ getRow(lst(1), x)\n            val x2: List[Long] = getRow(lst(2), x)\n    \
    \        x1 ::: x2 ::: x1 ::: x2\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpki8wffsz.scala:21:33\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m(lst.length == \e[31m1\e[0m) x -> lst(\e[31m0\e[0m)(\e[31m0\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Found:    (Long, Long)\n\e[31m   |\e[0m  \
    \                               Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0m(Long,\
    \ Long)\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpki8wffsz.scala:22:33 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(lst.length == \e[31m2\e[0m) x ->\
    \ lst(\e[31m0\e[0m)(\e[31m0\e[0m) -> (lst(\e[31m1\e[0m)(\e[31m0\e[0m) -> lst(\e\
    [31m0\e[0m)(\e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                         Found:    \e[1m\e[31m(\e[0m\e[1m\e[31m(\e[0m\e[1m\e\
    [31mLong\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m)\e\
    [0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m(Long, Long)\e[1m\e[31m)\e[0m\n\e[31m   |\e\
    [0m                                 Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e\
    [0m(Long, Long)\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpki8wffsz.scala:23:33 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33melse\e[0m \e[33mif\e[0m(lst.length == \e[31m3\e[0m) x ->\
    \ lst(\e[31m0\e[0m)(\e[31m0\e[0m) -> (lst(\e[31m1\e[0m)(\e[31m0\e[0m) -> (lst(\e\
    [31m1\e[0m)(\e[31m1\e[0m) -> lst(\e[31m0\e[0m)(\e[31m1\e[0m))) -> (lst(\e[31m2\e\
    [0m)(\e[31m0\e[0m) -> (lst(\e[31m2\e[0m)(\e[31m1\e[0m) -> lst(\e[31m0\e[0m)(\e\
    [31m1\e[0m)))\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  Found:    (((Long, Long), (Long, (Long, Long))), (Long,\
    \ (Long, Long)))\n\e[31m   |\e[0m  Required: List[(Long, Long)]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer "
  stdout: ''
  timestamp: 1660010558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.flatMap(_.toList)\n\
    \        val rows = rows.sortWith(_.first < _.first)\n        val cols = rows.map(_.toList)\n\
    \        val cols = cols.sortWith(_.last > _.last)\n        val pairs = rows.zipWithIndex.map\
    \ {\n            case (row, idx) => (idx, cols.map(idx => if (row == x) (idx +\
    \ 1) else idx))\n        }\n        pairs.sortBy(_._1).map {\n            case\
    \ (idx, cols) => (idx, cols.reverse)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv2lmny13.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rows.sortWith(_.first\
    \ < _.first)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv2lmny13.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = cols.sortWith(_.last > _.last)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mcols is already defined as \e[33mvalue\e[0m \e[35mcols\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpv2lmny13.scala:22:30 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mcols\e[0m = rows.map(_.toList)\n\e[31m\e[31m \
    \  |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ toList is not a member of Long - did you mean _$4.toInt?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpv2lmny13.scala:25:72 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            \e[33mcase\e[0m (row, idx) => (idx, cols.map(idx\
    \ => \e[33mif\e[0m (row == x) (idx + \e[31m1\e[0m) \e[33melse\e[0m idx))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Nothing, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m\
    \   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m\
    \   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char"
  stdout: ''
  timestamp: 1660010561
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val r = lst.flatMap(x => x).map(i\
    \ => (i, 0))\n        val c = lst.flatMap(x => x.reverse).map(i => (0, i))\n \
    \       (r.reverse, c.reverse).sortBy(_._1).map(x => (x._2, x._1)).filter(_._1\
    \ == x).map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpecq3ngs3.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        (r.reverse, c.reverse).sortBy(_._1).map(\e[36mx\e\
    [0m => (x._2, x._1)).filter(_._1 == x).map(_._2)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  value sortBy is not a\
    \ member of (List[(Long, Int)], List[(Int, Long)])\n1 error found\n"
  stdout: ''
  timestamp: 1660010557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getTuple(lst: List[List[Long]],\
    \ index: Int, value: Long): List[Tuple2[Long, Long]] = { \n            if (index\
    \ == lst.size) {\n                tupleList[index]\n            } else if (lst(index).nonEmpty)\
    \ {\n                val res = getTuple(lst, (index + 1) % lst.size, lst(index).head).map(x\
    \ -> Tuple2(value, x))\n                tupleList ++ res\n            } else {\n\
    \                getTuple(lst, (index + 1) % lst.size, value)\n            }\n\
    \        }\n        val tupleList: List[Tuple2[Long, Long]] = List(Tuple2(0, x))\n\
    \        getTuple(lst, 0, x)\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0j53izw.scala:22:26 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                tupleList[\e[35mindex\e[0m]\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \               Not found: type index\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpq0j53izw.scala:24:85 --------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mres\e[0m = getTuple(lst,\
    \ (index + \e[31m1\e[0m) % lst.size, lst(index).head).map(x -> Tuple2(value, x))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                     Found:    (Long, \e[1m\e[31m(\e[0m\e[1m\e\
    [31mLong\e[0m\e[1m\e[31m,\e[0m \e[1m\e[31mLong\e[0m\e[1m\e[31m)\e[0m\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                                         Required: ((Long,\
    \ Long))\e[1m\e[32m \e[0m\e[1m\e[32m=\e[0m\e[1m\e[32m>\e[0m\e[1m\e[32m \e[0m\e\
    [1m\e[32mAny\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010558
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var newRow = List[Tuple2[Long,\
    \ Long]]()\n        var newCol = List[Long]()\n        for (i <- 0 until lst.size)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    newRow += Tuple2((i, j))\n                }\n \
    \               if (newRow.isEmpty && newCol.isEmpty && lst(i).length == 1) {\n\
    \                    newRow += Tuple2((i, lst(i)(0)))\n                }\n   \
    \         }\n        }\n        if (newRow.isEmpty) {\n            newRow += Tuple2((0,\
    \ 0l))\n        }\n        if (newCol.isEmpty) {\n            newCol += 0l\n \
    \       }\n        if (newCol.head == newCol.last) {\n            newCol = List.fill(newCol.head)((newCol.head\
    \ - 1l) until newCol.last)\n        }\n        newCol.sortWith((a, b) => b - a).reverse\n\
    \        newCol.sortWith((a, b) => a - b)\n        newCol.sortWith((a, b) => b\
    \ - a)\n        newCol.sortWith((a, b) => b - a)\n        for (i <- 0 until newCol.length)\
    \ {\n            newCol(i) match {\n                case 0l =>\n             \
    \       break\n                case n =>\n                }\n                newCol(i)\
    \ match {\n                    case nl =>\n                        newCol(i) match\
    \ {\n                            case 0l =>\n                                break\n\
    \                            case nl =>\n                        }\n         \
    \               newCol(i) match {\n                            case nl =>\n  \
    \                              newCol(i) match {\n                           \
    \         case nl =>\n                                    }\n                \
    \                    newCol(i) match {\n                                     \
    \   case nl =>\n                                    }\n                      \
    \              newCol(i) match {\n                                        case\
    \ nl =>\n                                    }\n                             \
    \       newCol(i) match {\n                                        case nl =>\n\
    \                                    }\n                                    newCol(i)\
    \ match {\n                                        case nl =>\n              \
    \                      }\n                                    newCol(i) match\
    \ {\n                                        case nl =>\n                    \
    \                }\n                                    newCol(i) match {\n  \
    \                                      case nl =>\n                          \
    \          }\n                                    newCol(i) match {\n        \
    \                                case nl =>\n                                \
    \    }\n                                    newCol(i) match {\n              \
    \                          case nl =>\n                                    }\n\
    \                                    newCol(i) match {\n                     \
    \                   case nl =>\n                                    }\n      \
    \                              newCol(i) match {\n                           \
    \             case nl =>\n                                    }\n            \
    \                        newCol(i) match {\n                                 \
    \       case nl =>\n                                    }\n                  \
    \                  newCol(i) match {\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppstwjcul.scala:97:4 ----------------------------\e\
    [0m\e[0m\n\e[31m97 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'case' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppstwjcul.scala:108:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m108 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmppstwjcul.scala:25:27 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                    newRow += Tuple2((i, j))\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a\
    \ member of List[(Long, Long)] - did you mean List[(Long, Long)].!=?\n\e[31m\e\
    [31m-- Error: /tmp/tmppstwjcul.scala:25:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    newRow += Tuple2((i, j))\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter _2 of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mobject\e\
    [0m \e[35mTuple2\e[0m: (_1: T1, _2: T2): (T1, T2)\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmppstwjcul.scala:28:27 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m                    newRow += Tuple2((i, lst(i)(\e[31m0\e[0m)))\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of List[(Long, Long)] - did you mean List[(Long, Long)].!=?\n\e[31m\e\
    [31m-- Error: /tmp/tmppstwjcul.scala:28:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                    newRow += Tuple2((i, lst(i)(\e[31m0\e\
    [0m)))\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter _2 of \e[33mmethod\e[0m \e\
    [35mapply\e[0m in \e[33mobject\e[0m \e[35mTuple2\e[0m: (_1: T1, _2: T2): (T1,\
    \ T2)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppstwjcul.scala:33:19 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m            newRow += Tuple2((\e[31m0\e[0m, \e[31m0l\e\
    [0m))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue +=\
    \ is not a member of List[(Long, Long)] - did you"
  stdout: ''
  timestamp: 1660010564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n      val tuples = lst.map(_.map(_\
    \ + x).map(Tuple2.apply))\n      tuples.groupBy(_._1).sortBy(_._2).map(p => (p._1,\
    \ p._2.map(_._2)))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphl4xo53j.scala:20:44\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m      \e[33mval\e[0m \e[36mtuples\e\
    [0m = lst.map(_.map(_ + x).map(Tuple2.apply))\n\e[31m\e[31m   |\e[0m         \
    \                                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                       Found:    (Any, Any) => (Nothing, Nothing)\n\e[31m   |\e\
    [0m                              Required: Long => Any\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphl4xo53j.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m      tuples.groupBy(_._1).sortBy(_._2).map(\e[36mp\e\
    [0m => (p._1, p._2.map(_._2)))\n\e[31m\e[31m   |\e[0m                     ^^^^\e\
    [0m\n\e[31m   |\e[0m                    value _1 is not a member of List[(Nothing,\
    \ Nothing)]\n2 errors found\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var i = 0\n        var j =\
    \ 0\n        var row = List[Tuple2[Long, Long]]()\n        while (i < lst.size)\
    \ {\n            val tmpRow = lst(i).take(x).toList\n            if (tmpRow.size\
    \ < x) {\n                tmpRow :: lst(i).drop(x).toList\n            } else\
    \ {\n                tmpRow.toList match {\n                    case h :: t =>\
    \ row ::= (h -> j)\n                    case _ => row ::= (j -> j)\n         \
    \       }\n            }\n            i += 1\n            j += 1\n           \
    \ if (j == lst(i).size) {\n                j += 1\n            }\n        }\n\
    \        row.sortBy(_._1).sortBy(_._2)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbxq0tduz.scala:24:37\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e\
    [36mtmpRow\e[0m = lst(i).take(x).toList\n\e[31m\e[31m   |\e[0m               \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \      Found:    (x : Long)\n\e[31m   |\e[0m                                 \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbxq0tduz.scala:26:38\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                tmpRow :: lst(i).drop(x).toList\n\
    \e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m   |\e\
    [0m                                      Found:    (x : Long)\n\e[31m   |\e[0m\
    \                                      Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbxq0tduz.scala:30:34 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    \e[33mcase\e[0m _ => row ::= (j ->\
    \ j)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue ::= is not a member of List[(Long, Long)] - did you mean List[(Long,\
    \ Long)].::?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val (maxRow, maxCol) = lst.foldLeft((0,\
    \ 0))({ (acc, el) => if (el.length > acc._1) el.length else acc })\n        val\
    \ (row, col) = lst.foldLeft((0, 0))({ (acc, el) => if (el.length == acc._1) (el(0).toInt,\
    \ el(1).toInt) else acc })\n        if (row._2 == maxRow && col._2 == maxCol)\
    \ {\n            var rowTmp = row._1\n            var colTmp = col._1\n      \
    \      var tmpRow = row._2\n            var tmpCol = col._2\n            var i\
    \ = col._2\n            var j = 0\n            while (i < maxCol) {\n        \
    \        var nextCol = i + 1\n                while (j < maxCol) {\n         \
    \           val (rowNew, colNew) = if (tmpRow == rowTmp && tmpCol == colTmp) {\n\
    \                        (tmpRow, tmpCol)\n                    } else if (tmpRow\
    \ > rowTmp) {\n                        (tmpRow, tmpCol)\n                    }\
    \ else {\n                        (tmpRow, tmpCol)\n                    }\n  \
    \                  tmpRow = rowNew\n                    tmpCol = colNew\n    \
    \                rowTmp = rowNew\n                    colTmp = colNew\n      \
    \              j++\n                }\n                i += 1\n              \
    \  tmpCol++\n            }\n            return List(Tuple2(rowTmp.toInt, colTmp.toInt))\n\
    \        } else {\n            return List()\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_ezpt3t8.scala:43:23 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmp_ezpt3t8.scala:46:24 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m                tmpCol++\n\e[31m\e[31m   |\e[0m                      \
    \  ^\e[0m\n\e[31m   |\e[0m                        expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ezpt3t8.scala:20:94\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m (maxRow,\
    \ maxCol) = lst.foldLeft((\e[31m0\e[0m, \e[31m0\e[0m))({ (\e[36macc\e[0m, \e[36mel\e\
    [0m) => \e[33mif\e[0m (el.length > acc._1) el.length \e[33melse\e[0m acc })\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                 ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                        Found:    Int\n\e[31m   |\e[0m      \
    \                                              Required: (Int, Int)\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ezpt3t8.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mif\e[0m (row._2 == maxRow && col._2 ==\
    \ maxCol) {\n\e[31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \         value _2 is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp_ezpt3t8.scala:23:29 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            \e[33mvar\e[0m \e[36mrowTmp\e[0m = row._1\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \  value _1 is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_ezpt3t8.scala:24:29\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m            "
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.zipWithIndex.sortBy(_._1).reverse.map(_._2)\n\
    \        val columns =\n            lst.zipWithIndex.map(_.map(x => x match {\n\
    \                case None => 0\n                case Some(x) => x\n         \
    \   }))\n                .zipWithIndex.map(_.map(_._2))\n                .sortBy(_._1).reverse\n\
    \                .map(_._2)\n        val outputRows = rows.zipWithIndex.filter(i\
    \ => i._1 == x).map(i => (i._2, i._1))\n        val outputColumns = columns.zipWithIndex.map(i\
    \ => i._1 -> i._2).sortBy(_._1).reverse.map(_._2)\n        List(outputRows, outputColumns)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpov03n3sa.scala:20:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = lst.zipWithIndex.sortBy(_._1).reverse.map(_._2)\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[List[Long]].\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m   |\e[0m\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmpov03n3sa.scala:22:39 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            lst.zipWithIndex.map(_.map(\e[36mx\e[0m =>\
    \ x \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                                \
    \       ^\e[0m\n\e[31m   |\e[0m                          Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m                          I could not infer the\
    \ type of the parameter x.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpov03n3sa.scala:26:40\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                .zipWithIndex.map(_.map(_._2))\n\
    \e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m  \
    \ |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$5 of expanded function:\n\e[31m   |\e\
    [0m   _$5 => _$5._2.\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpov03n3sa.scala:27:26\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                .sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                  value _1 is not a member of Tuple\n\e[31m\e[31m-- Error: /tmp/tmpov03n3sa.scala:27:29\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m27 |\e[0m       \
    \         .sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m  "
  stdout: ''
  timestamp: 1660010564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val list = lst.toList\n  \
    \      list.sortBy(a => a(0))\n        list.sortBy(a => a(1)).reverse\n      \
    \  val xIndex = list.indexWhere(a => a(0) == x)\n        val result = list.get(xIndex).toList\n\
    \        result.sortBy(a => a(1)).reverse\n        result.reverse\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplou4gms1.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = list.get(xIndex).toList\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m  value\
    \ get is not a member of List[List[Long]] - did you mean list.seq?\n1 error found\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = Nil\n        var row = 0\n        var col = 0\n        var num = 0\n\
    \        lst.foreach { i =>\n            if ((i = 0) && (num < x)) row += 1\n\
    \            else if ((i = 0) && (num >= x)) {\n                num -= x\n   \
    \             col += 1\n                result ::= (Tuple2(row, col))\n      \
    \          row = 0\n                col = 0\n            }\n            num +=\
    \ 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppiqj1xz5.scala:25:21\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mif\e[0m ((i\
    \ = \e[31m0\e[0m) && (num < x)) row += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m   \
    \                  ^\e[0m\n\e[31m   |\e[0m                     Found:    (\e[31m0\e\
    [0m : Int)\n\e[31m   |\e[0m                     Required: List[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppiqj1xz5.scala:26:26 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m ((i = \e[31m0\e\
    [0m) && (num >= x)) {\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\
    \e[31m   |\e[0m                          Found:    (\e[31m0\e[0m : Int)\n\e[31m\
    \   |\e[0m                          Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmppiqj1xz5.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                num -= x\n\e[31m\e[31m   |\e[0m     \
    \           ^^^^^^\e[0m\n\e[31m   |\e[0m                value -= is not a member\
    \ of Int - did you mean Int.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.size\n       \
    \ val n = lst(0).size\n        var tuples: List[Tuple2[Long, Long]] = Nil\n\n\
    \        for (row <- 0 until m) {\n            var row_tuples: List[Tuple2[Long,\
    \ Long]] = Nil\n            for (column <- 0 until n) {\n                if(lst(row)(x)\
    \ == column) {\n                    row_tuples = row_tuples :+ (row, column)\n\
    \                }\n            }\n            tuples = tuples ++ row_tuples\n\
    \        }\n        val tupleSort = tuples.sortBy(x => x._1)\n        val tupleSortReverse\
    \ = tupleSort.sortBy(x => x._1).reverse\n        tupleSortReverse.foreach(x =>\
    \ tupleSort(x))\n        tupleSortReverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnkl04820.scala:27:28\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                \e[33mif\e[0m(lst(row)(x)\
    \ == column) {\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m\
    \   |\e[0m                            Found:    (x : Long)\n\e[31m   |\e[0m  \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpnkl04820.scala:35:48 --------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        tupleSortReverse.foreach(\e[36mx\e[0m => tupleSort(x))\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                                            Found:    (x : (Long,\
    \ Long))\n\e[31m   |\e[0m                                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010564
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Get row from matrix data\n\
    \        val rows = lst.map(x => x)\n        // Get row from matrix data\n   \
    \     val rowIndex = rows.indexOf(x)\n        val row = rows(rowIndex)\n     \
    \   // Get column from matrix data\n        val columns = row.map( x => x % x).getOrElse(0)\n\
    \        val columnIndex = columns.indexOf(x)\n        val rowValues = rows(rowIndex).map(\
    \ x => x % x).getOrElse(0)\n        val tuples = for (i <- 0 until rowIndex; x\
    \ <- rowValues(i)) yield ((rowIndex - i - 1, columnIndex - x), x)\n        //\
    \ Sort tuples by rows in ascending order - row 0 is first row\n        tuples.sortBy(x\
    \ => x._1).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphaeiuhh9.scala:26:43 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcolumns\e[0m = row.map(\
    \ \e[36mx\e[0m => x % x).getOrElse(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \              value getOrElse is not a member of List[Long]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmphaeiuhh9.scala:28:56 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mrowValues\e[0m = rows(rowIndex).map(\
    \ \e[36mx\e[0m => x % x).getOrElse(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        value getOrElse is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmphaeiuhh9.scala:31:29 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        tuples.sortBy(\e[36mx\e[0m => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ _1 is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import concurrent.duration.durationToPair\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmphaeiuhh9.scala:31:32 -----------------------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        tuples.sortBy(\e[36mx\e[0m => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def toTuple(row: List[Long])\
    \ : List[Tuple2[Long, Long]] = {\n            val tup: List[(Long, Long)] = row.zipWithIndex.sortBy(_._1).map{x\
    \ => (x._2, x._1)}\n            val tup2 = tup.sortBy(_._1).reverse\n        \
    \    (tup2.map(x => (x._2, x._1)).filter(x => x == (x._2, x)).map(x => (x._1,\
    \ x._2))).toList\n        }\n        if(lst.isEmpty) List(Tuple2[Long, Long](x,\
    \ x))\n        else if(lst.isEmpty) List(Tuple2[Long, Long]())\n        else getRow(lst.head,\
    \ x)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpk657cj3r.scala:23:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (tup2.map(\e[36mx\e[0m => (x._2, x._1)).filter(\e\
    [36mx\e[0m => x == (x._2, x)).map(\e[36mx\e[0m => (x._1, x._2))).toList\n\e[31m\e\
    [31m   |\e[0m                                                     ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mValues of types (Long, Long) and (Long, (Long, Long)) cannot\
    \ be compared with == or !=.\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m    Tuple.canEqualTuple[\e[35mH1\e[0m, \e[35mT1\e[0m, \e[35mH2\e[0m,\
    \ \e[35mT2\e[0m](scala.CanEqual.canEqualAny[\e[35mH1\e[0m, \e[35mH2\e[0m], \n\e\
    [31m   |\e[0m      Tuple.canEqualTuple[\e[35mH1\e[0m, \e[35mT1\e[0m, \e[35mH2\e\
    [0m, \e[35mT2\e[0m](/* missing */summon[CanEqual[H1, H2]], ???\n\e[31m   |\e[0m\
    \        )\n\e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit\
    \ values were found that match type CanEqual[H1, H2].\n\e[31m\e[31m-- Error: /tmp/tmpk657cj3r.scala:26:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33melse\e[0m \e[33mif\e[0m(lst.isEmpty) List(Tuple2[Long, Long]())\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmissing argument for parameter _1 of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mobject\e[0m \e[35mTuple2\e[0m: (_1: Long, _2: Long): (Long, Long)\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk657cj3r.scala:27:24 --------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m getRow(lst.head, x)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \      Found:    List[Long]\n\e[31m   |\e[0m                    Required: List[\e\
    [1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lst0 = lst.flatten\n \
    \       val lst1 = lst0.slice(lst0.length - x, lst0.length)\n        val lst2\
    \ = lst1.flatten\n        val lst3 = lst2.slice(lst2.length - x, lst2.length)\n\
    \        lst3.map(x => (x - x, x)).sortBy(_._1).reverse.sortBy(_._2).map(x =>\
    \ (x._1, x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp13fgqcd.scala:21:30\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mlst1\e\
    [0m = lst0.slice(lst0.length - x, lst0.length)\n\e[31m\e[31m   |\e[0m        \
    \                      ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \             Found:    Long\n\e[31m   |\e[0m                              Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmpp13fgqcd.scala:22:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mlst2\e[0m = lst1.flatten\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0mno\
    \ given instance of type Long => IterableOnce[B] was found for parameter toIterableOnce\
    \ of \e[33mmethod\e[0m \e[35mflatten\e[0m in \e[33mtrait\e[0m \e[35mStrictOptimizedIterableOps\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type variable\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.size\n       \
    \ val n = lst(0).size\n        val y = m.toInt\n        val z = (lst.toList flatMap\
    \ { case Nil => Nil } sorted)\n        val z = z.zipWithIndex.filter(x => x._2\
    \ % y == 0).sortBy(x => x._2).reverse\n        val x = z(0)._2\n        val z\
    \ = z.filter(_._2 % x != 0).sortBy(_._2).reverse\n        z.map(_._1).zipWithIndex.map\
    \ {\n            case (i, j) => (i -> j -> lst(i)(j))\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4gf23mnk.scala:23:62 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mz\e[0m = (lst.toList flatMap\
    \ { \e[33mcase\e[0m Nil => Nil } sorted)\n\e[31m\e[31m   |\e[0m              \
    \                                                ^\e[0m\n\e[31m   |\e[0m     \
    \                                  expression expected but \e[31m')'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4gf23mnk.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mz\e[0m = z.zipWithIndex.filter(\e[36mx\e[0m => x._2 % y == \e[31m0\e[0m).sortBy(\e\
    [36mx\e[0m => x._2).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4gf23mnk.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mz\e[0m = z.filter(_._2 % x != \e[31m0\e[0m).sortBy(_._2).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mz is already defined as \e[33mvalue\e[0m \e[35mz\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp4gf23mnk.scala:25:21 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mx\e[0m = z(\e[31m0\e[0m)._2\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m                value _2 is not\
    \ a member of Nothing\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4gf23mnk.scala:27:16\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        z.map(_._1).zipWithIndex.map\
    \ {\n\e[31m\e[31m   |\e[0m              ^^^^\e[0m\n\e[31m   |\e[0m           \
    \   value _1 is not a member of Nothing\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp4gf23mnk.s"
  stdout: ''
  timestamp: 1660010565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val numRows = lst.length\n\
    \        val numCols = lst(0).length\n        val coord = mutable.ArrayBuffer.empty[Tuple2[Long,\
    \ Long]]\n        coord.append(Tuple2(0, 0))\n        val colIndx = 0\n      \
    \  for (i <- 0 to numRows - 1) {\n            val rowIndx = 0\n            while\
    \ (rowIndx < numCols && colIndx < lst(i).length) {\n                if (lst(i)(colIndx)\
    \ == x)\n                    coord.append(Tuple2(i, lst(i)(rowIndx)))\n      \
    \          rowIndx += 1\n                colIndx += 1\n            }\n       \
    \ }\n        coord.sortBy(_._1).reverse.sortBy(_._2).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplmme5g33.scala:22:20 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcoord\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplmme5g33.scala:30:24\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                rowIndx +=\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m              value += is not a member of Int - did you mean rowIndx.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplmme5g33.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                colIndx += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value\
    \ += is not a member of Int - did you mean colIndx.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Your code goes here!\n\
    \        val retVal = mutable.ListBuffer[Tuple2[Long, Long]]()\n        val mapIn\
    \ = mutable.Map[Long, List[Long]]()\n        for (innerList <- lst) {\n      \
    \      var currentRow = mapIn.getOrElseUpdate(innerList.head,\n              \
    \  List[Long]()) match {\n                case Nil => List[Long]()\n         \
    \       case head::tail => head::tail\n            }\n            currentRow ::=\
    \ innerList.tail\n            mapIn += (innerList.head -> currentRow)\n      \
    \  }\n        val sortedMap = mapIn.toSeq.sortBy(_._1) ++ mapIn.toSeq.sortBy(_._2)\n\
    \        val searchVal = sortedMap.toList(x).last\n        sortedMap.toList.map\
    \ { case (k, v) => k.toString -> (v.toList zip sortedMap.toList.filter(_._1 ==\
    \ k).map { case (k, v) => v.toList }).filter(_._1 == searchVal).sortBy(_._1).toList\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_1ni1v6j.scala:21:21 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mretVal\e[0m = mutable.ListBuffer[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_1ni1v6j.scala:22:20\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mmapIn\e[0m = mutable.Map[\e[35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_1ni1v6j.scala:27:41 ------------------------\e[0m\e[0m\n\e[31m27 |\e\
    [0m                \e[33mcase\e[0m head::tail => head::tail\n\e[31m\e[31m   |\e\
    [0m                                         ^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                  Not found: tail\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_1ni1v6j.scala:29:23 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            currentRow ::= innerList.tail\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ::= is not\
    \ a member of List[Long] - did you mean List[Long].::?\n4 errors found\n"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_(0))\n\
    \        val cols = lst.length\n        val result = new mutable.LinkedHashMap[Long,\
    \ Long]()\n        val index = 0\n        while (index < rows.length) {\n    \
    \        val row = (index / cols).toLong\n            val col = (index % cols).toLong\n\
    \            val value = row(col) - x\n            if (result.containsKey(row))\n\
    \                result(row) = result.getOrElse(row, 0l) + value\n           \
    \ else\n                result.put(row, value)\n            index = index + 1\n\
    \        }\n        result.values.toList.sortWith((a, b) => b.compareTo(a))\n\
    \            .sortWith((a, b) => a.compareTo(b))\n            .map(v => ((v -\
    \ 0).toLong, v.toLong))\n            .sortWith((a, b) => b.compareTo(a))\n   \
    \         .map(v => ((v + 1).toLong, v.toLong))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkq9fsehd.scala:22:25 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.LinkedHashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m  \
    \ |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpkq9fsehd.scala:27:24 -----------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            \e[33mval\e[0m \e[36mvalue\e[0m = row(col) - x\n\e[31m\e[31m\
    \   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m                  \
    \      \e[33mvalue\e[0m \e[35mrow\e[0m does not take parameters\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpkq9fsehd.scala:32:18 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            index = index + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            Reassignment\
    \ to val index\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result = new mutable.HashMap[Long,\
    \ mutable.HashMap[Long, Long]]()\n        lst match {\n            case Nil =>\
    \ Nil\n            case head :: tail => {\n                head match {\n    \
    \                case Nil => Nil\n                    case head :: tail1 => {\n\
    \                        tail match {\n                            case Nil =>\
    \ Nil\n                            case tail1 :: tail2 => {\n                \
    \                tail1 match {\n                                    case Nil =>\
    \ Nil\n                                    case tail1 :: tail2 => {\n        \
    \                                tail2 match {\n                             \
    \               case Nil => Nil\n                                            case\
    \ tail2 :: tail3 => {\n                                                tail3 match\
    \ {\n                                                    case Nil => Nil\n   \
    \                                                 case tail3 :: tail4 => {\n \
    \                                                       tail4 match {\n      \
    \                                                      case Nil => Nil\n     \
    \                                                       case tail4 :: tail5 =>\
    \ {\n                                                                tail5 match\
    \ {\n                                                                    case\
    \ Nil => Nil\n                                                               \
    \     case tail5 :: tail6 => {\n                                             \
    \                           tail6 match {\n                                  \
    \                                          case Nil => Nil\n                 \
    \                                                           case tail6 :: tail7\
    \ => {\n                                                                     \
    \           tail7 match {\n                                                  \
    \                                  case Nil => Nil\n                         \
    \                                                           case tail7 :: tail8\
    \ => {\n                                                                     \
    \                   tail8 match {\n                                          \
    \                                                  case Nil => Nil\n         \
    \                                                                            \
    \       case tail8 :: tail9 => {\n                                           \
    \                                                     tail9 match {\n        \
    \                                                                            \
    \                case Nil => Nil\n                                           \
    \                                                         case tail9 :: tail10\
    \ => {\n                                                                     \
    \                                   tail10 match {\n                         \
    \                                                                            \
    \       case Nil => Nil\n                                                    \
    \                                                        case tail10 :: tail11\
    \ => {\n                                                                     \
    \                                           tail11 match {\n                 \
    \                                                                            \
    \                       case Nil => Nil\n                                    \
    \                                                                            \
    \    case tail11 :: tail12 => {\n                                            \
    \                                                                            tail12\
    \ match {\n                                                                  \
    \                                                          case Nil => Nil\n \
    \                                                                            \
    \                                               case tail12 :: tail13 => {\n \
    \                                                                            \
    \                                                   tail13 match {\n         \
    \                                                                            \
    \                                               case Nil => Nil\n            \
    \                                                                            \
    \                                            case tail13 :: tail14 => {\n    \
    \                                                                            \
    \                                                        tail14 match {\n    \
    \                                                                            \
    \                                                            case Nil => Nil\n\
    \                                                                            \
    \                                                                case tail14 ::\
    \ tail15 => {\n                                                              \
    \                                                                            \
    \      tail15 match {\n                                                      \
    \                                                                            \
    \                  case Nil => Nil\n                                         \
    \                                                                            \
    \                               case tail15 :: tail16 => {\n                 \
    \                                                                            \
    \                                                           tail16 match {\n \
    \                                                                            \
    \                                                                            \
    \   case Nil => Nil\n                                                        \
    \                                                                            \
    \                        case tail16 :: tail17 => {\n                        \
    \                                                                            \
    \                                                            tail17 match {\n\
    \                                                                            \
    \                                                                            \
    \            case Nil => Nil\n                                               \
    \                                                                            \
    \                                         case tail17 :: \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_v3vedhd.scala:80:178 --------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m                                                    \
    \                                                                            \
    \                                    \e[33mcase\e[0m tail17 :: \n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                                            \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                                      pattern expected\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp_v3vedhd.scala:92:0 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_v3vedhd.scala:20:25\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m                    \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_v3vedhd.scala:91:1\
    \ ---------------------\e[0m\e[0m\n\e[31m91 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[(Long, Long)]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp_v3vedhd.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def swap(lst: List[Long],\
    \ i: Int, j: Int): List[Long] = {\n            var tmp: List[Long] = null\n  \
    \          var index = 0\n            while (index < lst.size) {\n           \
    \     if (j >= lst(index).size) {\n                    if (index >= lst.size)\
    \ {\n                        tmp :: lst\n                    } else {\n      \
    \                  tmp = swap(lst, index, j + 1)\n                    }\n    \
    \                break\n                }\n                if (j == lst(index).size)\
    \ {\n                    tmp :+ lst(index)\n                    index += 1\n \
    \               } else {\n                    index += 1\n                }\n\
    \            }\n            return tmp\n        }\n\n        def getRows(lst:\
    \ List[List[Long]], x: Long): List[Tuple2[Long, Long]] = {\n            def getCols(lst:\
    \ List[Long]): List[Long] = {\n                var col: List[Long] = null\n  \
    \              var index = 0\n                while (index < lst.size) {\n   \
    \                 if (x >= lst(index).size) {\n                        if (index\
    \ >= lst.size) {\n                            col :: lst\n                   \
    \     } else {\n                            col = swap(lst, index, 0)\n      \
    \                  }\n                        break\n                    }\n \
    \                   if (x == lst(index).size) {\n                        col :+\
    \ lst(index)\n                        index += 1\n                    } else {\n\
    \                        index += 1\n                    }\n                }\n\
    \                return col\n            }\n\n            def getRowsReversed(lst:\
    \ List[List[Long]], x: Long): List[Tuple2[Long, Long]] = {\n                var\
    \ row: List[Long] = null\n                var index = 0\n                while\
    \ (index < lst.size) {\n                    if (x >= lst(index).size) {\n    \
    \                    if (index >= lst.size) {\n                            row\
    \ :: lst\n                        } else {\n                            row =\
    \ swap(lst, index, 0)\n                        }\n                        break\n\
    \                    }\n                    if (x == lst(index).size) {\n    \
    \                    row :+ lst(index)\n                        index += 1\n \
    \                   } else {\n                        index += 1\n           \
    \         }\n                }\n                return row\n            }\n\n\
    \            var row: List[Long] = null\n            var col: List[Long] = null\n\
    \            var index = 0\n            while (index < lst.size) {\n         \
    \       if (col == null) {\n                    col = getCols(lst(index))\n  \
    \              }\n                if (row == null) {\n                    row\
    \ = getRowsReversed(lst, lst(index).apply(col))\n                }\n         \
    \       if (x == lst(index).size) {\n                    row.zip(col) map (_._1)\
    \ :+ Tuple2(x, Tuple2(x, Tuple2(0, Tuple2(x - 1, x - 1))))\n                }\
    \ else {\n                    row.zip(col) map (_._1) :+ Tuple2(x, Tuple2(lst(index).apply(col),\
    \ x - 1))\n                }\n                index++\n            }\n       \
    \     return row.toList\n        }\n\n        lst.toList.flatMap {\n         \
    \   _.getRows(x).map(_\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpaun8r44o.scala:102:23 --------------------------\e\
    [0m\e[0m\n\e[31m102 |\e[0m                index++\n\e[31m\e[31m    |\e[0m    \
    \                   ^\e[0m\n\e[31m    |\e[0m                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpaun8r44o.scala:109:4 ---------------------------\e[0m\e\
    [0m\n\e[31m109 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e[0m\
    \    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaun8r44o.scala:120:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m120 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpaun8r44o.scala:24:36 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m                \e[33mif\e[0m (j >= lst(index).size) {\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value size is not a member of Long\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpaun8r44o.scala:30:20 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaun8r44o.scala:32:36\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m                \e[33mif\e\
    [0m (j == lst(index).size) {\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value size is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaun8r44o.scala:47:40 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                    \e[33mif\e[0m (x >= lst(index).size)\
    \ {\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                             value size is not a member of Long\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaun8r44o.scala:53:24 -------------"
  stdout: ''
  timestamp: 1660010568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var lst1 = lst\n        var\
    \ lst2 = lst\n        val length = lst1.size\n        if(length <= 0)\n      \
    \      return lst2\n        val colList = lst1.head.drop(x)\n        val rowList\
    \ = lst1.drop(1).takeWhile(_ != colList)\n        val row2col = lst2.zipWithIndex.map(x\
    \ => (x._2._1, x._2._2 + x)).toMap\n        val result = rowList.map(x => (row2col(x),\
    \ x))\n        result.sortBy(x => x._1)\n        result.sortBy(x => x._2, Ordering[Long].reverse)\n\
    \        result.map(x => (x._1._1, x._1._2)).toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg91qa5ws.scala:24:19\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mreturn\e[0m\
    \ lst2\n\e[31m\e[31m   |\e[0m                   ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                Found:    (lst2 : List[List[Long]])\n\e[31m   |\e[0m        \
    \           Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpg91qa5ws.scala:25:37 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mcolList\e[0m = lst1.head.drop(x)\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0m                                     Found:    (x : Long)\n\e[31m   |\e[0m\
    \                                     Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpg91qa5ws.scala:27:55 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mrow2col\e[0m = lst2.zipWithIndex.map(\e\
    [36mx\e[0m => (x._2._1, x._2._2 + x)).toMap\n\e[31m\e[31m   |\e[0m           \
    \                                       ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                 value _1 is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpg91qa5ws.scala:27:64 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mrow2col\e[0m = lst2.zipWithIndex.map(\e\
    [36mx\e[0m => (x._2._1, x._2._2 + x)).toMap\n\e[31m\e[31m   |\e[0m           \
    \                                                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                         value _2 is not a member of Int\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg91qa5ws.scala:28:47 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = rowList.map(\e\
    [36mx\e[0m => (row2col(x), x))\n\e[31m\e[31m   |\e[0m                        \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \                Found:    (x : List[Long])\n\e[31m   |\e[0m                 \
    \                            "
  stdout: ''
  timestamp: 1660010571
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty) List(Tuple2(0,\
    \ 0))\n        else if((lst(0).isEmpty) && (lst(1).isEmpty)) {\n            val\
    \ tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple => Tuple2(tuple._1,\
    \ x).zip(tuple._2))\n        }\n        else if((lst(0).isEmpty) && (lst(1).isEmpty\
    \ == false)) {\n            val tmp : List[Tuple2[Long, Long]] = lst\n       \
    \     tmp.map(tuple => Tuple2(tuple._2, x).zip(tuple._1))\n        }\n       \
    \ else if((lst(0).isEmpty == false) && (lst(1).isEmpty)) {\n            val tmp\
    \ : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple => Tuple2(tuple._1,\
    \ x).zip(tuple._2).reverse)\n        }\n        else if((lst(0).isEmpty == false)\
    \ && (lst(1).isEmpty == false)) {\n            val tmp : List[Tuple2[Long, Long]]\
    \ = lst\n            tmp.map(tuple => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false && lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false && lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse.sortBy(_._3).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false) && (lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse.sortBy(_._3).reverse.sortBy(_._4).reverse\n\
    \        }\n        else if((lst(0).isEmpty == false && lst(1).isEmpty == false))\
    \ {\n            val tmp : List[Tuple2[Long, Long]] = lst\n            tmp.map(tuple\
    \ => Tuple2(tuple._1, x).zip(tuple._2).reverse).sortBy(_._1).reverse.sortBy(_._2).reverse.sortBy(_._3).reverse.sortBy(_._4).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp5h0wwat.scala:63:0 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp5h0wwat.scala:22:49\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e\
    [36mtmp\e[0m : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e\
    [0m]] = lst\n\e[31m\e[31m   |\e[0m                                           \
    \      ^^^\e[0m\n\e[31m   |\e[0m                                      Found: \
    \   (lst : List[List[Long]])\n\e[31m   |\e[0m                                \
    \      Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp5h0wwat.scala:23:59 --------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            tmp.map(\e[36mtuple\e[0m => Tuple2(tuple._1, x).zip(tuple._2))\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                     Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \  Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp5h0wwat.scala:26:49\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e\
    [36mtmp\e[0m : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e\
    [0m]] = lst\n\e[31m\e[31m   |\e[0m                                           \
    \      ^^^\e[0m\n\e[31m   |\e[0m                                      Found: \
    \   (lst : List[List[Long]])\n\e[31m   |\e[0m                                \
    \      Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp5h0wwat.scala:27:59 --------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m            tmp.map(\e[36mtuple\e[0m => Tuple2(tuple._2, x).zip(tuple._1))\n\
    \e[31m\e[31m   |\e[0m                                                 "
  stdout: ''
  timestamp: 1660010577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty) Nil\n    \
    \    else {\n            val m = lst.head\n            val r = m.zipWithIndex.filter(x\
    \ => x % m.size == 0).sortBy(_._1).reverse\n            val c = lst.last.zipWithIndex.filter(x\
    \ => x % m.size == 0).sortBy(_._2).reverse\n            r.zipWithIndex.map(x =>\
    \ (x._2, x._1)).sortBy(_._1).reverse.flatMap {\n                case (i, j) =>\n\
    \                    (j.map(_ - i).map(i => Tuple2(i, j))).toList\n          \
    \  }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvhpink_z.scala:23:49 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = m.zipWithIndex.filter(\e\
    [36mx\e[0m => x % m.size == \e[31m0\e[0m).sortBy(_._1).reverse\n\e[31m\e[31m \
    \  |\e[0m                                               ^^^\e[0m\n\e[31m   |\e\
    [0mvalue % is not a member of (Long @uncheckedVariance, Int), but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following\
    \ import might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvhpink_z.scala:24:56 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mc\e[0m = lst.last.zipWithIndex.filter(\e\
    [36mx\e[0m => x % m.size == \e[31m0\e[0m).sortBy(_._2).reverse\n\e[31m\e[31m \
    \  |\e[0m                                                      ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue % is not a member of (Long @uncheckedVariance, Int), but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might make progress towards fixing the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpvhpink_z.scala:27:27 -----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    (j.map(_ - i).map(\e[36mi\e[0m =>\
    \ Tuple2(i, j))).toList\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\
    \e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I\
    \ could not infer the type of the parameter _$4 of expanded function:\n\e[31m\
    \   |\e[0m   _$4 => _$4 - i.\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvhpink_z.scala:27:38\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    (j.map(_\
    \ - i).map(\e[36mi\e[0m => Tuple2(i, j))).toList\n\e[31m\e[31m   |\e[0m      \
    \                                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                                Found:    Any => (Any, (Long, Int))\n\e[31m \
    \  |\e[0m                             "
  stdout: ''
  timestamp: 1660010575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_.length)\n\
    \        assert(rows.length == 1, \"Only 1 row allowed\")\n        val cols =\
    \ lst(0).map(_.length)\n        assert(cols.length == 1, \"Only 1 column allowed\"\
    )\n        val coords = lst.map(a => (a(0), a(1)))\n        assert(coords.length\
    \ == lst.size, \"List size mismatch\")\n        val xInd = coords.indexOf(x)\n\
    \        assert(xInd != -1, \"Could not find \" + x + \" in coords\")\n      \
    \  coords.map(a=>a._2.map(a._1).toSeq).sortBy(a=>a._1).reverse.sortBy(a=>a._2).reverse.map\
    \ {\n            case ((a, b), (c, d)) => Tuple2(a, b)\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpilyw8zcy.scala:22:32 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = lst(\e[31m0\e\
    [0m).map(_.length)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value length is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpilyw8zcy.scala:28:27\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        coords.map(\e[36ma\e\
    [0m=>a._2.map(a._1).toSeq).sortBy(\e[36ma\e[0m=>a._1).reverse.sortBy(\e[36ma\e\
    [0m=>a._2).reverse.map {\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value map is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpilyw8zcy.scala:28:56 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        coords.map(\e[36ma\e[0m=>a._2.map(a._1).toSeq).sortBy(\e\
    [36ma\e[0m=>a._1).reverse.sortBy(\e[36ma\e[0m=>a._2).reverse.map {\n\e[31m\e[31m\
    \   |\e[0m                                                      ^^^^\e[0m\n\e\
    [31m   |\e[0mvalue _1 is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import concurrent.duration.durationToPair\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpilyw8zcy.scala:28:59 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        coords.map(\e[36ma\e[0m=>a._2.map(a._1).toSeq).sortBy(\e\
    [36ma\e[0m=>a._1).reverse.sortBy(\e[36ma\e[0m=>a._2).reverse.map {\n\e[31m\e[31m\
    \   |\e[0m                                                           ^\e[0m\n\e\
    [31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val size = lst.size\n    \
    \    val r = lst.filter(l=> l.contains(x)).sortWith((a: List, b: List) => a._1\
    \ > b._1).map(l => (l.indexOf(x),l.indexOf(x) + 1))\n        if(size > 0) {\n\
    \          val c = lst.filter(l=> l.contains(x)).sortWith((a: List, b: List) =>\
    \ a._1 > b._1).map(l => (l.indexOf(x),l.indexOf(x) + 1))\n          val nr = c.groupBy(a\
    \ => a._1).mapValues(_.map(_._2)).sortWith((a: List, b: List) => b._2 > a._2).map(_._1)\n\
    \          val nrf = nr.filter(_ < size)\n          nrf.map(_ => r.map(_._1)).flatMap(x\
    \ => x).sortWith((a: List, b: List) => a._1 > b._1).map(_ => (x(0),x._2 - 1))\n\
    \        } else {\n          List[Tuple2[Long,Long]]()\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E056] Syntax Error: /tmp/tmpr6qjvdjs.scala:21:59 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = lst.filter(\e[36ml\e\
    [0m=> l.contains(x)).sortWith((\e[36ma\e[0m: \e[35mList\e[0m, \e[36mb\e[0m: \e\
    [35mList\e[0m) => a._1 > b._1).map(\e[36ml\e[0m => (l.indexOf(x),l.indexOf(x)\
    \ + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \                       ^^^^\e[0m\n\e[31m   |\e[0m                           \
    \              Missing type parameter for List\n\e[31m\e[31m-- [E056] Syntax Error:\
    \ /tmp/tmpr6qjvdjs.scala:21:68 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = lst.filter(\e[36ml\e[0m=> l.contains(x)).sortWith((\e\
    [36ma\e[0m: \e[35mList\e[0m, \e[36mb\e[0m: \e[35mList\e[0m) => a._1 > b._1).map(\e\
    [36ml\e[0m => (l.indexOf(x),l.indexOf(x) + \e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                                                    ^^^^\e\
    [0m\n\e[31m   |\e[0m                                         Missing type parameter\
    \ for List\n\e[31m\e[31m-- [E056] Syntax Error: /tmp/tmpr6qjvdjs.scala:23:61 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m          \e[33mval\e[0m \e[36mc\e[0m = lst.filter(\e\
    [36ml\e[0m=> l.contains(x)).sortWith((\e[36ma\e[0m: \e[35mList\e[0m, \e[36mb\e\
    [0m: \e[35mList\e[0m) => a._1 > b._1).map(\e[36ml\e[0m => (l.indexOf(x),l.indexOf(x)\
    \ + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \                         ^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                Missing type parameter for List\n\e[31m\e[31m-- [E056] Syntax\
    \ Error: /tmp/tmpr6qjvdjs.scala:23:70 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m          \e[33mval\e[0m \e[36mc\e[0m = lst.filter(\e[36ml\e[0m=>\
    \ l.contains(x)).sortWith((\e[36ma\e[0m: \e[35mList\e[0m, \e[36mb\e[0m: \e[35mList\e\
    [0m) => a._1 > b._1).map(\e[36ml\e[0m => (l.indexOf(x),l.indexOf(x) + \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                                 \
    \                     ^^^^\e[0m\n\e[31m   |\e[0m                             \
    \            Missing type parameter for List\n\e[31m\e[31m-- [E008] Not Found\
    \ Erro"
  stdout: ''
  timestamp: 1660010573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_.reverse)\n\
    \        val cols = lst.map(_.size)\n        val rowIndexes = rows.map(_(0)).toIndexedSeq\n\
    \        val colIndexes = cols.toIndexedSeq\n        val rows = rowIndexes.zip(colIndexes).toList\n\
    \        val cols = colIndexes.zipWithIndex.sortBy(_._1).reverse.map(_._2)\n \
    \       val colIndexes = cols.toIndexedSeq\n        val result = colIndexes.zip(rowIndexes).toList.flatMap\
    \ {\n            row =>\n                row.map{\n                    case (row,\
    \ col) => Tuple2((row + x, col + x))\n                }\n        }\n        result.sortBy(_._1).reverse.map(_._2)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa77nfy9h.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rowIndexes.zip(colIndexes).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa77nfy9h.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = colIndexes.zipWithIndex.sortBy(_._1).reverse.map(_._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcols is already defined as \e[33mvalue\e[0m \e[35mcols\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa77nfy9h.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mcolIndexes\e[0m = cols.toIndexedSeq\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcolIndexes\
    \ is already defined as \e[33mvalue\e[0m \e[35mcolIndexes\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpa77nfy9h.scala:30:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                   \
    \ \e[33mcase\e[0m (row, col) => Tuple2((row + x, col + x))\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter x$1\
    \ of expanded function:\n\e[31m   |\e[0m   x$1 => \n\e[31m   |\e[0m     x$1\e\
    [33m match \e[0m\n\e[31m   |\e[0m       {\n\e[31m   |\e[0m         \e[33mcase\
    \ \e[0m(row, col) => \n\e[31m   |\e[0m           Tuple2((row + x, col + x))\n\e\
    [31m   |\e[0m       }.\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa77nfy9h.scala:30:51\
    \ ------------------------\e[0m\e[0m\n\e"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val mapRow = mutable.Map[Long,\
    \ List[Long]]()\n        val mapCol = mutable.Map[Long, List[Long]]()\n      \
    \  \n        lst.map(row => {\n            val mapRowValues = row.map(elem =>\
    \ mapRow.getOrElseUpdate(elem, List.empty[Long]))\n            val mapColValues\
    \ = row.map(elem => mapCol.getOrElseUpdate(elem, List.empty[Long]))\n        \
    \    mapCol.updated(0, row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n\
    \            mapRow.updated(0, row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n\
    \            mapCol.updated(row.zipWithIndex.filter(_._1 == x).map(_._2).reverse,\
    \ row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n            mapRow.updated(row.zipWithIndex.filter(_._1\
    \ == x).map(_._2).reverse, row.zipWithIndex.filter(_._1 == x).map(_._2).reverse)\n\
    \        })\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp458ekyt0.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmapRow\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp458ekyt0.scala:21:21\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mmapCol\e[0m = mutable.Map[\e[35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var inRow = lst\n        for\
    \ (i <- 0 to lst.length - 1) {\n            lst(i) = lst(i).sortWith((x, y) =>\
    \ x < y)\n        }\n        for (i <- 0 to lst(0).length - 1) {\n           \
    \ inRow = inRow.sortWith((x, y) => y < x)\n        }\n        inRow = inRow.sortWith((x,\
    \ y) => y > x)\n        lst = inRow\n        for (i<- 0 to lst(0).length - 1)\
    \ {\n            if (lst(0)(i) == x) {\n                lst(0) = lst(0)\n    \
    \            break\n            }\n        }\n        val res = for (i <- 0 until\
    \ lst.size - 1) yield {\n            val xy = lst(i).zipWithIndex.filter(_._1\
    \ == i)\n            (xy(0)._2, xy(0)._1)\n        }\n        res.sortWith((x,\
    \ y) => x._1 < y._1)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp23zk3y4l.scala:22:12 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            lst(i) = lst(i).sortWith((\e[36mx\e[0m, \e\
    [36my\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e\
    [0mvalue update is not a member of List[List[Long]] - did you mean lst.updated?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp23zk3y4l.scala:25:47 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            inRow = inRow.sortWith((\e[36mx\e[0m, \e\
    [36my\e[0m) => y < x)\n\e[31m\e[31m   |\e[0m                                 \
    \            ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of List[Long], but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp23zk3y4l.scala:27:43 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        inRow = inRow.sortWith((\e[36mx\e[0m, \e[36my\e\
    [0m) => y > x)\n\e[31m\e[31m   |\e[0m                                        \
    \ ^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of List[Long], but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp23zk3y4l.scala:28:12 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        lst = inRow\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Reassignment to val lst\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp23zk3y4l.scala:31:16 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                lst(\e[31m0\e[0m) = lst(\e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0mvalue upda"
  stdout: ''
  timestamp: 1660010577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(l=> l.toMap)\n\
    \        val rowsSorted = rows sortBy (_.keys.toList.sorted)\n        val columns\
    \ = rowsSorted map _.keys.toList\n        val columnsSorted = columns sortBy (_\
    \ < x)\n        val tuples = rowsSorted map {\n            case(row: List[Long],\
    \ rowMap) =>\n                val key = rowMap.get(columnsSorted.head).map(x =>\
    \ Tuple2(x, x)).map(_.swap)\n                val result = columns.map(x => Tuple2(row.head,\
    \ key))\n                result\n        }\n        tuples.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_cj402h4.scala:20:38 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = lst.map(\e[36ml\e\
    [0m=> l.toMap)\n\e[31m\e[31m   |\e[0m                                      ^\e\
    [0m\n\e[31m   |\e[0m                                      Cannot prove that Long\
    \ <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                               \
    \       where:    K is a type variable\n\e[31m   |\e[0m                      \
    \                          V is a type variable\n\e[31m   |\e[0m             \
    \                         .\n\e[31m\e[31m-- Error: /tmp/tmp_cj402h4.scala:21:58\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ \e[33mval\e[0m \e[36mrowsSorted\e[0m = rows sortBy (_.keys.toList.sorted)\n\e\
    [31m\e[31m   |\e[0m                                                          ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mShort\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msorted\e[0m in \e[33mtrait\e[0m \e[35mStrictOptimizedSeqOps\e\
    [0m\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp_cj402h4.scala:22:37 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcolumns\e[0m = rowsSorted\
    \ map _.keys.toList\n\e[31m\e[31m   |\e[0m                                   \
    \  ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m   I could not infer the type of the parameter _$2 of expanded function:\n\
    \e[31m   |\e[0m   _$2 => rowsSorted map _$2.keys.toList.\n3 errors found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val numCols = lst.map(_.length).reduce(_\
    \ + _)\n        val numRows = lst.length\n        val lstRows = lst.map(_.zipWithIndex.sortBy(_._1))\n\
    \        val lstCols = lstRows.map(_.map(x => (x, (_: Int))).sortBy(_._1).reverse)\n\
    \        val lstTuples = lstRows.flatMap(row => lstCols.map(col => (col._1, row._2\
    \ + col._1)))\n        lstTuples.map(t => (t._1, t._2 - numCols)).sortBy(_._1).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxop4xku1.scala:23:69 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlstCols\e[0m = lstRows.map(_.map(\e\
    [36mx\e[0m => (x, (_: \e[35mInt\e[0m))).sortBy(_._1).reverse)\n\e[31m\e[31m  \
    \ |\e[0m                                                                   ^^^^\e\
    [0m\n\e[31m   |\e[0m                   value _1 is not a member of Int => ((Long,\
    \ Int), Int)\n\e[31m\e[31m-- Error: /tmp/tmpxop4xku1.scala:23:72 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlstCols\e[0m = lstRows.map(_.map(\e\
    [36mx\e[0m => (x, (_: \e[35mInt\e[0m))).sortBy(_._1).reverse)\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \   ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e\
    [35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e\
    [35mDeprecatedFloatOrdering\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match\
    \ type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in\
    \ \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxop4xku1.scala:24:71\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mlstTuples\e[0m = lstRows.flatMap(\e[36mrow\e[0m => lstCols.map(\e[36mcol\e\
    [0m => (col._1, row._2 + col._1)))\n\e[31m\e[31m   |\e[0m                    \
    \                                               ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                    value _1 is not a member of Nothing\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxop4xku1.scala:24:79 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mlstTuples\e[0m = lstRows.flatMap(\e\
    [36mrow\e[0m => lstCols.map(\e[36mcol\e[0m => (col._1, row._2 + col._1)))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                 ^^^^^^\e[0m\n\e[31m   |\e[0m                           value\
    \ _2 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxop4xku1.scala:25:39 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        lstTuples.map(\e[36mt\e[0m "
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) {\n     \
    \       throw new Exception(\"Can't find row with 0 element\")\n        } else\
    \ if (lst(0).isEmpty) {\n            throw new Exception(\"Can't find row with\
    \ 0 element in this row\")\n        } else if (lst.size != 1) {\n            throw\
    \ new Exception(\"Not a matrix\")\n        } else {\n            // Sort coordinates\
    \ initially by rows in ascending order.\n            val sortedCoordinate = lst.sortWith(x\
    \ => x.head) \n            // Also, sort coordinates of the row by columns in\
    \ descending order.\n            val sortedCoordinateWithDesc = sortedCoordinate.sortWith(x\
    \ => x.last)\n            val x = x % sortedCoordinateWithDesc.last.last\n   \
    \         val coordinateWithDesc = sortedCoordinateWithDesc.find(x => x.last.last\
    \ == x).sortWith(x => x.last.last)\n            // Get coordinate of (x, x)\n\
    \            val coordinate = coordinateWithDesc.find(x => x.last == x).sortWith(x\
    \ => x.last.last)\n            return coordinateWithDesc.map(x => coordinate.map(y\
    \ => (x, y))).toList\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpbnl_0rax.scala:28:50 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36msortedCoordinate\e[0m\
    \ = lst.sortWith(\e[36mx\e[0m => x.head) \n\e[31m\e[31m   |\e[0m             \
    \                                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                         Wrong number of parameters, expected: 2\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmpbnl_0rax.scala:30:71 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36msortedCoordinateWithDesc\e\
    [0m = sortedCoordinate.sortWith(\e[36mx\e[0m => x.last)\n\e[31m\e[31m   |\e[0m\
    \                                                                     ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbnl_0rax.scala:31:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mx\e[0m = x % sortedCoordinateWithDesc.last.last\n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    Recursive \e\
    [33mvalue\e[0m \e[35mx\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpbnl_0rax.scala:32:79 ------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mcoordinateWithDesc\e[0m =\
    \ sortedCoordinateWithDesc.find(\e[36mx\e[0m => x.last.last == x).sortWith(\e\
    [36mx\e[0m => x.last.last)\n\e[31m\e[31m   |\e[0m                            \
    \                                            ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                      value last is not a member of Long\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Sorting coordinates by\
    \ rows in ascending order\n        lst.sortWith((a,b) => a.toLong > b.toLong)\n\
    \n        // Sorting coordinates by columns in descending order\n        lst.sortWith((a,b)\
    \ => b.toLong > a.toLong)\n\n        // Creating a 2-dim mutable array and filling\
    \ it with coordinates - (row, columns) in the form of tuples\n        var lst2d\
    \ = Array.ofDim[Tuple2[Long, Long]](lst.size)\n        // Getting all elements\
    \ that exist in the inner list for each row and store them in the array\n    \
    \    lst.map {\n            row =>\n                row.foreach { elem =>\n  \
    \                  lst2d(elem.toInt) = (elem.toLong, elem.toLong)\n          \
    \      }\n        }\n\n        // Returning the coordinates which match the x\
    \ value\n        lst.find(elem => elem.toLong == x).toList.sortWith((a,b) => a.toLong\
    \ > b.toLong).sortWith((a,b) => b.toLong > a.toLong).map(xy => (xy.toInt, xy.toInt))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa8s4u3i8.scala:21:32 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        lst.sortWith((\e[36ma\e[0m,\e[36mb\e[0m) => a.toLong\
    \ > b.toLong)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpa8s4u3i8.scala:24:32 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        lst.sortWith((\e[36ma\e[0m,\e[36mb\e[0m) => b.toLong\
    \ > a.toLong)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpa8s4u3i8.scala:37:30 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        lst.find(\e[36melem\e[0m => elem.toLong == x).toList.sortWith((\e\
    [36ma\e[0m,\e[36mb\e[0m) => a.toLong > b.toLong).sortWith((\e[36ma\e[0m,\e[36mb\e\
    [0m) => b.toLong > a.toLong).map(\e[36mxy\e[0m => (xy.toInt, xy.toInt))\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import"
  stdout: ''
  timestamp: 1660010581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(row =>\
    \ row.map(x => x -> row).zipWithIndex)\n        val sortedRows = rows.sortBy(row\
    \ => row._1)\n        val sortedCols = rows.map(row => row._2).sortBy(col => -col(0))\n\
    \        val resultRows = sortedCols.map(col => (col(0), col(1)))\n        val\
    \ result = (resultRows ::: sortedRows.map(row => (row(0), row(1)) :: Nil))\n \
    \       result.sortBy(row => (row._1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprty0j558.scala:21:48 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36msortedRows\e[0m = rows.sortBy(\e\
    [36mrow\e[0m => row._1)\n\e[31m\e[31m   |\e[0m                               \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m             value _1 is not a member\
    \ of List[((Long, List[Long]), Int)]\n\e[31m\e[31m-- Error: /tmp/tmprty0j558.scala:21:51\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ \e[33mval\e[0m \e[36msortedRows\e[0m = rows.sortBy(\e[36mrow\e[0m => row._1)\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprty0j558.scala:22:45 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msortedCols\e[0m = rows.map(\e\
    [36mrow\e[0m => row._2).sortBy(\e[36mcol\e[0m => -col(\e[31m0\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                         ^^^^^^\e[0m\n\e[31m   |\e\
    [0m             value _2 is not a member of List[((Long, List[Long]), Int)]\n\e\
    [31m\e[31m-- [E050] Type Error: /tmp/tmprty0j558.scala:22:64 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msortedCols\e[0m = rows.map(\e\
    [36mrow\e[0m => row._2).sortBy(\e[36mcol\e[0m => -col(\e[31m0\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                                ^^^\e\
    [0m\n\e[31m   |\e[0m                                  \e[33mparameter\e[0m \e\
    [35mcol\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmprty0j558.scala:22:71 -----------------------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msortedCols\e[0m = rows.map(\e\
    [36mrow\e[0m => row._2).sortBy(\e[36mcol\e[0m => -col(\e[31m0\e[0"
  stdout: ''
  timestamp: 1660010579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // We need to sort the rows,\
    \ then sort the columns in descending order using scala.math.Ordering\n      \
    \  // Scala.math.Ordering.Int.reverse() will sort a list in ascending order\n\
    \        val rowOrdering = Ordering[List[Long]].reverse\n        val rowOrderingByCol\
    \ = Ordering[List[Long]].on(_.reverse)\n\n        // Sorting the first row in\
    \ the nested list rowOrder \n        // The row list should be sorted in ascending\
    \ order by rows \n        // So for each row in the nested list lst(outer list)\
    \ we will sort using rowOrder\n        val rows = lst.sort(rowOrdering) \n   \
    \     // Sorting the first element of each row in the nested list rowOrder\n \
    \       // The list should be sorted in ascending order by columns\n        //\
    \ So for each row in the nested list lst(outer list) we will sort using rowOrderByCol\n\
    \        val rowsWithCols = lst.map(row => row.sort(rowOrderingByCol))\n     \
    \   // Mapping each row in the nested list lst(outer list) to a list of its column\n\
    \        // We sort the columns using the columnOrder\n        val rows = rowsWithCols.map(row\
    \ => row.sortBy(_._1))\n        // Return the rows that match the given x\n  \
    \      val matchingRows = rows.filter(row => row._1 == x)\n        // Return the\
    \ matching row in the nested list rowOrder\n        val matchingRowWithCols =\
    \ rows.find(row => row._1 == x)\n        // Return the matching row in the nested\
    \ list rowOrderByCol\n        val matchingRowWithColsWithCol = rows.find(row =>\
    \ row._1 == x).map(row => row.sortBy(_._1))\n        \n        // Return empty\
    \ list if the given x is not in the list\n        matchingRowWithColsWithCol match\
    \ {\n          case None => matchingRowWithCols\n          case Some(row) => row\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoxn1g4ox.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rowsWithCols.map(\e\
    [36mrow\e[0m => row.sortBy(_._1))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmpoxn1g4ox.scala:22:46\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mrowOrdering\e[0m = Ordering[\e[35mList\e[0m[\e[35mLong\e\
    [0m]].reverse\n\e[31m\e[31m   |\e[0m                                         \
    \     ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\e\
    [31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- Error: /tmp/tmpoxn1g4ox.scala:23:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mrowOrderingByCol\e[0m =\
    \ Ordering[\e[35mList\e[0m[\e[35mLong\e[0m]].on(_.reverse)\n\e[31m\e[31m   |\e\
    [0m                                                   ^\e[0m\n\e[31m   |\e[0mNo\
    \ implicit Ordering defined for List[Long]..\n\e[31m   |\e[0mI found:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mList[Long]\e\
    [0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e"
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty) List()\n \
    \       else lst\n                .zipWithIndex\n                .sortBy{case\
    \ (it, index) => it._2}\n                .sortBy{case (it, index) => it._2}.filter(_._1==x).map(_._2).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy28mkknn.scala:23:47 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                .sortBy{\e[33mcase\e[0m (it, index) =>\
    \ it._2}\n\e[31m\e[31m   |\e[0m                                            ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  value _2 is not a member\
    \ of List[Long]\n\e[31m\e[31m-- Error: /tmp/tmpy28mkknn.scala:23:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                .sortBy{\e[33mcase\e[0m (it, index) =>\
    \ it._2}\n\e[31m\e[31m   |\e[0m                                              \
    \    ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mBigInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rowList = lst.map(row\
    \ => (row.indexOf(x), row)).toList\n        rowList.sortBy(row => (row.indexOf(x),\
    \ row)).flatMap(row => (row.sortBy(col => (-col, col)))).map(row => (row.head._1,\
    \ row.head._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx9aqsdkh.scala:21:35 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        rowList.sortBy(\e[36mrow\e[0m => (row.indexOf(x),\
    \ row)).flatMap(\e[36mrow\e[0m => (row.sortBy(\e[36mcol\e[0m => (-col, col)))).map(\e\
    [36mrow\e[0m => (row.head._1, row.head._2))\n\e[31m\e[31m   |\e[0m           \
    \                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value\
    \ indexOf is not a member of (Int, List[Long])\n\e[31m\e[31m-- Error: /tmp/tmpx9aqsdkh.scala:21:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ rowList.sortBy(\e[36mrow\e[0m => (row.indexOf(x), row)).flatMap(\e[36mrow\e\
    [0m => (row.sortBy(\e[36mcol\e[0m => (-col, col)))).map(\e[36mrow\e[0m => (row.head._1,\
    \ row.head._2))\n\e[31m\e[31m   |\e[0m                                       \
    \             ^\e[0m\n\e[31m   |\e[0mambiguous given instances of type Ordering[(T1,\
    \ T2)] found for parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e\
    [0m \e[35mSeqOps\e[0m.\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m    scala.math.Ordering.Tuple2[\e[35mT1\e[0m, \e[35mT2\e[0m](\n\e[31m   |\e\
    [0m      /* ambiguous: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[T1] */\n\e[31m   |\e[0m        summon[Ordering[T1]]\n\
    \e[31m   |\e[0m    , \n\e[31m   |\e[0m      scala.math.Ordering.Tuple2[\e[35mInt\e\
    [0m, \e[35mIterable[T]\e[0m](scala.math.Ordering.Int, \n\e[31m   |\e[0m      \
    \  scala.math.Ordering.Iterable[\e[35mT\e[0m](scala.math.Ordering.Long)\n\e[31m\
    \   |\e[0m      )\n\e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut both\
    \ \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[T1].\n2 errors found\n"
  stdout: ''
  timestamp: 1660010579
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        require(lst.length > 0, \"\
    Empty List\")\n        val len = lst(0).length\n        val rows = new collection.mutable.ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            val row = lst.apply(i).zipWithIndex.sortBy(_._1).sortBy(_._2).reverse\n\
    \            rows ++= row.takeWhile(_._1 == x).map(t => (t._2, t._1 + 1))\n  \
    \      }\n        rows.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_aeat9ij.scala:30)\n\tat Problem.main(tmp_aeat9ij.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Solution 1 - Using Scala\
    \ 2.8\n        // Solution 2 - Using Scala 2.7\n        // Solution 3 - Using\
    \ Scala 2.8\n        // Solution 4 - Using Scala 2.7\n        // Solution 5 -\
    \ Using Scala 2.8\n        require(!lst.isEmpty)\n        val rows = lst.size\n\
    \        val cols = lst(0).size\n        val ans = mutable.ListBuffer[Tuple2[Long,\
    \ Long]]()\n        (0 until rows).foreach(row => {\n            (0 until cols).foreach(col\
    \ => {\n                val value = lst(row)(col)\n                ans += (Tuple2(row,\
    \ col) -> value)\n            })\n        })\n        ans.sortBy(t => t._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp57b1hcek.scala:28:18 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mans\e[0m = mutable.ListBuffer[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val map = new mutable.HashMap[Long,\
    \ List[Long]]()\n        val map2 = new mutable.HashMap[Long, List[Long]]()\n\
    \        var index = 0\n        var result: List[Tuple2[Long, Long]] = List()\n\
    \        // first sort\n        for(i <- 0 until lst(0).size){\n            if(map.containsKey(lst(0(i)))){\n\
    \                map.get(lst(0(i)))(i) = lst(0(i))\n            }else{\n     \
    \           map.put(lst(0(i)), lst(0(i)))\n            }\n        }\n        //\
    \ second sort\n        for(i <- 0 until lst(0).size){\n            if(map2.containsKey(lst(0(i)))){\n\
    \                map2.get(lst(0(i)))(i) = lst(1).size - i\n            }else{\n\
    \                map2.put(lst(0(i)), lst(1).size - i)\n            }\n       \
    \ }\n        // first sort\n        for(i <- 0 until map.keySet().toArray.sortWith(_\
    \ < _)){\n            result += ((map.get(i).toList, map2.get(i).toList))\n  \
    \      }\n        return result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa3g2_ht8.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpa3g2_ht8.scala:21:23 ------------------------\e[0m\e[0m\n\e[31m21 |\e\
    [0m        \e[33mval\e[0m \e[36mmap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m    \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa3g2_ht8.scala:42:19\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            result += ((map.get(i).toList,\
    \ map2.get(i).toList))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue += is not a member of List[(Long, Long)] - did you mean List[(Long,\
    \ Long)].!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010579
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var r : List[Tuple2[Long,\
    \ Long]] = List(Tuple2(x, 0l))\n        for (i <- 0 until lst.size) {\n      \
    \      val curr = lst(i)\n            var y = curr(0)\n            var x = 0\n\
    \            var count = 0\n            if (curr == List(x)) {\n             \
    \   count += 1\n            }\n            if (count == 0) {\n               \
    \ y = curr(1)\n                count = 0\n            }\n            for (j <-\
    \ 0 until curr) {\n                if (curr(j) == y) {\n                    x\
    \ = j\n                    count = 1\n                }\n            }\n     \
    \       val tuple = Tuple2(x, y)\n            if (count > 0) {\n             \
    \   r = r ++ List(tuple)\n            }\n        }\n        r.sortBy(_._1)\n \
    \       r.sortBy(_._2)\n        r\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ujf10b0.scala:33:30\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mfor\e[0m (j\
    \ <- \e[31m0\e[0m until curr) {\n\e[31m\e[31m   |\e[0m                       \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                              Found:    (curr\
    \ : List[Long])\n\e[31m   |\e[0m                              Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_ujf10b0.scala:41:30\
    \ --------------------\e[0m\e[0m\n\e[31m41 |\e[0m                r = r ++ List(tuple)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              Found:    (tuple : (Int, Long))\n\e[31m   |\e[0m\
    \                              Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getRowHelper(row: List[Long],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            if (row.size >= x) return\
    \ (row.toList, (row.toList.length, 0l))\n            val newRow = row.drop(x -\
    \ row.size)\n            val getRowHelperResult = getRowHelper(newRow, x)\n  \
    \          row.drop(x - newRow.size) match {\n                case Nil => (getRowHelperResult._1,\
    \ getRowHelperResult._2)\n                case x :: xs =>\n                  \
    \  if (x == row.last) getRowHelperResult :: xs\n                    else getRowHelperResult\
    \ :: getRowHelper(x, row.last) :: getRowHelper(row.drop(1), xs)\n            }\n\
    \        }\n        getRowHelper(lst, x)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcygstdyr.scala:21:38\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (row.size\
    \ >= x) \e[33mreturn\e[0m (row.toList, (row.toList.length, \e[31m0l\e[0m))\n\e\
    [31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Found:    \e[1m\e[31m(\e\
    [0mList[\e[1m\e[31mLong\e[0m\e[1m\e[31m]\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m(\e\
    [1m\e[31mInt\e[0m, Long)\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                   \
    \                  Required: List[(\e[1m\e[32mLong\e[0m, Long)\e[1m\e[32m]\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcygstdyr.scala:22:34\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e\
    [36mnewRow\e[0m = row.drop(x - row.size)\n\e[31m\e[31m   |\e[0m              \
    \                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \            Found:    Long\n\e[31m   |\e[0m                                 \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcygstdyr.scala:24:21\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            row.drop(x - newRow.size)\
    \ \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    Long\n\e[31m   |\e[0m     \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpcygstdyr.scala:25:48 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                \e[33mcase\e[0m Nil => (getRowHelperResult._1, getRowHelperResult._2)\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          value _1 is not a member of List[(Long,\
    \ Long)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcygstdyr.scala:25:71\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                \e[33mcase\e\
    [0m"
  stdout: ''
  timestamp: 1660010581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        val rowIndex = mutable.ListBuffer.empty[Long]\n   \
    \     for (row <- lst) {\n            for (i <- 0 until row.size) {\n        \
    \        if (row(i) == x) {\n                    rowIndex += i\n             \
    \   }\n            }\n        }\n        val columnIndex = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 0 until rowIndex.size) {\n            if (rowIndex(i) >= rowIndex.size)\
    \ {\n                columnIndex += rowIndex.size - i\n            } else {\n\
    \                columnIndex += rowIndex(i)\n            }\n        }\n      \
    \  for (i <- 0 until columnIndex.size) {\n            if (columnIndex(i) >= columnIndex.size)\
    \ {\n                columnIndex += columnIndex.size - i\n            } else {\n\
    \                columnIndex += columnIndex(i)\n            }\n        }\n   \
    \     for (i <- 0 until columnIndex.size) {\n            if (columnIndex(i) >=\
    \ columnIndex.size) {\n                columnIndex += columnIndex.size - i\n \
    \           } else {\n                columnIndex += columnIndex(i)\n        \
    \    }\n        }\n        val columnIndex = columnIndex.toList.sortWith(_ > _)\n\
    \        val rowIndex = rowIndex.toList.sortWith(_ < _)\n        var row = 0\n\
    \        var column = 0\n        for (i <- 0 until rowIndex.size) {\n        \
    \    row += 1\n            column += 1\n            for (j <- 0 until columnIndex.size)\
    \ {\n                if (i == columnIndex(j)) {\n                    result +=\
    \ ((row.toLong, column.toLong))\n                }\n            }\n        }\n\
    \        result.sortWith(_._1 < _._1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpprvc9768.scala:51:12 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mcolumnIndex\e[0m = columnIndex.toList.sortWith(_\
    \ > _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcolumnIndex is already defined as \e[33mvalue\e[0m \e[35mcolumnIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpprvc9768.scala:52:12 ---------------------------\e[0m\e[0m\n\e\
    [31m52 |\e[0m        \e[33mval\e[0m \e[36mrowIndex\e[0m = rowIndex.toList.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrowIndex is already defined as \e[33mvalue\e[0m \e[35mrowIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpprvc9768.scala:21:23 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrowIndex\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpprvc9768.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcolumnIndex\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpprvc9768.scala:60:27 ------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m                    result += ((row.toLong, column.toLong))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ += is not a member of List[(Long, Long)] - did you mean List[(Long, Long)].!=?\n\
    5 error"
  stdout: ''
  timestamp: 1660010581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result = new mutable.LinkedHashSet[Tuple2[Long,\
    \ Long]]()\n        val index = new mutable.HashMap[Long, Long]()\n\n        lst.foreach{row\
    \ =>\n            row.foreach{col =>\n                if(index.getOrElse(col,\
    \ -1) < x) {\n                    index += (col -> x)\n                    result\
    \ += Tuple2(col, x)\n                }\n            }\n        }\n\n        val\
    \ sortedIndices = index.toSeq.sortWith(_._1 < _._1)\n        val sortedResults\
    \ = result.sortWith(_._2 < _._2)\n        val tuples = sortedResults.map(e =>\
    \ Tuple2(sortedIndices(e._2).toInt, e._1)).toList\n        tuples.sortWith(_._1\
    \ < _._1)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp09ggqip6.scala:20:25 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.LinkedHashSet[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp09ggqip6.scala:21:24 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def row(lst : List[List[Long]],\
    \ r : Long, c : Long) : List[Long] = {\n            if (lst.isEmpty) Nil\n   \
    \         else if (r == x) lst(r - 1).map(_ + c) //ascending\n            else\
    \ row(lst.take(r - 1), r, c + 1) //descending\n        }\n        row(lst, 0,\
    \ 0).sortWith(\n            (x1: Long, y1: Long) => x1 < y1,\n            (x1:\
    \ Long, y1: Long) => x1 > y1).map(\n            (x1: Long, y1: Long) => Tuple2(y1\
    \ - x1, x1)).toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv_erd6r4.scala:22:33\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33melse\e[0m \e\
    [33mif\e[0m (r == x) lst(r - \e[31m1\e[0m).map(_ + c) \e[34m//ascending\e[0m\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Found:    Long\n\e[31m   |\e[0m          \
    \                       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpv_erd6r4.scala:23:30 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            \e[33melse\e[0m row(lst.take(r - \e[31m1\e[0m),\
    \ r, c + \e[31m1\e[0m) \e[34m//descending\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                      ^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \   Found:    Long\n\e[31m   |\e[0m                              Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv_erd6r4.scala:26:12\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m            (\e[36mx1\e[0m: \e\
    [35mLong\e[0m, \e[36my1\e[0m: \e[35mLong\e[0m) => x1 < y1,\n\e[31m\e[31m   |\e\
    [0m            ^\e[0m\n\e[31m   |\e[0m            Found:    (\e[1m\e[31m(\e[0mLong,\
    \ Long) => \e[1m\e[31mBoolean\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m(\e\
    [0m\e[1m\e[31mLong\e[0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e\
    [1m\e[31m)\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m=\e[0m\e[1m\e[31m>\e[0m\e[1m\e[31m\
    \ \e[0mBoolean\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m            Required: (Long, Long)\
    \ => Boolean\n\e[31m27 |\e[0m            (x1: Long, y1: Long) => x1 > y1).map(\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv_erd6r4.scala:28:12\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            (\e[36mx1\e[0m: \e\
    [35mLong\e[0m, \e[36my1\e[0m: \e[35mLong\e[0m) => Tuple2(y1 - x1, x1)).toList\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    \e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m \e[1m\e[31mLong\e[0m\e["
  stdout: ''
  timestamp: 1660010586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(l => l.map(x\
    \ => Tuple2(x, x)))\n        val cols = rows.flatMap(_.map(l => l.map(_ -> 0)))\n\
    \        val sortedRows = rows.sortBy(r => -r.map(_.asInstanceOf[Long]).max)\n\
    \        val sortedCols = cols.sortBy(c => -c.map(_.asInstanceOf[Long]).max)\n\
    \        val res = sortedRows.flatMap(row => sortedCols.map(col => Tuple2(row(0),\
    \ col(0))))\n        return res\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp0oxvqrdk.scala:21:49 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = rows.flatMap(_.map(\e\
    [36ml\e[0m => l.map(_ -> \e[31m0\e[0m)))\n\e[31m\e[31m   |\e[0m              \
    \                                   ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => _$2 -> 0.\n\e[31m\e[31m--\
    \ [E081] Type Error: /tmp/tmp0oxvqrdk.scala:23:49 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36msortedCols\e[0m = cols.sortBy(\e\
    [36mc\e[0m => -c.map(_.asInstanceOf[\e[35mLong\e[0m]).max)\n\e[31m\e[31m   |\e\
    [0m                                                 ^\e[0m\n\e[31m   |\e[0m  \
    \ Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$4 of expanded function:\n\e[31m   |\e[0m   _$4 =>\
    \ _$4.asInstanceOf[\e[35mLong\e[0m].\n\e[31m\e[31m-- Error: /tmp/tmp0oxvqrdk.scala:23:75\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36msortedCols\e[0m = cols.sortBy(\e[36mc\e[0m => -c.map(_.asInstanceOf[\e\
    [35mLong\e[0m]).max)\n\e[31m\e[31m   |\e[0m                                  \
    \                                         ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mDeprecatedDoubleOrdering\e[0m in \e\
    [33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val map = mutable.Map[Long,\
    \ Long]()\n        val rows = lst.flatMap(row => row.map(i => map.putIfAbsent(i,\
    \ i + x)))\n        val columns = rows.flatMap(col => col.map(i => map.putIfAbsent(i,\
    \ i + 1)))\n        rows.flatMap(row => row.zipWithIndex)\n            .sortBy(_._1)\n\
    \            .sortBy(_._2)\n            .map(x => (x._1, x._2))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprzw21d9z.scala:20:18 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mmap\e[0m = mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmprzw21d9z.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcolumns\e[0m = rows.flatMap(\e\
    [36mcol\e[0m => col.map(\e[36mi\e[0m => map.putIfAbsent(i, i + \e[31m1\e[0m)))\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue map is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprzw21d9z.scala:23:32\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        rows.flatMap(\e[36mrow\e\
    [0m => row.zipWithIndex)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue zipWithIndex is not a member of Nothing, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m "
  stdout: ''
  timestamp: 1660010589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.sortWith((x, y) => x.head\
    \ < y.head).\n          flatMap((_, i) =>\n            lst\n              .take(i)\n\
    \              .sortWith((x, y) => x.head > y.head).\n              flatMap((_,\
    \ j) =>\n                lst\n                  .take(j)\n                  .sortWith((x,\
    \ y) => x.head < y.head)))\n          .filter((i, j) => j == x).\n          map((_,\
    \ x) => Tuple2(i, x)).toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmppa3d50_n.scala:21:25 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m          flatMap((_, \e[36mi\e[0m) =>\n\e[31m\e[31m\
    \   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Wrong number\
    \ of parameters, expected: 1\n\e[31m22 |\e[0m            lst\n\e[31m23 |\e[0m\
    \              .take(i)\n\e[31m24 |\e[0m              .sortWith((\e[36mx\e[0m,\
    \ \e[36my\e[0m) => x.head > y.head).\n\e[31m25 |\e[0m              flatMap((_,\
    \ \e[36mj\e[0m) =>\n\e[31m26 |\e[0m                lst\n\e[31m27 |\e[0m      \
    \            .take(j)\n\e[31m28 |\e[0m                  .sortWith((\e[36mx\e[0m,\
    \ \e[36my\e[0m) => x.head < y.head)))\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmppa3d50_n.scala:29:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m          .filter((i,\
    \ j) => j == x).\n\e[31m\e[31m   |\e[0m                  ^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                  Wrong number of parameters, expected: 1\n\e[31m\e\
    [31m-- [E086] Syntax Error: /tmp/tmppa3d50_n.scala:30:21 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m          map((_, \e[36mx\e[0m) => Tuple2(i, x)).toList\n\
    \e[31m\e[31m   |\e[0m              ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \              Wrong number of parameters, expected: 1\n3 errors found\n"
  stdout: ''
  timestamp: 1660010586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        require(lst.length == 1)\n\
    \        require(lst(0).length == lst(1).length)\n        val m = lst(0).length\n\
    \        val n = lst(1).length\n        val coords = scala.collection.mutable.ListBuffer.empty[Tuple2[Long,\
    \ Long]]\n        coords.+=((0l, 0l))\n        coords.+=((0l, x)).sortBy(_._1)\n\
    \        coords.+=((xl.toLong, 0l)).sortBy(_._2)\n        coords.+=((xl.toLong,\
    \ xl))\n        coords.+=((xl.toLong, n))\n        coords.+=((n, 0l)).sortBy(_._1)\n\
    \        coords.+=((n, xl))\n        coords.+=((n, n))\n        coords.toList.sortBy(_._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuapch0fs.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        coords.+=((xl.toLong, \e[31m0l\e[0m)).sortBy(_._2)\n\
    \e[31m\e[31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e[0m             \
    \      Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuapch0fs.scala:28:19\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        coords.+=((xl.toLong,\
    \ xl))\n\e[31m\e[31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e[0m     \
    \              Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpuapch0fs.scala:28:30 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        coords.+=((xl.toLong, xl))\n\e[31m\e[31m   |\e[0m                 \
    \             ^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuapch0fs.scala:29:19\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        coords.+=((xl.toLong,\
    \ n))\n\e[31m\e[31m   |\e[0m                   ^^\e[0m\n\e[31m   |\e[0m      \
    \             Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpuapch0fs.scala:31:22 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        coords.+=((n, xl))\n\e[31m\e[31m   |\e[0m                      ^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: xl\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val r = lst.sortWith((r1,\
    \ r2) => r1.zip(r2).map(_._1).sum < r2.zip(r1).map(_._1).sum)\n        val m =\
    \ r.map(_.zip(r).map(x => (x, 0l)).toSet).map { x => x.last.zip(x.last.map(y =>\
    \ (y, 0l)).toSet) }\n        val w = r.map(_.zip(m).map(x => x.last.zip(x.last.map(y\
    \ => (y, y._2._1 - x._1)).toSet)).flatten)\n        val l = r.map(_.zip(w).map(x\
    \ => x.last.zip(x.last.map(y => (y, y._2._1 - x._1)).toSet)).flatten)\n      \
    \  l :+ w.map(x => x.last.zip(x.last.map(y => (y, y._2 + x._1)).toSet)).flatten\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpcybtbxxh.scala:21:89 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = r.map(_.zip(r).map(\e\
    [36mx\e[0m => (x, \e[31m0l\e[0m)).toSet).map { \e[36mx\e[0m => x.last.zip(x.last.map(\e\
    [36my\e[0m => (y, \e[31m0l\e[0m)).toSet) }\n\e[31m\e[31m   |\e[0m            \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                          Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m                          I could not infer the\
    \ type of the parameter y.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpcybtbxxh.scala:22:62\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e\
    [0m \e[36mw\e[0m = r.map(_.zip(m).map(\e[36mx\e[0m => x.last.zip(x.last.map(\e\
    [36my\e[0m => (y, y._2._1 - x._1)).toSet)).flatten)\n\e[31m\e[31m   |\e[0m   \
    \                                                           ^\e[0m\n\e[31m   |\e\
    [0m                          Missing parameter type\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m                          I could not infer the type of the parameter\
    \ y.\n\e[31m\e[31m-- Error: /tmp/tmpcybtbxxh.scala:22:103 ----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mw\e[0m = r.map(_.zip(m).map(\e\
    [36mx\e[0m => x.last.zip(x.last.map(\e[36my\e[0m => (y, y._2._1 - x._1)).toSet)).flatten)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                               ^\e[0m\n\e[31m   |\e[0mno given\
    \ instance of type Tuple.Zip[Tuple.Zip[((Long, List[Long]), Long), Nothing], Nothing]\
    \ => \n\e[31m   |\e[0m  IterableOnce[B] was found for parameter toIterableOnce\
    \ of \e[33mmethod\e[0m \e[35mflatten\e[0m in \e[33mtrait\e[0m \e[35mStrictOptimizedIterableOps\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type variable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote: a match type could not be fully\
    \ reduced:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  trying to reduce  Tuple.Zip[Tuple.Zip[((Long,\
    \ List[Long]), Long), Nothing], Nothing]\n\e[31m   |\e[0m  trying to reduce  Tuple.Zip[((Long,\
    \ List[Long]), Long), Noth"
  stdout: ''
  timestamp: 1660010591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // (0, 0) (1, 4) (1, 0) (2,\
    \ 5) (2, 0)\n        val ls = lst.map(l => l.map(l => (l, 0l)).toList.toSeq)\n\
    \            .sortWith(_.first < _.second)\n            .sortWith(_.first > _.second)\n\
    \            .map(l => (l, 0l))\n        val tuples = ls.zip(ls.tail).flatMap{\
    \ case (l, l2) =>\n            val l = l.map(x => (x, l2.head))\n            l.sortWith(_.first\
    \ < _.second).sortWith(_.first > _.second)\n        }\n        tuples.map(t =>\
    \ t._1 -> t._2)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6um4j2vd.scala:22:24 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            .sortWith(_.first < _.second)\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue first is not\
    \ a member of List[(Long, Long)] - did you mean _$1.find?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6um4j2vd.scala:23:24 ------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m            .sortWith(_.first > _.second)\n\e[31m\e[31m  \
    \ |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue first is not\
    \ a member of List[(Long, Long)] - did you mean _$3.find?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp6um4j2vd.scala:29:26 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        tuples.map(\e[36mt\e[0m => t._1 -> t._2)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^\e[0m\n\e[31m   |\e[0mvalue _1 is not\
    \ a member of Nothing, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import concurrent.duration.durationToPair\n\e\
    [31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def findRow(row: List[Long],\
    \ x: Long) : List[Long] = {\n            val r = row.indexOf(x)\n            if\
    \ (r == -1) {\n                row.push(x)\n                row\n            }\
    \ else {\n                if (row.last.compareTo(x) < 0) {\n                 \
    \   findRow(row.dropRight(1), x)\n                } else {\n                 \
    \   findRow(row.drop(1), x)\n                }\n            }\n        }\n   \
    \     val rows: List[List[Long]] = lst.map(findRow(_, x)).toList\n        val\
    \ newRows = rows.map((row, index) =>\n            (rows(index), row.map((_, row.lastIndexOf(x))).reduceLeft{(x,\
    \ y) => y.compareTo(x)}\n            )\n        ).sortWith((x, y) => -x._2._2).sortBy(_._1).reverse.map(x\
    \ => (x._1, x._2))\n        newRows.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_dizialh.scala:23:20 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                row.push(x)\n\e[31m\e[31m   |\e[0m  \
    \              ^^^^^^^^\e[0m\n\e[31m   |\e[0m       value push is not a member\
    \ of List[Long] - did you mean row.last?\n\e[31m\e[31m-- [E086] Syntax Error:\
    \ /tmp/tmp_dizialh.scala:34:44 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mnewRows\e[0m = rows.map((\e[36mrow\e[0m,\
    \ \e[36mindex\e[0m) =>\n\e[31m\e[31m   |\e[0m                               ^\e\
    [0m\n\e[31m   |\e[0m                               Wrong number of parameters,\
    \ expected: 1\n\e[31m35 |\e[0m            (rows(index), row.map((_, row.lastIndexOf(x))).reduceLeft{(\e\
    [36mx\e[0m, \e[36my\e[0m) => y.compareTo(x)}\n\e[31m36 |\e[0m            )\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_dizialh.scala:37:35 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        ).sortWith((x, y) => -x._2._2).sortBy(_._1).reverse.map(x\
    \ => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value _2 is not a member of\
    \ Nothing\n\e[31m\e[31m-- Error: /tmp/tmp_dizialh.scala:37:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        ).sortWith((x, y) => -x._2._2).sortBy(_._1).reverse.map(x\
    \ => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                                    \
    \               ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\
    \e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660010592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.size\n       \
    \ var tst = ListBuffer.empty[Tuple2[Long, Long]]()\n        var i = 0\n      \
    \  var col = 0\n        while(i < m) {\n            while (col < x.toLong) {\n\
    \                tst += List(Tuple2(i, col))\n                col += 1\n     \
    \       }\n            i += 1\n            col = 0\n        }\n        tst.sortWith((x,\
    \ y) => x._1 < y._1)\n        tst.sortWith((x, y) => x._2 < y._2)\n        tst.toList.filter(_._1\
    \ == x).filter(_._2 == x).toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6tsoi0dy.scala:21:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mtst\e[0m = ListBuffer.empty[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m  \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing\
    \ argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e\
    [0m \e[35mListBuffer\e[0m: (i: Int): (Long, Long)\n1 error found\n"
  stdout: ''
  timestamp: 1660010587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var rowMap : Map[Long, List[Long]]\
    \ = Map()\n        var row = ListBuffer[Tuple2[Long, Long]]()\n        var idx\
    \ = 0\n        for (x <- lst) {\n            if (rowMap.getOrElse(x, List.empty).contains(idx))\
    \ {\n                row += ((idx, rowMap(x, idx)))\n            }\n         \
    \   rowMap += (x -> rowMap.getOrElse(x, List.empty).::(idx))\n            idx\
    \ += 1\n        }\n        row.toList.reverse.sortBy(_._1).toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiqqnkmfg.scala:24:33\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mif\e[0m (rowMap.getOrElse(x,\
    \ List.empty).contains(idx)) {\n\e[31m\e[31m   |\e[0m                        \
    \         ^\e[0m\n\e[31m   |\e[0m                                 Found:    (x\
    \ : List[Long])\n\e[31m   |\e[0m                                 Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiqqnkmfg.scala:25:37\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                row += ((idx,\
    \ rowMap(x, idx)))\n\e[31m\e[31m   |\e[0m                                    \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m                                     Found:    (List[Long],\
    \ Int)\n\e[31m   |\e[0m                                     Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiqqnkmfg.scala:27:45\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m            rowMap += (x -> rowMap.getOrElse(x,\
    \ List.empty).::(idx))\n\e[31m\e[31m   |\e[0m                                \
    \             ^\e[0m\n\e[31m   |\e[0m                                        \
    \     Found:    (x : List[Long])\n\e[31m   |\e[0m                            \
    \                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.foldLeft[List[Tuple2[Long,\
    \ Long]]](List[Tuple2[Long, Long]]())((x, y) => y match {\n            case Nil\
    \ => x :: Nil\n            case head :: tail => getRow(tail, x.head + x.last)\
    \ :: (head :: Nil)\n        })\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzcnwn9p6.scala:21:24\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m Nil\
    \ => x :: Nil\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Found:    (\e[1m\e[31mx\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31m:\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31m(\e\
    [0mLong, Long\e[1m\e[31m)\e[0m\e[1m\e[31m]\e[0m)\n\e[31m   |\e[0m            \
    \            Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzcnwn9p6.scala:22:40 --------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m            \e[33mcase\e[0m head :: tail => getRow(tail, x.head + x.last)\
    \ :: (head :: Nil)\n\e[31m\e[31m   |\e[0m                                    \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                                        Found:\
    \    \e[1m\e[31m(\e[0m\e[1m\e[31mtail\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e\
    [1m\e[31m \e[0mList[Long]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m                  \
    \                      Required: \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mList[Long]\e\
    [1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzcnwn9p6.scala:22:53\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e\
    [0m head :: tail => getRow(tail, x.head + x.last) :: (head :: Nil)\n\e[31m\e[31m\
    \   |\e[0m                                              ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue + is not a member of (Long, Long), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val indexToFindInList = lst.indexOf(x)\n\
    \        if (indexToFindInList < 0) List() else (0 until lst(indexToFindInList).size).map(i\
    \ => (i, lst.map(x => x(i)).toList)).sortWith(_.swap).reverse.map(x => (x._1,\
    \ x._2))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp1tn8v59b.scala:21:135 --------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mif\e[0m (indexToFindInList < \e[31m0\e\
    [0m) List() \e[33melse\e[0m (\e[31m0\e[0m until lst(indexToFindInList).size).map(\e\
    [36mi\e[0m => (i, lst.map(\e[36mx\e[0m => x(i)).toList)).sortWith(_.swap).reverse.map(\e\
    [36mx\e[0m => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                           \
    \                                                                            \
    \                                ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                 Wrong number of parameters, expected: 2\n1 error found\n"
  stdout: ''
  timestamp: 1660010588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // First sort the coordinates\
    \ of all rows by rows in ascending order\n        var rows: List[List[Long]] =\
    \ lst.reverse.foldRight(List[List[Long]]()){ (acc, current) =>\n            val\
    \ row: List[Long] = current.reverse\n            (acc.sortWith((x, y) => x < y)\
    \ || acc.reverse, row.sortWith((x, y) => y < x))\n        }._1.sortWith((x, y)\
    \ => x < y)\n        // Then sort the coordinates of each row by columns in descending\
    \ order\n        rows = rows.map(_.sortWith((x, y) => y < x))\n        val result:\
    \ List[Tuple2[Long, Long]] = rows.map(row =>\n            val tuple = row.zipWithIndex.filter(x\
    \ => x._1 == x).sortBy(x => x._2).reverse\n            (tuple._1, tuple._2)\n\
    \        ).takeWhile(x => x._2 == x).map(x => (x._1, x._2 + x))\n        result.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpghez1s4a.scala:22:42\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e\
    [36mrow\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = current.reverse\n\e[31m\e[31m\
    \   |\e[0m                                  ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  Found:    List[\e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0mLong\e[1m\e[31m]\e[0m]\n\e[31m   |\e[0m                            \
    \      Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpghez1s4a.scala:23:43 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            (acc.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x < y) || acc.reverse,\
    \ row.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => y < x))\n\e[31m\e[31m   |\e[0m\
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \    value || is not a member of List[Long]\n\e[31m\e[31m-- Error: /tmp/tmpghez1s4a.scala:28:53\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m28 |\e[0m       \
    \     \e[33mval\e[0m \e[36mtuple\e[0m = row.zipWithIndex.filter(\e[36mx\e[0m =>\
    \ x._1 == x).sortBy(\e[36mx\e[0m => x._2).reverse\n\e[31m\e[31m   |\e[0m     \
    \                                                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mValues of types Long @uncheckedVariance and (Long @uncheckedVariance, Int)\
    \ cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpghez1s4a.scala:29:19\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            (tuple._1, tuple._2)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^\e[0m\n\e[31m   |\e[0m             value\
    \ _1 is not a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpghez1s4a.scala:29:29 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m            (tuple._1, tuple._2)\n\e[31m\e[31m   |\e[0m                   \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value _2 is not a member\
    \ of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpghez1s4a.scala:30:57\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        ).takeWhile(x =>\
    \ x._2 == x).map("
  stdout: ''
  timestamp: 1660010594
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // TODO: Write your code here\n\
    \        var result: List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until\
    \ lst.size) {\n            for (j <- 0 until lst(i).size) {\n                if\
    \ ((i == 0) && (lst(j).contains(x))) {\n                    result = result :+\
    \ ((i.toLong, j.toLong))\n                }\n                if (j == lst(i).size\
    \ - 1) {\n                    result = result :+ ((i.toLong, j.toLong))\n    \
    \            }\n                if (i == lst.size - 1) {\n                   \
    \ if (lst(j).contains(x)) {\n                        result = result :+ ((i.toLong,\
    \ j.toLong))\n                    }\n                }\n            }\n      \
    \  }\n        result.sortWith((a, b) => (a._1 < b._1))\n        result.sortWith((a,\
    \ b) => (b._1 > a._1))\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: 3\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.getRow$$anonfun$1$$anonfun$1(tmptlt_do6z.scala:24)\n\tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.getRow$$anonfun$1(tmptlt_do6z.scala:35)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.getRow(tmptlt_do6z.scala:36)\n\
    \tat Problem$.main(tmptlt_do6z.scala:42)\n\tat Problem.main(tmptlt_do6z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main"
  stdout: ''
  timestamp: 1660010595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        require(!lst.isEmpty)\n  \
    \      require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n        require(!lst.isEmpty)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaly16fum.scala:83:15\
    \ --------------------\e[0m\e[0m\n\e[31m83 |\e[0m        require(!lst.isEmpty)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Unit\n\e[31m   |\e[0m        Required: List[(Long, Long)]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lst1 = lst.toList\n  \
    \      val lst2 = lst1.map(_ match {\n            case head :: tail => head\n\
    \            case Nil => x\n        }).toList\n        val lst3 = lst2.sortWith(_.compareTo(_)\
    \ < 0)\n        val lst4 = lst3.sortWith(_.compareTo(_) > 0)\n        val lst5\
    \ = lst4.zipWithIndex.sortWith(_.last.compareTo(_._1) > 0)\n        val lst6 =\
    \ lst5.map(_._2)\n        val lst7 = lst6.map((_, x)).toList\n        lst7.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpsme03kvi.scala:27:46 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlst5\e[0m = lst4.zipWithIndex.sortWith(_.last.compareTo(_._1)\
    \ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \              Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpsme03kvi.scala:30:13 --------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        lst7.reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[(\e[1m\e[31mInt\e[0m, Long)]\n\e[31m\
    \   |\e[0m        Required: List[(\e[1m\e[32mLong\e[0m, Long)]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(row =>\
    \ row.map(_.toLong))\n        val rows = rows.sortBy(_.map(_._1))\n        val\
    \ rows = rows.sortBy(_.map(_._2), Ordering.Int.reverse)\n        val rows = rows.filter(row\
    \ => row._1 == x)\n        val rows = rows.map(row => Tuple2(row._1, row._2))\n\
    \        val rows = rows.sortBy(row => (row._2, row._1), Ordering.Long.reverse)\n\
    \        val rows = rows.map(row => (row._1, row._2))\n        rows.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5bs6rtsg.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rows.sortBy(_.map(_._1))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5bs6rtsg.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rows.sortBy(_.map(_._2), Ordering.Int.reverse)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5bs6rtsg.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rows.filter(\e[36mrow\e[0m =>\
    \ row._1 == x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5bs6rtsg.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rows.map(\e[36mrow\e[0m => Tuple2(row._1,\
    \ row._2))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5bs6rtsg.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rows.sortBy(\e[36mrow\e[0m =>\
    \ (row._2, row._1), Ordering.Long.reverse)\n\e[31m\e[31m   |\e["
  stdout: ''
  timestamp: 1660010594
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) List(Tuple2(0,0))\n\
    \        else {\n            val m = lst(0)\n            val i = Int((x.toLong\
    \ - m.toLong)/m.toLong)\n            val y = m.toLong + i * m.toLong\n       \
    \     val m2 = lst(1)\n            val i2 = Int((y.toLong - m2.toLong)/m2.toLong)\n\
    \            val y2 = m2.toLong + i2 * m2.toLong\n            val m3 = lst(2)\n\
    \            val i3 = Int((y2.toLong - m3.toLong)/m3.toLong)\n            val\
    \ y2 = m3.toLong + i3 * m3.toLong\n            (for {\n                i <- 0L\
    \ until i\n                j <- 0L until i2\n                k <- 0L until i3\n\
    \            } yield Tuple2(i*m.toLong + j,m2.toLong + k*m2.toLong + y)).sortBy(_._1).reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcicizfc9.scala:30:16 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36my2\e[0m = m3.toLong\
    \ + i3 * m3.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0my2 is already defined as \e[33mvalue\e[0m \e[35my2\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpcicizfc9.scala:23:20 -----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m            \e[33mval\e[0m \e[36mi\e[0m = Int((x.toLong - m.toLong)/m.toLong)\n\
    \e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m           \
    \         \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mpackage\e[0m \e[35mscala\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpcicizfc9.scala:23:38 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m            \e[33mval\e[0m \e[36mi\e[0m = Int((x.toLong - m.toLong)/m.toLong)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue toLong is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcicizfc9.scala:24:22 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36my\e[0m = m.toLong + i * m.toLong\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional."
  stdout: ''
  timestamp: 1660010596
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var lst2 : List[List[Long]]\
    \ = lst.reverse\n        for (rowCols <- lst2)\n            for (col <- rowCols.reverse)\n\
    \                if (x == col) yield (row, col)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpto4qc26e.scala:23:30 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mif\e[0m (x == col) \e[33myield\e\
    [0m (row, col)\n\e[31m\e[31m   |\e[0m                              ^^^^^\e[0m\n\
    \e[31m   |\e[0m                              'then' expected, but 'yield' found\n\
    \e[33m\e[33m-- [E129] Potential Issue Warning: /tmp/tmpto4qc26e.scala:24:4 -----------------\e\
    [0m\e[0m\n\e[33m23 |\e[0m                \e[33mif\e[0m (x == col) \e[33myield\e\
    [0m (row, col)\n\e[33m24 |\e[0m    }\n\e[33m\e[33m   |\e[0m                  \
    \                            ^\e[0m\n\e[33m   |\e[0mA pure expression does nothing\
    \ in statement position; you may be omitting necessary parentheses\n\e[33m   |\e\
    [0m\n\e[33m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 warning found\n1 error found\n"
  stdout: ''
  timestamp: 1660010591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // sort lst by rows by descending\
    \ order\n        lst.sortBy( (x) => -x(1) )\n\n        // sort each row by columns\
    \ in descending order\n        // returns List[List[Tuple2[Long, Long]]]\n   \
    \     def sortRow(xs : List[List[Long]]) : List[List[Tuple2[Long, Long]]] = {\n\
    \            xs.map( _.sortBy( (x) => -x(2) ) ).flatten\n        }\n\n       \
    \ // returns List[Tuple2[Long, Long]]\n        def getCoord(xs : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n            xs.find( _.exists( (x)\
    \ => x == x(x) ) ).getOrElse( List[Tuple2[Long, Long]]() )\n        }\n\n    \
    \    // if lst is empty, return empty list\n        if(lst.isEmpty) List[Tuple2[Long,\
    \ Long]]()\n\n        // if x is in the lst, return the list of coordinates of\
    \ x, otherwise return empty list\n        lst.flatMap( getCoord ).find( x => x\
    \ == x ).getOrElse( List[Tuple2[Long, Long]]() )\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp82zqd9bz.scala:26:38 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            xs.map( _.sortBy( (\e[36mx\e[0m) => -x(\e\
    [31m2\e[0m) ) ).flatten\n\e[31m\e[31m   |\e[0m                               \
    \       ^\e[0m\n\e[31m   |\e[0m                                    \e[33mparameter\e\
    [0m \e[35mx\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp82zqd9bz.scala:26:44 -----------------------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m            xs.map( _.sortBy( (\e[36mx\e[0m) => -x(\e[31m2\e\
    [0m) ) ).flatten\n\e[31m\e[31m   |\e[0m                                      \
    \      ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m\
    \ \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n\e[31m\e[31m-- Error: /tmp/tmp82zqd9bz.scala:26:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            xs.map( _.sortBy( (\e[36mx\e[0m) => -x(\e\
    [31m2\e[0m) ) ).flatten\n\e[31m\e[31m   |\e[0m                               \
    \                       ^\e[0m\n\e[31m   |\e[0mno given instance of type List[Long]\
    \ => IterableOnce[B] was found for parameter toIterableOnce of \e[33mmethod\e\
    [0m \e[35mflatten\e[0m in \e[33mtrait\e[0m \e[35mStrictOptimizedIterableOps\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mwhere:    B is a type variable with constraint\
    \ <: List[(Long, Long)]\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp82zqd9bz.scala:31:43\
    \ -----------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            xs.find(\
    \ _.exists( (\e[36mx\e[0m) => x == x(x) ) ).getOrElse( List[\e[35mTuple2\e[0m[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]]() )\n\e[31m\e[31m   |\e[0m                  \
    \                         ^\e[0m\n\e[31m   |\e[0m                            \
    \        \e[33mparameter\e[0m \e[35mx\e[0m does not take parameters\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[3"
  stdout: ''
  timestamp: 1660010595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Sort the list by row number\n\
    \        lst.sortWith(_.compareTo(_, Ordering[Long]()))\n\n        val listOfTupleOfLongs\
    \ = lst.map {\n            x =>\n                val (row, col) = x\n        \
    \        (row.toLong, col.toLong)\n        }\n        listOfTupleOfLongs.sortWith(_.compareTo(_,\
    \ Ordering[Long](Ordering[Long]())))\n\n        listOfTupleOfLongs.sliding(2).map\
    \ {\n            x =>\n                (x._1, x._2)\n        }.filter(_._1 ==\
    \ x).sortWith(_.compareTo(_, Ordering[Long](Ordering[Long]())))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr1ksgrb3.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        lst.sortWith(_.compareTo(_, Ordering[\e[35mLong\e\
    [0m]()))\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue compareTo is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpr1ksgrb3.scala:21:50 -----------------------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        lst.sortWith(_.compareTo(_, Ordering[\e[35mLong\e\
    [0m]()))\n\e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter ord of \e[33mmethod\e[0m \e\
    [35mapply\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m: (\e[33mimplicit \e[0mord:\
    \ Ordering[Long]): Ordering[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr1ksgrb3.scala:26:21\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                (row.toLong,\
    \ col.toLong)\n\e[31m\e[31m   |\e[0m                 ^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toLong is not a member of Any, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr1ksgrb3.scala:26:33\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                (row.toLong,\
    \ col.toLong)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Any, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional."
  stdout: ''
  timestamp: 1660010597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(_.length)\n\
    \        val columns = rows.max\n        val maxTuples = columns.toLong / 2\n\
    \        val maxTuplesSize = maxTuples * 2\n\n        val lstOfListOfLongs = lst.map(_.map(_\
    \ => x.toLong))\n        val lstOfListOfTuples = lstOfListOfLongs.map(_.toList)\n\
    \n        val lstOfListOfTuplesAndTuples = lstOfListOfTuples.zip(lstOfListOfTuples.dropRight(maxTuplesSize))\n\
    \n        val lstOfListOfTuplesAndTuplesSorted = lstOfListOfTuplesAndTuples.sortBy(_._1)\n\
    \n        val lstOfListOfTuplesAndTuplesSortedByRow = lstOfListOfTuplesAndTuplesSorted.sortBy(_._2)\n\
    \n        val lstOfListOfTuplesAndTuplesSortedByColumn = lstOfListOfTuplesAndTuplesSortedByRow.sortBy(_._1)\n\
    \n        val tuples = lstOfListOfTuplesAndTuplesSortedByColumn.map(_._2).toList\n\
    \        val tuplesWithOutDuplicates = tuples\n        tuplesWithOutDuplicates.distinct.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppn4eabr2.scala:28:91\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlstOfListOfTuplesAndTuples\e\
    [0m = lstOfListOfTuples.zip(lstOfListOfTuples.dropRight(maxTuplesSize))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                          Found:    (maxTuplesSize : Long)\n\e[31m   |\e[0m \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- Error: /tmp/tmppn4eabr2.scala:30:86 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlstOfListOfTuplesAndTuplesSorted\e\
    [0m = lstOfListOfTuplesAndTuples.sortBy(_._1)\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\e[31m\
    \   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[List[Long]].\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m   |\e[0m\n2\
    \ errors found\n"
  stdout: ''
  timestamp: 1660010595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def swap(x: Long, y: Long,\
    \ list: List[List[Long]]) : List[List[Long]] = list match {\n            case\
    \ Nil => list\n            case _ =>\n                val temp = list(x)(y)\n\
    \                list(x)(y) = list(x)(y)\n                list(x)(y) = temp\n\
    \                list\n        }\n        val sortedLst = lst.sortBy(x => x(0))\n\
    \        val rowNr = sortedLst.map(x => x(0)).indexOf(x)\n        val colNr =\
    \ sortedLst.map(x => x(1)).indexOf(x)\n        val res = sortedLst match {\n \
    \           case Nil => Nil\n            case _ => swap(0, rowNr, sortedLst).map(x\
    \ => swap(1, colNr, x)).sorted\n        }\n        val reRow = res.map(_(0)).sorted\n\
    \        val reCol = res.map(_(1)).sorted\n        val finalRe = reRow ++ reCol\n\
    \        reRow\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn3z7ujqf.scala:23:32\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m\
    \ \e[36mtemp\e[0m = list(x)(y)\n\e[31m\e[31m   |\e[0m                        \
    \        ^\e[0m\n\e[31m   |\e[0m                                Found:    (x :\
    \ Long)\n\e[31m   |\e[0m                                Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn3z7ujqf.scala:23:35 --------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                \e[33mval\e[0m \e[36mtemp\e[0m = list(x)(y)\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                   Found:    (y : Long)\n\e[31m   |\e[0m    \
    \                               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpn3z7ujqf.scala:24:21 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                list(x)(y) = list(x)(y)\n\e[31m\e[31m\
    \   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     Found:\
    \    (x : Long)\n\e[31m   |\e[0m                     Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn3z7ujqf.scala:24:34 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                list(x)(y) = list(x)(y)\n\e[31m\e[31m\
    \   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m          \
    \                        Found:    (x : Long)\n\e[31m   |\e[0m               \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpn3z7ujqf.scala:24:37 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m                list(x)(y) = list(x)(y)\n\e[31m\e[31m   |\e[0m       \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \              Found:    (y : Long)\n\e[31m   |\e[0m                         \
    \            Required: Int\n\e["
  stdout: ''
  timestamp: 1660010597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val n = lst.length\n     \
    \   var i = 0\n        var j = 0\n        var k = lst(0)(0).toLong\n        var\
    \ temp = 0l\n        var ans = List[Tuple2[Long, Long]]()\n\n        while (i\
    \ < n) {\n            var minIndex = 0\n            var minRow = lst(i)\n    \
    \        var minCol = lst(0)(0)\n            var minVal = lst(0)(0)\n        \
    \    var maxIndex = 0\n            var maxRow = lst(n - 1)\n            var maxCol\
    \ = lst(n - 1)(0)\n            var maxVal = lst(n - 1)(0)\n\n            for (k\
    \ <- 0 until n) {\n                if (lst(k)(0).toLong < minVal) {\n        \
    \            minIndex = k\n                    minRow = lst(k)\n             \
    \       minCol = lst(0)(0)\n                    minVal = lst(0)(0)\n         \
    \       }\n                else if (lst(k)(0).toLong > maxVal) {\n           \
    \         maxIndex = k\n                    maxRow = lst(k)\n                \
    \    maxCol = lst(0)(0)\n                    maxVal = lst(0)(0)\n            \
    \    }\n            }\n\n            for (j <- 0 until n) {\n                if\
    \ (lst(j)(0).toLong < minVal) {\n                    minIndex = j\n          \
    \          minRow = lst(j)\n                    minCol = lst(0)(0)\n         \
    \           minVal = lst(0)(0)\n                }\n                else if (lst(j)(0).toLong\
    \ > maxVal) {\n                    maxIndex = j\n                    maxRow =\
    \ lst(j)\n                    maxCol = lst(0)(0)\n                    maxVal =\
    \ lst(0)(0)\n                }\n            }\n\n            if (minIndex == maxIndex)\
    \ {\n                var tmpCol = lst(0)(0)\n                var tmpVal = lst(0)(0)\n\
    \                for (k <- 0 until n) {\n                    if (lst(k)(0).toLong\
    \ < minVal) {\n                        minIndex = k\n                        minRow\
    \ = lst(k)\n                        minCol = lst(0)(0)\n                     \
    \   minVal = lst(0)(0)\n                    }\n                    else if (lst(k)(0).toLong\
    \ > maxVal) {\n                        maxIndex = k\n                        maxRow\
    \ = lst(k)\n                        maxCol = lst(0)(0)\n                     \
    \   maxVal = lst(0)(0)\n                    }\n                }\n\n         \
    \       for (j <- 0 until n) {\n                    if (lst(j)(0).toLong < minVal)\
    \ {\n                        minIndex = j\n                        minRow = lst(j)\n\
    \                        minCol = lst(0)(0)\n                        minVal =\
    \ lst(0)(0)\n                    }\n                    else if (lst(j)(0).toLong\
    \ > maxVal) {\n                        maxIndex = j\n                        maxRow\
    \ = lst(j)\n                        maxCol = lst(0)(0)\n                     \
    \   maxVal = lst\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv3v_t1n3.scala:108:0 ---------------------------\e\
    [0m\e[0m\n\e[31m108 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv3v_t1n3.scala:96:33\
    \ --------------------\e[0m\e[0m\n\e[31m96 |\e[0m                        maxVal\
    \ = lst\n\e[31m\e[31m   |\e[0m                                 ^^^\e[0m\n\e[31m\
    \   |\e[0m                                 Found:    (lst : List[List[Long]])\n\
    \e[31m   |\e[0m                                 Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [33m\e[33m-- Warning: /tmp/tmpv3v_t1n3.scala:98:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m98 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660010599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def toTuple(t: List[Long])\
    \ : Tuple2[Long, Long] = {\n            val r = t.sorted\n            val c =\
    \ t.reverse.sorted\n            (c.get(0), r.get(r.length - 1))\n        }\n\n\
    \        def getRows(t: List[Long], rows: List[Long], cols: List[Long]): List[Tuple2[Long,\
    \ Long]] = {\n            if (t.isEmpty) List(Tuple2(rows(0), cols(0)))\n    \
    \        else {\n                val r : List[Long] = t.get\n                val\
    \ c : List[Long] = t.reverse\n                if (c.length >= rows.length) getRows(t.tail,\
    \ rows.::(rows), cols.::(cols))\n                else if (r.length >= cols.length)\
    \ getRows(t, rows, cols.::(cols))\n                else getRows(t.tail, rows.::(rows),\
    \ cols.::(cols))\n            }\n        }\n\n        def getCols(t: List[Long],\
    \ rows: List[Long], cols: List[Long]): List[Tuple2[Long, Long]] = {\n        \
    \    if (t.isEmpty) List(Tuple2(cols(0), rows(0)))\n            else {\n     \
    \           val r : List[Long] = t.get\n                val c : List[Long] = t.reverse\n\
    \                if (r.length >= cols.length) getCols(t.tail, rows.::(rows), cols.::(cols))\n\
    \                else if (c.length >= rows.length) getCols(t, rows, cols.::(cols))\n\
    \                else getCols(t.tail, rows.::(rows), cols.::(cols))\n        \
    \    }\n        }\n\n        val rows = lst.flatMap { x => x.toList }\n      \
    \  val cols = lst.flatMap { x => x.reverse }\n        getRows(rows, rows, cols).flatMap\
    \ { x => toTuple(x) }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjizbl4o.scala:23:15 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (c.get(\e[31m0\e[0m), r.get(r.length - \e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m             ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \         value get is not a member of List[Long] - did you mean c.seq?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpqjizbl4o.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            (c.get(\e[31m0\e[0m), r.get(r.length - \e\
    [31m1\e[0m))\n\e[31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue get is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqjizbl4o.scala:29:39\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                \e[33mval\e\
    [0m \e[36mr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m] = t.get\n\e[31m\e[31m   |\e\
    [0m                                     ^^^^^\e[0m\n\e[31m   |\e[0mvalue get is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqjizbl4o.scala:31:69\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                \e[33mif\e[0m\
    \ (c.length >= rows.length) getRows(t.tail, rows.::(rows), cols.::(cols))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \           ^^^^\e[0m\n\e[31m   |\e[0m                                       \
    \    Found:    (rows : List[Long])\n\e[31m   |\e[0m                          \
    \                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available wh"
  stdout: ''
  timestamp: 1660010604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Solution below is O(n^2).\
    \ Solution below is O(n) by first sorting by columns in descending order\n   \
    \     val lst2 = lst.reverse\n        val lst3 = lst2.groupBy(x => x)\n      \
    \  val lst4 = lst3.toList\n        val lst5 = lst4.sortWith((a, b) => b._2 > a._2)\n\
    \        val lst6 = lst5.map(x => Tuple2(x._1, x)).map(x => (x._1, x._2)).sortBy(x\
    \ => x._1)\n        lst6.take(x)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprbw8cyu6.scala:24:48 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mlst5\e[0m = lst4.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => b._2 > a._2)\n\e[31m\e[31m   |\e[0m             \
    \                              ^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member\
    \ of List[List[Long]], but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmprbw8cyu6.scala:25:90 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mlst6\e[0m = lst5.map(\e\
    [36mx\e[0m => Tuple2(x._1, x)).map(\e[36mx\e[0m => (x._1, x._2)).sortBy(\e[36mx\e\
    [0m => x._1)\n\e[31m\e[31m   |\e[0m                                          \
    \                                                ^\e[0m\n\e[31m   |\e[0mNo implicit\
    \ Ordering defined for List[Long]..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mList[Long]\e[0m](\n\e[31m\
    \   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var rows : List[Tuple2[Long,\
    \ Long]] = List()\n        var cols : List[Long] = List()\n        var result\
    \ : List[Tuple2[Long, Long]] = List()\n        var currentRow : List[Long] = List()\n\
    \        var currentCol : List[Long] = List()\n        var flag : Boolean = false\n\
    \n        if (lst.isEmpty) {\n            rows = (List(xl.toLong, 0l))\n     \
    \   } else {\n            rows.head = (xl.toLong, 0l)\n        }\n\n        for(i\
    \ <- 0 until lst.size) {\n            currentRow.clear()\n            currentCol.clear()\n\
    \n            if (lst(i).size == 0) {\n                rows += (lst(i).head.toLong,\
    \ 0l)\n                currentRow += 0l\n                cols += 0l\n        \
    \    } else if (lst(i).head.toLong != 0) {\n                rows += (lst(i).head.toLong,\
    \ 0l)\n                currentRow += 0l\n                cols += 0l\n        \
    \        result += getRow(lst(i).tail, x)\n            } else {\n            \
    \    currentCol = lst(i).tail.distinct\n\n                if (lst(i).head.contains(x))\
    \ {\n                    flag = true\n                } else {\n             \
    \       for (j <- 0 until currentCol.size) {\n                        if (currentCol(j)\
    \ != 0l && currentCol(j) != (currentCol(j) - 1)) {\n                         \
    \   flag = true\n                            currentCol(j) = currentCol(j) - 1\n\
    \                            currentCol(j) = (currentCol(j) + 1).toLong\n    \
    \                        break\n                        }\n                  \
    \  }\n                }\n\n                if (flag) {\n                    currentRow\
    \ += currentCol.tail.distinct\n                    cols += currentCol.tail.distinct\n\
    \                    if (!rows.contains((currentRow, cols))) {\n             \
    \           rows += (currentRow, cols)\n                    }\n              \
    \  }\n            }\n        }\n\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0498k33t.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            rows = (List(xl.toLong, \e[31m0l\e[0m))\n\
    \e[31m\e[31m   |\e[0m                         ^^\e[0m\n\e[31m   |\e[0m       \
    \                  Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp0498k33t.scala:28:36 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            rows = (List(xl.toLong, \e[31m0l\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                    ^^\e[0m\n\e[31m   |\e[0m              \
    \                      Found:    (\e[31m0L\e[0m : Long)\n\e[31m   |\e[0m     \
    \                               Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0498k33t.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            rows.head = (xl.toLong, \e[31m0l\e[0m)\n\e\
    [31m\e[31m   |\e[0m                         ^^\e[0m\n\e[31m   |\e[0m         \
    \                Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp0498k33t.scala:34:23 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m            currentRow.clear()\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue clear is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\e\
    [31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0498k33t.scala:35:23\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            currentCol.clear()\n\
    \e[31m\e[3"
  stdout: ''
  timestamp: 1660010605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lstNew = lst.sortWith(_._2\
    \ < _._2)\n        val xRow = lstNew.indexOf(x)\n        val xCol = lst(newCols(lstNew,\
    \ xRow))\n        val row = lst(newRows(lstNew, xRow))\n        val lst2 = lstNew.map(_._1).zipWithIndex.sortBy(x\
    \ => x).map{\n            case (x, i) => Tuple2(xRow - i, xCol - i)\n        }\n\
    \        row :: lst2\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptxrtgm0v.scala:20:36 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlstNew\e[0m = lst.sortWith(_._2\
    \ < _._2)\n\e[31m\e[31m   |\e[0m                                  ^^^^\e[0m\n\e\
    [31m   |\e[0m                                  value _2 is not a member of List[Long]\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptxrtgm0v.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mxCol\e[0m = lst(newCols(lstNew,\
    \ xRow))\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                       Not found: newCols\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmptxrtgm0v.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mrow\e[0m = lst(newRows(lstNew,\
    \ xRow))\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Not found: newRows\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmptxrtgm0v.scala:24:32 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mlst2\e[0m = lstNew.map(_._1).zipWithIndex.sortBy(\e\
    [36mx\e[0m => x).map{\n\e[31m\e[31m   |\e[0m                              ^^^^\e\
    [0m\n\e[31m   |\e[0m                              value _1 is not a member of\
    \ List[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptxrtgm0v.scala:25:49\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mcase\e\
    [0m (x, i) => Tuple2(xRow - i, xCol - i)\n\e[31m\e[31m   |\e[0m              \
    \                              ^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of List[Long], but could be made available as an extension method.\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress towards\
    \ fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.I"
  stdout: ''
  timestamp: 1660010604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val res = new mutable.LinkedList[Tuple2[Long,\
    \ Long]]()\n        val m = lst.size\n        for(i <- 0 until m) {\n        \
    \    if(lst(i).size == 0) {\n                if(!res.contains(Tuple2(i, x))) res.add(Tuple2(i,\
    \ x))\n                else\n                    res.remove(Tuple2(i, x))\n  \
    \          }\n            else {\n                val rows = lst(i)\n        \
    \        val cols = rows.tail\n                val maxR = rows.max\n         \
    \       val maxC = cols.max\n                val r = if (maxR > x) maxR else x\n\
    \                val c = if (maxC > x) maxC else x\n                for(j <- 0\
    \ until cols.size) {\n                    if(!res.contains(Tuple2(i, j))) res.add(Tuple2(i,\
    \ j))\n                    else if(!res.contains(Tuple2(i + m, j + m))) res.add(Tuple2(i\
    \ + m, j + m))\n                    else if(!res.contains(Tuple2(i, j + m))) res.add(Tuple2(i,\
    \ j + m))\n                }\n            }\n        }\n        res\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjb4ejjp7.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mres\e[0m = \e[33mnew\e[0m\
    \ mutable.LinkedList[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\e\
    [31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst match {\n            case\
    \ Nil => ((0 to x.toInt).map(x => (x, 0l)), Nil)\n            case _ => lst.sortWith(_.length).flatMap\
    \ { row =>\n                (0 to x.toInt).map { i =>\n                    (i\
    \ to (row.length - 1).toInt).map(j => (j, row.map(x => x.toLong).sum))\n     \
    \           }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp068ne_ze.scala:21:24\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            \e[33mcase\e[0m Nil\
    \ => ((\e[31m0\e[0m to x.toInt).map(x => (x, \e[31m0l\e[0m)), Nil)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mFound:    (IndexedSeq[(Int, Long)], scala.collection.immutable.Nil.type)\n\
    \e[31m   |\e[0mRequired: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmp068ne_ze.scala:22:35 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m _ => lst.sortWith(_.length).flatMap\
    \ { row =>\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp068ne_ze.scala:24:53\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                    (i to (row.length\
    \ - \e[31m1\e[0m).toInt).map(\e[36mj\e[0m => (j, row.map(\e[36mx\e[0m => x.toLong).sum))\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    IndexedSeq[(Int, Long)]\n\e\
    [31m   |\e[0m                    Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val coordinates = lst.map(row\
    \ => row.map(_ -> 0l).toList).flatten.toList\n        val coordinatePairs = coordinates.map(c\
    \ => c.zipWithIndex).toList.sortBy(_._1).map(x => (x._2, x._1)).map(x => x._2)\n\
    \        val coordinatePairsReverse = coordinatePairs.reverse\n        val coordinatePairsByRow\
    \ = coordinatePairs.map(x => (x._1, x._2)).groupBy(x => x._1)\n        val coordinatePairsByRowReverse\
    \ = coordinatePairsByRow.reverse\n        val rowCoordinate : Map[Long, Long]\
    \ = coordinatePairsByRowReverse.filter(_._1 == x).toList.maxBy(_._2)._2._2._1.toLong\n\
    \        val columnCoordinate : Long = coordinatePairsReverse.filter(_._2 == rowCoordinate).toList.maxBy(_._1)._1\n\
    \        val coordinates : List[Tuple2[Long, Long]] = coordinatePairsByRowReverse.filter(_._1\
    \ == rowCoordinate).sortBy(_._1).map(x => (x._2, x._1))\n        val coordinatesReverse:\
    \ List[Tuple2[Long, Long]] = coordinates.map(x => (x._2, x._1))\n        val coordinatesReverseByRow\
    \ : List[Tuple2[Long, Long]] = coordinatesReverse.groupBy(_._1).filter(_._1 ==\
    \ rowCoordinate)\n        val coordinatesReverseByRowReverse: List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRow.reverse\n        val coordinatesReverseByRowReverseByColumn\
    \ : List[Tuple2[Long, Long]] = coordinatesReverseByRowReverse.groupBy(_._2)\n\
    \        val coordinatesReverseByRowReverseByColumnReverse: List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRowReverseByColumn.reverse\n        val coordinatesReverseByRowReverseByColumnReverseByRow\
    \ : List[Tuple2[Long, Long]] = coordinatesReverseByRowReverseByColumnReverse.groupBy(_._1)\n\
    \        val coordinatesReverseByRowReverseByColumnReverseByRowReverse: List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRowReverseByColumnReverseByRow.reverse\n      \
    \  val coordinatesReverseByRowReverseByColumnReverseByRowReverseByColumn : List[Tuple2[Long,\
    \ Long]] = coordinatesReverseByRowReverseByColumnReverseByRowReverse.groupBy(_._2)\n\
    \        val coordinatesReverseByRowReverseByColumnReverseByRowReverseByColumnReverse:\
    \ List[Tuple2[Long, Long]] = coordinatesReverseByRowReverseByColumnReverseByRowReverseByColumnReverse.sortBy(_._1).map(x\
    \ => (x._2, x._1))\n        val coordinatesReverseByRowReverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpynqpq8l6.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpynqpq8l6.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcoordinates\e[0m : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m,\
    \ \e[35mLong\e[0m]] = coordinatePairsByRowReverse.filter(_._1 == rowCoordinate).sortBy(_._1).map(\e\
    [36mx\e[0m => (x._2, x._1))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcoordinates is already defined as \e[33mvalue\e[0m \e[35mcoordinates\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpynqpq8l6.scala:21:53 ------------------------\e[0m\e[0m\n\
    \e[31m21 |\e[0m        \e[33mval\e[0m \e[36mcoordinatePairs\e[0m = coordinates.map(\e\
    [36mc\e[0m => c.zipWithIndex).toList.sortBy(_._1).map(\e[36mx\e[0m => (x._2, x._1)).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value\
    \ zipWithIndex is not a member of (Long, Long)\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpynqpq8l6.scala:21:83 ------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mcoordinatePairs\e[0m = coordinates.map(\e\
    [36mc\e[0m => c.zipWithIndex).toList.sortBy(_._1).map(\e[36mx\e[0m => (x._2, x._1)).map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m                                   \
    \                                              ^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                 value _1 is not a member of Nothing\n\e[31m\e\
    [31m-- Error: /tmp/tmpynqpq8l6.scala:21:86 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mcoordinatePairs\e[0m = coordinates.map(\e\
    [36mc\e[0m => c.zipWithIndex).toList.sortBy(_._1).map(\e[3"
  stdout: ''
  timestamp: 1660010607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.head\n       \
    \ val n = lst.tail.length\n        val l = lst.map(c => getColumn(c.map(m %/%\
    \ x), n))\n        l.toList.sortWith(_._1 > _._1).map(x => (x._1, x._2))\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnqwdmzea.scala:22:29 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36ml\e[0m = lst.map(\e[36mc\e\
    [0m => getColumn(c.map(m %/% x), n))\n\e[31m\e[31m   |\e[0m                  \
    \           ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ getColumn\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnqwdmzea.scala:22:47\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36ml\e[0m = lst.map(\e[36mc\e[0m => getColumn(c.map(m %/% x), n))\n\e[31m\e[31m\
    \   |\e[0m                                             ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 value %/% is not a member of List[Long]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpnqwdmzea.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        l.toList.sortWith(_._1 > _._1).map(\e[36mx\e\
    [0m => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                          ^^^^\e[0m\n\
    \e[31m   |\e[0m                          value _1 is not a member of Nothing\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnqwdmzea.scala:23:51 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        l.toList.sortWith(_._1 > _._1).map(\e[36mx\e\
    [0m => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                                  \
    \               ^^^^\e[0m\n\e[31m   |\e[0mvalue _1 is not a member of Nothing,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import concurrent.duration.durationToPair\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpnqwdmzea.scala:23:57 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        l.toList.sortWith(_._1 > _._1).map(\e[36mx\e\
    [0m => (x._1, x._2))\n\e[31m\e[31m   |\e[0m                                  \
    \                     ^^^^\e[0m\n\e[31m   |\e[0mvalue _2 is not a member of Nothing,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mThe following import might fix the problem:\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1660010605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst == Nil) Nil\n    \
    \    else {\n            val m = lst.head\n            val m = m.reverse.take(x)\n\
    \            lst.tail.foldLeft(List[Tuple2[Long, Long]](Nil)) { (x, y) =>\n  \
    \              val ym = y.reverse.take(x)\n                if (ym == Nil) x ::\
    \ x\n                else {\n                    val c = ym.size\n           \
    \         x :: Tuple2(ym.head.head + x * (c - 1l), ym.head.tail + (c - 1l))\n\
    \                }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7c30hp_q.scala:23:16 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mm\e[0m = m.reverse.take(x)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7c30hp_q.scala:24:55\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            lst.tail.foldLeft(List[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]](Nil)) { (\e[36mx\e[0m, \e[36my\e\
    [0m) =>\n\e[31m\e[31m   |\e[0m                                               \
    \        ^^^\e[0m\n\e[31m   |\e[0m                                 Found:    collection.immutable.Nil.type\n\
    \e[31m   |\e[0m                                 Required: (Long, Long)\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7c30hp_q.scala:25:40 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mym\e[0m = y.reverse.take(x)\n\
    \e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m  \
    \ |\e[0m                                      Found:    (x : List[(Long, Long)])\n\
    \e[31m   |\e[0m                                      Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7c30hp_q.scala:26:31 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mif\e[0m (ym == Nil) x :: x\n\e\
    [31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m    \
    \                           Found:    (\e[1m\e[31mx\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31m:\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31m(\e\
    [0mLong, Long\e[1m\e[31m)\e[0m\e[1m\e[31m]\e[0m)\n\e[31m   |\e[0m            \
    \                   Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tm"
  stdout: ''
  timestamp: 1660010606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Your code here\n      \
    \  val row = lst\n        val len = row.size\n        var row = lst\n        var\
    \ column = row\n        var ans = List[Tuple2[Long, Long]]()\n        for (i <-\
    \ 0 until len) {\n            if (row(i).contains(x)) {\n                ans =\
    \ ans ::: (Tuple2(x-row(i), i))\n                row = row.drop(i)\n         \
    \       column = column.drop(i)\n                break\n            }\n      \
    \  }\n        if (row.nonEmpty) {\n            ans = ans ::: (getRow(row, x))\n\
    \        }\n        if (column.nonEmpty) {\n            ans = ans ::: (getRow(column,\
    \ x))\n        }\n        return ans\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzgkhlta4.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e[36mrow\e[0m = lst\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrow is already defined\
    \ as \e[33mvalue\e[0m \e[35mrow\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmpzgkhlta4.scala:28:39 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                ans = ans ::: (Tuple2(x-row(i), i))\n\
    \e[31m\e[31m   |\e[0m                                      ^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short):\
    \ Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments (List[Long])\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpzgkhlta4.scala:29:20 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                row = row.drop(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val row\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzgkhlta4.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.size==0) return List[Tuple2[Long,\
    \ Long]]()\n        val rowLst = lst.sortWith(_ > _)\n        val columnLst =\
    \ rowLst.sortWith(_ < _.reverse)\n        val l1 = columnLst.size\n        val\
    \ l2 = rowLst.size\n        val rows = ListBuffer[Tuple2[Long, Long]]()\n    \
    \    for(i <- 0 to (l1-1)) {\n            for(j <- 0 to (l2-1)) {\n          \
    \      val res = rowLst(i)(j) == x\n                if(res){\n               \
    \     rows ++= List(Tuple2(i+1, j+1))\n                }\n            }\n    \
    \    }\n        rows.toList.sortBy(_._1).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn1w828sc.scala:21:36 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrowLst\e[0m = lst.sortWith(_\
    \ > _)\n\e[31m\e[31m   |\e[0m                                  ^^^\e[0m\n\e[31m\
    \   |\e[0mvalue > is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn1w828sc.scala:22:42\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mcolumnLst\e[0m = rowLst.sortWith(_ < _.reverse)\n\e[31m\e[31m   |\e[0m   \
    \                                     ^^^\e[0m\n\e[31m   |\e[0mvalue < is not\
    \ a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010609
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(row =>\
    \ Tuple2(row(0), row.length)) // Rows starting with index 0 are sorted by columns\n\
    \        val columnSort = rows.sortBy(r => (-r._1, r._2)) // Sorts columns in\
    \ descending order\n        val sortRowSort = columnSort.sortBy(r => (-r._2, r._1))\
    \ // Sorts rows by columns in descending order\n        val result = sortRowSort.filter(r\
    \ => r._1 == x) // Filters rows that contain given number\n        result.map(p\
    \ => p._2 -> p._1).sortBy(r => (-r._1, r._2)) // Sorts coordinates by rows in\
    \ ascending order and by columns in descending order\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpays0pwpr.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        result.map(\e[36mp\e\
    [0m => p._2 -> p._1).sortBy(\e[36mr\e[0m => (-r._1, r._2)) \e[34m// Sorts coordinates\
    \ by rows in ascending order and by columns in descending order\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[(\e[1m\e[31mInt\e[0m, Long)]\n\e[31m\
    \   |\e[0m        Required: List[(\e[1m\e[32mLong\e[0m, Long)]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lst2 = lst.sortBy(l =>\
    \ l)\n        val lst3 = lst2.sortBy(l => l)\n        val lst4 = lst3.sortBy(l\
    \ => l)\n        val lst5 = lst4.sortBy(l => l)\n        lst5.find(l => l._2 ==\
    \ x).toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpe0tei9p5.scala:20:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mlst2\e[0m = lst.sortBy(\e\
    [36ml\e[0m => l)\n\e[31m\e[31m   |\e[0m                                     ^\e\
    [0m\n\e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\e[31m   |\e\
    [0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e\
    [35mList[Long]\e[0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val (rs, cs, rt) = (lst.map(a\
    \ => a.indexOf(x)), lst.map(_.indexOf(x)), lst.indexOf(x))\n        val rts =\
    \ if (rt == 0) 0 else 1\n        val rtc = if (rts == 0) 0 else rts.toInt\n  \
    \      val rtl = if (rtc == 0) 0 else rtc.toInt\n        val rtd = if (rtl ==\
    \ 0) 0 else rtl.toInt\n        val rc = if (rs == 0) 0 else rs.toInt\n       \
    \ val rl = if (rc == 0) 0 else rc.toInt\n        val rr = if (rl == 0) 0 else\
    \ rl.toInt\n        (0 until rl).map((i, x) => Tuple2(x * i.toInt, x * i.toInt\
    \ + rtd.toInt))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp22led7no.scala:25:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mrc\e[0m = \e[33mif\e[0m\
    \ (rs == \e[31m0\e[0m) \e[31m0\e[0m \e[33melse\e[0m rs.toInt\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      Values of types List[Int]\
    \ and Int cannot be compared with == or !=\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp22led7no.scala:25:40 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mrc\e[0m = \e[33mif\e[0m (rs == \e[31m0\e[0m) \e\
    [31m0\e[0m \e[33melse\e[0m rs.toInt\n\e[31m\e[31m   |\e[0m                   \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toInt is not a member of\
    \ List[Int], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E086] Syntax Error: /tmp/tmp22led7no.scala:28:32 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        (\e[31m0\e[0m until rl).map((\e[36mi\e[0m, \e\
    [36mx\e[0m) => Tuple2(x * i.toInt, x * i.toInt + rtd.toInt))\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Wrong number of parameters, expected:\
    \ 1\n3 errors found\n"
  stdout: ''
  timestamp: 1660010608
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.sortBy(_.toLong).map(row\
    \ => (row.indexOf(x), row.lastIndexOf(x)) )\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm3n5xyl5.scala:20:21 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        lst.sortBy(_.toLong).map(\e[36mrow\e[0m => (row.indexOf(x),\
    \ row.lastIndexOf(x)) )\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpm3n5xyl5.scala:20:28 -----------------------------------------\e[0m\e\
    [0m\n\e[31m20 |\e[0m        lst.sortBy(_.toLong).map(\e[36mrow\e[0m => (row.indexOf(x),\
    \ row.lastIndexOf(x)) )\n\e[31m\e[31m   |\e[0m                            ^\e\
    [0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mByte\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010609
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n      lst.map(l => l.map(i => Tuple2(x,\
    \ i)))\n          .sortWith(_.first < _.first)\n          .sortBy(_.first < _.first.reverse)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpln9c80tj.scala:21:22 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m          .sortWith(_.first < _.first)\n\e[31m\e[31m\
    \   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue first is not\
    \ a member of List[(Long, Long)] - did you mean _$1.find?\n\e[31m\e[31m-- [E086]\
    \ Syntax Error: /tmp/tmpln9c80tj.scala:22:18 ---------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m          .sortBy(_.first < _.first.reverse)\n\e[31m\e[31m\
    \   |\e[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                Wrong number of parameters, expected: 1\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpln9c80tj.scala:22:44 -----------------------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m          .sortBy(_.first < _.first.reverse)\n\e[31m\e[31m\
    \   |\e[0m                                            ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010609
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def sortCoords(lst: List[List[Long]],\
    \ startIndex: Int = 0) : List[List[Long]] = {\n            val rowIndex = startIndex\n\
    \            val listIndex = startIndex\n            val rows = lst.size\n   \
    \         val cols = lst(rowIndex).size\n            val coords = List[List[Long]](List(startIndex))\n\
    \            for {\n                row <- 0 until rows\n                col <-\
    \ 0 until cols\n            } yield {\n                if (row == rowIndex)\n\
    \                    coords = lst(rowIndex)\n                else if (col == listIndex)\n\
    \                    coords = lst(row)\n                else\n               \
    \     coords = sortCoords(lst, rowIndex)\n                coords.map(_ -> col)\n\
    \            }\n        }\n        if (lst.isEmpty)\n            List[Tuple2[Long,\
    \ Long]]()\n        else\n            sortCoords(lst).map(_ -> x)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmrd00nn7.scala:31:32\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m                    coords =\
    \ lst(rowIndex)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Found:    List[Long]\n\e[31m\
    \   |\e[0m                             Required: List[\e[1m\e[32mList\e[0m\e[1m\e\
    [32m[\e[0mLong\e[1m\e[32m]\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpmrd00nn7.scala:33:32 --------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                    coords = lst(row)\n\e[31m\e[31m   |\e[0m         \
    \                    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \   Found:    List[Long]\n\e[31m   |\e[0m                             Required:\
    \ List[\e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpmrd00nn7.scala:35:27 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    coords = sortCoords(lst, rowIndex)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val coords\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmrd00nn7.scala:42:32 --------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            sortCoords(lst).map(_ -> x)\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                         Found:    (\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e\
    [1m\e[31m]\e[0m, Long)\n\e[31m   |\e[0m                                Required:\
    \ (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010610
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var row = (0.to(lst.size).reverse.map(i\
    \ => (i, 0)))\n        val lst2 = lst.map(xs => xs.filter(x=> x == x))\n     \
    \   lst2.foreach { x => row = row.map{ x => (x._1, x._2 - 1) }}\n        lst.sortWith((x,\
    \ y) => x._1 < y._1 && x._1 < y._2) // sort by first col\n        lst.sortWith((x,\
    \ y) => x._1 < y._1 && x._2 < y._1) // sort by second col\n        lst.sortWith((x,\
    \ y) => x._1 < y._1 && x._2 < y._2) // sort by first col\n        row\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn5y82d59.scala:23:33 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        lst.sortWith((\e[36mx\e[0m, \e[36my\e[0m) =>\
    \ x._1 < y._1 && x._1 < y._2) \e[34m// sort by first col\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                               ^^^^\e[0m\n\e[31m   |\e[0m            \
    \                   value _1 is not a member of List[Long]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpn5y82d59.scala:24:33 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        lst.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x._1\
    \ < y._1 && x._2 < y._1) \e[34m// sort by second col\e[0m\n\e[31m\e[31m   |\e\
    [0m                               ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value _1 is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpn5y82d59.scala:25:33 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m        lst.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x._1 < y._1\
    \ && x._2 < y._2) \e[34m// sort by first col\e[0m\n\e[31m\e[31m   |\e[0m     \
    \                          ^^^^\e[0m\n\e[31m   |\e[0m                        \
    \       value _1 is not a member of List[Long]\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpn5y82d59.scala:26:8 ---------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        row\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m  \
    \      Found:    (row : IndexedSeq[(Int, Int)])\n\e[31m   |\e[0m        Required:\
    \ List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result: List[Tuple2[Long,\
    \ Long]] = new ListBuffer[Tuple2[Long, Long]]\n        val matrix: mutable.Map[Long,\
    \ Long] = mutable.Map()\n\n        for (i <- 0 until lst.size) {\n           \
    \ for (j <- 0 until lst(i).size) {\n                if (lst(i)(j) == x) {\n  \
    \                  matrix(i) = matrix(i) + 1\n                    result.add(Tuple2(i,\
    \ matrix(i)))\n                }\n            }\n        }\n\n        val maxCol\
    \ = matrix.values.toList.max\n        val result = result.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \        result.map { case (x, y) => (x - maxCol, y) }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi0jb6bbd.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpi0jb6bbd.scala:20:47 --------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mTuple2\e\
    [0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    scala.collection.mutable.ListBuffer[(Long,\
    \ Long)]\n\e[31m   |\e[0m             Required: List[(Long, Long)]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi0jb6bbd.scala:21:20 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmatrix\e[0m: mutable.Map[\e\
    [35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map()\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi0jb6bbd.scala:21:46\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mmatrix\e[0m: mutable.Map[\e[35mLong\e[0m, \e[35mLong\e[0m] = mutable.Map()\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                              Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpi0jb6bbd.scala:27:27\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1660010611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getFirstIndex(lst : List[Long],\
    \ x : Long) : Long = {\n            val index = lst.indexWhere(_ == x)\n     \
    \       if(index == -1l) return -1l\n            lst(index).toLong\n        }\n\
    \n        def getLastIndex(lst : List[Long], x : Long) : Long = {\n          \
    \  val index = lst.indexWhere(_ == x)\n            if(index == -1l) return -1l\n\
    \            lst(index - 1l).toLong\n        }\n\n        // Find row index\n\
    \        val firstIndex = getFirstIndex(lst(x), x)\n        val lastIndex = getLastIndex(lst(x),\
    \ x)\n        val rowTuple = new scala.collection.mutable.LinkedList[Tuple2[Long,\
    \ Long]]\n        while(firstIndex != -1l && lastIndex != -1l) {\n           \
    \ rowTuple.add(new scala.Tuple2[Long, Long](firstIndex, lastIndex))\n        \
    \    firstIndex = getFirstIndex(lst(firstIndex), firstIndex)\n            lastIndex\
    \ = getLastIndex(lst(lastIndex), lastIndex)\n        }\n        if(firstIndex\
    \ == -1l || lastIndex == -1l) rowTuple.clear()\n        rowTuple.toList.reverse.sortWith(_._1\
    \ < _._1).map { case (row, col) => new scala.Tuple2[Long, Long](row, col) }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpccbe3b3p.scala:29:16\
    \ --------------------\e[0m\e[0m\n\e[31m29 |\e[0m            lst(index - \e[31m1l\e\
    [0m).toLong\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                Found:    Long\n\e[31m   |\e[0m                Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpccbe3b3p.scala:33:43\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mfirstIndex\e\
    [0m = getFirstIndex(lst(x), x)\n\e[31m\e[31m   |\e[0m                        \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \         Found:    (x : Long)\n\e[31m   |\e[0m                              \
    \             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpccbe3b3p.scala:34:41 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mlastIndex\e[0m = getLastIndex(lst(x), x)\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                         Found:    (x : Long)\n\e[31m\
    \   |\e[0m                                         Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpccbe3b3p.scala:35:52 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mrowTuple\e[0m = \e[33mnew\e\
    [0m scala.collection.mutable.LinkedList[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             type LinkedList is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpccbe3b3p.scala:38:43 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            firstIndex = getFirstIndex(lst(firstIndex),\
    \ firstIndex)\n\e[31m\e[31m   |\e[0m                                         \
    \  ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       "
  stdout: ''
  timestamp: 1660010611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map(lst =>\
    \ (lst, lst.indexOf(x)))\n        rows.sortBy(_._1.indexOf(x)).map(_._1) :+ rows.map(_.indexOf(x)).max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuck7iwj7.scala:21:61 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        rows.sortBy(_._1.indexOf(x)).map(_._1) :+ rows.map(_.indexOf(x)).max\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value indexOf is not\
    \ a member of (List[Long], Int)\n\e[31m\e[31m-- Error: /tmp/tmpuck7iwj7.scala:21:76\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \ rows.sortBy(_._1.indexOf(x)).map(_._1) :+ rows.map(_.indexOf(x)).max\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \            ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e\
    [35mIterableOnceOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Code here\n        if(lst.isEmpty){\n\
    \            return Nil\n        }\n        val lstOfLists = lst.map(_.toList)\n\
    \        val lstOfTuples = lstOfLists.map(xlst => xlst.map(x => Tuple2(x, xlst(0))))\n\
    \        val lstOfTuplesAndOrderedList = lstOfTuples.map(x => x._1 -> x._2).sortBy(x\
    \ => x._1).reverse.sortBy(x => x._2).reverse\n        lstOfTuplesAndOrderedList.filter(x\
    \ => x._1 == x).map(x => Tuple2(x._2, x._1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpny6fh6l7.scala:26:63 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlstOfTuplesAndOrderedList\e\
    [0m = lstOfTuples.map(\e[36mx\e[0m => x._1 -> x._2).sortBy(\e[36mx\e[0m => x._1).reverse.sortBy(\e\
    [36mx\e[0m => x._2).reverse\n\e[31m\e[31m   |\e[0m                           \
    \                                  ^^^^\e[0m\n\e[31m   |\e[0m                \
    \          value _1 is not a member of List[(Long, Long)]\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpny6fh6l7.scala:26:89 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlstOfTuplesAndOrderedList\e[0m\
    \ = lstOfTuples.map(\e[36mx\e[0m => x._1 -> x._2).sortBy(\e[36mx\e[0m => x._1).reverse.sortBy(\e\
    [36mx\e[0m => x._2).reverse\n\e[31m\e[31m   |\e[0m                           \
    \                                                            ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     value _1 is not a member of Nothing\n\
    \e[31m\e[31m-- Error: /tmp/tmpny6fh6l7.scala:26:92 -----------------------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlstOfTuplesAndOrderedList\e\
    [0m = lstOfTuples.map(\e[36mx\e[0m => x._1 -> x._2).sortBy(\e[36mx\e[0m => x._1).reverse.sortBy(\e\
    [36mx\e[0m => x._2).reverse\n\e[31m\e[31m   |\e[0m                           \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mString\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val res = new collection.mutable.ArrayBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.size) {\n            val xs = lst(i)\n\
    \            val y = xs(x).toLong\n            if (y > 0)\n                res.push(Tuple2(i,\
    \ y))\n        }\n        res.sortBy(r => (r.t._1, r.t._2))\n        res.sortWith((a,\
    \ b) => b._1 < a._1)\n        res.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyb7pw5ta.scala:23:23\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e\
    [36my\e[0m = xs(x).toLong\n\e[31m\e[31m   |\e[0m                       ^\e[0m\n\
    \e[31m   |\e[0m                       Found:    (x : Long)\n\e[31m   |\e[0m  \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpyb7pw5ta.scala:25:20 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                res.push(Tuple2(i, y))\n\e[31m\e[31m   |\e[0m             \
    \   ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue push is not a member of scala.collection.mutable.ArrayBuffer[(Long,\
    \ Long)] - did you mean res.last?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyb7pw5ta.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        res.sortBy(\e[36mr\e\
    [0m => (r.t._1, r.t._2))\n\e[31m\e[31m   |\e[0m                         ^^^\e\
    [0m\n\e[31m   |\e[0m                         value t is not a member of (Long,\
    \ Long)\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyb7pw5ta.scala:27:35 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        res.sortBy(\e[36mr\e[0m => (r.t._1, r.t._2))\n\
    \e[31m\e[31m   |\e[0m                                 ^^^\e[0m\n\e[31m   |\e[0m\
    \                                 value t is not a member of (Long, Long)\n\e\
    [31m\e[31m-- Error: /tmp/tmpyb7pw5ta.scala:27:41 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        res.sortBy(\e[36mr\e[0m => (r.t._1, r.t._2))\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0mambiguous given instances of type Ordering[(T1, T2)] found for parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m.\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.Tuple2[\e\
    [35mT1\e[0m, \e[35mT2\e[0m](\n\e[31m   |\e[0m      /* ambiguous: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[T1]\
    \ */\n\e[31m   |\e[0m        summon["
  stdout: ''
  timestamp: 1660010616
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rowNum = lst.foldLeft[List[Long]](List[Long]()){\
    \ (res, elem) =>\n            if (elem.isEmpty) res else res.head :: elem.head\n\
    \        }\n        val colNum = lst.get(rowNum.last).foldLeft[List[Long]](List[Long]()){\
    \ (res, elem) =>\n            if (elem.isEmpty) res else elem ::: res.last\n \
    \       }\n        lst.map{row =>\n            val sortedRow = row.sortWith((x,\
    \ y) => y < x)\n            (sortedRow.take(colNum.last), sortedRow.drop(colNum.last).take(rowNum.last))\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_jmno7dg.scala:21:48 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (elem.isEmpty) res \e[33melse\e\
    [0m res.head :: elem.head\n\e[31m\e[31m   |\e[0m                             \
    \                   ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                 value :: is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp_jmno7dg.scala:23:25 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcolNum\e[0m = lst.get(rowNum.last).foldLeft[\e\
    [35mList\e[0m[\e[35mLong\e[0m]](List[\e[35mLong\e[0m]()){ (\e[36mres\e[0m, \e\
    [36melem\e[0m) =>\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue get is not a member of List[List[Long]], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import collection.convert.ImplicitConversions.seq AsJavaList\n\e[31m   |\e[0m\
    \  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\e[31m\
    \   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_jmno7dg.scala:28:27\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            (sortedRow.take(colNum.last),\
    \ sortedRow.drop(colNum.last).take(rowNum.last))\n\e[31m\e[31m   |\e[0m      \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found: \
    \   \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m\
    \             Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp_jmno7dg.scala:28:82 --------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            (sortedRow.take(colNum.last), sortedRow.drop(colNum.last).take(rowNum.last))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                                  Found:    Long\n\e[31m   |\e[0m           \
    \                                               Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m long"
  stdout: ''
  timestamp: 1660010613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = new mutable.LinkedHashMap[Long,\
    \ Long]\n        lst.map{row =>\n            var n = 0\n            for(i <- 0\
    \ until row.length){\n                val e = m.getOrElseUpdate(row(i), 0l)\n\
    \                m.put(row(i), e+1l)\n                n += e\n            }\n\
    \        }\n        val res = m.toList.sortBy(_._1).sortByDescending(_._2)\n \
    \       if(res.size == 0) res\n        else{\n            val r = res(0)\n   \
    \         val c = res(res.length-1)\n            val xx = r._2\n            val\
    \ yy = r._1\n            val newX = xx + x\n            val newY = yy + x\n  \
    \          if((newY < yy) || (newX < xx))\n                getRow(lst, newY)\n\
    \            else res\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpklh5q9kr.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ mutable.LinkedHashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.flatten.zipWithIndex\n\
    \        val rows = rows.filter(r => r._1 == x).sortBy(_._1).reverse\n       \
    \ val cols = rows.map(_.toList).flatten.zipWithIndex\n        val cols = cols.filter(r\
    \ => r._1 == x).sortBy(_._1).reverse\n        rows.map(row => (row._2, row._1)).sortBy(_._1).reverse.zip(cols.map(col\
    \ => (col._2, col._1))).map(t => (t._2, t._1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp901qh9pd.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = rows.filter(\e\
    [36mr\e[0m => r._1 == x).sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrows is already defined as \e[33mvalue\e[0m \e[35mrows\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp901qh9pd.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mcols\e[0m = cols.filter(\e[36mr\e[0m => r._1\
    \ == x).sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcols is already defined as \e[33mvalue\e[0m \e[35mcols\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp901qh9pd.scala:24:114 -------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        rows.map(\e[36mrow\e[0m => (row._2, row._1)).sortBy(_._1).reverse.zip(cols.map(\e\
    [36mcol\e[0m => (col._2, col._1))).map(\e[36mt\e[0m => (t._2, t._1))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                ^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                           Found:    (Int, Long | Int)\n\e[31m\
    \   |\e[0m                                             Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp901qh9pd.scala:24:120 -------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        rows.map(\e[36mrow\e[0m => (row._2, row._1)).sortBy(_._1).reverse.zip(cols.map(\e\
    [36mcol\e[0m => (col._2, col._1))).map(\e[36mt\e[0m => (t._2, t._1))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                      ^^^^\e[0m\n\e[31m   |\e\
    [0m        "
  stdout: ''
  timestamp: 1660010617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lst_row_indexed = lst.map(i\
    \ => i.zipWithIndex.toList)\n        val lst_column_indexed = lst_row_indexed.map(i\
    \ => i.map(j => j._2))\n        val rows = lst_row_indexed.map(i => i._2)\n  \
    \      val columns = lst_column_indexed.map(i => i._2)\n        val x_index =\
    \ columns.indexOf(x)\n        if (x_index == -1) {\n            List[Tuple2[Long,\
    \ Long]]()\n        } else {\n            val row = rows.find(_.toLong == x_index)\n\
    \            val row_tuple = List(Tuple2(row._1, row._2))\n            row_tuple.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppa014g2x.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = lst_row_indexed.map(\e\
    [36mi\e[0m => i._2)\n\e[31m\e[31m   |\e[0m                                   \
    \         ^^^^\e[0m\n\e[31m   |\e[0m                           value _2 is not\
    \ a member of List[(Long, Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppa014g2x.scala:23:52\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcolumns\e[0m = lst_column_indexed.map(\e[36mi\e[0m => i._2)\n\e[31m\e[31m\
    \   |\e[0m                                                  ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   value _2 is not a member of List[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppa014g2x.scala:28:34 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mrow\e[0m = rows.find(_.toLong\
    \ == x_index)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of Nothing, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e\
    [0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e\
    [0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\e[31m\
    \   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\e\
    [31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppa014g2x.scala:29:44\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m\
    \ \e[36mrow_tuple\e[0m = List(Tuple2(row._1, row._2))\n\e[31m\e[31m   |\e[0m \
    \                                       ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                    value _1 is not a member of Option[Nothing]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmppa014g2x.scala:29:52 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36"
  stdout: ''
  timestamp: 1660010620
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lst0 = lst.head\n    \
    \    val lst1 = lst.tail\n        val lst2 = lst0.map( x => x :: lst1 )\n    \
    \    val lst3 = lst2.sortWith( x => x.reverse )\n        lst3.map( x => (x.head,\
    \ x.last) )\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpg5n4utl9.scala:23:36 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mlst3\e[0m = lst2.sortWith(\
    \ \e[36mx\e[0m => x.reverse )\n\e[31m\e[31m   |\e[0m                         \
    \         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \  Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpg5n4utl9.scala:24:26 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        lst3.map( \e[36mx\e[0m => (x.head, x.last) )\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \  Found:    Matchable\n\e[31m   |\e[0m                        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg5n4utl9.scala:24:34\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        lst3.map( \e[36mx\e[0m\
    \ => (x.head, x.last) )\n\e[31m\e[31m   |\e[0m                               \
    \ ^^^^^^\e[0m\n\e[31m   |\e[0m                                Found:    Matchable\n\
    \e[31m   |\e[0m                                Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010619
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) Nil\n   \
    \     else {\n            val lst1 = lst.flatten\n            if (lst1.isEmpty)\
    \ Nil\n            else lst1.map(row => (row, x)).sortBy(_._1).reverse.sortBy(_._2)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7u526fsb.scala:28)\n\tat Problem.main(tmp7u526fsb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Write your code here\n\
    \        if (lst.isEmpty) {\n            List[Tuple2[Long, Long]]()\n        }\
    \ else {\n            val mn = lst.head\n            val mx = lst.last\n     \
    \       val r = x / (mx - mn)\n            val l = (mx + mn) / (mx - mn)\n   \
    \         val i = (r - mn / l).ceil.toInt\n            val j = (r + mn / l).floor.toInt\n\
    \            val r2 = (i - 1) * l + j\n            val r3 = r2 - l\n         \
    \   val r4 = r3 + l\n            val coords = lst.drop(r3).take(r4)\n        \
    \    coords.sortWith((a: Tuple2[Long, Long], b: Tuple2[Long, Long]) => b._2.compareTo(a._2))\n\
    \            coords.sortWith((a: Tuple2[Long, Long], b: Tuple2[Long, Long]) =>\
    \ a._1.compareTo(b._1))\n            coords.map(c => (c._1.toLong * l.toLong +\
    \ c._2.toLong))\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpco6ahfaz.scala:26:28 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mr\e[0m = x / (mx - mn)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ - is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpco6ahfaz.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m\
    \ \e[36ml\e[0m = (mx + mn) / (mx - mn)\n\e[31m\e[31m   |\e[0m                \
    \     ^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of List[Long], but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpco6ahfaz.scala:34:92 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            coords.sortWith((\e[36ma\e[0m: \e[35mTuple2\e\
    [0m[\e[35mLong\e[0m, \e[35mLong\e[0m], \e[36mb\e[0m: \e[35mTuple2\e[0m[\e[35mLong\e\
    [0m, \e[35mLong\e[0m]) => b._2.compareTo(a._2))\n\e[31m\e[31m   |\e[0m       \
    \                                                                       ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpco6ahfaz.scala:35:92\
    \ --------------------\e[0m\e[0"
  stdout: ''
  timestamp: 1660010621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result = lst.foldLeft((List(),\
    \ List()))(\n            (acc, e) => {\n                val rowNum = e.sum\n \
    \               val colNum = e.length\n                val temp: List[Long] =\
    \ List(xl.toLong)\n                for (i <- 0 until rowNum) temp = acc :+ xl\
    \ % rowNum\n                for (i <- 0 until colNum) temp = acc :+ xl(i) % colNum\n\
    \                (temp, List(acc))\n            }\n        )\n\n        // Get\
    \ rows in ascending order\n        val rows = result._1.sortBy(x => x).reverse\n\
    \n        // Get columns in descending order\n        val cols = result._2.sortBy(x\
    \ => -x)\n\n        result._2 zip result._1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmr9ksccg.scala:24:44 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mtemp\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = List(xl.toLong)\n\e[31m\e[31m   |\e[0m                \
    \                            ^^\e[0m\n\e[31m   |\e[0m                        \
    \                    Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpmr9ksccg.scala:25:34 --------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m                \e[33mfor\e[0m (i <- \e[31m0\e[0m until rowNum) temp =\
    \ acc :+ xl % rowNum\n\e[31m\e[31m   |\e[0m                                  ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (rowNum : Long)\n\
    \e[31m   |\e[0m                                  Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpmr9ksccg.scala:25:53 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mfor\e[0m (i <- \e[31m0\e[0m until\
    \ rowNum) temp = acc :+ xl % rowNum\n\e[31m\e[31m   |\e[0m                   \
    \                              ^^^^^^\e[0m\n\e[31m   |\e[0mvalue :+ is not a member\
    \ of (List[Nothing], List[Nothing]) - did you mean acc.++?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmr9ksccg.scala:25:56 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                \e[33mfor\e[0m (i <- \e[31m0\e[0m until rowNum)\
    \ temp = acc :+ xl % rowNum\n\e[31m\e[31m   |\e[0m                           \
    \                             ^^\e[0m\n\e[31m   |\e[0m                       \
    \                                 Not found: xl\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpmr9ksccg.scala:26:53 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mfor\e[0m (i <- \e[31m0\e[0m until\
    \ colNum) temp = acc :+ xl(i) % colNum\n\e[31m\e[31m   |\e[0m                \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0mvalue :+ is not\
    \ a mem"
  stdout: ''
  timestamp: 1660010621
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rows = lst.map { row =>\
    \ row.map(_.toLong) }\n        val result = rows.foldLeft(List[Tuple2[Long, Long]]())((acc,\
    \ row) => {\n            val columns = row.map(_.toLong)\n            val indexOfX\
    \ = columns.indexOf(x)\n            if (indexOfX == -1) {\n                acc\
    \ :+ Tuple2(row, 0)\n            } else {\n                val rowWithX = row\
    \ :+ Tuple2(row(indexOfX), row(indexOfX+1))\n                acc :+ Tuple2(rowWithX,\
    \ 0)\n            }\n        })\n        result.sortBy(x => (x._1)).sortBy(x =>\
    \ (x._2, -1)).map { x => (x._1, x._2) }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmak2zeg8.scala:25:30\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                acc :+ Tuple2(row,\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                              ^^^\e[0m\n\
    \e[31m   |\e[0m                              Found:    (row : List[Long])\n\e\
    [31m   |\e[0m                              Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmak2zeg8.scala:28:30 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                acc :+ Tuple2(rowWithX, \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Found:    (rowWithX : List[Matchable])\n\e[31m\
    \   |\e[0m                              Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var coors: List[Tuple2[Long,\
    \ Long]] = List()\n        var xcoor: List[Long] = List()\n        var ycoor:\
    \ List[Long] = List()\n        var row: List[Long] = List()\n        var counts:\
    \ Map[Long, Long] = HashMap()\n        var maxcount = -1\n        var maxrow =\
    \ 0\n        var maxcol = -1\n        var i = 0\n        for (r <- 0 until lst.length)\
    \ {\n            var j = 0\n            for (c <- 0 until lst(r).length) {\n \
    \               var x = lst(r).(c).toLong\n                if (counts.exists(x))\
    \ {\n                    var count = counts(x)\n                    counts.remove(x)\n\
    \                    counts(x) // Update the counts map\n                    if\
    \ (count > maxcount) {\n                        maxcount = count\n           \
    \             maxrow = r\n                        maxcol = c\n               \
    \     }\n                } else {\n                    counts(x) = 1 + counts.getOrElse(x,\
    \ 0l) // Initialize to 0 if not present (first occurance)\n                }\n\
    \            }\n        }\n        for (xi <- 0 until counts.keys) {\n       \
    \     coors = coors :+ ((maxrow + 0l, maxcol + xi))\n        }\n        coors\
    \ = coors.sortBy(_._1)\n        coors = coors.sortBy(_._2)\n        for (r <-\
    \ 0 until lst.length) {\n            row = row :+ lst(r).indexOf(maxcol.toLong)\n\
    \        }\n        row = row.sortBy(_ - maxcol.toLong)\n        row = row.sortBy(_\
    \ - maxrow.toLong)\n        return coors.map(t => (t._1, t._2))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqtd8cgk9.scala:32:31 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                \e[33mvar\e[0m \e[36mx\e[0m = lst(r).(c).toLong\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                             an identifier expected, but '(' found\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqtd8cgk9.scala:38:35 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                        maxcount = count\n\e[31m\e[31m\
    \   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                              Found:    (count : Long)\n\e[31m   |\e[0m     \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpqtd8cgk9.scala:47:34 --------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mfor\e[0m (xi <- \e[31m0\e[0m until counts.keys)\
    \ {\n\e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    Iterable[Long]\n\e[31m   |\e[0m\
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010621
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val n = lst(0).length\n  \
    \      val m = (lst(0).length + 1) * lst(1).length\n        val m1 = m + 2 * x\n\
    \        if (n == 0) List((0l, 0l))\n        else if (m1 == m) List(Tuple2(0l,\
    \ 0l))\n        else List(Tuple2(0l, 0l))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6xq3t9z3.scala:28)\n\tat Problem.main(tmp6xq3t9z3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val n = lst.size\n       \
    \ val rows = lst.map(_.toArray.toList).map(_.toLong)\n        val cols = lst(0).toArray.toList\n\
    \        val m = rows.size\n        val result: List[Tuple2[Long, Long]] = new\
    \ ArrayList[Tuple2[Long, Long]]()\n        for (i <- 0 until n) {\n          \
    \  var row: Long = 0\n            var col: Long = 0\n            var j = i\n \
    \           while(j >= 0 && rows(j) >= x) {\n                row += rows(j--)\n\
    \                col += 1\n            }\n            result.add(new Tuple2[Long,\
    \ Long](row, col))\n        }\n        result.sortBy(t => (t._1.toLong, t._2.toLong)).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2gagg54c.scala:30:31 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                row += rows(j--)\n\e[31m\e[31m   |\e\
    [0m                               ^\e[0m\n\e[31m   |\e[0m                    \
    \           expression expected but \e[31m')'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2gagg54c.scala:21:51 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = lst.map(_.toArray.toList).map(_.toLong)\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toLong is not a member of List[Long], but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might make progress towards fixing the problem:\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2gagg54c.scala:24:51 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = \e[33mnew\e[0m \e[35mArrayList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                               Not found: type ArrayList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2gagg54c.scala:29:36\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mwhile\e\
    [0m(j >= \e[31m0\e[0m && rows(j) >= x) {\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value >= is not a member\
    \ of Nothing - did you mean Nothing.!=?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2gagg54c.scala:30:20 ------------------------\e[0m\e[0m\n\e"
  stdout: ''
  timestamp: 1660010622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val m = lst.size // rows\n\
    \        val n = lst(0).size // cols\n        val list = lst.map(row => {\n  \
    \          val tuple = row.toSeq.sortWith(_.toLong > x)\n            (tuple(0).toLong,\
    \ tuple(1).toLong)\n        }).toList\n        val reversedList = list.reverse\n\
    \        val reversedListMap = reversedList.map(_.toSeq.toMap).sortedWith(_.keys.toList\
    \ > _.keys.toList.reverse).getOrElse(Map.empty)\n        val reversedListMap =\
    \ reversedListMap.map(key => {\n            val tuple = reversedListMap(key).toSeq.sortWith(_.keys.toList\
    \ > _.keys.toList.reverse)\n            (tuple(0).toLong, tuple(1).toLong)\n \
    \       }).toList\n        val reversedListMap = reversedListMap.toMap\n     \
    \   val listMap = (list.map(_.toSeq.toMap).sortedWith(_.keys.toList > _.keys.toList.reverse).getOrElse(Map.empty))\
    \ ++ reversedListMap\n        listMap.toList.sortWith(_.keys.toList > _.keys.toList.reverse).map(_.toSeq.toMap).sortedWith(_.keys.toList\
    \ > _.keys.toList.reverse).flatMap(_.values).map(Tuple2(_._1, _._2))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5gcxh4yv.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mreversedListMap\e[0m = reversedListMap.map(\e\
    [36mkey\e[0m => {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mreversedListMap\
    \ is already defined as \e[33mvalue\e[0m \e[35mreversedListMap\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m29 |\e[0m            \e[33mval\e[0m\
    \ \e[36mtuple\e[0m = reversedListMap(key).toSeq.sortWith(_.keys.toList > _.keys.toList.reverse)\n\
    \e[31m30 |\e[0m            (tuple(\e[31m0\e[0m).toLong, tuple(\e[31m1\e[0m).toLong)\n\
    \e[31m31 |\e[0m        }).toList\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5gcxh4yv.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mreversedListMap\e[0m = reversedListMap.toMap\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mreversedListMap\
    \ is already defined as \e[33mvalue\e[0m \e[35mreversedListMap\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp5gcxh4yv.scala:23:43\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e\
    [0m \e[36mtuple\e[0m = row.toSeq.sortWith(_.toLong > x)\n\e[31m\e[31m   |\e[0m\
    \                                           ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                 Wrong number of parameters, expected: 2\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp5gcxh4yv.scala:27:49 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mreversedListMap\e[0m = reversedList.map(_.toSeq.toMap).sortedWith(_.keys.toList\
    \ > _.keys.toList.reverse).getOrElse(Map.empty)\n\e[31m\e[31m   |\e[0m       \
    \                                        ^^^^^^^\e[0m\n\e[31m   |\e[0m    value\
    \ toSeq is not a member of (Long, Long) - did you mean _$2.take?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp5gcxh4yv.scala:33:34 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval"
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Your code here\n      \
    \  // Solution here\n        // Solution here\n        // Solution here\n    \
    \    // Solution here\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9amt36g5.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// Your code here\e[0m\n\e[31m21 |\e[0m        \e[34m// Solution\
    \ here\e[0m\n\e[31m22 |\e[0m        \e[34m// Solution here\e[0m\n\e[31m23 |\e\
    [0m        \e[34m// Solution here\e[0m\n\e[31m24 |\e[0m        \e[34m// Solution\
    \ here\e[0m\n\e[31m25 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val result = new scala.collection.mutable.ArrayListBuffer[Tuple2[Long,\
    \ Long]]()\n        for (row <- lst.sortWith((l, r) => l < r)) {\n           \
    \ val rowList = row.toList\n            val rowListLength = row.size\n       \
    \     for (col <- 0 until row.size) {\n                if (rowList(col) == x)\
    \ {\n                    result += Tuple2(rowListLength - col, row)\n        \
    \        }\n            }\n        }\n        result += Tuple2(result.size - 1,\
    \ lst(result.size - 1))\n        result.sortWith((x, y) => x._1 < y._1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0zowg6rn.scala:20:50 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m scala.collection.mutable.ArrayListBuffer[\e[35mTuple2\e[0m[\e[35mLong\e[0m,\
    \ \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        type ArrayListBuffer is not a member of scala.collection.mutable\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0zowg6rn.scala:21:45 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mfor\e[0m (row <- lst.sortWith((\e[36ml\e\
    [0m, \e[36mr\e[0m) => l < r)) {\n\e[31m\e[31m   |\e[0m                       \
    \                    ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var ret: List[Tuple2[Long,\
    \ Long]] = Nil\n        var i: Long = 0\n        lst.sortWith(_ < _)\n       \
    \ lst.map(row => {\n            while (i < row.length) {\n                if ((row(i)\
    \ == x)) {\n                    ret :+= Tuple2(i, x)\n                }\n    \
    \            i += 1\n            }\n        })\n        lst.sortWith(_.head >\
    \ _.head)\n        lst.sortWith(_ < _.head)\n        lst.map(row => {\n      \
    \      row.tail.sortWith(_ < _)\n            row.tail.map(col => {\n         \
    \       if (col(i) == x) {\n                    ret :+= Tuple2(i, x)\n       \
    \         }\n            })\n        })\n        lst.sortWith(_.head > _.head)\n\
    \        lst.sortWith(_ < _.head)\n        return ret\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy9h50_7h.scala:22:23 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        lst.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy9h50_7h.scala:25:25 --------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mif\e[0m ((row(i) == x)) {\n\e[31m\e\
    [31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m                \
    \         Found:    (i : Long)\n\e[31m   |\e[0m                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy9h50_7h.scala:32:23\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        lst.sortWith(_ <\
    \ _.head)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmpy9h50_7h.scala:36:20\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                \e[33mif\e\
    [0m (col(i) == x) {\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m\
    \   |\e[0m                    \e[33mparameter\e[0m \e[35mcol\e[0m does not take\
    \ parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy9h50_7h.scala:42:23\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        lst.sortWith(_ <\
    \ _.head)\n\e[31m\e[31m   |\e[0m                "
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // TODO: Write your code here\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5y78am54.scala:19:78\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m    \e[33mdef\e[0m \e[36mgetRow\e\
    [0m(\e[36mlst\e[0m : \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]], \e[36mx\e\
    [0m : \e[35mLong\e[0m) : \e[35mList\e[0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e\
    [35mLong\e[0m]] = {\n\e[31m\e[31m   |\e[0m                                   \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                  Found:    Unit\n\e[31m   |\e[0m           \
    \                                 Required: List[(Long, Long)]\n\e[31m20 |\e[0m\
    \        \e[34m// TODO: Write your code here\e[0m\n\e[31m21 |\e[0m        \n\e\
    [31m22 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        lst.map(r => (r.indexOf(x),\
    \ r.lastIndexOf(x))).sorted.zipWithIndex.sortBy(_._1).map(_._2).zip(lst.map(_.head).map(_\
    \ => (0, 0)))\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmltfqwi3.scala:20:101\
    \ -------------------\e[0m\e[0m\n\e[31m20 |\e[0m        lst.map(\e[36mr\e[0m =>\
    \ (r.indexOf(x), r.lastIndexOf(x))).sorted.zipWithIndex.sortBy(_._1).map(_._2).zip(lst.map(_.head).map(_\
    \ => (\e[31m0\e[0m, \e[31m0\e[0m)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[(Int, (Int, Int))]\n\e[31m   |\e[0m\
    \        Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val rowIndex = lst.zipWithIndex.map\
    \ { case (e, idx) => (idx, e._1) }.toList\n        val index = rowIndex.indexOf(x)\n\
    \        val columnIndex = rowIndex.filter(_.1==index).map { case (e, idx) =>\
    \ (idx, e._2) }.toList.reverse\n        columnIndex.map { case (e, idx) => (e,\
    \ idx) }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0qhw45vv.scala:22:43 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcolumnIndex\e[0m = rowIndex.filter(_\e\
    [31m.1\e[0m==index).map { \e[33mcase\e[0m (e, idx) => (idx, e._2) }.toList.reverse\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                  ')' expected, but number literal found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0qhw45vv.scala:20:71 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mrowIndex\e[0m = lst.zipWithIndex.map\
    \ { \e[33mcase\e[0m (e, idx) => (idx, e._1) }.toList\n\e[31m\e[31m   |\e[0m  \
    \                                                                   ^^^^\e[0m\n\
    \e[31m   |\e[0m                                  value _1 is not a member of List[Long]\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmp0qhw45vv.scala:22:42 -----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcolumnIndex\e[0m = rowIndex.filter(_\e\
    [31m.1\e[0m==index).map { \e[33mcase\e[0m (e, idx) => (idx, e._2) }.toList.reverse\n\
    \e[31m\e[31m   |\e[0m                                          ^\e[0m\n\e[31m\
    \   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$1 of expanded function:\n\e[31m   |\e\
    [0m   _$1 => \n\e[31m   |\e[0m     rowIndex.filter(_$1).map(\n\e[31m   |\e[0m\
    \       {\n\e[31m   |\e[0m         \e[33mcase \e[0m(e, idx) => \n\e[31m   |\e\
    [0m           (idx, e._2)\n\e[31m   |\e[0m       }\n\e[31m   |\e[0m     ).toList.reverse.\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0qhw45vv.scala:22:85 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mcolumnIndex\e[0m = rowIndex.filter(_\e\
    [31m.1\e[0m==index).map { \e[33mcase\e[0m (e, idx) => (idx, e._2) }.toList.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                  value _2 is not a member of Int\n4 errors found\n"
  stdout: ''
  timestamp: 1660010626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        require(lst.length > 0)\n\
    \        require(lst(0).length == lst.length)\n        val sorted = lst.sorted\
    \ (_(0))\n        val rows = (0 until sorted.length).map(_ => (sorted(_).reverse,\
    \ sorted.drop(_).last)).toList\n        rows.sortWith(_._1 > _._1).sortWith(_._1\
    \ < _._1)\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpkm881yv_.scala:22:33 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = lst.sorted\
    \ (_(\e[31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                 ^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 2\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpkm881yv_.scala:23:60\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mrows\e[0m = (\e[31m0\e[0m until sorted.length).map(_ => (sorted(_).reverse,\
    \ sorted.drop(_).last)).toList\n\e[31m\e[31m   |\e[0m                        \
    \                                    ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => sorted(_$3).reverse.\n\e\
    [31m\e[31m-- [E081] Type Error: /tmp/tmpkm881yv_.scala:23:84 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mrows\e[0m = (\e[31m0\e[0m\
    \ until sorted.length).map(_ => (sorted(_).reverse, sorted.drop(_).last)).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                            ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$4 of expanded function:\n\e[31m   |\e[0m   _$4 => sorted.drop(_$4).last.\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkm881yv_.scala:24:27 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        rows.sortWith(_._1 > _._1).sortWith(_._1 < _._1)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^\e[0m\n\e[31m   |\e[0mvalue >\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkm881yv_.scala:24:49 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m       "
  stdout: ''
  timestamp: 1660010627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val r = lst.sortBy(r => r(0).toInt,\
    \ Ordering.Int)\n        val c = r.sortBy(c => c(0).toInt, Ordering.Int)\n   \
    \     val ret = c.takeWhile(_(0) == x).flatMap { c =>\n            (0 until r(0).size).map(i\
    \ => Tuple2(c(i), r(0).apply(i)(c)))\n        }.toList\n        ret.reverse.sortBy(r\
    \ => -r._1).toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmprvm018qh.scala:20:27 -----------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = lst.sortBy(\e[36mr\e\
    [0m => r(\e[31m0\e[0m).toInt, Ordering.Int)\n\e[31m\e[31m   |\e[0m           \
    \                ^\e[0m\n\e[31m   |\e[0m                          Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          I could not\
    \ infer the type of the parameter r.\n\e[31m\e[31m-- Error: /tmp/tmprvm018qh.scala:20:57\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \ \e[33mval\e[0m \e[36mr\e[0m = lst.sortBy(\e[36mr\e[0m => r(\e[31m0\e[0m).toInt,\
    \ Ordering.Int)\n\e[31m\e[31m   |\e[0m                                       \
    \                  ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByte\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e\
    [0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B]\
    \ of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m\
    \ \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var tuples: List[Tuple2[Long,\
    \ Long]] = Nil\n        var count = 1\n        var row: List[Tuple2[Long, Long]]\
    \ = Nil\n        for(elem <- lst){\n            for(elem <- elem){\n         \
    \       if(elem == x){\n                    tuples = elem\n                  \
    \  break\n                }\n            }\n        }\n        while(count <=\
    \ lst.length){\n            row = Nil\n            for(elem <- lst){\n       \
    \         for(elem <- elem){\n                    if(elem == x){\n           \
    \             row = elem\n                        break\n                    }\n\
    \                }\n            }\n            if(row.length > 0){\n         \
    \       tuples = row :: tuples\n            }\n            count +=1\n       \
    \ }\n        return tuples\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2gfxkwyl.scala:26:29\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m                    tuples =\
    \ elem\n\e[31m\e[31m   |\e[0m                             ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                             Found:    (elem : Long)\n\e[31m   |\e[0m\
    \                             Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2gfxkwyl.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2gfxkwyl.scala:36:30\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m                        row =\
    \ elem\n\e[31m\e[31m   |\e[0m                              ^^^^\e[0m\n\e[31m \
    \  |\e[0m                              Found:    (elem : Long)\n\e[31m   |\e[0m\
    \                              Required: List[(Long, Long)]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2gfxkwyl.scala:37:24 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2gfxkwyl.scala:42:25\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                tuples = row\
    \ :: tuples\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (\e[1m\e[31mrow\e[0m\e[1m\e[31m \e\
    [0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e\
    [31m(\e[0mLong, Long\e[1m\e[31m)\e[0m\e[1m\e[31m]\e[0m)\n\e[31m   |\e[0m     \
    \                    Required: (Long, Long)\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling wit"
  stdout: ''
  timestamp: 1660010627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        var lstSize : Int = lst.size\n        lst.foreach(row\
    \ => {\n            row.foreach(col => {\n                if(col == x) {\n   \
    \                 result = List((row.toLong, col.toLong))\n                }\n\
    \            })\n        })\n        if(result == List()) {\n            return\
    \ List()\n        }\n        var result : List[Tuple2[Long, Long]] = List()\n\
    \        result.foreach(row => {\n            row.foreach(col => {\n         \
    \       if(row.toLong > col.toLong) {\n                    result.updated(row.toLong\
    \ - 1, Tuple2(row.toLong, col.toLong))\n                }\n            })\n  \
    \      })\n        if(result == List()) {\n            return List()\n       \
    \ }\n        result.sortBy(row => row._1).reverse\n        result.sortBy(row =>\
    \ row._2).reverse\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfjgm21c3.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mvar\e[0m \e[36mresult\e[0m : \e[35mList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = List()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mresult is already defined as \e[33mvariable\e[0m \e[35mresult\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpfjgm21c3.scala:25:39 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m                    result = List((row.toLong, col.toLong))\n\e[31m\e[31m \
    \  |\e[0m                                   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toLong is not a member of List[Long], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfjgm21c3.scala:34:16\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            row.foreach(\e\
    [36mcol\e[0m => {\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m            value foreach is not a member of (Long, Long)\n3 errors found\n"
  stdout: ''
  timestamp: 1660010627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val map0 = mutable.HashMap[(Long,\
    \ Long), List[Long]]()\n        val map1 = mutable.HashMap[(Long, Long), List[Long]]()\n\
    \        lst.zipWithIndex.foreach {\n            case(v, i) =>\n             \
    \   if (i <= 0) return\n                if (map0.contains(v)) map0(v).append(i)\n\
    \                else {\n                    val list0 = mutable.ListBuffer[Long]()\n\
    \                    list0 += i\n                    map0.put(v,list0)\n     \
    \           }\n                if (map1.contains(v)) {\n                    val\
    \ list1 = mutable.ListBuffer[Long]()\n                    list1 += map1(v).last\n\
    \                    map1.put(v,list1)\n                } else {\n           \
    \         map1.put(v,List(i))\n                }\n        }\n        val result\
    \ = map1.get(x)\n        val map2 = mutable.HashMap[(Long, Long), List[Long]]()\n\
    \        val map3 = mutable.HashMap[(Long, Long), List[Long]]()\n        val result\
    \ = map2.get(x)\n        if (result != null) map3(result) else map3(x)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9kb_crcn.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = map2.get(x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mresult\
    \ is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9kb_crcn.scala:20:19\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mmap0\e[0m = mutable.HashMap[(\e[35mLong\e[0m, \e[35mLong\e[0m), \e[35mList\e\
    [0m[\e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9kb_crcn.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmap1\e[0m = mutable.HashMap[(\e\
    [35mLong\e[0m, \e[35mLong\e[0m), \e[35mList\e[0m[\e[35mLong\e[0m]]()\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9kb_crcn.scala:24:28\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mif\e[0m\
    \ (i <= \e[31m0\e[0m) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m               \
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m                            Found: \
    \   Unit\n\e[31m   |\e[0m                            Required: List[(Long, Long)]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9kb_crcn.scala:27:32\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                    \e[33mval\e\
    [0m \e[36mlist0\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ e"
  stdout: ''
  timestamp: 1660010627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lstRev = lst.reverse\n\
    \        val lstRow = lstRev.map{x => (x, lstRev.indexOf(x))}\n        val lstCol\
    \ = lstRev.map{x => (lstRev.indexOf(x), x)}\n        val lstRowRev = lstRow.reverse\n\
    \        val lstColRev = lstCol.reverse\n        lstRowRev.map(x => (lstColRev.indexOf(x._1),\
    \ x._1)).filter{x => x == x}\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt0q79jqa.scala:25:66\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        lstRowRev.map(\e[36mx\e\
    [0m => (lstColRev.indexOf(x._1), x._1)).filter{\e[36mx\e[0m => x == x}\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[(\e[1m\e[31mInt\e[0m, \e[1m\e[31mList\e\
    [0m\e[1m\e[31m[\e[0mLong\e[1m\e[31m]\e[0m)]\n\e[31m   |\e[0m        Required:\
    \ List[(\e[1m\e[32mLong\e[0m, Long)]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n      val rows = lst.toList.sortBy(_(0))\n\
    \      val cols = lst(0).toList.sortBy(_ - 1)\n      val rowAndCols = rows.map(row\
    \ => (row, cols)).toList\n      val rowAndColsSorted = rowAndCols.sortBy(_._1)\n\
    \      rowAndColsSorted.map(_._2)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpdhj4kik7.scala:23:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m      \e[33mval\e[0m \e[36mrowAndColsSorted\e[0m = rowAndCols.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mNo implicit Ordering defined for List[Long]..\n\e[31m   |\e[0mI\
    \ found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mList[Long]\e\
    [0m](\n\e[31m   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[List[Long]]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[List[Long]].\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mThe following import might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import math.Ordering.Implicits.seqOrdering\n\e[31m\
    \   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660010630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        var rows : List[Tuple2[Long,\
    \ Long]] = Nil\n        var cols : List[Long] = Nil\n        var xRow = 0\n  \
    \      var xCol = 0\n        var i = 0\n        var j = 0\n        var col = 0\n\
    \        while (i < lst.size) {\n            if (lst(i) == x.toLong) {\n     \
    \           rows += ((xRow, xCol))\n                cols += lst(j)\n         \
    \       ++i\n                ++j\n            } else {\n                ++xCol\n\
    \            }\n        }\n        rows.sortWith(_.swap)\n        cols.sortWith(_.swap)\n\
    \        val sortedRows = rows.toList\n        val sortedCols = cols.toList\n\
    \        if (sortedCols.last < sortedRows.last) {\n            sortedRows.reverse\n\
    \        } else {\n            sortedCols.reverse\n        }\n        sortedRows.map\
    \ { case (row, col) => (row, col) }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfsrlpre3.scala:32:19 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                ++j\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfsrlpre3.scala:34:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                ++xCol\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpfsrlpre3.scala:28:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mif\e[0m (lst(i) == x.toLong) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \  Values of types List[Long] and Long cannot be compared with == or !=\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfsrlpre3.scala:29:21 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                rows += ((xRow, xCol))\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not a member\
    \ of List[(Long, Long)] - did you mean List[(Long, Long)].!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpfsrlpre3.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                cols += lst(j)\n\e[31m\e[31m   |\e[0m\
    \                ^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of\
    \ List[Long] - did you mean List[Long].!=?\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfsrlpre3.scala:31:16 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m                ++i\n\e[31m\e[31m   |\e[0m                ^^\e[0m\n\e[31m \
    \  |\e[0m                Not found: ++\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpfsrlpre3.scala:34:16 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m                ++xCol\n\e[31m\e[31m   |\e[0m            \
    \    ^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660010631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        // Create mutable list of\
    \ coordinates - initially empty.\n        var rows = mutable.LinkedHashSet[Tuple2[Long,\
    \ Long]]()\n        // Create mutable list of columns - initially empty.\n   \
    \     var columns = mutable.LinkedHashSet[Long]()\n        // Traverse nested\
    \ list lst,\n        // each element contains sublist,\n        // each sublist\
    \ contains one row.\n        lst.foreach(rows ++= {\n            (rows ++= (0\
    \ until lst.size)).map(_ => lst.map(_.toLong).toSet).flatten\n        })\n   \
    \     val rowCoordinates = rows.toSeq.sortBy(row => {\n            columns.addAll(row)\n\
    \            columns.size\n        }).map(row => row.toSeq.sortBy(column => columns.lastIndexOf(_))).toList\n\
    \        val rowAndColumnCoordinates = rowCoordinates.map(coordinate => (coordinate._1,\
    \ coordinate._2))\n        val xAndYs = rowAndColumnCoordinates.filter(coordinate\
    \ => coordinate._1 == x).unzip._2\n        xAndYs.sortBy(coordinate => coordinate._1)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9aghhgw6.scala:21:19 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mvar\e[0m \e[36mrows\e[0m = mutable.LinkedHashSet[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]]()\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9aghhgw6.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mvar\e[0m \e\
    [36mcolumns\e[0m = mutable.LinkedHashSet[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty)\n       \
    \     Nil\n        else\n            lst.sortWith(compareRows)\n             \
    \   .toList.flatMap {\n                case row :: Nil => row.zipWithIndex.map\
    \ { case (item, index) => Tuple2(index.toLong, item) }\n                case row\
    \ => row.zipWithIndex.map { case (item, index) => Tuple2(index.toLong, item) }.filter(x\
    \ => x._1 >=x).map(x => (x._1, x._2 - x))\n            }\n            .toList\n\
    \            .sortWith(compareRows)\n            .map(x => Tuple2(x, x))\n   \
    \         .toList\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4m8xd3cp.scala:23:25 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            lst.sortWith(compareRows)\n\e[31m\e[31m \
    \  |\e[0m                         ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: compareRows\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp4m8xd3cp.scala:25:39 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m row :: Nil => row.zipWithIndex.map\
    \ { \e[33mcase\e[0m (item, index) => Tuple2(index.toLong, item) }\n\e[31m\e[31m\
    \   |\e[0m                                   ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              value zipWithIndex is not a member of Long\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmp4m8xd3cp.scala:26:119 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mcase\e[0m row => row.zipWithIndex.map\
    \ { \e[33mcase\e[0m (item, index) => Tuple2(index.toLong, item) }.filter(x =>\
    \ x._1 >=x).map(x => (x._1, x._2 - x))\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m>=\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with\
    \ types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\
    \e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m\
    \   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e\
    [0m (x: Byte): Boolean\n\e[31m   |\e[0mmatch arguments ((x : (Long, Long)))\n\e\
    [31m\e[31m-- [E134] Type Error: /tmp/tmp4m8xd3cp.scala:26:145 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mcase\e[0m row => row.zipWithIndex.map\
    \ { \e[33mcase\e[0m (item, index) => Tuple2(index.toLong, item) }.filter(x =>\
    \ x._1 >=x).map(x => (x._1, x._2 - x))\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                ^^^^^^\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660010631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def getRowHelper(lst: List[List[Long]],\
    \ x : Long, result : List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]] = {\n\
    \            if (lst.isEmpty) {\n                result :+ Tuple2(x, 0)\n    \
    \        } else {\n                getRowHelper(\n                    if (lst(0)\
    \ contains x) (lst.tail, x, lst)\n                    else (lst.tail, x, lst),\n\
    \                    x,\n                    result :+ Tuple2(x, 0))\n       \
    \     }\n        }\n        getRowHelper(lst, x, Nil)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprk_l3jga.scala:25:43\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e[33mif\e\
    [0m (lst(\e[31m0\e[0m) contains x) (lst.tail, x, lst)\n\e[31m\e[31m   |\e[0m \
    \                                          ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    Found:    \e[1m\e[31m(\e[0mList[List[Long]\e[1m\e[31m]\e\
    [0m\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e\
    [0m\e[1m\e[31mLong\e[0m\e[1m\e[31m]\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m  \
    \                  Required: List[List[Long]]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmprk_l3jga.scala:26:25 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    \e[33melse\e[0m (lst.tail, x, lst),\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m Found:    (List[List[Long] @uncheckedVariance], Long, List[List[Long]])\n\
    \e[31m   |\e[0m Required: List[List[Long]]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val newList = mutable.ArrayBuffer.empty[(Long,\
    \ Long)]\n        for (row <- lst) {\n            for (cell <- row) {\n      \
    \          if (cell == x) {\n                    newList += ((row, cell))\n  \
    \              }\n            }\n        }\n        newList.sortBy(_._1).reverse.sortBy(_._2).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf9763l5i.scala:20:22 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewList\e[0m = mutable.ArrayBuffer.empty[(\e\
    [35mLong\e[0m, \e[35mLong\e[0m)]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst == Nil || lst.length\
    \ == 0) return Nil\n        val lst0 = lst(0)\n        var result = Nil\n    \
    \    var i = 1\n        for (x <- lst0 reversed) {\n            var found = true\n\
    \            if (i >= lst.length) break\n            for (y <- lst(i)) {\n   \
    \             if (y == x) found = false\n            }\n            if (found)\
    \ result = result :+ (i, x)\n            i += 1\n        }\n        result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgjzm287c.scala:24:31 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mfor\e[0m (x <- lst0 reversed) {\n\e[31m\e\
    [31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m          \
    \                     expression expected but \e[31m')'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if(lst.isEmpty) return List()\n\
    \        def isRow(xs: List[Long], x: Long) : Boolean = xs == List(x, x) && xs.headOption.exists(x\
    \ => x == x) || x == xs.head\n\n        val coords: List[Tuple2[Long, Long]] =\
    \ lst.sortWith(x => x.zipWithIndex).map{case (row, x) => row.map{ case (x, y)\
    \ => (y, x) }}.sortWith(x => x._2).map{case (row, _) => row.map{ case (x, y) =>\
    \ (y, x) }}.sortWith(x => (x._1 < x._2))\n        val indexes = coords.map {case\
    \ (row, col) => (row, col)}\n\n        val rowIndex = indexes.headOption.filter{case\
    \ (row, col) => isRow(row, x)}\n        val coord = coords.find(row => row._1\
    \ == rowIndex.get._1).map{case (row, col) => row.map{case (x, y) => (y, x)}}.getOrElse(IndexedSeq())\n\
    \        coord\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp91hh77vh.scala:23:62 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcoords\e[0m: \e[35mList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = lst.sortWith(\e[36mx\e\
    [0m => x.zipWithIndex).map{\e[33mcase\e[0m (row, x) => row.map{ \e[33mcase\e[0m\
    \ (x, y) => (y, x) }}.sortWith(\e[36mx\e[0m => x._2).map{\e[33mcase\e[0m (row,\
    \ _) => row.map{ \e[33mcase\e[0m (x, y) => (y, x) }}.sortWith(\e[36mx\e[0m =>\
    \ (x._1 < x._2))\n\e[31m\e[31m   |\e[0m                                      \
    \                      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                    Wrong number of parameters, expected: 2\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp91hh77vh.scala:23:106 -----------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcoords\e[0m: \e[35mList\e[0m[\e\
    [35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = lst.sortWith(\e[36mx\e[0m\
    \ => x.zipWithIndex).map{\e[33mcase\e[0m (row, x) => row.map{ \e[33mcase\e[0m\
    \ (x, y) => (y, x) }}.sortWith(\e[36mx\e[0m => x._2).map{\e[33mcase\e[0m (row,\
    \ _) => row.map{ \e[33mcase\e[0m (x, y) => (y, x) }}.sortWith(\e[36mx\e[0m =>\
    \ (x._1 < x._2))\n\e[31m\e[31m   |\e[0m                                      \
    \                                                                ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value map is not a member\
    \ of Any\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp91hh77vh.scala:23:147 --------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcoords\e[0m: \e[35mList\e\
    [0m[\e[35mTuple2\e[0m[\e[35mLong\e[0m, \e[35mLong\e[0m]] = lst.sortWith(\e[36mx\e\
    [0m => x.zipWithIndex).map{\e[33mcase\e[0m (row, x) => row.map{ \e[33mcase\e[0m\
    \ (x, y) => (y, x) }}.sortWith(\e[36mx\e[0m => x._2).map{\e[33mcase\e[0m (row,\
    \ _) => row.map{ \e[33mcase\e[0m (x, y) => (y, x) }}.sortWith(\e[36mx\e[0m =>\
    \ (x._1 < x._2))\n\e[31m\e[31m   |\e[0m                                      \
    \                                                                            \
    \                               ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                   Wrong number"
  stdout: ''
  timestamp: 1660010633
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val xList = lst.filter(_ contains\
    \ x).sortBy(_.toLong).reverse\n        val yList = xList.map(_._2).sortBy(_.toLong).reverse\n\
    \        xList.zipAll(yList).sortBy(_._1).map(_._2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplfqrjfz_.scala:20:54 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mxList\e[0m = lst.filter(_\
    \ contains x).sortBy(_.toLong).reverse\n\e[31m\e[31m   |\e[0m                \
    \                                    ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmplfqrjfz_.scala:20:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mxList\e[0m = lst.filter(_\
    \ contains x).sortBy(_.toLong).reverse\n\e[31m\e[31m   |\e[0m                \
    \                                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByte\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mBigInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660010632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        if (lst.isEmpty) return Nil\n\
    \        val m = lst.map(_.length)\n        var maxRow = x.toLong\n        for\
    \ (i <- 0 to m-1) {\n            if (lst(i).indexOf(x) >= 0) {\n             \
    \   maxRow = lst(i).indexOf(x)\n            } else {\n                break\n\
    \            }\n        }\n        if (lst(0).isEmpty) {\n            return Nil\n\
    \        }\n        if (maxRow == 0) {\n            return lst(1).map(i => (0,\
    \ i)).sorted\n        }\n        return lst(maxRow).map(i => (maxRow, i)).sorted\
    \ // reverse the sorted rows\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9bafqpzi.scala:23:24 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m to m-\e[31m1\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                       ^^\e[0m\n\e[31m   |\e[0mvalue\
    \ - is not a member of List[Int], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9bafqpzi.scala:27:16\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9bafqpzi.scala:34:19\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mreturn\e[0m\
    \ lst(\e[31m1\e[0m).map(\e[36mi\e[0m => (\e[31m0\e[0m, i)).sorted\n\e[31m\e[31m\
    \   |\e[0m                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Found:    List[(\e[1m\e[31mInt\e[0m, Long)]\n\e[31m   |\e\
    [0m                   Required: List[(\e[1m\e[32mLong\e[0m, Long)]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9bafqpzi.scala:36:19 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mreturn\e[0m lst(maxRow).map(\e[36mi\e[0m\
    \ => (maxRow, i)).sorted \e[34m// reverse the sorted rows\e[0m\n\e[31m\e[31m \
    \  |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:\
    \    (maxRow : Long)\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        def sortRow(row: List[Long],\
    \ rowSize: List[Long], result: List[Tuple2[Long, Long]]) : List[Tuple2[Long, Long]]\
    \ = {\n            val row = row.sortWith(_ < _)\n            val rowSize = rowSize.sortWith(_\
    \ < _)\n            val index = row.zipWithIndex.filter(_._1 == x).map(x => x._2).map(i\
    \ => rowSize(i))\n            val size = rowSize.zipWithIndex.filter(_._2 == x).map(x\
    \ => x._2).map(i => row(i))\n            val resultSize = result.map(_._1).zipWithIndex.filter(_._1\
    \ == x).map(x => x._2)\n            val resultIndex = result.map(_._2).zipWithIndex.filter(_._1\
    \ == x).map(x => x._2)\n            val size = size.map(x => x._1).zip(x._2)\n\
    \            val index = index.map(x => x._1).zip(x._2)\n            val newSize\
    \ = rowSize.zipWithIndex.filter(_._2 == x).map(x => x._2).map(i => row(i))\n \
    \           val newIndex = row.zipWithIndex.filter(_._1 == x).map(x => x._2).map(i\
    \ => rowSize(i))\n            val newSizeIndex = size.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newIndexIndex = index.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => rowSize(i))\n            val newIndexSize = rowSize.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newSizeSizeIndex = newSize.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newIndexSizeIndex = newIndex.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newSizeSizeSizeIndex\
    \ = newSize.zipWithIndex.filter(_._2 == x).map(x => x._2).map(i => row(i))\n \
    \           val newIndexSizeSizeIndex = newIndex.zipWithIndex.filter(_._2 == x).map(x\
    \ => x._2).map(i => row(i))\n            val newIndexSizeSizeSizeIndex = newIndex.zipWithIndex.filter(_._2\
    \ == x).map(x => x._2).map(i => row(i))\n            val newSizeSizeSizeSizeIndex\
    \ = newSize.zipWithIndex.filter(_._2 == x).map(x => \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1uas5518.scala:39:90 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mnewSizeSizeSizeSizeIndex\e\
    [0m = newSize.zipWithIndex.filter(_._2 == x).map(\e[36mx\e[0m => \n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp1uas5518.scala:51:0 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1uas5518.scala:27:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e\
    [0m \e[36msize\e[0m = size.map(\e[36mx\e[0m => x._1).zip(x._2)\n\e[31m\e[31m \
    \  |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msize is already defined as \e[33mvalue\e[0m \e[35msize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1uas5518.scala:28:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36mindex\e[0m = index.map(\e[36mx\e[0m => x._1).zip(x._2)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mindex is already defined as \e[33mvalue\e[0m \e[35mindex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp1uas5518.scala:21:22 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m            \e[33mval\e[0m \e[36mrow\e[0m = row.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   Recursive \e[33mvalue\e[0m \e[35mrow\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp"
  stdout: ''
  timestamp: 1660010632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val size = lst(0).size\n \
    \       if (size == 0) {\n            List()\n        } else {\n            val\
    \ newLst: List[List[Long]] = lst.map(l => l.map(n => (n, n+x))).toList\n     \
    \       val lstSize = newLst(0).size\n            val rowList: List[List[Long]]\
    \ = newLst.map(l => l.sortWith(_ > _))\n            val newRowList: List[List[Long]]\
    \ = rowList.map(l => l.sortWith(_ < _))\n            getRow(newRowList, x)\n \
    \       }\n    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4yccb7gy.scala:24:78\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e\
    [36mnewLst\e[0m: \e[35mList\e[0m[\e[35mList\e[0m[\e[35mLong\e[0m]] = lst.map(\e\
    [36ml\e[0m => l.map(\e[36mn\e[0m => (n, n+x))).toList\n\e[31m\e[31m   |\e[0m \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Found:    List[List[\e\
    [1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mLong\e[0m\e[1m\e\
    [31m)\e[0m]]\n\e[31m   |\e[0m                                      Required: List[List[Long]]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a 2 dimensional data, as a nested lists,\n    // which\
    \ is similar to matrix, however, unlike matrices,\n    // each row may contain\
    \ a different number of columns.\n    // Given lst, and integer x, find integers\
    \ x in the list,\n    // and return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n    // each tuple is a coordinate - (row, columns), starting with 0.\n\
    \    // Sort coordinates initially by rows in ascending order.\n    // Also, sort\
    \ coordinates of the row by columns in descending order.\n    // Examples:\n \
    \   // >>> getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
    \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
    \ x : Long) : List[Tuple2[Long, Long]] = {\n        val lstCopy = lst\n      \
    \  def inOrderHelper(lst: List[Long], x: Long, acc: List[Tuple2[Long, Long]])\
    \ : List[Tuple2[Long, Long]] =\n            lst match {\n                case\
    \ Nil => acc\n                case List(rl, rc, rc0) =>\n                    val\
    \ ll = inOrderHelper(rl, x, Tuple2.tuple2(ll, rc))\n                    if (ll\
    \ == Nil) {\n                        inOrderHelper(rc, x, Tuple2.tuple2(rl, rc))\n\
    \                    } else {\n                        inOrderHelper(rl, x, Tuple2.tuple2(rl,\
    \ rc))\n                    }\n                case List(rl, rc, rc0) =>\n   \
    \                 if (rc < rc0) {\n                        inOrderHelper(rl, x,\
    \ Tuple2.tuple2(rl, rc))\n                    } else if (rc > rc0) {\n       \
    \                 inOrderHelper(rc, x, Tuple2.tuple2(rl, rc))\n              \
    \      } else {\n                        inOrderHelper(rl, x, Tuple2.tuple2(rl,\
    \ rc))\n                    }\n            }\n\n        inOrderHelper(lstCopy,\
    \ x, Tuple2.tuple2(x, 0l))\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
    \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n   \
    \ assert(getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 1l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 1l.toLong,\
    \ 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long, Long]]((0l,\
    \ 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l, 0l), (5l,\
    \ 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
    \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
    \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
    \ Long]]((2l, 2l)))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmzbgut4x.scala:25:43\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m                    \e[33mval\e\
    [0m \e[36mll\e[0m = inOrderHelper(rl, x, Tuple2.tuple2(ll, rc))\n\e[31m\e[31m\
    \   |\e[0m                                           ^^\e[0m\n\e[31m   |\e[0m\
    \                                           Found:    (rl : Long)\n\e[31m   |\e\
    [0m                                           Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmzbgut4x.scala:25:57 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                    \e[33mval\e[0m \e[36mll\e[0m = inOrderHelper(rl,\
    \ x, Tuple2.tuple2(ll, rc))\n\e[31m\e[31m   |\e[0m                           \
    \                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \         value tuple2 is not a member of object Tuple2\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpmzbgut4x.scala:25:64 ---------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                    \e[33mval\e[0m \e[36mll\e[0m = inOrderHelper(rl,\
    \ x, Tuple2.tuple2(ll, rc))\n\e[31m\e[31m   |\e[0m                           \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \                           Recursive \e[33mvalue\e[0m \e[35mll\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmzbgut4x.scala:27:38\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m                        inOrderHelper(rc,\
    \ x, Tuple2.tuple2(rl, rc))\n\e[31m\e[31m   |\e[0m                           \
    \           ^^\e[0m\n\e[31m   |\e[0m                                      Found:\
    \    (rc : Long)\n\e[31m   |\e[0m                                      Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmzbgut4x.scala:27:52\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m                        inOrderHelper(rc,\
    \ x, Tuple2.tuple2(rl, rc))\n\e[31m\e[31m   |\e[0m  "
  stdout: ''
  timestamp: 1660010633
