name: HumanEval_46_fib4
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n    // fib4(0) -> 0\n    // fib4(1) -> 0\n    // fib4(2)\
  \ -> 2\n    // fib4(3) -> 0\n    // fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3)\
  \ + fib4(n-4).\n    // Please write a function to efficiently compute the n-th element\
  \ of the fib4 number sequence.  Do not use recursion.\n    // >>> fib4((5l))\n \
  \   // (4l)\n    // >>> fib4((6l))\n    // (8l)\n    // >>> fib4((7l))\n    // (14l)\n\
  \    def fib4(n : Long) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(fib4((5l)) == (4l));\n\
  \    assert(fib4((8l)) == (28l));\n    assert(fib4((10l)) == (104l));\n    assert(fib4((12l))\
  \ == (386l));\n    }\n\n}\n"
completions: ["        if (n < 0L) 0L\n        else if (n < 4L) 0L\n        else 2L\
    \ + fib4(n - 1L) + fib4(n - 2L) + fib4(n - 3L) + fib4(n - 4L)", "        val a\
    \ = Array(0, 1, 2, 3, 4)\n        var x = a(0)\n        var y = a(0)\n       \
    \ var z = a(0)\n        var w = a(0)\n        var i = 0\n        while (i < n)\
    \ {\n            z = a(0) + a(0) + a(0) + a(0)\n            w = z + a(0) + a(0)\
    \ + a(0) + a(0)\n            x = y + z + w + a(0)\n            y = w\n       \
    \     i = i + 1\n        }\n        x", "        val fib4N = (1l).+(2l).+(3l).+(4l)\n\
    \        fib4N(n-l)", "        val fib4ns = mutable.Buffer.empty[Long]\n     \
    \   for (i <- 0 to n by 4)\n            fib4ns += fib4ns(i) + fib4ns(i+1) + fib4ns(i+2)\
    \ + fib4ns(i+3)\n        fib4ns(n) // Return fibonacci number at n", "       \
    \ if (n >= 0)\n            fib4(n / 2) + fib4(n / 4) + fib4(n / 8) + fib4(n /\
    \ 16)\n        else\n            0", '        // Code goes here', "        if(n\
    \ > 2) fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n        else n",
  "        val arr = new Array[Long](5)\n        arr(0) = 0\n        arr(1) = 0\n\
    \        arr(2) = 2\n        arr(3) = 0\n        arr(4) = arr(-1) + arr(-2) +\
    \ arr(-3) + arr(-4)\n        arr(n)", "        if (n <= 2) n\n        else fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        def loop(n: Long,\
    \ accum: Long) : Long = {\n            if (n == 0) accum\n            else {\n\
    \                loop(n-1, accum + n % 4)\n            }\n        }\n        loop(n,\
    \ 0)", "        var fib0 : Long = 0\n        var fib1 : Long = 1\n        var\
    \ fib2 : Long = 2\n        var fib3 : Long = 0\n        fib3 = n\n        while\
    \ (fib3 > 0) {\n            var fib4 = 0\n            fib4 = fib1\n          \
    \  fib1 = fib2\n            fib2 = fib3\n            fib3 = fib4 - fib1 + fib2\n\
    \        }\n        fib3", "        val fib4List = List(0l,0l,2l,0l,0l,2l)\n \
    \       fib4List(n-1)", "        // Write your code here.\n        // Use a mutable\
    \ hash-map to store the current fib sequence value and its index.\n        val\
    \ fibMap = mutable.HashMap[Long, Long]()\n        var sum = 0\n        var cur\
    \ = 0\n        var index = 1\n        while (index < n) {\n            fibMap\
    \ += (cur -> index)\n            cur = fibMap.getOrElseUpdate(n+index, cur + index\
    \ * index); index++\n        }\n        fibMap.getOrElse(n+1, 0l) //return 0 as\
    \ default value.", "        require(n >= 0 && n <= 40, \"fib4 called with invalid\
    \ parameter\")\n        val xs = List(1, 0, 1)\n        val ys = List(0, 1, 1)\n\
    \        val zs = List(1, 1, 2)\n        val yts = List(2, 1, 1)\n        var\
    \ ret = 0\n        if (n > 0) {\n            val f = xs(n - 1)\n            ret\
    \ += f\n        }\n        if (n >= 1) {\n            val f = ys(n - 1)\n    \
    \        ret += f\n        }\n        if (n >= 2) {\n            val f = zs(n\
    \ - 1)\n            ret += f\n        }\n        if (n >= 3) {\n            val\
    \ f = yts(n - 1)\n            ret += f\n        }\n        ret", "        val\
    \ nums = mutable.ListBuffer(1l, 2l, 3l, 4l, 5l)\n        val cur = mutable.ArrayBuffer(0l,\
    \ 1l, 2l, 3l, 4l, 5l)\n        (1l until nums.size).map { x =>\n            if\
    \ (x == nums.size) nums.last\n            else cur += nums(x)\n        }.last",
  "        if (n<=0 || n==1)\n            return 0\n        else \n            return\
    \ (fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4))", "        if (n ==\
    \ 0) 1\n        if (n == 1) 1\n        if (n == 2) 2\n        if (n == 3) 0\n\
    \        if (n == 4) 0\n        if (n >= 5) \n            fib4((n - 1) + fib4((n\
    \ - 2) + fib4((n - 3) + fib4((n - 4)))) \n        else \n            0", "   \
    \     val fib4n = scala.collection.mutable.ListBuffer.empty[Long]\n        fib4n\
    \ += 0\n        fib4n += 0\n        fib4n += 2\n        fib4n += 0\n        fib4n.head",
  "        if (n == 0)\n            return 0\n        else if (n == 1)\n         \
    \   return 1\n        else if (n == 2)\n            return 2\n        else if\
    \ (n == 3) {\n            fib4(4)\n        }\n        else {\n            val\
    \ tmp1 = fib4(n-1)\n            val tmp2 = fib4(n-2)\n            val tmp3 = fib4(n-3)\n\
    \            val tmp4 = fib4(n-4)\n            tmp1 + tmp2 + tmp3 + tmp4\n   \
    \     }", "        if(n < 0 || n > 4)\n            throw new IllegalArgumentException(\"\
    Invalid fib4 argument: \" + n)\n        if (n == 0)\n            return 0\n  \
    \      if (n == 1)\n            return 1\n        if (n == 2)\n            return\
    \ 2\n        if (n == 3)\n            return 0\n        if (n == 4)\n        \
    \    return 4\n        if (n % 2 == 0)\n            return fib4(n / 2) + fib4(n\
    \ / 3) + fib4(n / 4)\n        else\n            return fib4(n / 3)", "       \
    \ val fib = mutable.ArrayBuffer.empty[Long]\n        val fib2 = mutable.ArrayBuffer.empty[Long]\n\
    \        val fib3 = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n     \
    \   var j = 0\n        var k = 0\n        i =+ n\n        j =+ n\n        k =+\
    \ n\n        while(i<n){\n            fib2 += j\n            j += k\n        \
    \    k += n\n            i += n\n        }\n        fib3 = fib2.toArray ++ fib3.toArray\n\
    \        fib3.last", "        if (n <= 0) {\n            return 0\n        }\n\
    \        if (n <= 2) {\n            return 1\n        }\n        return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)", "        val m = scala.math.ceil(n)\n\
    \        if (m == 0) 0\n        else if (m == 1) 1\n        else if (m == 2) 2\n\
    \        else if (m == 3) 3\n        else scala.math.pow(2, 4l) * (fib4(m-1) +\
    \ fib4(m-2) + fib4(m-3) + fib4(m-4))", "        if (n == 0) 0\n        else (fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4) + fib4(n - 5)).asInstanceOf[Long]",
  "        if (n <= 2)\n            return n\n        else if (n == 3)\n         \
    \   return 1\n        else\n            val f1 = fib4(n-1)\n            val f2\
    \ = fib4(n-2)\n            val f3 = fib4(n-3)\n            val f4 = fib4(n-4)\n\
    \            f1 + f2 + f3 + f4\n        }", "        val mutable res = 0\n   \
    \     var i : Long = 0\n        for(i <- 0 until n){\n            res = res +\
    \ i\n        }\n        return res", "        if (n == 0) 0\n        if (n ==\
    \ 1) 1\n        if (n == 2) 2\n        if (n == 3) 0\n        else{\n        \
    \    val temp = fib4(n - 1)\n            fib4(n - 2) + temp\n        }", "   \
    \     if (n <= 0) 0\n        else if (n <= 1) 0\n        else if (n <= 2) 2\n\
    \        else if (n <= 3) 0\n        else {\n            val (f1, f2) = (fib4(n\
    \ - 1), fib4(n - 2))\n            val res = (f1 + f2 + f1 + f2) - f1\n       \
    \     res\n        }", "        var counter = mutable.LinkedHashMap.empty[Long,\
    \ Long]\n        for (i <- 0 until n)\n            counter.put(i+1, counter.getOrElse(i+1,\
    \ 0l) + counter.getOrElse(i-1, 0l) + counter.getOrElse(i-2, 0l) + counter.getOrElse(i-3,\
    \ 0l))\n        counter.get(n-1)", "        val fib4 = mutable.ArrayBuffer.empty[Long]\n\
    \        fib4 += 0\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n\
    \        fib4 += fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        fib4(n)",
  "        def loop(n: Long, a: Long, b: Long, c : Long): Long = {\n            if\
    \ (n > 0) loop(n - 1, a + b + c, b + a, c)\n            else a\n        }\n  \
    \      loop(n, 0, 1, 1)", "        val fib4 = (0 to n).foldLeft(0) { case (acc,\
    \ i) =>\n            acc+i\n        }\n        fib4", "        val fib4 = new\
    \ mutable.HashSet[Long]()\n        fib4.add(0l)\n        fib4.add(1l)\n      \
    \  fib4.add(2l)\n        fib4.add(3l)\n\n        fib4.foreach { x =>\n       \
    \     val n1 = n-1\n            val n2 = n-2 //n3 = n-4\n            val n3 =\
    \ n-3 //n4 = n-5\n            fib4.add(fib4(n1) + fib4(n2) + fib4(n3) + fib4(n4))\
    \ //fib4.add(fib4(n1) + fib4(n2) + fib4(n3) + fib4(n4))\n        }\n        fib4.last",
  "        if (n == 0 || n == 1)\n            return n\n        else if (n % 2 ==\
    \ 0)\n            return fib4(n - 1) + fib4(n - 2)\n        else\n           \
    \ return fib4(n - 3) + fib4(n - 4)", "        val fibs = mutable.LinkedHashMap[Long,\
    \ Long]()\n        fibs.put(0, 0l) \n        fibs.put(1, 1l)\n        fibs.put(2,\
    \ 2l)\n        fibs.put(3, 3l)\n        var i = 3l\n        fibs.put(n, fibs.get(n-3)+fibs.get(n-2)+fibs.get(n-1)+fibs.get(n))",
  "        val x = new Array[Long](5)\n        var sum = 0\n        x(0) = 0\n   \
    \     x(1) = 0\n        x(2) = 0\n        x(3) = 0\n        val i = 4\n      \
    \  while ( i != n ) {\n            sum += x(i)\n            i = (i + 3)\n    \
    \    }\n        sum", "    \tvar temp : Long = 0\n    \tvar temp2 : Long = 0\n\
    \    \tvar fib : Long = 0\n    \tvar fib2 : Long = 0\n    \tvar fib3 : Long =\
    \ 0\n    \tvar fib4 : Long = 0\n    \tif (n < 0)\n    \t\tthrow new IllegalArgumentException(\"\
    Fib number out of range\")\n    \tif (n <= 1)\n    \t\ttemp = 1\n    \telse\n\
    \    \t\ttemp = fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)\n    \tif (n == 0)\n \
    \   \t\tfib = 0\n    \telse if (n == 1)\n    \t\tfib = 1\n    \telse if (n ==\
    \ 2)\n    \t\tfib = 2\n    \telse if (n == 3)\n    \t\tfib3 = 3\n    \telse if\
    \ (n == 4)\n    \t\tfib4 = 4\n    \telse if (n >= 5)\n    \t\tfib = temp\n   \
    \ \telse \n    \t\tfib2 = temp2\n    \tif (temp > fib4)\n    \t\tfib4 = temp\n\
    \    \tif (temp2 > fib3)\n    \t\tfib3 = temp2\n    \tif (temp2 > fib2)\n    \t\
    \tfib2 = temp2\n    \tif (temp > fib3)\n    \t\tfib3 = temp\n    \tif (temp2 >\
    \ fib)\n    \t\tfib = temp2\n    \treturn fib", "        var first = 0\n     \
    \   var second = 0\n        var third = 0\n        var fourth = 0\n        while\
    \ (n>0) {\n            first = second\n            second = third\n          \
    \  third = fourth\n            fourth = n -= 1\n        }\n        fourth", " \
    \       // Base case\n        if (n <= 3) {\n            return n\n        }\n\
    \        // Recursive case\n        else {\n            val firstFib = fib4(n\
    \ - 1) + fib4(n - 2)\n            val secondFib = fib4(n - 3) + fib4(n - 4)\n\
    \            return firstFib + secondFib\n        }", "        if (n <= 1) 1\n\
    \        else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "      \
    \  if (n == 0l) 0l\n        else if (n == 1l) 1l\n        else if (n == 2l) 2l\n\
    \        else if (n == 3l) 0l\n        else if (n == 4l) 1l\n        else if (n\
    \ == 5l) 2l\n        else fib4(n-1l) + fib4(n-2l) + fib4(n-3l) + fib4(n-4l) ",
  "        val fib = mutable.ListBuffer.empty[Long]\n        for (i <- (0 until n))\
    \ { fib += (i + 1) }\n        fib.head", "        var fib :List[Int] = List.empty[Int]\n\
    \        val fib2 = for (i <- 0 to 3) yield if (i == 0) i else fib(i-1) + fib(i-2)\n\
    \        val fib4 = fib2.map(fib2(_) + fib2(_+1) + fib2(_+2) + fib2(_+3)).drop(1).filter(_\
    \ < n).map(_.toString).toArray\n        fib4(0)", "        //fib(n) = fib(n-1)\
    \ + fib(n-2) + fib(n-3) + fib(n-4).\n        var fib = 0\n        var fib4 = 0\n\
    \        var n = n\n        while (fib < n) {\n            fib = fib\n       \
    \     fib4 += fib\n        }\n        fib4", "        if (n == 0 || n == 1) {\n\
    \            return n\n        }\n        else {\n            val m1 = fib4(n-1)\n\
    \            val m2 = fib4(n-2)\n            val m3 = fib4(n-3)\n            val\
    \ m4 = fib4(n-4)\n            val res = (m1 + m2 + m3 + m4)\n            res\n\
    \        }", "      if(n < 0)\n        throw new IllegalArgumentException\n  \
    \    else\n        Fib4(n)._1", "        if (n <= 0) 0\n        else if (n ==\
    \ 1) 1\n        else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", " \
    \      if (n == 0) 0\n       else if (n == 1) 0\n       else if (n == 2) 2\n \
    \      else fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)", "        if\
    \ (n < 3) {\n            return 0\n        }\n        if (n > 3) {\n         \
    \   return fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)\n        }",
  "        if(n <= 1l) n\n        else fib(n - 1l) + fib(n - 2l) + fib(n - 3l) + fib(n\
    \ - 4l) ", "        val fibbonacci = mutable.MutableList[Int]()\n        fibbonacci.clear()\n\
    \        fibbonacci(0)\n        for(i <- 1 to n ) {\n            fibbonacci append\
    \ fib4(fibbonacci(i-1) + fibbonacci(i-2) + fibbonacci(i-3) + fibbonacci(i-4))\n\
    \        }\n        fibbonacci(n)", "        val fib : mutable.MutableList[Long]\
    \ = mutable.MutableList(1)\n        fib(n) match {\n            case n if n >\
    \ 0 => fib(n) = fib.last + fib.last\n            case n if n == 0 => 0l\n    \
    \        case n => fib.last + fib.last\n        }", "        if (n<0) \n     \
    \       throw new IllegalArgumentException(\"negative numbers are not allowed\"\
    )\n        if (n==0) \n            return 0\n        if (n==1) \n            return\
    \ 1\n        if (n==2) \n            return 2\n        if (n==3) \n          \
    \  return 4\n        if (n==4) \n            return 8\n        if (n==5) \n  \
    \          return 10\n        if (n==6) \n            return 16\n        if (n==7)\
    \ \n            return 32\n        if (n==8) \n            return 64\n       \
    \ if (n==9) \n            return 128\n        if (n==10) \n            return\
    \ 256\n        if (n==11) \n            return 512\n        if (n==12) \n    \
    \        return 1024\n        if (n==13) \n            return 2048\n        if\
    \ (n==14) \n            return 4096", "        if(n == 0) 1\n        else fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        if(n < 0) 0\n    \
    \    else if(n == 1) 1\n        else if(n == 2) 2\n        else fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        val fibSeq = Seq.fill(n)(0l)(1l)\n\
    \        def loop(n: Long, n: Long) : Long = {\n            if (n == 0) n\n  \
    \          else loop(n-1, n-2) + loop(n-3, n-4) + fibSeq(n, 0)\n        }\n  \
    \      loop(n, n)", "        def sum(m : Long) : Long = {\n            m match\
    \ {\n                case 0 => 0l\n                case 1 => 1l\n            \
    \    case 2 => 2l\n                case 3 => 3l\n                case _ => sum(m\
    \ - 1) + sum(m - 2) + sum(m - 3) + sum(m - 4)\n            }\n        }\n\n  \
    \      def sums(n : Long) : Long = {\n            val m = n\n            val sum\
    \ = sum(m)\n            val sums = sums(n - 1)\n            val sumst = sums(n\
    \ - 2)\n            val sumst = sums(n - 3)\n            val sumst = sums(n -\
    \ 4)\n            m + sum + sums + sumst + sumst\n        }\n\n        sums(n)",
  "        var fib : Long = 0\n        val fib4 = (0 until n).foldLeft(0) { acc, x\
    \ =>\n            fib = fib + ((x % 4 + 1) * (x % 4))\n            acc\n     \
    \   }\n        fib", "        if (n == 0) 0\n        else if (n == 1) 1\n    \
    \    else if (n == 2) 2\n        else if (n == 3) 3\n        else if (n > 3) fib4(n\
    \ - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n        else fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3)", "        var a = n.toLong\n        var res = 0\n      \
    \  var b = a\n        var i = 0\n        while (b != 0) {\n            if (i%4\
    \ == 0 ) {\n                res = res + b\n            }\n            a = a +\
    \ b\n            i = i + 1\n            b = a - b\n        }\n        res", " \
    \       if (n == 0) 0\n        else if (n == 1) 1\n        else if (n == 2) 2\n\
    \        else if (n == 3) 0\n        else fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)", "        var fib = mutable.Stack.empty[Long]\n        for (i <-\
    \ 0 until n) {\n            fib += fib.pop() + fib.pop() + fib.pop() + fib.pop()\n\
    \        }\n        fib(0)", "        if(n <= 1) n\n        else fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4) ", "        if (n < 0) throw new IllegalArgumentException(\"\
    fib4 only supports positive integer inputs\")\n        if (n == 0) return 0\n\
    \        if (n == 1) return 0\n        if (n == 2) return 2\n        if (n ==\
    \ 3) return 0\n        return fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)", "        val fib = mutable.ListBuffer.empty[Long]\n        val fib_1\
    \ = mutable.ListBuffer.empty[Long]\n        val fib_2 = mutable.ListBuffer.empty[Long]\n\
    \        val fib_3 = mutable.ListBuffer.empty[Long]\n        val fib_4 = mutable.ListBuffer.empty[Long]\n\
    \        for(i <- 0 until n)\n            fib_4 += fib(i) - fib(i-1)\n       \
    \ for(i <- 0 until n)\n            fib += fib_4(i) + fib_4(i-1) + fib_4(i-2) +\
    \ fib_4(i-3)\n        fib(0)", "        // base case\n        if (n <= 0)\n  \
    \          return 0\n        // recursive case\n        if (n < 4L)\n        \
    \    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        // base case\n\
    \        if (n < 8L)\n            return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\
    \ + fib4(n-5) + fib4(n-6)\n        // base case\n        if (n < 14L)\n      \
    \      return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4) + fib4(n-5) + fib4(n-6)\
    \ + fib4(n-7) + fib4(n-8)\n        // base case\n        fib4(-1L)", "       \
    \ def computeFib4(current : Long, n2 : Long) : Long = {\n            if (n2 ==\
    \ 0) current else computeFib4(current+n2, n2-1)\n        }\n        computeFib4(0,\
    \ n)", "        val fib = mutable.ArrayBuffer.empty[Long]\n        for(i <- 0\
    \ to n-1){\n            fib += fib(i-1)+fib(i-2)+fib(i-3)+fib(i-4)\n        }\n\
    \        fib.last", "        def loop(x : (Long, Long, Long, Long), acc : Long):\
    \ (Long, Long, Long, Long) = {\n            if (x._1 == 0)\n                (x._4,\
    \ x._3, x._2, x._1)\n            else\n                (x._1, x._2, x._3, x._4\
    \ + x._3 + x._2)\n        }\n        if (n == 1)\n            (1, 0, 0, 0, 0,\
    \ 0)\n        else if (n == 2)\n            (0, 2, 0, 0, 0)\n        else if (n\
    \ == 3)\n            (0, 0, 0, 3, 0)\n        else if (n == 4)\n            (0,\
    \ 0, 0, 0, 4)\n        else\n            loop((n, n - 4, n - 3, n - 2), (acc:\
    \ Long) => (loop((n - 1, n - 2, n - 3, n - 4), acc), acc))._1", "        val fib4\
    \ = Seq.fill(n)(0).scanLeft(1){case (a,b) => (a+b, b)}.tail\n        fib4(n -\
    \ 1)", "        val list = List(0, 1, 2, 3, 4)\n        val sum = (1 to n).foldLeft(0)((acc,\
    \ x) => acc + list(x))\n        list(n-1) + list(n-2) + list(n-3) + list(n-4)",
  "        val array = new Array[Long](4)\n        val fib : mutable.Buffer[Long]\
    \ = mutable.Buffer[Long]()\n        fib.push(0l)\n        fib.push(1l)\n     \
    \   fib.push(2l)\n        fib.push(3l)\n        for (i <- 0 until n) {\n     \
    \       array.update(i)(fib(i))\n        }\n        array(0)", "        var ret\
    \ = 0\n        var fib = 0\n        for (i <- 0 until n) {\n            fib =\
    \ fib + i\n            if (fib > n) {\n                ret = fib - n\n       \
    \         fib = 0\n            } else {\n                ret = fib\n         \
    \   }\n        }\n        ret", "        require(n>0 && n < (1l*1l), s\"fib4(n)\
    \ requires n>0 and n<(1*1)\")\n        (1l*1l*1l*1l*1l).drop(n - (1l*1l)).drop(1).sum",
  "        if (n < 0l || n > 4l) {\n            throw new IllegalArgumentException(\"\
    Invalid input\")\n        }\n        if (n == 4l) {\n            0l\n        }\n\
    \        else if (n == 3l) {\n            1l\n        }\n        else {\n    \
    \        fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n        }", " \
    \       val list = new mutable.ListBuffer[Long]()\n        for (i <- 0 to n)\n\
    \            list += fib4(n-i)\n        list.get(n-1)", "        if (n <= 2l)\
    \ {\n            0l\n        } else if (n > 2l && n <= 5l) {\n            1l\n\
    \        } else if (n > 5l && n <= 8l) {\n            2l\n        } else if (n\
    \ > 8l) {\n            fib4(n - 5l) + fib4(n - 7l) + fib4(n - 11l)\n        }",
  "        // Solution 1 with recursion\n        if (n <= 1) {\n            return\
    \ n\n        }\n        val fib4 = (n: Long, n1: Long, n2: Long, n3: Long, n4:\
    \ Long) => {\n            if (n <= 4) {\n                n\n            } else\
    \ if (n <= 5) {\n                n1\n            } else if (n <= 6) {\n      \
    \          n2\n            } else if (n <= 7) {\n                n3\n        \
    \    } else {\n                n4\n            }\n        }\n        val fib =\
    \ fib4(n,1,0,1,1,1)\n        fib4(n : Long, fib(n),fib(n - 1),fib(n - 2),fib(n\
    \ - 3))", "        val fibSeq = for {\n                i <- 0 until n\n      \
    \          j <- 0 until i\n            } yield j\n        fibSeq.drop(1).dropRight(1).sum",
  "        val fib : mutable.MutableList[Long] = mutable.MutableList(4l, 8l, 14l)\n\
    \        fib.take(n) match {\n            case Nil => fib(n).sum\n           \
    \ case x => fib(n).sum + fib(n-1).sum + fib(n-2).sum + fib(n-3).sum + fib(n-4).sum\n\
    \        }", "        val fib4 = new mutable.Queue[Long](4L)\n        for (i <-\
    \ 0 until n)\n            fib4.enqueue(fib4.dequeue() + fib4.dequeue() + fib4.dequeue()\
    \ + fib4.dequeue())\n        fib4.dequeue()", "        val fibonacci = mutable.ArrayBuffer.fill(n)(0l).withFilter(_.isDefined)\
    \ \n        fibonacci.headOption.flatMap(n => {\n            val old = fibonacci.tail\n\
    \            fibonacci.tail = old :+ old.head\n            fibonacci\n       \
    \ })", "        var sum = 0\n        for (i <- 0 to n-1) {\n            sum =\
    \ sum + i\n        }\n        return sum", "      import scala.math._\n      import\
    \ scala.collection.mutable._\n      def fib4(i: Int) : Long = {\n        if (i\
    \ < 0) {\n          throw new IllegalArgumentException(\"fib4 \" + n + \" is not\
    \ a valid n\")\n        }\n        if (i == 0) {\n          return 0\n       \
    \ }\n        if (i == 1) {\n          return 0\n        }\n        if (i == 2)\
    \ {\n          return 2\n        }\n        val j = fib(i - 1)\n        val k\
    \ = fib(i - 2)\n        val l = fib(i - 3)\n        val m = fib(i - 4)\n     \
    \   j + k + l + m\n      }\n      fib4(n)", "        if (n < 0) throw new IllegalArgumentException(\"\
    n must be greater than or equal to 0!\")\n        if (n <= 2) {\n            return\
    \ n\n        }\n        val fib4Sum = mutable.Stream.from(1L).scanLeft(0L)(_ +\
    \ _)\n        fib4Sum.takeWhile(_ < n).sum", "        val fibVals = mutable.ArrayBuffer.fill(5)\
    \ {0 }\n        fibVals(0) = 0\n        fibVals(1) = 0\n        fibVals(2) = 2\n\
    \        fibVals(3) = 0\n        fibVals(4) = 0\n        fibVals(5) = 0\n    \
    \    var counter = 0\n        for ( i <- 0 to (n - 4) ) {\n            counter\
    \ = fibVals(counter)\n            fibVals(counter) = fibVals(counter-1) + fibVals(counter-2)\
    \ + fibVals(counter-3) + fibVals(counter-4)\n        }\n        fibVals(counter)",
  "        val fib = new mutable.Array[Long]\n        fib(0) = 0\n        fib(1) =\
    \ 0\n        fib(2) = 2\n        fib(3) = 0\n        fib(4) = 0\n        fib(n)\
    \ = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4)\n        fib(n)", "        var prev\
    \ : Long = 0\n        var i : Long = 1\n        while (i < n) {\n            prev\
    \ = prev + i\n            i = i * (6l)\n        }\n        return prev", "   \
    \     var fib4 = 0\n        var fib5 = 0\n        var fib6 = 0\n        var fib7\
    \ = 0\n        var fib8 = 0\n        val fib4 = if (n == 0) 0 else fib4 + fib5(n\
    \ - 1)\n        val fib5 = if (n == 0) 1 else fib4 + fib5(n - 2)\n        val\
    \ fib6 = if (n == 0) 2 else fib4 + fib5(n - 3)\n        val fib7 = if (n == 0)\
    \ 3 else fib4 + fib5(n - 4)\n        val fib8 = if (n == 0) 4 else fib4 + fib5(n\
    \ - 4)\n        fib4", "        var x = n.toLong\n        var res = n.toLong\n\
    \        for (i<-0 to n-2) {\n            res = res + x.toLong\n            x\
    \ = x - 1\n        }\n        if (n <= 3) {\n            x = 1\n        } else\
    \ {\n            x = 3\n        }\n        return res + x.toLong", "        val\
    \ fib4 = fibonacci(n - 4)\n        fib4", "        if(n <= 1) 0\n        else\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        if (n < 0 ||\
    \ n > 400000) throw IllegalArgumentException(\"The fib4 number sequence is defined\
    \ between 1 and 400000 and must be greater than 0 and less than 400000\")\n  \
    \      if (n == 0 || n == 1 || n == 2) return n\n        return fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        val fib3 = Fib4.fibo3(n /\
    \ 2) // fib3(3n) is the fibonacci sequence from 0(fib3(0)), 1(fib3(1)), 2(fib3(2)),\
    \ 3(n).\n        n match {\n            case 0 => 0\n            case 1 => fib3(0)\n\
    \            case 2 => fib3(1) + fib3(0)\n            case 3 => fib3(0)\n    \
    \        case _ => fib3(1) + fib3(2) + fib3(3) + fib3(0)\n        }", "      \
    \  if(n < 0) throw new IllegalArgumentException(\"n must be positive!\")\n   \
    \     if(n <= 1) return n\n        val fib4 = mutable.Array[Long]()\n        fib4\
    \ += 0\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n        fib4\
    \ += 2\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n", "        //\
    \ YOUR CODE HERE\n        require(n > 0, \"n must be positive\")\n        if (n\
    \ == 0) 0\n        else if (n == 1) 1\n        else if (n == 2) 2\n        else\
    \ fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        if (n < 0 ||\
    \ n >= (2l*4l)) {\n            throw new IllegalArgumentException(\"n is a negative\
    \ number or greater than or equal to 0\")\n        }\n        val fib : mutable.MutableList[Int]\
    \ = mutable.MutableList(4l)\n        for (i<- (2l*4l) until ((2l*4l) until (n))\
    \ {\n            fib.append(i.toInt + fib(i-1) + fib(i-2) + fib(i-3) + fib(i-4))\n\
    \        }\n        fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4)", "   \
    \     if (n <= 0) {\n            0\n        } else if (n <= 2) {\n           \
    \ 0\n        } else if (n <= 4) {\n            2\n        } else if (n <= 8) {\n\
    \            0\n        } else {\n            fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n        }", "        var fib : Long = 0\n        var fib2\
    \ = 2\n        for (i <- 0 until n) {\n            fib += fib2\n            fib2\
    \ = fib + (fib2+1)\n        }\n        fib", "        var result = 1\n       \
    \ for (i <- 0 until n) {\n            result = result + i\n        }\n       \
    \ result", "        var f4 = n.toInt\n        var ret = 0\n        for(i<-0 to\
    \ n){\n            f4= fib4(n-i)\n            ret= ret + f4\n        }\n     \
    \   val res= ret\n        f4", "        val nums = scala.collection.mutable.ArrayBuffer.empty[Long]\n\
    \        for (x <- 0 to n -1)\n            nums += x\n        nums(n).asInstanceOf[Long]",
  "        var x = 0\n        var fib: Long = 0\n        var a = 0\n        var b\
    \ = 0\n        var c = 0\n        var d = 1\n\n        if (n > 0) {\n        \
    \    a = fib4(n-1)\n            b = fib4(n-2)\n            c = fib4(n-3)\n   \
    \         d = fib4(n-4)\n            fib = a + b + c + d\n            x = fib\n\
    \        }\n        x", "        if (n == 0) 0\n        else if (n == 1) 1\n \
    \       else if (n == 2) 2\n        else if (n == 3) 0\n        else fib4(n -\
    \ 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        if(n <= 1)\n       \
    \     return 0\n        val a = fib4(n-1)\n        val b = fib4(n-2)\n       \
    \ val c = fib4(n-3)\n        val d = fib4(n-4)\n        a+b+c+d", "        def\
    \ fib4(i : Long) : Long = {\n            if (i < 5) {\n                return\
    \ 0\n            } else if (i < 10) {\n                return 1\n            }\
    \ else {\n                return fib4(i - 4) + fib4(i - 3) + fib4(i - 2) + fib4(i-1)\n\
    \            }\n        }\n        return fib4(n)", "        // The Fibbonacci\
    \ sequence starts with 0\n        // The Fibbonacci sequence goes on up to fib(2*n)\
    \ where fib(2*n) is defined as follows:\n        // fib2(2 * n) == fib2(2*n-1)\
    \ + fib2(2*n-2).\n        val fib2 : (Long,Long) = (1l,2l)\n        val fib3 :\
    \ (Long,Long) = (1l,3l)\n        var fib4 : (Long,Long) = (0l,0l)\n\n        //\
    \ fib(2 * n) is the same as fib(n-1) + fib(n-2) since fib(n-1) is defined as follows:\n\
    \        // fib(n-1) == fib(n-2) + fib(n-3).\n        fib4 =  fib2(fib2._1-1l,fib2._2+fib2._3)\
    \ * fib3\n\n        // fib(n) is the same as fib(n-1) + fib(n-2) + fib(n-3) +\
    \ fib(n-4) since fib(n-1) is defined as follows:\n        // fib(n-1) == fib(n-2)\
    \ + fib(n-3) + fib(n-4).\n        fib4 =  fib4 +  fib3(fib3._1-1l,fib3._2+fib3._3)\
    \ * fib2(fib2._1-1l,fib2._2+fib2._3)\n\n        // fib(n) is the same as fib(n-1)\
    \ + fib(n-2) + fib(n-3) + fib(n-4) since fib(n-1) is defined as follows:\n   \
    \     // fib(n-1) == fib(n-2) + fib(n-3) + fib(n-4).\n        fib4 =  fib4 + \
    \ fib2(fib2._1-1l,fib2._2+fib2._3) * fib3(fib3._1-1l,fib3._2+fib3._3)\n\n    \
    \    // fib(n) is the same as fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) since\
    \ fib(n-1) is defined as follows:\n        // fib(n-1) == fib(n-2) + fib(n-3)\
    \ + fib(n-4).\n        fib4 =  fib4 +  fib2(fib2._1-1l,fib2._2+fib2._3) * fib2(fib3._1-1l,fib3._2+fib3._3)\n\
    \n        // fib(n) is the same as fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) since\
    \ fib(n-1) is defined as follows:\n        // fib(n-1) == fib(n-2) + fib(n-3)\
    \ + fib(n-4).\n        fib4 =  fib4 +  fib3(fib3._1-1l,fib3._2+fib3._3) * fib2(fib2._1-1l,fib2._2+fib2._3)\n\
    \n        // fib", "        val fib = (0 until n)\n          .map(i => 0)\n  \
    \        .scanLeft(0){case (x, acc) => acc +: x}\n          .last\n        fib",
  "        n match {\n            case 0 => 0\n            case 1 => 0\n         \
    \   case 2 => 2\n            case 3 => 0\n            case n => fib4(n - 1) +\
    \ fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n        }", "        if (n == 0) 0\n\
    \        else if (n == 1) 1\n        else if (n == 2) 2\n        else fib4(n -\
    \ 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)", "        val fib4 = mutable.Set[Long]()\n\
    \        for (i <- 0 until n){\n            fib4 += fib4(i-1)+fib4(i-2)+fib4(i-3)+fib4(i-4)\n\
    \        }\n        fib4.last", "        if (n >= 1) {\n            fib4(n - 1)\
    \ + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n        } else {\n            0\n\
    \        }", "        if(n<=0)\n            0\n        else if(n==1)\n       \
    \     1\n        else if(n==2)\n            1\n        else if(n==3)\n       \
    \     1\n        else fib4(n-1)+fib4(n-2)+fib4(n-3)+fib4(n-4)", "        val nums\
    \ = Vector.tabulate(n)(_ + 1).map(x => x(0))\n        nums.toArray(n-1)", "  \
    \      var lastfib : Long = 0\n        var curfib : Long = 1\n        for (i <-\
    \ 1 to n){\n            curfib = lastfib + curfib\n            lastfib = curfib\n\
    \        }\n        lastfib", "        if (n==0) 0\n        else fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)", "      var ans : Long = 0\n      var m : Long = 0\n\
    \      var i : Long = 0\n      val n = Math.min(n, 100000)\n      while (i < n)\
    \ {\n        m = (i + n)/2\n        ans = ans + m\n        i = m\n      }\n  \
    \    ans", "        var a : Long = 0\n        var b : Long = 1\n        var c\
    \ : Long = 0\n        for (i<-0 to n by -1){\n            c = b\n            b\
    \ = a\n            a = c + b\n        }\n        a", "      if(n<0) throw new\
    \ IllegalArgumentException(\"fib4: negative argument\")\n      val res : List[Long]\
    \ = new Array[Long](n)\n      res(0) = 0\n      res(1) = 0\n      res(2) = 1\n\
    \      res(3) = 0\n      for(i <- n+2 to n+4) res(i) = res(i-1) + res(i-2) + res(i-3)\n\
    \      res(n)", "        val fib = (0 until n).map(x => (x, fib(x)+fib(x-1) +\
    \ fib(x-2) + fib(x-3))).maxBy(_._2)\n        fib._1", "        val f = math.pow\
    \ (n, 4l)\n        f", "        if (n<0) throw new IllegalArgumentException(\"\
    Negative numbers not allowed!\")\n        if (n<1) return 0\n        if (n<2)\
    \ return 1\n        if (n<4) return 2\n        val a = fib4(n-1)\n        val\
    \ b = fib4(n-2)\n        val c = fib4(n-3)\n        val d = fib4(n-4)\n      \
    \  return a+b+c+d", "        def fib(n : Long) = (if (n < 4) 1 else fib(n - 1)\
    \ + fib(n - 2) + fib(n - 3) + fib(n - 4))\n\n        if (n < 0) throw new IllegalArgumentException(\"\
    fib4 requires a non-negative integer\")\n        if (n == 0) 0\n        else if\
    \ (n == 1) 1\n        else if (n == 2) 2\n        else if (n == 3) 1\n       \
    \ else fib(n - 4)", "        val fib : mutable.MutableList[Long] = mutable.MutableList[Long]()\n\
    \        for (i <- (0 to n-1)){\n            fib.add(fib(i) + fib(i-1) + fib(i-2)\
    \ + fib(i-3))\n        }\n        fib.get(n-1)", "        require(n > 0)\n   \
    \     var fib: mutable.MutableList[Int] = mutable.MutableList()\n        fib(0)\n\
    \        fib(1)\n        fib.append(fib(0) + fib(1))\n        for( i <- 2 to n\
    \ ) {\n            fib.append(fib(i) + fib(i - 2))\n        }\n        fib.last",
  "        // Your code here\n        val seq : mutable.Stack[Long] = new mutable.Stack[Long]\n\
    \        seq += 0\n        seq += 0\n        seq += 0\n        seq += 0\n    \
    \    seq += 0\n        seq.take(n)", "    \tval a = List(1l, 2l, 3l, 4l)\n   \
    \ \tval b = List(1l, 3l, 5l, 7l)\n    \tval c = List(2l, 5l, 8l, 11l)\n    \t\
    val d = List(3l, 7l, 13l, 20l)\n    \tval e = List(5l, 11l, 20l, 30l)\n    \t\
    if (n == 0l) 0l else\n    \tif (n == 1l) 1l else\n    \tif (n == 2l) 2l else\n\
    \    \tif (n == 3l) 3l else\n    \tif (n == 4l) 4l else\n    \tif (n == 5l) fib4(4l)\
    \ + fib4(3l) + fib2(2l) + fib1(1l)\n    \telse if (n == 6l) fib4(8l) + fib3(7l)\
    \ + fib2(5l) + fib1(3l)\n    \telse if (n == 7l) fib4(14l) + fib3(13l) + fib2(8l)\
    \ + fib1(2l)\n    \telse if (n == 8l) fib4(21l) + fib3(23l) + fib2(15l) + fib1(5l)\n\
    \    \telse if (n == 9l) fib4(34l) + fib3(55l) + fib2(20l) + fib1(8l)\n    \t\
    else if (n == 10l) fib4(56l) + fib3(89l) + fib2(35l) + fib1(11l)\n    \telse if\
    \ (n == 11l) fib4(89l) + fib3(120l) + fib2(50l) + fib1(14l)\n    \telse if (n\
    \ == 12l) fib4(144l) + fib3(169l) + fib2(76l) + fib1(21l)\n    \telse if (n ==\
    \ 13l) fib4(169l) + fib3(240l) + fib2(120l) + fib1(34l)\n    \telse if (n == 14l)\
    \ fib4(240l) + fib3(280l) + fib2(160l) + fib1(56l)\n    \telse if (n == 15l) fib4(280l)\
    \ + fib3(324l) + fib2(200l) + fib1(89l)\n    \telse if (n == 16l) fib4(324l) +\
    \ fib3(370l) + fib2(240l) + fib1(144l)\n    \telse if (n == 17l) fib4(370l) +\
    \ fib3(420l) + fib2(280l) + fib1(169l)\n    \telse if (n == 18l) fib4(420l) +\
    \ fib3(460l) + fib2(320l) + fib1(240l)\n    \telse if (n == 19l) fib4(460l) +\
    \ fib3(510l) + fib2(360l) + fib1(280l)\n    \telse if (", "        val r = new\
    \ scala.collection.mutable.Queue[Long]()\n        r.enqueue(0l)\n        var next\
    \ = 0l\n        while (r.size < n) {\n            next += r.dequeue() + r.dequeue()\
    \ + r.dequeue() + r.dequeue()\n            r.enqueue(next)\n        }\n      \
    \  r.dequeue()", "        if (n < 0) 0\n        else if(n % 2 == 0) 0\n      \
    \  else fib4(n - 1) + fib4(n - 2)", "        if (n <= 2) 0\n        else if (n\
    \ <= 3) 2\n        else fib4(n - 4) + fib4(n - 3) + fib4(n - 2) + fib4(n - 1)",
  "        val fib3 = n / 4\n        val fib2 = fib3 * 3\n        val fib1 = fib2\
    \ * 2\n        fib1 + fib3", "        var fib4 = 0\n        fib4 += n\n      \
    \  fib4 += n\n        fib4 += n\n        fib4 += n\n        fib4", "        val\
    \ fibSeq = scala.collection.mutable.ListBuffer[Long]()\n        fibSeq += 0\n\
    \        fibSeq += 0\n        fibSeq += 2\n        fibSeq += 0\n        fibSeq\
    \ += 0\n        fibSeq.last", "        val fibSeq = mutable.Stack[Int](0,1)\n\
    \        (fibSeq.push(n).toLong,fibSeq.push(n*2).toLong,fibSeq.push(n*3).toLong,fibSeq.push(n*4).toLong)",
  "        var result : Long = 0\n        val fib = new mutable.LinkedHashSet[Long]\n\
    \        fib.add(0l)\n        for(i <- 1 to n) {\n            if(fib.contains(n))\
    \ {\n                result = fib.last\n            } else {\n               \
    \ fib.add(fib.last+fib.last)\n            }\n        }\n        result", "   \
    \     val ret = new scala.collection.mutable.ListBuffer[Long]()\n        for (i<-0\
    \ to (n-1)) {\n            ret.add(0)\n        }\n        for (j<-0 to (n-1))\
    \ {\n            val tmp = ret(i) + ret(j+1)\n            ret(i) = tmp\n     \
    \   }\n        ret(n-1)", '        // Your code goes here.', "        val fib4\
    \ = 0\n        for( i <- 1 to n ) {\n            fib4 += i\n        }\n      \
    \  fib4", "        val x = math.BigInt(n)\n        if (n == 0) x\n        else\
    \ fib4(math.BigInt(n).minus(1).minus(2)).minus(3)", "       val result = new collection.mutable.HashSet[Long]()\n\
    \       val nn = math.max(2l, n)\n       val n1 = n / nn\n       val n2 = n %\
    \ nn\n       result.add(0l)\n       result.add(1l)\n       result.add(2l)\n  \
    \     result.add(3l)\n       result(nn)", "        var fibbonacci : Array[Long]\
    \ = new Array[Long](6)\n        fibbonacci(0) = 0\n        fibbonacci(1) = 0\n\
    \        fibbonacci(2) = 2\n        fibbonacci(3) = 0\n        fibbonacci(4) =\
    \ 0\n        fibbonacci(5) = 0\n        var fib : Long = 0\n        for(i <- 0\
    \ until n) {\n            fib = fibbonacci(i) + fibbonacci(i-1) + fibbonacci(i-2)\
    \ + fibbonacci(i-3) + fibbonacci(i-4)\n            fibbonacci(i) = fib\n     \
    \   }\n        fibbonacci(6) = fib\n        return fibbonacci(n)", "        val\
    \ f = mutable.ListBuffer[Long]()\n        for(i <- (0 to 4)) {\n            f.append(f(n\
    \ - 1) + f(n - 2) + f(n - 3) + f(n - 4))\n        }\n        f.last", "      val\
    \ fib : mutable.MutableList[Long] = mutable.MutableList(1l)(1l)\n      fib(n-1)(2l)(3l)(4l)\
    \ += fib(n-2)(4l)(6l)(8l)(14l) }\n}\n</code>\n<|/ a tags=scala |>\n<| c |>\nThis\
    \ is not working for large numbers.  For n = 10000000000 it gets stuck at fib(n-1)(4l)(6l)(8l)(14l)\
    \ += fib(n-2)(4l)(6l)(8l)(14l).  Any idea why?\n<|/ c |>\n<| c |>\nNot sure why\
    \ it didn't work. I'll post an update when I get it working correctly.\n<|/ c\
    \ |>\n<| a dscore=2 tags=scala |>\nThe answer that uses mutable is wrong.\nThe\
    \ answer, which uses functional programming is correct.\n<code>\ndef fib(n: Long):\
    \ Long = {\n  def fibs(n: Long, acc: Long): Long = n match {\n    case 0 => acc\n\
    \    case 1 => acc\n    case 2 => acc\n    case _ => fibs(n-1, acc + acc) + fibs(n-2,\
    \ acc + acc) + fibs(n-3, acc + acc) + fibs(n-4, acc + acc)\n  }\n  fibs(n, 0L)\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is not working for large numbers.  For n =\
    \ 10000000000 it gets stuck at fibs(n-1, acc + acc) + fibs(n-2, acc + acc) + fibs(n-3,\
    \ acc + acc) + fibs(n-4, acc + acc).  Any idea why?\n<|/ c |>\n<| c |>\nI ran\
    \ a test on n=1000000000 and it worked fine.  Are you sure you're running the\
    \ latest version of this?\n<|/ c |>\n<| c |>\nYes and I did notice that it is\
    \ actually very slow. Maybe it's because I am calling this in a loop. I am trying\
    \ to see if I can parallelize it but I am not sure how that would be done.\n<|/\
    \ c |>\n<| c |>\nI updated my answer based on yours. I was running a test on a\
    \ laptop that didn't have enough memory for that.  It will now work in parallel.\n\
    <|/ c |>\n<| c |>\nThis algorithm is also not working for n = 10000000000. I am\
    \ running scala 2.9.2 and am using Intellij to run the code. I will post the code\
    \ I have used as an update to my original question.\n", "        if(n == 0) {\n\
    \            return 0\n        }\n        if(n == 1) {\n            return 1\n\
    \        }\n        if(n == 2) {\n            return 2\n        }\n        if(n\
    \ == 3) {\n            return 0\n        }\n        val fib = mutable.ListBuffer(4l,\
    \ 8l, 14l)\n        fib += fib(n-1) + fib(n-2) + fib(n-3)\n        fib.last",
  "        if (n < 2) return n\n        else fib4(n - 1) + fib4(n - 2) + fib4(n -\
    \ 3) + fib4(n - 4)", "        var result = new collection.mutable.ListBuffer[Long]\n\
    \        for(i <- 0 until n)\n            result.append(result.lastOption.map(_+i).getOrElse(i))\n\
    \        result.last", "        val f = mutable.Set[Long]()\n        val n = mutable.Set[Long]()\n\
    \        f += 0l\n        n += 0l\n        f += 2l\n        n += 2l\n        f\
    \ += 4l\n        n += 4l\n        f += 8l\n        n += 8l\n        f += 16l\n\
    \        n += 16l\n        f += 32l\n        n += 32l\n        f += 64l\n    \
    \    n += 64l\n        f.size", "        val fib4 = mutable.ArrayBuffer[Long]()\n\
    \        var prev = 0\n        var current = 1\n        var next = prev + current\n\
    \        var c = n\n        while (c > 1) {\n            fib4 += prev\n      \
    \      prev = current\n            current = next\n            next = prev + current\n\
    \            c = c - 1\n        }\n        fib4 += prev\n        fib4.last", " \
    \       val fib4n = fib4(n-1)\n        fib4n + fib4(n-2) + fib4(n-3) + fib4(n-4)",
  "        val fib = new mutable.MutableList[Long]()\n        var fibVal : Long =\
    \ 1\n        for( i <- 1 to n ){\n            fib.add( fibVal )\n            fibVal\
    \ = fibVal * 3 + 1\n        }\n        fib.last", "        if (n == 0 || n ==\
    \ 1) return n\n        val retVal = fib4(n - 1) + fib4(n - 2) + fib4(n - 3) +\
    \ fib4(n - 4)\n        retVal", "        if (n <= 3) {\n            0\n      \
    \  }\n        else {\n            fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)\n        }", "        if(n < 0 || n > 4) return 0\n        val a = scala.math.BigInt(0)\n\
    \        val b = scala.math.BigInt(1)\n        var x = 1l\n        while(x < (n\
    \ * 4)) {\n            x = (a+b).abs\n            b = a\n            a = x\n \
    \       }\n        val y = (a+b).abs\n        if(((n*4) - y) < 0) y else ((n *\
    \ 4) - y)", "        val fib4n = 1 :+ ( 2 :+ ( 3 :+ ( 4 :+ ( 0 :+ ( 1 :+ ( 0 :+\
    \ ( 0 :+ fib4n(n-1) + fib4n(n-2) + fib4n(n-3) + fib4n(n-4)) ) ) ) ) )\n      \
    \  fib4n(n)", "        var x =0 // Use a mutable variable to hold the current\
    \ number in the sequence\n        var a =0l\n        var b = 0l\n        var c\
    \ = 0l\n        var d = 0l\n        var f = 0l\n        \n        for(i <- 0 until\
    \ (n-1)) \n        {\n            if(i%2==0) {\n                a = a + 1l\n \
    \           } else  {\n                b = b + 2l\n            }\n        }\n\
    \        \n        for (j <- 0 until (n-1))\n        {\n            if(j%2==0)\
    \ {\n                c = c + 2l\n            } else  {\n                d = d\
    \ + 3l\n            }\n        }\n        \n        for (k <- 0 until (n-1))\n\
    \        {\n            if(k%2==0) {\n                f = f + 4l\n           \
    \ } else  {\n                a = a + 5l\n            }\n        }\n        \n\
    \        \n        return (a + ((b) + (c) + (d) + (f))) //return the last number\
    \ of the sequence", "        val fib4Iter = fib4Iter()\n        fib4Iter.next",
  "        var fibo = mutable.ArrayBuffer(0)\n        fibo.update(0, 0l)(_ + _)\n\
    \        var i : Long = 1\n        while(i < n) {\n            fibo.update(i)(fibo(i)\
    \ + fibo(i+1))(_ + _)\n            i += 1\n        }\n        fibo(n)", "    \
    \    if (n <= 0) 0\n        else fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n\
    \ - 4)", "        var a : Long = 1\n        var b : Long = 1\n        var c :\
    \ Long = 1\n        var d : Long = 1\n        var e : Long = 1\n        for (i<-0\
    \ until n) {\n            val temp = a\n            a = b\n            b = c\n\
    \            c = d\n            d = e\n            e = temp + a * b * c * d\n\
    \        }\n        return e", "        if(n==0) 1\n        else fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)", "        if (n == 0l) 0l\n        else if (n == 1l)\
    \ 0l\n        else if (n == 2l) 2l\n        else if (n == 3l) 0l\n        else\
    \ fib4(n-1l) + fib4(n-2l) + fib4(n-3l) + fib4(n-4l)", '        // Your code goes
    here', "        val fib4num = scala.collection.mutable.ArrayBuffer[Long]()\n \
    \       fib4num += 0\n        fib4num += 0\n        fib4num += 2\n        fib4num\
    \ += 0\n        fib4num += fib4num.last\n        fib4num += fib4num.last\n   \
    \     fib4num += fib4num.last\n        fib4num += fib4num.last\n        fib4num.last",
  "        n match {\n            case 0 => 0\n            case 1 => 0\n         \
    \   case _ => 1 + fib4(n - 1) + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)\n    \
    \    }", "        val a = mutable.ArrayBuffer(0)\n        val b = mutable.ArrayBuffer(0)\n\
    \        val c = mutable.ArrayBuffer(0)\n        for (i <- 0 until n) {\n    \
    \        a.append(i.toLong)\n            b.append(i.toLong)\n            c.append(i.toLong)\n\
    \        }\n        val d = mutable.ArrayBuffer(0)\n        val e = mutable.ArrayBuffer(0)\n\
    \        val f = mutable.ArrayBuffer(0)\n        for (i <- 0 until n) {\n    \
    \        d += a(0)\n            e += b(0)\n            f += c(0)\n        }\n\
    \        (d + e + f).toLong", "        def loop(n: Long, m: Long, acc: Long, i:\
    \ Int) : Long = {\n            i match {\n                case 0 => acc\n    \
    \            case 1 => loop(n-1, m+acc, acc, 1)\n                case 2 => loop(n-2,\
    \ m+acc, acc, 2)\n                case 3 => loop(n-3, m+acc, acc, 3)\n       \
    \         case _ => loop(n-4, m+acc, acc, 4)\n            }\n        }\n     \
    \   loop(n, n, 0, 0)", "        val ret = (0l).+(if (n%2 == 0) 0l else 1l)\n \
    \       ret +: fib4(n / 2l) +: fib4(n / 2l) + 1l", "        if (n == 0)\n    \
    \        return 0\n        if (n == 1)\n            return 1\n        if (n ==\
    \ 2)\n            return 2\n        if (n == 3)\n            return 0\n      \
    \  if (n == 4)\n            return 4\n\n        val a = 0\n        val b = 1\n\
    \        val c = 2\n        val d = 0\n        val e = 4\n\n        var fib :\
    \ Long = 0\n        var i = 0\n        while (i<n-1){\n            fib = a + b\
    \ + c + d\n            a = b\n            b = c\n            c = d\n         \
    \   d = e\n            e = fib\n            i += 1\n        }\n        fib", " \
    \     val fib: mutable.Array[Int] = new mutable.Array[Int](n)\n      fib(0) =\
    \ 0\n      fib(1) = 0\n      fib(2) = 2\n      fib(3) = 0\n      for ( i <- 4\
    \ until n) {\n        fib(i) = fib(i-1) + fib(i-2) + fib(i-3) + fib(i-4)\n   \
    \   }\n      fib.last", "        var x : (Long, Long) = (1, 0)\n        var i\
    \ : Long = 1\n\n        while (i < n) {\n            (x := x._1, i := i + 1)\n\
    \        }\n\n        x._1", "        // write your code here\n        val res\
    \ = List[Int]()\n        var a=0\n        var b=1\n        var c=0\n        var\
    \ d=2\n        while(n>0) {\n            if(n<=4) {\n                res = a :+\
    \ b\n            }\n            else {\n                res = c :+ d\n       \
    \     }\n            n = n-4\n            a=b\n            b=c\n            c=d\n\
    \            d=res.head\n        }\n        res.head", "        val fib3 = new\
    \ mutable.LongArray[Long](4)\n        fib3(0) =  0\n        fib3(1) =  0\n   \
    \     fib3(2) =  1\n        fib3(3) =  1\n        val fib2 = new mutable.LongArray[Long](4)\n\
    \        fib2(0) =  1\n        fib2(1) =  1\n        fib2(2) =  2\n        fib2(3)\
    \ =  2\n        val fib1 = new mutable.LongArray[Long](4)\n        fib1(0) = \
    \ 2\n        fib1(1) =  2\n        fib1(2) =  3\n        fib1(3) =  3\n      \
    \  val fib0 = new mutable.LongArray[Long](4)\n        fib0(0) =  3\n        fib0(1)\
    \ =  3\n        fib0(2) =  4\n        fib0(3) =  4\n        if(n<=1l) {\n    \
    \        fib3(n)\n        }\n        else if(n>1l) {\n            fib3(n) += fib4(n-1)\n\
    \            fib3(n) += fib4(n-2)\n            fib3(n) += fib4(n-3)\n        \
    \    fib3(n) += fib4(n-4)\n        }", '        if (n == 0) 0 else fib4(n - 1)
    + fib4(n - 2) + fib4(n - 3) + fib4(n - 4)', "        if (n <= 1) {\n         \
    \   n\n        } else {\n            // return fib4(n - 1) + fib4(n - 2) + fib4(n\
    \ - 3) + fib4(n - 4)\n            val temp = n\n            fib4(n - 1) + fib4(n\
    \ - 2) + fib4(n - 3) + fib4(n - 4)\n            temp\n        }", "        if\
    \ (n == 0) 0\n        else if (n == 1) 1\n        else if (n == 2) 1\n       \
    \ else if (n == 3) 1\n        else fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)",
  "        val list = mutable.ListBuffer.empty[Long]\n        for (i <- 0 until n)\n\
    \        list += fib4(i)\n        list.last", "        var a = mutable.ListBuffer[Long]()\n\
    \        var n = n.toInt\n        var i = 1;\n        while (n > 0) {\n      \
    \      a.append(i)\n            i = i + 2\n            n = n - 1\n        }\n\
    \        a.last", "        var fibo : mutable.Array[Long] = mutable.Array()\n\
    \        fibo(0) = 0\n        fibo(1) = 0\n        fibo(2) = 2\n        fibo(3)\
    \ = 0\n        for(i<-0 until n){\n            fibo(i) = fibo(i-1)+ fibo(i-2)+\
    \ fibo(i-3)+ fibo(i-4)\n        }\n        fibo(n-1)", "        if (n<0) 0\n \
    \       else if (n==0) 1\n        else if (n==1) 1\n        else if (n==2) 2\n\
    \        else if (n>2) fib4(n-2) + fib4(n-3)\n        else fib4(n-1) + fib4(n-2)",
  "        val fib4List = List[Long]()\n        fib4List ::= fib4(n - 1)\n       \
    \ fib4List ::= fib4(n - 2)\n        fib4List ::= fib4(n - 3)\n        fib4List\
    \ ::= fib4(n - 4)\n        fib4List(0)", "        val fib4 = mutable.Stack[Long]()\n\
    \        fib4 += 0\n        fib4 += 0\n        fib4 += 2\n        fib4 += 0\n\
    \        fib4 += fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n        fib4(n)",
  "        def memo(m: Map[Long, Long]) = m.getOrElseUpdate(n) { n =>\n          \
    \  val newN = n+(n+2)\n            if(newN <= 7) memo(m + (n -> newN))\n     \
    \       else memo(m + (n -> memo(m + (n -> newN))))\n        }\n        memo(Map())",
  "        if (n == 0) 0\n        else if (n == 1) 1\n        else if (n == 2) 2\n\
    \        else if (n == 3) 3\n        else fib4(n-1) + fib4(n-2) + fib4(n-3) +\
    \ fib4(n-4)", "        val fibs = scala.collection.mutable.ListBuffer[Long]()\n\
    \        fibs += 0\n        fibs += 1\n        fibs += 2\n        if (n >= 3 )\
    \ fibs += 0\n        if (n >= 4 ) fibs += 2\n        fibs(n)", "        val fib1\
    \ : mutable.Buffer[Long] = mutable.Buffer.fill(5)(0)\n        fib1 += fib1.last\n\
    \        fib1 += fib1(1) + fib1(2) + fib1(3) + fib1(4)\n        fib1.drop(n).last",
  "        val fib1 = 1\n        val fib2 = 2\n        val fib3 = 2\n        val fib4\
    \ = 3\n        val fib5 = n\n        if (n==0) fib5\n        else fib4(fib5-1)\
    \ + fib1(fib5-2) + fib2(fib5-3) + fib3(fib5-4) ", "        if(n < 0) throw new\
    \ IllegalArgumentException(\"fib4 requires non-negative input\")\n        if(n\
    \ <= 2l) 0l\n        else if(n <= 4l) 0l\n        else 2l + fib4(3l) + fib4(5l)\
    \ + fib4(7l) + fib4(9l)", "        def helper(n: Long, fib4: mutable.Buffer[Long])\
    \ : Long = {\n            if (n == 0) fib4 += 0\n            else if (n == 1)\
    \ fib4 += 0\n            else helper(n-1, fib4) += helper(n-2, fib4) += helper(n-3,\
    \ fib4) += helper(n-4, fib4)\n        }\n        helper(n, mutable.Buffer[Long]())",
  "        def fib(i : Long, acc : Long) : Long = if (i >= n) acc else fib(i - 1,\
    \ acc + fib(i + 1, 0))\n        fib(n, 0L)", "        val result = mutable.Long.empty\n\
    \        for (i <- 0 to n) {\n            result += (i to ((i + 1) to (4 * i to\
    \ i)))\n        }\n        result.toArray[Long](0)", "        var ans : Long =\
    \ 0\n        var i : Long = 1\n        var tmp : Long = 1\n        while(n > 0)\
    \ {\n            tmp = tmp + i\n            i = i << 1\n            n = n - 1\n\
    \        }\n        ans = tmp\n        return ans", "        if (n == 0 || n ==\
    \ 1) {\n            return n\n        }\n        else {\n            val temp\
    \ = fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n            return temp\n \
    \       }", "        // Your code goes here\n        val fib4 = scala.collection.mutable.ArrayBuffer(0\
    \ until n)\n        for (i<-0 to n -1 ){\n            fib4 += (fib4(i+1) + (fib4(i+2))\
    \ + (fib4(i+3)) + (fib4(i+4)))\n        }\n        fib4(n-1)", "        val fib3\
    \ = new mutable.ArrayBuilder[Long]\n        fib3 += 0\n        fib3 += 0\n   \
    \     fib3 += 0\n        fib3 += 0\n        val fib2 = new mutable.ArrayBuilder[Long]\n\
    \        fib2 += 0\n        fib2 += 0\n        fib2 += 0\n        fib2 += 0\n\
    \        val fib1 = new mutable.ArrayBuilder[Long]\n        fib1 += 0\n      \
    \  fib1 += 0\n        fib1 += 0\n        fib1 += 0\n        val fib0 = new mutable.ArrayBuilder[Long]\n\
    \        fib0 += 0\n        fib0 += 0\n        fib0 += 0\n        fib0 += 0\n\
    \        if (n <= 5l)\n        fib4(n).toLong\n        else\n        fib4(n-1l)\
    \ + fib4(n-2l) + fib4(n-3l) + fib4(n-4l).toLong", "        val ans = scala.math.BigInt(0)\n\
    \        if (n <= 0) ans\n        else {\n            val first = (1 to n).map(i\
    \ => (i + 1) * (i + 2)).toList\n            val second = (1 to n).map(i => (i\
    \ + 1) * (i + 3)).toList\n            val third = (1 to n).map(i => (i + 1) *\
    \ (i + 4)).toList\n            val fourth = (1 to n).map(i => (i + 1) * (i + 5)).toList\n\
    \            val fifth = (1 to n).map(i => (i + 1) * (i + 6)).toList\n       \
    \     val sixth = (1 to n).map(i => (i + 1) * (i + 7)).toList\n            val\
    \ seventh = (1 to n).map(i => (i + 1) * (i + 8)).toList\n            val eighth\
    \ = (1 to n).map(i => (i + 1) * (i + 9)).toList\n            val ninth = (1 to\
    \ n).map(i => (i + 1) * (i + 10)).toList\n            val tenth = (1 to n).map(i\
    \ => (i + 1) * (i + 11)).toList\n            val eleventh = (1 to n).map(i =>\
    \ (i + 1) * (i + 12)).toList\n            val twelfth = (1 to n).map(i => (i +\
    \ 1) * (i + 13)).toList\n            val thirteenth = (1 to n).map(i => (i + 1)\
    \ * (i + 14)).toList\n            val fourteenth = (1 to n).map(i => (i + 1) *\
    \ (i + 15)).toList\n            val fifteenth = (1 to n).map(i => (i + 1) * (i\
    \ + 16)).toList\n            val sixteenth = (1 to n).map(i => (i + 1) * (i +\
    \ 17)).toList\n            val seventeenth = (1 to n).map(i => (i + 1) * (i +\
    \ 18)).toList\n            val eighteenth = (1 to n).map(i => (i + 1) * (i + 19)).toList\n\
    \            val nineteenth = (1 to n).map(i => (i + 1) * (i + 20)).toList\n \
    \           val twentieth = (1 to n).map(i => (i + 1) * (i + 21)).toList\n   \
    \         val twenty = (1 to n).map(i => (i + 1) * (i + 22)).toList\n        \
    \    val twentyone = (1 to n).map(i => (i + 1) * (i + 23)).toList\n          \
    \  val twentytwo = (1 to n).map(i => (i + 1) * (i + 24)).toList\n            val\
    \ twentythree = (1 to n).map(i => (i + 1) * (i + 25)).toList\n            ", " \
    \       if (n == 0) 0\n        if (n == 1) 0\n        if (n == 2) 2\n        if\
    \ (n == 3) 0\n        if (n == 4) 4\n        else fib4(n - 1) + fib4(n - 2) +\
    \ fib4(n - 3) + fib4(n - 4)", "        if (n == 0) 0\n        if (n == 1) 1\n\
    \        if (n == 2) 2\n        if (n == 3) return 0\n        if (n == 4) return\
    \ 4\n        val first = fib4(n-1)\n        val second = fib4(n-2)\n        val\
    \ third = fib4(n-3)\n        val fourth = fib4(n-4)\n        first+second+third+fourth",
  "        val result = mutable.Stack[Long]()\n        result push 0\n        result\
    \ push 1\n        result push 2\n        result push 3\n        result foreach\
    \ (x => result push (result pop + result pop + result pop + result pop))\n   \
    \     return result(n)", "        def fib(i:Long, a:Long, b:Long):Long = {\n \
    \           if (i > 0) (a + b) * fib(i-1, a, b)\n            else a\n        }\n\
    \        fib(n, 1, 1, 0)", "        val fib4 = new mutable.HashMap[Long, Long]\n\
    \        fib4 += 0l -> 0\n        fib4 += 1l -> 0\n        fib4 += 2l -> 2\n \
    \       fib4 += 3l -> 0\n        fib4 += 4l -> fib4(4l-1l) + fib4(4l-2l) + fib4(4l-3l)\
    \ + fib4(4l-4l)\n        fib4(n).asInstanceOf[Long]"]
stop_tokens:
- "\n    }\n"
